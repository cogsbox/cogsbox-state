{"version":3,"file":"Components.jsx","sources":["../src/Components.tsx"],"sourcesContent":["import { FormElementParams, StateObject, type FormOptsType } from './CogsState';\r\nimport { pluginStore } from './pluginStore';\r\nimport { createMetadataContext, toDeconstructedMethods } from './plugins';\r\nimport React, {\r\n  memo,\r\n  RefObject,\r\n  useCallback,\r\n  useEffect,\r\n  useLayoutEffect,\r\n  useRef,\r\n  useState,\r\n  useMemo,\r\n} from 'react';\r\nimport { getGlobalStore, ValidationError, ValidationSeverity } from './store';\r\nimport { useInView } from 'react-intersection-observer';\r\nimport { v4 as uuidv4 } from 'uuid';\r\nimport { isDeepEqual } from './utility';\r\nimport { useStore } from 'zustand';\r\nconst {\r\n  getInitialOptions,\r\n\r\n  getShadowMetadata,\r\n  setShadowMetadata,\r\n  getShadowValue,\r\n\r\n  registerComponent,\r\n  unregisterComponent,\r\n\r\n  notifyPathSubscribers,\r\n  subscribeToPath,\r\n} = getGlobalStore.getState();\r\nconst { stateHandlers, notifyFormUpdate } = pluginStore.getState();\r\n\r\nexport type ValidationWrapperProps = {\r\n  formOpts?: FormOptsType;\r\n  path: string[];\r\n  stateKey: string;\r\n  children: React.ReactNode;\r\n};\r\n\r\nexport function ValidationWrapper({\r\n  formOpts,\r\n  path,\r\n  stateKey,\r\n  children,\r\n}: ValidationWrapperProps) {\r\n  const { getInitialOptions, getShadowMetadata, getShadowValue } =\r\n    getGlobalStore.getState();\r\n  const thisStateOpts = getInitialOptions(stateKey!);\r\n\r\n  const shadowMeta = getShadowMetadata(stateKey!, path);\r\n  const validationState = shadowMeta?.validation;\r\n\r\n  const status = validationState?.status || 'NOT_VALIDATED';\r\n\r\n  const errors = (validationState?.errors || []).map((err) => ({\r\n    ...err,\r\n    path: path,\r\n  })) as ValidationError[];\r\n  const errorMessages = errors\r\n    .filter((err) => err.severity === 'error')\r\n    .map((err) => err.message);\r\n  const warningMessages = errors\r\n    .filter((err) => err.severity === 'warning')\r\n    .map((err) => err.message);\r\n\r\n  // Use first error, or first warning if no errors\r\n  const message = errorMessages[0] || warningMessages[0];\r\n  const primarySeverity: ValidationSeverity =\r\n    errorMessages.length > 0\r\n      ? 'error'\r\n      : warningMessages.length > 0\r\n        ? 'warning'\r\n        : undefined;\r\n  return (\r\n    <>\r\n      {thisStateOpts?.formElements?.validation &&\r\n      !formOpts?.validation?.disable ? (\r\n        thisStateOpts.formElements!.validation!({\r\n          children: (\r\n            <React.Fragment key={path.toString()}>{children}</React.Fragment>\r\n          ),\r\n          status, // Now passes the new ValidationStatus type\r\n          message: formOpts?.validation?.hideMessage\r\n            ? ''\r\n            : formOpts?.validation?.message || message || '',\r\n          severity: primarySeverity,\r\n          hasErrors: errorMessages.length > 0,\r\n          hasWarnings: warningMessages.length > 0,\r\n          allErrors: errors,\r\n          path: path,\r\n          getData: () => getShadowValue(stateKey!, path),\r\n        })\r\n      ) : (\r\n        <React.Fragment key={path.toString()}>{children}</React.Fragment>\r\n      )}\r\n    </>\r\n  );\r\n}\r\nexport const MemoizedCogsItemWrapper = memo(\r\n  ListItemWrapper,\r\n  (prevProps, nextProps) => {\r\n    // Re-render if any of these change:\r\n    return (\r\n      prevProps.itemPath.join('.') === nextProps.itemPath.join('.') &&\r\n      prevProps.stateKey === nextProps.stateKey &&\r\n      prevProps.itemComponentId === nextProps.itemComponentId &&\r\n      prevProps.localIndex === nextProps.localIndex\r\n    );\r\n  }\r\n);\r\nexport function ListItemWrapper({\r\n  stateKey,\r\n  itemComponentId,\r\n  itemPath,\r\n  localIndex,\r\n  arraySetter,\r\n  rebuildStateShape,\r\n  renderFn,\r\n}: {\r\n  stateKey: string;\r\n  itemComponentId: string;\r\n  itemPath: string[];\r\n  localIndex: number;\r\n  arraySetter: any;\r\n\r\n  rebuildStateShape: (options: {\r\n    currentState: any;\r\n    path: string[];\r\n    componentId: string;\r\n    meta?: any;\r\n  }) => any;\r\n  renderFn: (\r\n    setter: any,\r\n    index: number,\r\n\r\n    arraySetter: any\r\n  ) => React.ReactNode;\r\n}) {\r\n  const [, forceUpdate] = useState({});\r\n  const { ref: inViewRef, inView } = useInView();\r\n  const elementRef = useRef<HTMLDivElement | null>(null);\r\n\r\n  const imagesLoaded = useImageLoaded(elementRef);\r\n  const hasReportedInitialHeight = useRef(false);\r\n  const fullKey = [stateKey, ...itemPath].join('.');\r\n  useRegisterComponent(stateKey, itemComponentId, forceUpdate);\r\n\r\n  const setRefs = useCallback(\r\n    (element: HTMLDivElement | null) => {\r\n      elementRef.current = element;\r\n      inViewRef(element); // This is the ref from useInView\r\n    },\r\n    [inViewRef]\r\n  );\r\n\r\n  useEffect(() => {\r\n    const unsubscribe = subscribeToPath(fullKey, (e) => {\r\n      forceUpdate({});\r\n    });\r\n    return () => unsubscribe();\r\n  }, [fullKey]);\r\n  useEffect(() => {\r\n    if (!inView || !imagesLoaded || hasReportedInitialHeight.current) {\r\n      return;\r\n    }\r\n\r\n    const element = elementRef.current;\r\n    if (element && element.offsetHeight > 0) {\r\n      hasReportedInitialHeight.current = true;\r\n      const newHeight = element.offsetHeight;\r\n\r\n      setShadowMetadata(stateKey, itemPath, {\r\n        virtualizer: {\r\n          itemHeight: newHeight,\r\n          domRef: element,\r\n        },\r\n      });\r\n\r\n      const arrayPath = itemPath.slice(0, -1);\r\n      const arrayPathKey = [stateKey, ...arrayPath].join('.');\r\n      notifyPathSubscribers(arrayPathKey, {\r\n        type: 'ITEMHEIGHT',\r\n        itemKey: itemPath.join('.'),\r\n\r\n        ref: elementRef.current,\r\n      });\r\n    }\r\n  }, [inView, imagesLoaded, stateKey, itemPath]);\r\n\r\n  const itemValue = getShadowValue(stateKey, itemPath);\r\n\r\n  if (itemValue === undefined) {\r\n    return null;\r\n  }\r\n\r\n  const itemSetter = rebuildStateShape({\r\n    currentState: itemValue,\r\n    path: itemPath,\r\n    componentId: itemComponentId,\r\n  });\r\n  const children = renderFn(itemSetter, localIndex, arraySetter);\r\n\r\n  return <div ref={setRefs}>{children}</div>;\r\n}\r\n\r\nexport function FormElementWrapper({\r\n  stateKey,\r\n  path,\r\n  rebuildStateShape,\r\n  renderFn,\r\n  formOpts,\r\n  setState,\r\n}: {\r\n  stateKey: string;\r\n  path: string[];\r\n  rebuildStateShape: (options: {\r\n    path: string[];\r\n    componentId: string;\r\n    meta?: any;\r\n  }) => any;\r\n  renderFn: (params: FormElementParams<any>) => React.ReactNode;\r\n  formOpts?: FormOptsType;\r\n  setState: any;\r\n}) {\r\n  const componentId = useRef(uuidv4()).current;\r\n\r\n  const [, forceUpdate] = useState({});\r\n  const formElementRef = useRef<any>(null);\r\n  const stateKeyPathKey = [stateKey, ...path].join('.');\r\n  useRegisterComponent(stateKey, componentId, forceUpdate);\r\n  // Get the shadow node to access typeInfo and schema\r\n  const shadowNode = getGlobalStore.getState().getShadowNode(stateKey, path);\r\n  const typeInfo = shadowNode?._meta?.typeInfo;\r\n  const fieldSchema = typeInfo?.schema; // The actual Zod schema for this field\r\n  console.log('fieldSchema', fieldSchema);\r\n  const globalStateValue = getShadowValue(stateKey, path);\r\n  const [localValue, setLocalValue] = useState<any>(globalStateValue);\r\n  const isCurrentlyDebouncing = useRef(false);\r\n  const debounceTimeoutRef = useRef<NodeJS.Timeout | null>(null);\r\n\r\n  const cogsState = stateHandlers.get(stateKey);\r\n\r\n  // 2. Memoize the list of active form wrappers to avoid re-calculating on every render.\r\n  const activeFormWrappers = useMemo(() => {\r\n    return (\r\n      pluginStore\r\n        .getState()\r\n        .getPluginConfigsForState(stateKey)\r\n        // We only care about plugins that have defined a formWrapper\r\n        .filter((config) => typeof config.plugin.formWrapper === 'function')\r\n    );\r\n  }, [stateKey]);\r\n\r\n  useEffect(() => {\r\n    if (\r\n      !isCurrentlyDebouncing.current &&\r\n      !isDeepEqual(globalStateValue, localValue)\r\n    ) {\r\n      setLocalValue(globalStateValue);\r\n    }\r\n  }, [globalStateValue]);\r\n\r\n  useEffect(() => {\r\n    const { setShadowMetadata } = getGlobalStore.getState();\r\n    setShadowMetadata(stateKey, path, { formRef: formElementRef });\r\n\r\n    const unsubscribe = getGlobalStore\r\n      .getState()\r\n      .subscribeToPath(stateKeyPathKey, (newValue) => {\r\n        if (!isCurrentlyDebouncing.current && localValue !== newValue) {\r\n          forceUpdate({});\r\n        }\r\n      });\r\n    return () => {\r\n      unsubscribe();\r\n      if (debounceTimeoutRef.current) {\r\n        clearTimeout(debounceTimeoutRef.current);\r\n        isCurrentlyDebouncing.current = false;\r\n      }\r\n      const currentMeta = getGlobalStore\r\n        .getState()\r\n        .getShadowMetadata(stateKey, path);\r\n      if (currentMeta && currentMeta.formRef) {\r\n        setShadowMetadata(stateKey, path, { formRef: undefined });\r\n      }\r\n    };\r\n  }, []);\r\n\r\n  // Separate validation function that uses the field's schema\r\n  const validateField = useCallback(\r\n    (value: any, trigger: 'onChange' | 'onBlur') => {\r\n      const validationOptions = getInitialOptions(stateKey)?.validation;\r\n      console.log('validationOptions', validationOptions);\r\n      if (!validationOptions) return;\r\n\r\n      const currentMeta = getShadowMetadata(stateKey, path) || {};\r\n      const currentStatus = currentMeta?.validation?.status;\r\n\r\n      let shouldValidate = false;\r\n      let severity: 'error' | 'warning' | undefined;\r\n\r\n      if (trigger === 'onBlur' && validationOptions.onBlur) {\r\n        shouldValidate = true;\r\n        severity = validationOptions.onBlur ?? 'error';\r\n      } else if (trigger === 'onChange') {\r\n        if (validationOptions.onChange) {\r\n          shouldValidate = true;\r\n          severity = validationOptions.onChange;\r\n        } else if (currentStatus === 'INVALID') {\r\n          shouldValidate = true;\r\n          severity = 'warning';\r\n        }\r\n      }\r\n      console.log('shouldValidate', shouldValidate);\r\n      if (!shouldValidate) return;\r\n\r\n      let validationResult: { success: boolean; message?: string } | null =\r\n        null;\r\n\r\n      if (fieldSchema && shouldValidate) {\r\n        // Direct field validation using its own schema\r\n        const result = fieldSchema.safeParse(value);\r\n\r\n        if (!result.success) {\r\n          const errors =\r\n            'issues' in result.error\r\n              ? result.error.issues\r\n              : (result.error as any).errors;\r\n\r\n          validationResult = {\r\n            success: false,\r\n            message: errors[0]?.message || 'Invalid value',\r\n          };\r\n        } else {\r\n          validationResult = { success: true };\r\n        }\r\n      } else {\r\n        // Fallback: validate using the entire schema\r\n        const zodSchema =\r\n          validationOptions.zodSchemaV4 || validationOptions.zodSchemaV3;\r\n        if (!zodSchema) return;\r\n\r\n        // Create a test state with the new value at the correct path\r\n        const fullState = getShadowValue(stateKey, []);\r\n        const testState = JSON.parse(JSON.stringify(fullState)); // Deep clone\r\n\r\n        // Set the value at the correct path\r\n        let current = testState;\r\n        for (let i = 0; i < path.length - 1; i++) {\r\n          if (!current[path[i]!]) current[path[i]!] = {};\r\n          current = current[path[i]!];\r\n        }\r\n        if (path.length > 0) {\r\n          current[path[path.length - 1]!] = value;\r\n        } else {\r\n          // Root level update\r\n          Object.assign(testState, value);\r\n        }\r\n\r\n        const result = zodSchema.safeParse(testState);\r\n\r\n        if (!result.success) {\r\n          const errors =\r\n            'issues' in result.error\r\n              ? result.error.issues\r\n              : (result.error as any).errors;\r\n\r\n          // Find errors for this specific path\r\n          const pathErrors = errors.filter((error: any) => {\r\n            // Handle array paths with id: prefixes\r\n            if (path.some((p) => p.startsWith('id:'))) {\r\n              const parentPath = path[0]!.startsWith('id:')\r\n                ? []\r\n                : path.slice(0, -1);\r\n              const arrayMeta = getGlobalStore\r\n                .getState()\r\n                .getShadowMetadata(stateKey, parentPath);\r\n\r\n              if (arrayMeta?.arrayKeys) {\r\n                const itemKey = path.slice(0, -1).join('.');\r\n                const itemIndex = arrayMeta.arrayKeys.findIndex(\r\n                  (k) => k === path[path.length - 2]\r\n                );\r\n                const zodPath = [...parentPath, itemIndex, ...path.slice(-1)];\r\n                return JSON.stringify(error.path) === JSON.stringify(zodPath);\r\n              }\r\n            }\r\n\r\n            return JSON.stringify(error.path) === JSON.stringify(path);\r\n          });\r\n\r\n          if (pathErrors.length > 0) {\r\n            validationResult = {\r\n              success: false,\r\n              message: pathErrors[0]?.message,\r\n            };\r\n          } else {\r\n            validationResult = { success: true };\r\n          }\r\n        } else {\r\n          validationResult = { success: true };\r\n        }\r\n      }\r\n\r\n      // Update validation state based on result\r\n      if (validationResult) {\r\n        if (!validationResult.success) {\r\n          setShadowMetadata(stateKey, path, {\r\n            ...currentMeta,\r\n            validation: {\r\n              status: 'INVALID',\r\n              errors: [\r\n                {\r\n                  source: 'client' as const,\r\n                  message: validationResult.message!,\r\n                  severity: severity!,\r\n                },\r\n              ],\r\n              lastValidated: Date.now(),\r\n              validatedValue: value,\r\n            },\r\n          });\r\n        } else {\r\n          setShadowMetadata(stateKey, path, {\r\n            ...currentMeta,\r\n            validation: {\r\n              status: 'VALID',\r\n              errors: [],\r\n              lastValidated: Date.now(),\r\n              validatedValue: value,\r\n            },\r\n          });\r\n        }\r\n      }\r\n      forceUpdate({});\r\n    },\r\n    [stateKey, path, fieldSchema]\r\n  );\r\n\r\n  const debouncedUpdate = useCallback(\r\n    (newValue: any) => {\r\n      if (typeInfo) {\r\n        if (typeInfo.type === 'number' && typeof newValue === 'string') {\r\n          newValue =\r\n            newValue === ''\r\n              ? typeInfo.nullable\r\n                ? null\r\n                : (typeInfo.default ?? 0)\r\n              : Number(newValue);\r\n        } else if (\r\n          typeInfo.type === 'boolean' &&\r\n          typeof newValue === 'string'\r\n        ) {\r\n          newValue = newValue === 'true' || newValue === '1';\r\n        } else if (typeInfo.type === 'date' && typeof newValue === 'string') {\r\n          newValue = new Date(newValue);\r\n        }\r\n      } else {\r\n        // Fallback to old behavior if no typeInfo\r\n\r\n        const currentType = typeof globalStateValue;\r\n\r\n        if (currentType === 'number' && typeof newValue === 'string') {\r\n          newValue = newValue === '' ? 0 : Number(newValue);\r\n        }\r\n      }\r\n\r\n      setLocalValue(newValue);\r\n      notifyFormUpdate({\r\n        stateKey,\r\n        type: 'input',\r\n        path,\r\n        value: newValue,\r\n      });\r\n      // Validate immediately on change (will only run if configured or clearing errors)\r\n      validateField(newValue, 'onChange');\r\n\r\n      isCurrentlyDebouncing.current = true;\r\n\r\n      if (debounceTimeoutRef.current) {\r\n        clearTimeout(debounceTimeoutRef.current);\r\n      }\r\n\r\n      const debounceTime = formOpts?.debounceTime ?? 200;\r\n\r\n      // Debounce only the state update, not the validation\r\n      debounceTimeoutRef.current = setTimeout(() => {\r\n        isCurrentlyDebouncing.current = false;\r\n        setState(newValue, path, { updateType: 'update' });\r\n      }, debounceTime);\r\n    },\r\n    [\r\n      setState,\r\n      path,\r\n      formOpts?.debounceTime,\r\n      validateField,\r\n      typeInfo,\r\n      globalStateValue,\r\n    ]\r\n  );\r\n  const virtualFocusPath = `${stateKey}.__focusedElement`;\r\n  const newFocusedElement = { path, ref: formElementRef };\r\n  const handleFocus = useCallback(() => {\r\n    const rootMeta =\r\n      getGlobalStore.getState().getShadowMetadata(stateKey, []) || {};\r\n    setShadowMetadata(stateKey, [], {\r\n      ...rootMeta,\r\n      focusedElement: { path, ref: formElementRef },\r\n    });\r\n    notifyPathSubscribers(virtualFocusPath, newFocusedElement);\r\n    notifyFormUpdate({\r\n      stateKey,\r\n      type: 'focus',\r\n      path,\r\n      value: localValue,\r\n    });\r\n  }, [stateKey, path, formElementRef]);\r\n\r\n  const handleBlur = useCallback(() => {\r\n    if (debounceTimeoutRef.current) {\r\n      clearTimeout(debounceTimeoutRef.current);\r\n      debounceTimeoutRef.current = null;\r\n      isCurrentlyDebouncing.current = false;\r\n      setState(localValue, path, { updateType: 'update' });\r\n    }\r\n    console.log('handleBlur');\r\n    queueMicrotask(() => {\r\n      const rootMeta =\r\n        getGlobalStore.getState().getShadowMetadata(stateKey, []) || {};\r\n      if (\r\n        rootMeta.focusedElement &&\r\n        JSON.stringify(rootMeta.focusedElement.path) === JSON.stringify(path)\r\n      ) {\r\n        setShadowMetadata(stateKey, [], {\r\n          focusedElement: null,\r\n        });\r\n        notifyPathSubscribers(virtualFocusPath, null);\r\n        notifyFormUpdate({\r\n          stateKey,\r\n          type: 'blur',\r\n          path,\r\n          value: localValue,\r\n        });\r\n      }\r\n    });\r\n    console.log('handleBlur', localValue);\r\n    validateField(localValue, 'onBlur');\r\n  }, [localValue, setState, path, validateField, stateKey]);\r\n\r\n  const baseState = rebuildStateShape({\r\n    path: path,\r\n    componentId: componentId,\r\n    meta: undefined,\r\n  });\r\n\r\n  const stateWithInputProps = new Proxy(baseState, {\r\n    get(target, prop) {\r\n      if (prop === '$inputProps') {\r\n        return {\r\n          value: localValue ?? '',\r\n          onChange: (e: any) => {\r\n            debouncedUpdate(e.target.value);\r\n          },\r\n          onFocus: handleFocus,\r\n          onBlur: handleBlur,\r\n          ref: formElementRef,\r\n        };\r\n      }\r\n\r\n      return target[prop];\r\n    },\r\n  });\r\n\r\n  const initialElement = renderFn(stateWithInputProps);\r\n\r\n  const wrappedElement = activeFormWrappers.reduceRight(\r\n    (currentElement, config, index) => (\r\n      <PluginWrapper\r\n        stateKey={stateKey}\r\n        path={path}\r\n        pluginName={config.plugin.name}\r\n        wrapperDepth={activeFormWrappers.length - 1 - index}\r\n      >\r\n        {currentElement}\r\n      </PluginWrapper>\r\n    ),\r\n    initialElement\r\n  );\r\n\r\n  return (\r\n    <ValidationWrapper formOpts={formOpts} path={path} stateKey={stateKey}>\r\n      {wrappedElement}\r\n    </ValidationWrapper>\r\n  );\r\n}\r\nexport function useRegisterComponent(\r\n  stateKey: string,\r\n  componentId: string,\r\n  forceUpdate: (o: object) => void\r\n) {\r\n  const fullComponentId = `${stateKey}////${componentId}`;\r\n\r\n  useLayoutEffect(() => {\r\n    // Call the safe, centralized function to register\r\n    registerComponent(stateKey, fullComponentId, {\r\n      forceUpdate: () => forceUpdate({}),\r\n      paths: new Set(),\r\n      reactiveType: ['component'],\r\n    });\r\n\r\n    // The cleanup now calls the safe, centralized unregister function\r\n    return () => {\r\n      unregisterComponent(stateKey, fullComponentId);\r\n    };\r\n  }, [stateKey, fullComponentId]); // Dependencies are stable and correct\r\n}\r\n\r\nconst useImageLoaded = (ref: RefObject<HTMLElement>): boolean => {\r\n  const [loaded, setLoaded] = useState(false);\r\n\r\n  useLayoutEffect(() => {\r\n    if (!ref.current) {\r\n      setLoaded(true);\r\n      return;\r\n    }\r\n\r\n    const images = Array.from(ref.current.querySelectorAll('img'));\r\n\r\n    // If there are no images, we are \"loaded\" immediately.\r\n    if (images.length === 0) {\r\n      setLoaded(true);\r\n      return;\r\n    }\r\n\r\n    let loadedCount = 0;\r\n    const handleImageLoad = () => {\r\n      loadedCount++;\r\n      if (loadedCount === images.length) {\r\n        setLoaded(true);\r\n      }\r\n    };\r\n\r\n    images.forEach((image) => {\r\n      if (image.complete) {\r\n        handleImageLoad();\r\n      } else {\r\n        image.addEventListener('load', handleImageLoad);\r\n        image.addEventListener('error', handleImageLoad);\r\n      }\r\n    });\r\n\r\n    return () => {\r\n      images.forEach((image) => {\r\n        image.removeEventListener('load', handleImageLoad);\r\n        image.removeEventListener('error', handleImageLoad);\r\n      });\r\n    };\r\n  }, [ref.current]);\r\n\r\n  return loaded;\r\n};\r\n// Components.tsx\r\n\r\n// Generic isolated component wrapper\r\nexport function IsolatedComponentWrapper({\r\n  stateKey,\r\n  path,\r\n  rebuildStateShape,\r\n  renderFn,\r\n}: {\r\n  stateKey: string;\r\n  path: string[];\r\n  rebuildStateShape: (options: {\r\n    path: string[];\r\n    componentId: string;\r\n    meta?: any;\r\n  }) => any;\r\n  renderFn: (state: any) => React.ReactNode;\r\n}) {\r\n  const [componentId] = useState(() => uuidv4());\r\n  const [, forceUpdate] = useState({});\r\n\r\n  const stateKeyPathKey = [stateKey, ...path].join('.');\r\n  useRegisterComponent(stateKey, componentId, forceUpdate);\r\n\r\n  useEffect(() => {\r\n    const unsubscribe = getGlobalStore\r\n      .getState()\r\n      .subscribeToPath(stateKeyPathKey, () => {\r\n        forceUpdate({});\r\n      });\r\n    return () => unsubscribe();\r\n  }, [stateKeyPathKey]);\r\n\r\n  const baseState = rebuildStateShape({\r\n    path: path,\r\n    componentId: componentId,\r\n    meta: undefined,\r\n  });\r\n\r\n  return <>{renderFn(baseState)}</>;\r\n}\r\n\r\n// 1. Define the MINIMAL props needed.\r\ntype PluginWrapperProps = {\r\n  children: React.ReactNode;\r\n  stateKey: string;\r\n  path: string[];\r\n  pluginName: string;\r\n  wrapperDepth: number;\r\n};\r\n\r\nconst PluginWrapper = memo(function PluginWrapper({\r\n  children,\r\n  stateKey,\r\n  path,\r\n  pluginName,\r\n  wrapperDepth,\r\n}: PluginWrapperProps) {\r\n  const [, forceUpdate] = useState({});\r\n\r\n  useEffect(() => {\r\n    const fullPathKey = [stateKey, ...path].join('.');\r\n    const unsubscribe = getGlobalStore\r\n      .getState()\r\n      .subscribeToPath(fullPathKey, () => {\r\n        forceUpdate({});\r\n      });\r\n    return unsubscribe;\r\n  }, [stateKey, path]);\r\n\r\n  const plugin = pluginStore\r\n    .getState()\r\n    .registeredPlugins.find((p) => p.name === pluginName);\r\n\r\n  const stateHandler: StateObject<any> | undefined = pluginStore\r\n    .getState()\r\n    .stateHandlers.get(stateKey);\r\n\r\n  const typeInfo = getGlobalStore.getState().getShadowNode(stateKey, path)\r\n    ?._meta?.typeInfo;\r\n\r\n  const options = pluginStore\r\n    .getState()\r\n    .pluginOptions.get(stateKey)\r\n    ?.get(pluginName);\r\n\r\n  const hookData = pluginStore.getState().getHookResult(stateKey, pluginName);\r\n\r\n  if (!plugin?.formWrapper || !stateHandler) {\r\n    return <>{children}</>;\r\n  }\r\n\r\n  const metadataContext = createMetadataContext(stateKey, plugin.name);\r\n  const deconstructed = toDeconstructedMethods(stateHandler);\r\n\r\n  return plugin.formWrapper({\r\n    element: children,\r\n    path,\r\n    stateKey,\r\n    pluginName: plugin.name,\r\n    ...deconstructed,\r\n    ...metadataContext,\r\n    options,\r\n    hookData,\r\n    fieldType: typeInfo?.type,\r\n    wrapperDepth,\r\n  });\r\n});\r\n"],"names":["getInitialOptions","getShadowMetadata","setShadowMetadata","getShadowValue","registerComponent","unregisterComponent","notifyPathSubscribers","subscribeToPath","getGlobalStore","stateHandlers","notifyFormUpdate","pluginStore","ValidationWrapper","formOpts","path","stateKey","children","thisStateOpts","validationState","status","errors","err","errorMessages","warningMessages","message","primarySeverity","jsx","Fragment","React","MemoizedCogsItemWrapper","memo","ListItemWrapper","prevProps","nextProps","itemComponentId","itemPath","localIndex","arraySetter","rebuildStateShape","renderFn","forceUpdate","useState","inViewRef","inView","useInView","elementRef","useRef","imagesLoaded","useImageLoaded","hasReportedInitialHeight","fullKey","useRegisterComponent","setRefs","useCallback","element","useEffect","unsubscribe","e","newHeight","arrayPath","arrayPathKey","itemValue","itemSetter","FormElementWrapper","setState","componentId","uuidv4","formElementRef","stateKeyPathKey","typeInfo","fieldSchema","globalStateValue","localValue","setLocalValue","isCurrentlyDebouncing","debounceTimeoutRef","activeFormWrappers","useMemo","config","isDeepEqual","newValue","currentMeta","validateField","value","trigger","validationOptions","currentStatus","shouldValidate","severity","validationResult","result","zodSchema","fullState","testState","current","i","pathErrors","error","p","parentPath","arrayMeta","itemIndex","k","zodPath","debouncedUpdate","debounceTime","virtualFocusPath","newFocusedElement","handleFocus","rootMeta","handleBlur","baseState","stateWithInputProps","target","prop","initialElement","wrappedElement","currentElement","index","PluginWrapper","fullComponentId","useLayoutEffect","ref","loaded","setLoaded","images","loadedCount","handleImageLoad","image","IsolatedComponentWrapper","pluginName","wrapperDepth","fullPathKey","plugin","stateHandler","options","hookData","metadataContext","createMetadataContext","deconstructed","toDeconstructedMethods"],"mappings":"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"}