{"version":3,"file":"CogsState.jsx","sources":["../src/CogsState.tsx"],"sourcesContent":["\"use client\";\r\nimport {\r\n  createElement,\r\n  startTransition,\r\n  useEffect,\r\n  useLayoutEffect,\r\n  useMemo,\r\n  useRef,\r\n  useState,\r\n  useSyncExternalStore,\r\n  type ReactNode,\r\n} from \"react\";\r\n\r\nimport {\r\n  debounce,\r\n  getDifferences,\r\n  getNestedValue,\r\n  isFunction,\r\n  type GenericObject,\r\n} from \"./utility.js\";\r\nimport {\r\n  cutFunc,\r\n  FormControlComponent,\r\n  pushFunc,\r\n  updateFn,\r\n  ValidationWrapper,\r\n} from \"./Functions.js\";\r\nimport { isDeepEqual, transformStateFunc } from \"./utility.js\";\r\nimport type { UseMutationResult } from \"@tanstack/react-query\";\r\nimport { v4 as uuidv4 } from \"uuid\";\r\nimport { ZodArray, ZodObject, type ZodRawShape } from \"zod\";\r\n\r\nimport { formRefStore, getGlobalStore, type ComponentsType } from \"./store.js\";\r\nimport { useCogsConfig } from \"./CogsStateClient.js\";\r\n\r\ntype Prettify<T> = { [K in keyof T]: T[K] } & {};\r\n\r\nexport type ServerSyncStatus = {\r\n  isFresh: boolean;\r\n  isFreshTime: number;\r\n  isStale: boolean;\r\n  isStaleTime: number;\r\n  isSyncing: boolean;\r\n  isSyncingTime: number;\r\n};\r\n\r\nexport type SyncInfo = {\r\n  timeStamp: number;\r\n  userId: number;\r\n};\r\n\r\nexport type FormElementParams<T> = {\r\n  get: () => T;\r\n\r\n  set: UpdateType<T>;\r\n  syncStatus: (SyncInfo & { date: Date }) | null;\r\n  path: string[];\r\n  validationErrors: () => string[];\r\n  addValidationError: (message?: string) => void;\r\n\r\n  inputProps: {\r\n    ref?: React.RefObject<any>;\r\n    value?: T extends boolean ? never : T;\r\n    onChange?: (\r\n      event: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>\r\n    ) => void;\r\n    onBlur?: () => void;\r\n  };\r\n};\r\n\r\nexport type StateKeys = string;\r\n\r\ntype findWithFuncType<U> = (\r\n  thisKey: keyof U,\r\n  thisValue: U[keyof U]\r\n) => EndType<U> & StateObject<U>;\r\nexport type PushArgs<U> = (\r\n  update:\r\n    | Prettify<U>\r\n    | ((prevState: NonNullable<Prettify<U>>[]) => NonNullable<Prettify<U>>),\r\n  opts?: UpdateOpts<U>\r\n) => void;\r\n\r\ntype CutFunctionType = (\r\n  index?: number,\r\n  options?: { waitForSync?: boolean }\r\n) => void;\r\n\r\nexport type InferArrayElement<T> = T extends (infer U)[] ? U : never;\r\n\r\nexport type ArrayEndType<TShape extends unknown> = {\r\n  findWith: findWithFuncType<InferArrayElement<TShape>>;\r\n  index: (index: number) => StateObject<InferArrayElement<TShape>> & {\r\n    insert: PushArgs<InferArrayElement<TShape>>;\r\n    cut: CutFunctionType;\r\n    _index: number;\r\n  } & EndType<InferArrayElement<TShape>>;\r\n  insert: PushArgs<InferArrayElement<TShape>>;\r\n  cut: CutFunctionType;\r\n  cutByValue: (value: string | number | boolean) => void;\r\n  toggleByValue: (value: string | number | boolean) => void;\r\n  stateSort: (\r\n    compareFn: (\r\n      a: InferArrayElement<TShape>,\r\n      b: InferArrayElement<TShape>\r\n    ) => number\r\n  ) => ArrayEndType<TShape>;\r\n\r\n  stateMapNoRender: (\r\n    callbackfn: (\r\n      value: InferArrayElement<TShape>,\r\n      setter: StateObject<InferArrayElement<TShape>>,\r\n      index: number,\r\n      array: TShape,\r\n      arraySetter: StateObject<TShape>\r\n    ) => void\r\n  ) => any;\r\n  stateMap: (\r\n    callbackfn: (\r\n      value: InferArrayElement<TShape>,\r\n      setter: StateObject<InferArrayElement<TShape>>,\r\n      index: number,\r\n      array: TShape,\r\n      arraySetter: StateObject<TShape>\r\n    ) => void\r\n  ) => any;\r\n  $stateMap: (\r\n    callbackfn: (\r\n      value: InferArrayElement<TShape>,\r\n      setter: StateObject<InferArrayElement<TShape>>,\r\n      index: number,\r\n      array: TShape,\r\n      arraySetter: StateObject<TShape>\r\n    ) => void\r\n  ) => any;\r\n  stateFlattenOn: <K extends keyof InferArrayElement<TShape>>(\r\n    field: K\r\n  ) => StateObject<InferArrayElement<InferArrayElement<TShape>[K]>[]>;\r\n  uniqueInsert: (\r\n    payload: UpdateArg<InferArrayElement<TShape>>,\r\n    fields?: (keyof InferArrayElement<TShape>)[],\r\n    onMatch?: (existingItem: any) => any\r\n  ) => void;\r\n  stateFilter: (\r\n    callbackfn: (value: InferArrayElement<TShape>, index: number) => void\r\n  ) => ArrayEndType<TShape>;\r\n  getSelected: () => StateObject<InferArrayElement<TShape>> | undefined;\r\n  getSelectedIndex: () => number;\r\n} & EndType<TShape> & {\r\n    [K in keyof (any[] extends infer T ? T : never)]: never;\r\n  };\r\n\r\nexport type UpdateType<T> = (\r\n  payload: UpdateArg<Prettify<T>>,\r\n  opts?: UpdateOpts<T>\r\n) => void;\r\nexport type FormOptsType = {\r\n  key?: string;\r\n  validation?: {\r\n    hideMessage?: boolean;\r\n    message?: string;\r\n    stretch?: boolean;\r\n    props?: GenericObject;\r\n    disable?: boolean;\r\n  };\r\n  formElements?: boolean;\r\n  debounceTime?: number;\r\n  stateServerDifferences?: string[][];\r\n};\r\n\r\nexport type FormControl<T> = (obj: FormElementParams<T>) => JSX.Element;\r\n\r\nexport type UpdateArg<S> = S | ((prevState: S) => S);\r\nexport type UpdateOpts<T> = {\r\n  afterUpdate?: (state: T) => void;\r\n  debounce?: number;\r\n};\r\nexport type ObjectEndType<T> = EndType<T> & {\r\n  [K in keyof T]-?: ObjectEndType<T[K]>;\r\n} & {\r\n  stateObject: (callbackfn: (value: T, setter: StateObject<T>) => void) => any;\r\n  delete: () => void;\r\n};\r\ntype EffectFunction<T, R> = (state: T) => R;\r\nexport type EndType<T, IsArrayElement = false> = {\r\n  update: UpdateType<T>;\r\n  _path: string[];\r\n  _stateKey: string;\r\n  formElement: (control: FormControl<T>, opts?: FormOptsType) => JSX.Element;\r\n  get: () => T;\r\n  $get: () => T;\r\n  $derive: <R>(fn: EffectFunction<T, R>) => R;\r\n  _status: \"fresh\" | \"stale\" | \"synced\";\r\n  getStatus: () => \"fresh\" | \"stale\";\r\n  showValidationErrors: () => string[];\r\n  setValidation: (ctx: string) => void;\r\n  removeValidation: (ctx: string) => void;\r\n  ignoreFields: (fields: string[]) => StateObject<T>;\r\n  _selected: boolean;\r\n  setSelected: (value: boolean) => void;\r\n  getFormRef: () => React.RefObject<any> | undefined;\r\n  removeStorage: () => void;\r\n  validationWrapper: ({\r\n    children,\r\n    hideMessage,\r\n  }: {\r\n    children: React.ReactNode;\r\n    hideMessage?: boolean;\r\n  }) => JSX.Element;\r\n  lastSynced?: SyncInfo;\r\n} & (IsArrayElement extends true ? { cut: () => void } : {}) & {\r\n    [K in keyof (any extends infer T ? T : never)]: never;\r\n  };\r\n\r\nexport type StateObject<T> = (T extends any[]\r\n  ? ArrayEndType<T>\r\n  : T extends Record<string, unknown> | object\r\n    ? { [K in keyof T]-?: StateObject<T[K]> } & ObjectEndType<T>\r\n    : T extends string | number | boolean | null\r\n      ? T\r\n      : never) &\r\n  EndType<T, true> & {\r\n    getAllFormRefs: () => Map<string, React.RefObject<any>>;\r\n    _componentId: string | null;\r\n    getComponents: () => ComponentsType;\r\n    validateZodSchema: () => void;\r\n    _initialState: T;\r\n    updateInitialState: (newState: T | null) => {\r\n      fetchId: (field: keyof T) => string | number;\r\n    };\r\n    _isLoading: boolean;\r\n    _serverState: T;\r\n    revertToInitialState: (obj?: { validationKey?: string }) => T;\r\n    middleware: (\r\n      middles: ({\r\n        updateLog,\r\n        update,\r\n      }: {\r\n        updateLog: UpdateTypeDetail[] | undefined;\r\n        update: UpdateTypeDetail;\r\n      }) => void\r\n    ) => void;\r\n    _isServerSynced: () => boolean;\r\n    getLocalStorage: (key: string) => LocalStorageData<T> | null;\r\n  };\r\n\r\nexport type CogsUpdate<T extends unknown> = UpdateType<T>;\r\n\r\nexport type EffectiveSetState<TStateObject> = (\r\n  newStateOrFunction:\r\n    | TStateObject\r\n    | ((prevState: TStateObject) => TStateObject),\r\n  path: string[],\r\n  updateObj: { updateType: \"update\" | \"insert\" | \"cut\" },\r\n  validationKey?: string,\r\n  opts?: UpdateOpts<TStateObject>\r\n) => void;\r\n\r\nexport type UpdateTypeDetail = {\r\n  timeStamp: number;\r\n  stateKey: string;\r\n  updateType: \"update\" | \"insert\" | \"cut\";\r\n  path: string[];\r\n  status: \"new\" | \"sent\" | \"synced\";\r\n  oldValue: any;\r\n  newValue: any;\r\n  userId?: number;\r\n};\r\n\r\nexport type ActionsType<T> = {\r\n  type: \"onChange\";\r\n  action: ({ state, actionType }: { state: T; actionType: string }) => void;\r\n  debounce?: number;\r\n}[];\r\n\r\ntype ArrayToObject<T extends string[]> = Record<T[number], string>;\r\ntype CookieType<T> = {\r\n  timeStamp: number;\r\n  value: T;\r\n  cookieName: string;\r\n  OnUnMountCookie?: Boolean;\r\n};\r\nexport type CogsCookiesType<T extends string[] = string[]> = CookieType<\r\n  ArrayToObject<T>\r\n>;\r\nexport type ReactivityType = \"none\" | \"component\" | \"deps\" | \"all\";\r\n\r\ntype ValidationOptionsType = {\r\n  key?: string;\r\n  zodSchema?: ZodObject<ZodRawShape> | ZodArray<ZodObject<ZodRawShape>>;\r\n  onBlur?: boolean;\r\n};\r\n\r\nexport type OptionsType<T extends unknown = unknown> = {\r\n  log?: boolean;\r\n  componentId?: string;\r\n  serverSync?: ServerSyncType<T>;\r\n  validation?: ValidationOptionsType;\r\n  enableServerState?: boolean;\r\n  middleware?: ({\r\n    updateLog,\r\n    update,\r\n  }: {\r\n    updateLog: UpdateTypeDetail[] | undefined;\r\n    update: UpdateTypeDetail;\r\n  }) => void;\r\n\r\n  modifyState?: (state: T) => T;\r\n  localStorage?: {\r\n    key: string | ((state: T) => string);\r\n    onChange?: (state: T) => void;\r\n  };\r\n  formElements?: FormsElementsType;\r\n  enabledSync?: (state: T) => boolean;\r\n  reactiveDeps?: (state: T) => any[] | true;\r\n  reactiveType?: ReactivityType[] | ReactivityType;\r\n  syncUpdate?: Partial<UpdateTypeDetail>;\r\n  pk?: keyof T;\r\n  currrentPk?: string | number;\r\n  initialState?: T;\r\n  dependencies?: any[]; // Just like useEffect dependencies\r\n};\r\nexport type ServerSyncType<T> = {\r\n  testKey?: string;\r\n  syncKey: (({ state }: { state: T }) => string) | string;\r\n  syncFunction: ({ state }: { state: T }) => void;\r\n  debounce?: number;\r\n  mutation: UseMutationResult<any, unknown, any, unknown>;\r\n  snapshot?: {\r\n    name: (({ state }: { state: T }) => string) | string;\r\n    stateKeys: StateKeys[];\r\n    currentUrl: string;\r\n    currentParams?: URLSearchParams;\r\n  };\r\n};\r\nexport type SyncActionsType<T> = {\r\n  syncKey: string;\r\n\r\n  rollBackState?: T;\r\n  actionTimeStamp: number;\r\n  retryCount?: number;\r\n  status:\r\n    | \"success\"\r\n    | \"waiting\"\r\n    | \"rolledBack\"\r\n    | \"error\"\r\n    | \"cancelled\"\r\n    | \"failed\";\r\n  snapshot?: {\r\n    name: string;\r\n    stateKeys: StateKeys[];\r\n    currentUrl: string;\r\n    currentParams?: URLSearchParams;\r\n  };\r\n};\r\n\r\nexport type ValidationWrapperOptions<T extends unknown = unknown> = {\r\n  children: React.ReactNode;\r\n  active: boolean;\r\n  stretch?: boolean;\r\n  path: string[];\r\n  message?: string;\r\n  data?: T;\r\n  key?: string;\r\n};\r\nexport type SyncRenderOptions<T extends unknown = unknown> = {\r\n  children: React.ReactNode;\r\n  time: number;\r\n  data?: T;\r\n  key?: string;\r\n};\r\n\r\ntype FormsElementsType<T extends unknown = unknown> = {\r\n  validation?: (options: ValidationWrapperOptions<T>) => React.ReactNode;\r\n  syncRender?: (options: SyncRenderOptions<T>) => React.ReactNode;\r\n};\r\n\r\nexport type InitialStateInnerType<T extends unknown = unknown> = {\r\n  initialState: T;\r\n} & OptionsType<T>;\r\n\r\nexport type InitialStateType<T> = {\r\n  [key: string]: InitialStateInnerType<T>;\r\n};\r\n\r\nexport type AllStateTypes<T extends unknown> = Record<string, T>;\r\n\r\nexport type CogsInitialState<T> = {\r\n  initialState: T;\r\n  formElements?: FormsElementsType<T>;\r\n};\r\n\r\nexport type TransformedStateType<T> = {\r\n  [P in keyof T]: T[P] extends CogsInitialState<infer U> ? U : T[P];\r\n};\r\n\r\nfunction setAndMergeOptions(\r\n  stateKey: string,\r\n  newOptions: OptionsType<unknown>\r\n) {\r\n  const getInitialOptions = getGlobalStore.getState().getInitialOptions;\r\n  const setInitialStateOptions =\r\n    getGlobalStore.getState().setInitialStateOptions;\r\n\r\n  const initialOptions = getInitialOptions(stateKey as string) || {};\r\n\r\n  setInitialStateOptions(stateKey as string, {\r\n    ...initialOptions,\r\n    ...newOptions,\r\n  });\r\n}\r\nfunction setOptions<StateKey, Opt>({\r\n  stateKey,\r\n  options,\r\n  initialOptionsPart,\r\n}: {\r\n  stateKey: StateKey;\r\n  options?: OptionsType<any>;\r\n  initialOptionsPart: Record<string, any>;\r\n}) {\r\n  const initialOptions = getInitialOptions(stateKey as string) || {};\r\n  const initialOptionsPartState = initialOptionsPart[stateKey as string] || {};\r\n  const setInitialStateOptions =\r\n    getGlobalStore.getState().setInitialStateOptions;\r\n  const mergedOptions = { ...initialOptionsPartState, ...initialOptions };\r\n\r\n  let needToAdd = false;\r\n  if (options) {\r\n    for (const key in options) {\r\n      if (!mergedOptions.hasOwnProperty(key)) {\r\n        needToAdd = true;\r\n        mergedOptions[key] = options[key as keyof typeof options];\r\n      } else {\r\n        if (\r\n          key == \"localStorage\" &&\r\n          options[key] &&\r\n          mergedOptions[key].key !== options[key]?.key\r\n        ) {\r\n          needToAdd = true;\r\n          mergedOptions[key] = options[key];\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  if (needToAdd) {\r\n    setInitialStateOptions(stateKey as string, mergedOptions);\r\n  }\r\n}\r\nexport function addStateOptions<T extends unknown>(\r\n  initialState: T,\r\n  { formElements, validation }: OptionsType<T>\r\n) {\r\n  return { initialState: initialState, formElements, validation } as T;\r\n}\r\n\r\nexport const createCogsState = <State extends Record<string, unknown>>(\r\n  initialState: State,\r\n  opt?: { formElements?: FormsElementsType; validation?: ValidationOptionsType }\r\n) => {\r\n  let newInitialState = initialState;\r\n\r\n  // Extract state parts and options using transformStateFunc\r\n  const [statePart, initialOptionsPart] =\r\n    transformStateFunc<State>(newInitialState);\r\n\r\n  // Apply global formElements as defaults to each state key's options\r\n  if (\r\n    Object.keys(initialOptionsPart).length > 0 ||\r\n    (opt && Object.keys(opt).length > 0)\r\n  ) {\r\n    Object.keys(initialOptionsPart).forEach((key) => {\r\n      // Get the existing options for this state key\r\n      initialOptionsPart[key] = initialOptionsPart[key] || {};\r\n\r\n      initialOptionsPart[key].formElements = {\r\n        ...opt?.formElements, // Global defaults first\r\n        ...opt?.validation,\r\n        ...(initialOptionsPart[key].formElements || {}), // State-specific overrides\r\n      };\r\n      const existingOptions = getInitialOptions(key);\r\n\r\n      if (!existingOptions) {\r\n        getGlobalStore\r\n          .getState()\r\n          .setInitialStateOptions(key, initialOptionsPart[key]);\r\n      }\r\n    });\r\n  }\r\n\r\n  getGlobalStore.getState().setInitialStates(statePart);\r\n  type StateKeys = keyof typeof statePart;\r\n\r\n  const useCogsState = <StateKey extends StateKeys>(\r\n    stateKey: StateKey,\r\n    options?: OptionsType<(typeof statePart)[StateKey]>\r\n  ) => {\r\n    const [componentId] = useState(options?.componentId ?? uuidv4());\r\n\r\n    setOptions({\r\n      stateKey,\r\n      options,\r\n      initialOptionsPart,\r\n    });\r\n\r\n    const thiState =\r\n      getGlobalStore.getState().cogsStateStore[stateKey as string] ||\r\n      statePart[stateKey as string];\r\n    const partialState = options?.modifyState\r\n      ? options.modifyState(thiState)\r\n      : thiState;\r\n\r\n    const [state, updater] = useCogsStateFn<(typeof statePart)[StateKey]>(\r\n      partialState,\r\n      {\r\n        stateKey: stateKey as string,\r\n        syncUpdate: options?.syncUpdate,\r\n        componentId,\r\n        localStorage: options?.localStorage,\r\n        middleware: options?.middleware,\r\n        enabledSync: options?.enabledSync,\r\n        reactiveType: options?.reactiveType,\r\n        reactiveDeps: options?.reactiveDeps,\r\n        initialState: options?.initialState,\r\n        dependencies: options?.dependencies,\r\n      }\r\n    );\r\n\r\n    return updater;\r\n  };\r\n\r\n  function setCogsOptions<StateKey extends StateKeys>(\r\n    stateKey: StateKey,\r\n    options: OptionsType<(typeof statePart)[StateKey]>\r\n  ) {\r\n    setOptions({ stateKey, options, initialOptionsPart });\r\n  }\r\n\r\n  return { useCogsState, setCogsOptions };\r\n};\r\n\r\nconst {\r\n  setUpdaterState,\r\n  setState,\r\n  getInitialOptions,\r\n  getKeyState,\r\n  getValidationErrors,\r\n  setStateLog,\r\n  updateInitialStateGlobal,\r\n  addValidationError,\r\n  removeValidationError,\r\n  setServerSyncActions,\r\n} = getGlobalStore.getState();\r\n\r\nconst loadFromLocalStorage = (localStorageKey: string) => {\r\n  if (!localStorageKey) return null;\r\n\r\n  try {\r\n    const storedData = window.localStorage.getItem(localStorageKey);\r\n    if (!storedData) return null;\r\n\r\n    const parsedData = JSON.parse(storedData);\r\n\r\n    return parsedData;\r\n  } catch (error) {\r\n    console.error(\"Error loading from localStorage:\", error);\r\n    return null;\r\n  }\r\n};\r\n\r\nconst saveToLocalStorage = <T,>(\r\n  state: T,\r\n  thisKey: string,\r\n  currentInitialOptions: any,\r\n  sessionId?: string,\r\n  baseStateToSave?: T\r\n) => {\r\n  // --- Keep existing logic to calculate storageKey ---\r\n  const key = isFunction(currentInitialOptions?.localStorage?.key)\r\n    ? currentInitialOptions.localStorage?.key(state)\r\n    : currentInitialOptions?.localStorage?.key;\r\n  if (!key || !sessionId) {\r\n    return;\r\n  }\r\n  const storageKey = `${sessionId}-${thisKey}-${key}`;\r\n  // --- End existing logic ---\r\n\r\n  try {\r\n    let data: LocalStorageData<T>;\r\n    if (baseStateToSave !== undefined) {\r\n      // Case 1: Base state is provided (initial save/refresh)\r\n      data = {\r\n        state: state,\r\n        baseServerState: baseStateToSave, // Use provided base\r\n        lastUpdated: Date.now(),\r\n      };\r\n    } else {\r\n      // Case 2: Base state is NOT provided (user edit) - preserve existing base\r\n      const existingData = loadFromLocalStorage(storageKey); // Reuse load function\r\n      data = {\r\n        state: state,\r\n        // !!! --- REMOVED '?? null' --- !!!\r\n        baseServerState: existingData?.baseServerState, // Preserve existing base (will be T | null | undefined)\r\n        lastUpdated: Date.now(),\r\n      };\r\n    }\r\n    window.localStorage.setItem(storageKey, JSON.stringify(data));\r\n  } catch (error) {\r\n    console.error(\"Error saving to localStorage:\", storageKey, error);\r\n  }\r\n};\r\n\r\ntype LocalStorageData<T> = {\r\n  state: T;\r\n  lastUpdated: number;\r\n  lastSyncedWithServer?: number;\r\n  baseServerState?: T; // Add this to track what server state our changes are based on\r\n};\r\n\r\nconst updateGlobalState = (\r\n  thisKey: string,\r\n  initialState: any,\r\n  newState: any,\r\n  effectiveSetState: EffectiveSetState<any>,\r\n  componentId: string,\r\n  sessionId?: string\r\n) => {\r\n  // Update all global state at once\r\n  const updates = {\r\n    initialState: initialState,\r\n    updaterState: createProxyHandler(\r\n      thisKey,\r\n      effectiveSetState,\r\n      componentId,\r\n      sessionId\r\n    ),\r\n    state: newState,\r\n  };\r\n\r\n  startTransition(() => {\r\n    updateInitialStateGlobal(thisKey, updates.initialState);\r\n    setUpdaterState(thisKey, updates.updaterState);\r\n    setState(thisKey, updates.state);\r\n  });\r\n};\r\n\r\nconst notifyComponents = (thisKey: string) => {\r\n  const stateEntry = getGlobalStore.getState().stateComponents.get(thisKey);\r\n  if (!stateEntry) return;\r\n\r\n  // Batch component updates\r\n  const updates = new Set<() => void>();\r\n  stateEntry.components.forEach((component) => {\r\n    updates.add(() => component.forceUpdate());\r\n  });\r\n\r\n  // Schedule updates in the next tick to allow batching\r\n  queueMicrotask(() => {\r\n    startTransition(() => {\r\n      updates.forEach((update) => update());\r\n    });\r\n  });\r\n};\r\n\r\nexport const notifyComponent = (stateKey: string, componentId: string) => {\r\n  const stateEntry = getGlobalStore.getState().stateComponents.get(stateKey);\r\n  if (stateEntry) {\r\n    const fullComponentId = `${stateKey}////${componentId}`;\r\n    const component = stateEntry.components.get(fullComponentId);\r\n\r\n    if (component) {\r\n      // Force an update to ensure the current value is saved\r\n\r\n      component.forceUpdate();\r\n    }\r\n  }\r\n};\r\n\r\nexport function useCogsStateFn<TStateObject extends unknown>(\r\n  stateObject: TStateObject,\r\n  {\r\n    stateKey,\r\n    serverSync,\r\n    localStorage,\r\n    formElements,\r\n    middleware,\r\n    reactiveDeps,\r\n    reactiveType,\r\n    componentId,\r\n    initialState,\r\n    syncUpdate,\r\n    dependencies,\r\n  }: {\r\n    stateKey?: string;\r\n    componentId?: string;\r\n  } & OptionsType<TStateObject> = {}\r\n) {\r\n  const [reactiveForce, forceUpdate] = useState({}); //this is the key to reactivity\r\n  const { sessionId } = useCogsConfig();\r\n\r\n  let noStateKey = stateKey ? false : true;\r\n  const [thisKey] = useState(stateKey ?? uuidv4());\r\n  const stateLog = getGlobalStore.getState().stateLog[thisKey];\r\n  const componentUpdatesRef = useRef(new Set<string>());\r\n  const componentIdRef = useRef(componentId ?? uuidv4());\r\n  const latestInitialOptionsRef = useRef<any>(null);\r\n  latestInitialOptionsRef.current = getInitialOptions(thisKey as string);\r\n\r\n  useEffect(() => {\r\n    if (syncUpdate && syncUpdate.stateKey === thisKey && syncUpdate.path?.[0]) {\r\n      // Update the actual state value\r\n      setState(thisKey, (prevState: any) => ({\r\n        ...prevState,\r\n        [syncUpdate.path![0]!]: syncUpdate.newValue,\r\n      }));\r\n\r\n      // Create combined key and update sync info\r\n      const syncKey = `${syncUpdate.stateKey}:${syncUpdate.path.join(\".\")}`;\r\n      getGlobalStore.getState().setSyncInfo(syncKey, {\r\n        timeStamp: syncUpdate.timeStamp!,\r\n        userId: syncUpdate.userId!,\r\n      });\r\n    }\r\n  }, [syncUpdate]);\r\n\r\n  // Find the main useEffect that depends on initialState\r\n  useEffect(() => {\r\n    // --- Keep existing setup ---\r\n    // setAndMergeOptions(...)\r\n    const options = latestInitialOptionsRef.current;\r\n    const currentInitialState = initialState; // Capture prop for use in this effect run\r\n    let localData: LocalStorageData<TStateObject> | null = null;\r\n    const localkey = isFunction(options?.localStorage?.key)\r\n      ? options?.localStorage?.key(currentInitialState ?? stateObject) // Use currentInitialState for key calc\r\n      : options?.localStorage?.key;\r\n    // --- End existing setup ---\r\n\r\n    if (localkey && sessionId) {\r\n      localData = loadFromLocalStorage(\r\n        // Call existing load function\r\n        sessionId + \"-\" + thisKey + \"-\" + localkey\r\n      );\r\n    }\r\n\r\n    let newStateToUse: TStateObject | null = null;\r\n    let baseStateForStorage: TStateObject | undefined =\r\n      currentInitialState ?? undefined; // Default base is current initial\r\n    let isUsingLocalState = false;\r\n\r\n    if (localData) {\r\n      // Compare incoming initialState with the base stored locally\r\n      if (\r\n        !isDeepEqual(\r\n          currentInitialState as Record<string, unknown>,\r\n          localData.baseServerState as Record<string, unknown>\r\n        )\r\n      ) {\r\n        // Base mismatch: initialState is different from what local was based on. Use initialState.\r\n        newStateToUse = currentInitialState ?? stateObject; // Use fresh or fallback\r\n        baseStateForStorage = currentInitialState ?? undefined; // Base is the fresh one\r\n        console.warn(\r\n          \"Initial state differs from localStorage base. Using initialState.\"\r\n        ); // Minimal warning\r\n      } else {\r\n        // Base matches: Local edits are based on the correct version. Use local state.\r\n        newStateToUse = localData.state;\r\n        baseStateForStorage = localData.baseServerState; // Keep the existing base\r\n        isUsingLocalState = true;\r\n      }\r\n    } else {\r\n      // No local data: Use initialState.\r\n      newStateToUse = currentInitialState ?? stateObject; // Use initial or fallback\r\n      baseStateForStorage = currentInitialState ?? undefined; // Base is the initial one\r\n    }\r\n\r\n    // --- Keep existing update logic ---\r\n    if (newStateToUse !== null) {\r\n      // Check if we determined a state to use\r\n      const currentGlobalState = getKeyState(thisKey);\r\n      // Only update if needed\r\n      if (\r\n        !currentGlobalState ||\r\n        !isDeepEqual(currentGlobalState, newStateToUse)\r\n      ) {\r\n        updateGlobalState(\r\n          thisKey,\r\n          currentInitialState ?? stateObject, // Pass the *actual* initialState prop reference\r\n          newStateToUse,\r\n          effectiveSetState,\r\n          componentIdRef.current,\r\n          sessionId\r\n        );\r\n        // *** SAVE TO LOCAL STORAGE WITH BASE STATE ***\r\n        saveToLocalStorage(\r\n          newStateToUse,\r\n          thisKey,\r\n          options,\r\n          sessionId,\r\n          baseStateForStorage\r\n        );\r\n\r\n        if (isUsingLocalState && options?.localStorage?.onChange) {\r\n          // Only call onChange if we loaded local\r\n          options.localStorage.onChange(newStateToUse);\r\n        }\r\n        notifyComponents(thisKey);\r\n        forceUpdate({}); // Keep if original had this\r\n      }\r\n    }\r\n    // --- End existing update logic ---\r\n\r\n    // Keep original dependency array structure (use JSON.stringify for object stability if needed)\r\n  }, [initialState, ...(dependencies || [])]);\r\n\r\n  useLayoutEffect(() => {\r\n    if (noStateKey) {\r\n      setAndMergeOptions(\r\n        thisKey as string,\r\n        {\r\n          serverSync,\r\n          formElements,\r\n          initialState,\r\n          localStorage,\r\n          middleware,\r\n        } as OptionsType<unknown>\r\n      );\r\n    }\r\n\r\n    const depsKey = `${thisKey}////${componentIdRef.current}`;\r\n    const stateEntry = getGlobalStore\r\n      .getState()\r\n      .stateComponents.get(thisKey) || {\r\n      components: new Map(),\r\n    };\r\n\r\n    stateEntry.components.set(depsKey, {\r\n      forceUpdate: () => forceUpdate({}),\r\n      paths: new Set(),\r\n      deps: [],\r\n      depsFunction: reactiveDeps || undefined,\r\n      reactiveType: reactiveType ?? [\"component\", \"deps\"],\r\n    });\r\n\r\n    getGlobalStore.getState().stateComponents.set(thisKey, stateEntry);\r\n    //need to force update to create the stateUpdates references\r\n    forceUpdate({});\r\n    return () => {\r\n      const depsKey = `${thisKey}////${componentIdRef.current}`;\r\n\r\n      if (stateEntry) {\r\n        stateEntry.components.delete(depsKey);\r\n        if (stateEntry.components.size === 0) {\r\n          getGlobalStore.getState().stateComponents.delete(thisKey);\r\n        }\r\n      }\r\n    };\r\n  }, []);\r\n\r\n  const effectiveSetState = (\r\n    newStateOrFunction:\r\n      | TStateObject\r\n      | ((prevState: TStateObject) => TStateObject),\r\n    path: string[],\r\n    updateObj: { updateType: \"insert\" | \"cut\" | \"update\" },\r\n    validationKey?: string\r\n  ) => {\r\n    if (Array.isArray(path)) {\r\n      const pathKey = `${thisKey}-${path.join(\".\")}`;\r\n      componentUpdatesRef.current.add(pathKey);\r\n    }\r\n    setState(thisKey, (prevValue: TStateObject) => {\r\n      const payload = isFunction<TStateObject>(newStateOrFunction)\r\n        ? newStateOrFunction(prevValue as TStateObject)\r\n        : newStateOrFunction;\r\n\r\n      const signalId = `${thisKey}-${path.join(\".\")}`;\r\n      if (signalId) {\r\n        let isArrayOperation = false;\r\n        let elements = getGlobalStore\r\n          .getState()\r\n          .signalDomElements.get(signalId);\r\n\r\n        if (\r\n          (!elements || elements.size === 0) &&\r\n          (updateObj.updateType === \"insert\" || updateObj.updateType === \"cut\")\r\n        ) {\r\n          // Remove last segment (index) from path\r\n          const arrayPath = path.slice(0, -1);\r\n          const arrayValue = getNestedValue(payload, arrayPath);\r\n          // If it's an array, use that path for signal\r\n          if (Array.isArray(arrayValue)) {\r\n            isArrayOperation = true;\r\n            const arraySignalId = `${thisKey}-${arrayPath.join(\".\")}`;\r\n            elements = getGlobalStore\r\n              .getState()\r\n              .signalDomElements.get(arraySignalId);\r\n          }\r\n        }\r\n\r\n        if (elements) {\r\n          const newValue = isArrayOperation\r\n            ? getNestedValue(payload, path.slice(0, -1))\r\n            : getNestedValue(payload, path);\r\n          elements.forEach(({ parentId, position, effect }) => {\r\n            const parent = document.querySelector(\r\n              `[data-parent-id=\"${parentId}\"]`\r\n            );\r\n            if (parent) {\r\n              const childNodes = Array.from(parent.childNodes);\r\n              if (childNodes[position]) {\r\n                const displayValue = effect\r\n                  ? new Function(\"state\", `return (${effect})(state)`)(newValue)\r\n                  : newValue;\r\n                childNodes[position].textContent = String(displayValue);\r\n              }\r\n            }\r\n          });\r\n        }\r\n      }\r\n      if (\r\n        updateObj.updateType === \"update\" &&\r\n        (validationKey || latestInitialOptionsRef.current?.validationKey) &&\r\n        path\r\n      ) {\r\n        removeValidationError(\r\n          (validationKey || latestInitialOptionsRef.current?.validationKey) +\r\n            \".\" +\r\n            path.join(\".\")\r\n        );\r\n      }\r\n      const arrayWithoutIndex = path.slice(0, path.length - 1);\r\n      if (\r\n        updateObj.updateType === \"cut\" &&\r\n        latestInitialOptionsRef.current?.validationKey\r\n      ) {\r\n        removeValidationError(\r\n          latestInitialOptionsRef.current?.validationKey +\r\n            \".\" +\r\n            arrayWithoutIndex.join(\".\")\r\n        );\r\n      }\r\n      if (\r\n        updateObj.updateType === \"insert\" &&\r\n        latestInitialOptionsRef.current?.validationKey\r\n      ) {\r\n        let getValidation = getValidationErrors(\r\n          latestInitialOptionsRef.current?.validationKey +\r\n            \".\" +\r\n            arrayWithoutIndex.join(\".\")\r\n        );\r\n\r\n        //TODO this is untested its supposed to cahnge teh validation errors alreaady stored when a new entry is push\r\n\r\n        getValidation.filter(([k, v]) => {\r\n          let length = k?.split(\".\").length;\r\n\r\n          if (\r\n            k == arrayWithoutIndex.join(\".\") &&\r\n            length == arrayWithoutIndex.length - 1\r\n          ) {\r\n            //   console.log(length, pathWithoutIndex.length);\r\n            let newKey = k + \".\" + arrayWithoutIndex;\r\n            removeValidationError(k!);\r\n            addValidationError(newKey, v!);\r\n          }\r\n        });\r\n      }\r\n\r\n      const oldValue = getNestedValue(prevValue, path);\r\n      const newValue = getNestedValue(payload, path);\r\n      const pathToCheck =\r\n        updateObj.updateType === \"update\"\r\n          ? path.join(\".\")\r\n          : [...path].slice(0, -1).join(\".\");\r\n      const stateEntry = getGlobalStore.getState().stateComponents.get(thisKey);\r\n\r\n      if (stateEntry) {\r\n        for (const [key, component] of stateEntry.components.entries()) {\r\n          let shouldUpdate = false;\r\n          const reactiveTypes = Array.isArray(component.reactiveType)\r\n            ? component.reactiveType\r\n            : [component.reactiveType || \"component\"];\r\n\r\n          // Skip if reactivity is disabled\r\n          if (reactiveTypes.includes(\"none\")) {\r\n            continue;\r\n          }\r\n\r\n          // Force update if \"all\" is specified\r\n          if (reactiveTypes.includes(\"all\")) {\r\n            component.forceUpdate();\r\n\r\n            continue;\r\n          }\r\n\r\n          // Check component-level path reactivity\r\n          if (reactiveTypes.includes(\"component\")) {\r\n            if (\r\n              component.paths &&\r\n              (component.paths.has(pathToCheck) || component.paths.has(\"\"))\r\n            ) {\r\n              shouldUpdate = true;\r\n            }\r\n          }\r\n\r\n          // Check dependency-based reactivity\r\n          if (!shouldUpdate && reactiveTypes.includes(\"deps\")) {\r\n            if (component.depsFunction) {\r\n              const depsResult = component.depsFunction(payload);\r\n\r\n              if (typeof depsResult === \"boolean\") {\r\n                if (depsResult) {\r\n                  shouldUpdate = true;\r\n                }\r\n              } else if (!isDeepEqual(component.deps, depsResult)) {\r\n                component.deps = depsResult;\r\n                shouldUpdate = true;\r\n              }\r\n            }\r\n          }\r\n\r\n          if (shouldUpdate) {\r\n            component.forceUpdate();\r\n          }\r\n        }\r\n      }\r\n      const timeStamp = Date.now();\r\n\r\n      const newUpdate = {\r\n        timeStamp,\r\n        stateKey: thisKey,\r\n        path,\r\n        updateType: updateObj.updateType,\r\n        status: \"new\" as const,\r\n        oldValue,\r\n        newValue,\r\n      } satisfies UpdateTypeDetail;\r\n\r\n      setStateLog(thisKey, (prevLogs) => {\r\n        const logs = [...(prevLogs ?? []), newUpdate];\r\n\r\n        // Aggregate the updates by stateKey and path\r\n        const aggregatedLogs = logs.reduce((acc, log) => {\r\n          const uniqueKey = `${log.stateKey}:${JSON.stringify(log.path)}`;\r\n          const existing = acc.get(uniqueKey);\r\n\r\n          if (existing) {\r\n            // Update the existing entry with the most recent details\r\n            existing.timeStamp = Math.max(existing.timeStamp, log.timeStamp);\r\n            existing.newValue = log.newValue; // Overwrite with the latest value\r\n            existing.oldValue = existing.oldValue ?? log.oldValue; // Retain the initial oldValue\r\n            existing.updateType = log.updateType; // Update to the most recent type\r\n          } else {\r\n            // Add the log if no existing match is found\r\n            acc.set(uniqueKey, { ...(log as any) });\r\n          }\r\n\r\n          return acc;\r\n        }, new Map<string, typeof newUpdate>());\r\n\r\n        // Convert the aggregated map back to an array\r\n        return Array.from(aggregatedLogs.values());\r\n      });\r\n\r\n      saveToLocalStorage(\r\n        payload,\r\n        thisKey,\r\n        latestInitialOptionsRef.current,\r\n        sessionId\r\n      );\r\n\r\n      if (middleware) {\r\n        middleware({\r\n          updateLog: stateLog,\r\n          update: newUpdate,\r\n        });\r\n      }\r\n      if (latestInitialOptionsRef.current?.serverSync) {\r\n        const serverStateStore = getGlobalStore.getState().serverState[thisKey];\r\n        const serverSync = latestInitialOptionsRef.current?.serverSync;\r\n        setServerSyncActions(thisKey, {\r\n          syncKey:\r\n            typeof serverSync.syncKey == \"string\"\r\n              ? serverSync.syncKey\r\n              : serverSync.syncKey({ state: payload }),\r\n          rollBackState: serverStateStore,\r\n          actionTimeStamp: Date.now() + (serverSync.debounce ?? 3000),\r\n          status: \"waiting\",\r\n        });\r\n      }\r\n\r\n      return payload;\r\n    });\r\n  };\r\n  if (!getGlobalStore.getState().updaterState[thisKey]) {\r\n    setUpdaterState(\r\n      thisKey,\r\n      createProxyHandler(\r\n        thisKey,\r\n        effectiveSetState,\r\n        componentIdRef.current,\r\n        sessionId\r\n      )\r\n    );\r\n    if (!getGlobalStore.getState().cogsStateStore[thisKey]) {\r\n      setState(thisKey, stateObject);\r\n    }\r\n    if (!getGlobalStore.getState().initialStateGlobal[thisKey]) {\r\n      updateInitialStateGlobal(thisKey, stateObject);\r\n    }\r\n  }\r\n\r\n  const updaterFinal = useMemo(() => {\r\n    // Create proxy with baseObject as target\r\n    return createProxyHandler<TStateObject>(\r\n      thisKey,\r\n      effectiveSetState,\r\n      componentIdRef.current,\r\n      sessionId\r\n    );\r\n  }, [thisKey]);\r\n\r\n  return [getKeyState(thisKey), updaterFinal] as [\r\n    TStateObject,\r\n    StateObject<TStateObject>,\r\n  ];\r\n}\r\n\r\nfunction createProxyHandler<T>(\r\n  stateKey: string,\r\n  effectiveSetState: EffectiveSetState<T>,\r\n  componentId: string,\r\n  sessionId?: string\r\n): StateObject<T> {\r\n  // ADDED: Enhanced cache with versioning\r\n  type CacheEntry = {\r\n    proxy: any;\r\n    stateVersion: number;\r\n  };\r\n  const shapeCache = new Map<string, CacheEntry>();\r\n  let stateVersion = 0;\r\n\r\n  // ADDED: Cache invalidation helper\r\n  const invalidateCachePath = (path: string[]) => {\r\n    const pathKey = path.join(\".\");\r\n    for (const [key] of shapeCache) {\r\n      if (key === pathKey || key.startsWith(pathKey + \".\")) {\r\n        shapeCache.delete(key);\r\n      }\r\n    }\r\n    stateVersion++;\r\n  };\r\n\r\n  const baseObj = {\r\n    removeValidation: (obj?: { validationKey?: string }) => {\r\n      if (obj?.validationKey) {\r\n        removeValidationError(obj.validationKey);\r\n      }\r\n    },\r\n\r\n    revertToInitialState: (obj?: { validationKey?: string }) => {\r\n      const init = getGlobalStore\r\n        .getState()\r\n        .getInitialOptions(stateKey)?.validation;\r\n      if (init?.key) {\r\n        removeValidationError(init?.key);\r\n      }\r\n\r\n      if (obj?.validationKey) {\r\n        removeValidationError(obj.validationKey);\r\n      }\r\n\r\n      const initialState =\r\n        getGlobalStore.getState().initialStateGlobal[stateKey];\r\n\r\n      // ADDED: Clear cache on revert\r\n      shapeCache.clear();\r\n      stateVersion++;\r\n\r\n      const newProxy = rebuildStateShape(initialState, []);\r\n      const initalOptionsGet = getInitialOptions(stateKey as string);\r\n      const localKey = isFunction(initalOptionsGet?.localStorage?.key)\r\n        ? initalOptionsGet?.localStorage?.key(initialState)\r\n        : initalOptionsGet?.localStorage?.key;\r\n\r\n      const storageKey = `${sessionId}-${stateKey}-${localKey}`;\r\n\r\n      if (storageKey) {\r\n        localStorage.removeItem(storageKey);\r\n      }\r\n      startTransition(() => {\r\n        setUpdaterState(stateKey, newProxy);\r\n        setState(stateKey, initialState);\r\n        const stateEntry = getGlobalStore\r\n          .getState()\r\n          .stateComponents.get(stateKey);\r\n        if (stateEntry) {\r\n          stateEntry.components.forEach((component) => {\r\n            component.forceUpdate();\r\n          });\r\n        }\r\n      });\r\n\r\n      return initialState;\r\n    },\r\n    updateInitialState: (newState: T) => {\r\n      // ADDED: Clear cache on initial state update\r\n      shapeCache.clear();\r\n      stateVersion++;\r\n\r\n      const newUpdaterState = createProxyHandler(\r\n        stateKey,\r\n        effectiveSetState,\r\n        componentId,\r\n        sessionId\r\n      );\r\n      startTransition(() => {\r\n        updateInitialStateGlobal(stateKey, newState);\r\n        setUpdaterState(stateKey, newUpdaterState);\r\n        setState(stateKey, newState);\r\n        const stateEntry = getGlobalStore\r\n          .getState()\r\n          .stateComponents.get(stateKey);\r\n        if (stateEntry) {\r\n          stateEntry.components.forEach((component) => {\r\n            component.forceUpdate();\r\n          });\r\n        }\r\n      });\r\n\r\n      return {\r\n        fetchId: (field: keyof T) => newUpdaterState.get()[field],\r\n      };\r\n    },\r\n    _initialState: getGlobalStore.getState().initialStateGlobal[stateKey],\r\n    _serverState: getGlobalStore.getState().serverState[stateKey],\r\n    _isLoading: getGlobalStore.getState().isLoadingGlobal[stateKey],\r\n    _isServerSynced: () => {\r\n      const serverState = getGlobalStore.getState().serverState[stateKey];\r\n      return Boolean(\r\n        serverState && isDeepEqual(serverState, getKeyState(stateKey))\r\n      );\r\n    },\r\n  };\r\n\r\n  function rebuildStateShape(\r\n    currentState: T,\r\n    path: string[] = [],\r\n    meta?: { filtered?: string[][]; validIndices?: number[] }\r\n  ): any {\r\n    const cacheKey = path.map(String).join(\".\");\r\n\r\n    // MODIFIED: Cache check with version\r\n    const cachedEntry = shapeCache.get(cacheKey);\r\n    // if (cachedEntry?.stateVersion === stateVersion) {\r\n    //     return cachedEntry.proxy;\r\n    // }\r\n    type CallableStateObject<T> = {\r\n      (): T;\r\n    } & {\r\n      [key: string]: any;\r\n    };\r\n\r\n    const baseFunction = function () {\r\n      return getGlobalStore().getNestedState(stateKey, path);\r\n    } as unknown as CallableStateObject<T>;\r\n\r\n    // Copy properties from baseObj to the function with type assertion\r\n    Object.keys(baseObj).forEach((key) => {\r\n      (baseFunction as any)[key] = (baseObj as any)[key];\r\n    });\r\n\r\n    const handler = {\r\n      apply(target: any, thisArg: any, args: any[]) {\r\n        console.log(\r\n          `PROXY APPLY TRAP HIT: stateKey=${stateKey}, path=${path.join(\".\")}`\r\n        ); // <--- ADD LOGGING\r\n        console.trace(\"Apply trap stack trace\");\r\n        return getGlobalStore().getNestedState(stateKey, path);\r\n      },\r\n\r\n      get(target: any, prop: string) {\r\n        if (\r\n          prop !== \"then\" &&\r\n          !prop.startsWith(\"$\") &&\r\n          prop !== \"stateMapNoRender\"\r\n        ) {\r\n          const currentPath = path.join(\".\");\r\n          const fullComponentId = `${stateKey}////${componentId}`;\r\n\r\n          const stateEntry = getGlobalStore\r\n            .getState()\r\n            .stateComponents.get(stateKey);\r\n\r\n          if (stateEntry) {\r\n            const component = stateEntry.components.get(fullComponentId);\r\n\r\n            if (component) {\r\n              // Only add paths for non-root or specifically for get() at root\r\n              if (path.length > 0 || prop === \"get\") {\r\n                component.paths.add(currentPath);\r\n              }\r\n            } else {\r\n            }\r\n          }\r\n        }\r\n        if (prop === \"_status\") {\r\n          // Get current state at this path (non-reactive version)\r\n          const thisReactiveState = getGlobalStore\r\n            .getState()\r\n            .getNestedState(stateKey, path);\r\n\r\n          // Get initial state at this path\r\n          const initialState =\r\n            getGlobalStore.getState().initialStateGlobal[stateKey];\r\n          const initialStateAtPath = getNestedValue(initialState, path);\r\n\r\n          // Simply compare current state with initial state\r\n          if (isDeepEqual(thisReactiveState, initialStateAtPath)) {\r\n            return \"fresh\"; // Matches initial state\r\n          } else {\r\n            return \"stale\"; // Different from initial state\r\n          }\r\n        }\r\n        if (prop === \"getStatus\") {\r\n          return function () {\r\n            // Get current state at this path (reactive version)\r\n            const thisReactiveState = getGlobalStore().getNestedState(\r\n              stateKey,\r\n              path\r\n            );\r\n\r\n            // Get initial state at this path\r\n            const initialState =\r\n              getGlobalStore.getState().initialStateGlobal[stateKey];\r\n            const initialStateAtPath = getNestedValue(initialState, path);\r\n\r\n            // Simply compare current state with initial state\r\n            if (isDeepEqual(thisReactiveState, initialStateAtPath)) {\r\n              return \"fresh\"; // Matches initial state\r\n            } else {\r\n              return \"stale\"; // Different from initial state\r\n            }\r\n          };\r\n        }\r\n        if (prop === \"removeStorage\") {\r\n          return () => {\r\n            const initialState =\r\n              getGlobalStore.getState().initialStateGlobal[stateKey];\r\n            const initalOptionsGet = getInitialOptions(stateKey as string);\r\n            const localKey = isFunction(initalOptionsGet?.localStorage?.key)\r\n              ? initalOptionsGet?.localStorage?.key(initialState)\r\n              : initalOptionsGet?.localStorage?.key;\r\n\r\n            const storageKey = `${sessionId}-${stateKey}-${localKey}`;\r\n            console.log(\"removing storage\", storageKey);\r\n            if (storageKey) {\r\n              localStorage.removeItem(storageKey);\r\n            }\r\n          };\r\n        }\r\n        if (prop === \"showValidationErrors\") {\r\n          return () => {\r\n            const init = getGlobalStore\r\n              .getState()\r\n              .getInitialOptions(stateKey)?.validation;\r\n\r\n            if (!init?.key) {\r\n              throw new Error(\"Validation key not found\");\r\n            }\r\n            const errors = getGlobalStore\r\n              .getState()\r\n              .getValidationErrors(init.key + \".\" + path.join(\".\"));\r\n\r\n            return errors;\r\n          };\r\n        }\r\n        if (Array.isArray(currentState)) {\r\n          if (prop === \"getSelected\") {\r\n            return () => {\r\n              const selectedIndex = getGlobalStore\r\n                .getState()\r\n                .getSelectedIndex(stateKey, path.join(\".\"));\r\n              if (selectedIndex === undefined) return undefined;\r\n              return rebuildStateShape(\r\n                currentState[selectedIndex],\r\n                [...path, selectedIndex.toString()],\r\n                meta\r\n              );\r\n            };\r\n          }\r\n          if (prop === \"getSelectedIndex\") {\r\n            return () => {\r\n              const selectedIndex = getGlobalStore\r\n                .getState()\r\n                .getSelectedIndex(stateKey, path.join(\".\"));\r\n\r\n              return selectedIndex ?? -1;\r\n            };\r\n          }\r\n          if (prop === \"stateSort\") {\r\n            return (\r\n              compareFn: (\r\n                a: InferArrayElement<T>,\r\n                b: InferArrayElement<T>\r\n              ) => number\r\n            ) => {\r\n              const currentArray = getGlobalStore\r\n                .getState()\r\n                .getNestedState(stateKey, path) as any[];\r\n\r\n              // Create a shallow copy with original indices\r\n              const arrayCopy = currentArray.map((v: any, i: number) => ({\r\n                ...v,\r\n                __origIndex: i.toString(),\r\n              }));\r\n\r\n              // Sort the copy using the provided compare function\r\n              const sortedArray = [...arrayCopy].sort(compareFn);\r\n\r\n              // ADDED: Clear cache for sort operation\r\n              shapeCache.clear();\r\n              stateVersion++;\r\n\r\n              // Return the sorted array with state objects\r\n              return rebuildStateShape(sortedArray as any, path, {\r\n                filtered: [...(meta?.filtered || []), path],\r\n                validIndices: sortedArray.map((item) =>\r\n                  parseInt(item.__origIndex as string)\r\n                ),\r\n              });\r\n            };\r\n          }\r\n          if (prop === \"stateMap\" || prop === \"stateMapNoRender\") {\r\n            return (\r\n              callbackfn: (\r\n                value: InferArrayElement<T>,\r\n                setter: StateObject<InferArrayElement<T>>,\r\n                index: number,\r\n                array: T,\r\n                arraySetter: StateObject<T>\r\n              ) => void\r\n            ) => {\r\n              const isFiltered = meta?.filtered?.some(\r\n                (p) => p.join(\".\") === path.join(\".\")\r\n              );\r\n              const arrayToMap = isFiltered\r\n                ? currentState\r\n                : getGlobalStore.getState().getNestedState(stateKey, path);\r\n\r\n              if (prop !== \"stateMapNoRender\") {\r\n                shapeCache.clear();\r\n                stateVersion++;\r\n              }\r\n\r\n              return arrayToMap.map((val: any, index: number) => {\r\n                const thisIndex =\r\n                  isFiltered && val.__origIndex ? val.__origIndex : index;\r\n                const elementProxy = rebuildStateShape(\r\n                  val,\r\n                  [...path, thisIndex.toString()],\r\n                  meta\r\n                );\r\n                return callbackfn(\r\n                  val,\r\n                  elementProxy,\r\n                  index,\r\n                  currentState as any,\r\n                  rebuildStateShape(currentState as any, path, meta)\r\n                );\r\n              });\r\n            };\r\n          }\r\n          if (prop === \"$stateMap\") {\r\n            return (\r\n              callbackfn: (\r\n                value: InferArrayElement<T>,\r\n                setter: StateObject<InferArrayElement<T>>,\r\n                index: number,\r\n                array: T,\r\n                arraySetter: StateObject<T>\r\n              ) => void\r\n            ) => {\r\n              return createElement(SignalMapRenderer, {\r\n                proxy: {\r\n                  _stateKey: stateKey,\r\n                  _path: path,\r\n                  _mapFn: callbackfn as any, // Pass the actual function, not string\r\n                },\r\n\r\n                rebuildStateShape,\r\n              });\r\n            };\r\n          }\r\n          if (prop === \"stateFlattenOn\") {\r\n            return (fieldName: string) => {\r\n              const isFiltered = meta?.filtered?.some(\r\n                (p) => p.join(\".\") === path.join(\".\")\r\n              );\r\n              const arrayToMap = isFiltered\r\n                ? currentState\r\n                : getGlobalStore.getState().getNestedState(stateKey, path);\r\n\r\n              // ADDED: Clear shape cache for flattening operation\r\n              shapeCache.clear();\r\n              stateVersion++;\r\n\r\n              const flattenedResults = arrayToMap.flatMap(\r\n                (val: any, index: number) => {\r\n                  return val[fieldName] ?? [];\r\n                }\r\n              );\r\n\r\n              return rebuildStateShape(\r\n                flattenedResults,\r\n                [...path, \"[*]\", fieldName],\r\n                meta\r\n              );\r\n            };\r\n          }\r\n\r\n          if (prop === \"findWith\") {\r\n            return (\r\n              thisKey: keyof InferArrayElement<T>,\r\n              thisValue: InferArrayElement<T>[keyof InferArrayElement<T>]\r\n            ) => {\r\n              const foundIndex = currentState.findIndex(\r\n                (obj: any) => obj[thisKey] === thisValue\r\n              );\r\n              if (foundIndex === -1) return undefined;\r\n              const foundValue = currentState[foundIndex];\r\n              const newPath = [...path, foundIndex.toString()];\r\n              // console.log(\r\n              //     \"findWithfindWithfindWithfindWith\",\r\n              //     stateKey,\r\n              //     foundValue,\r\n              //     newPath,\r\n              // );\r\n              shapeCache.clear();\r\n              stateVersion++;\r\n\r\n              // ADDED: Clear cache for find operation\r\n              shapeCache.clear();\r\n              stateVersion++;\r\n              // Try returning without spread\r\n              return rebuildStateShape(foundValue, newPath);\r\n            };\r\n          }\r\n\r\n          if (prop === \"index\") {\r\n            return (index: number) => {\r\n              const indexValue = currentState[index];\r\n              return rebuildStateShape(indexValue, [...path, index.toString()]);\r\n            };\r\n          }\r\n\r\n          if (prop === \"insert\") {\r\n            return (payload: UpdateArg<T>) => {\r\n              // ADDED: Invalidate cache on insert\r\n              invalidateCachePath(path);\r\n              pushFunc(effectiveSetState, payload, path, stateKey);\r\n              return rebuildStateShape(\r\n                getGlobalStore.getState().cogsStateStore[stateKey],\r\n                []\r\n              );\r\n            };\r\n          }\r\n\r\n          if (prop === \"uniqueInsert\") {\r\n            return (\r\n              payload: UpdateArg<T>,\r\n              fields?: (keyof InferArrayElement<T>)[],\r\n              onMatch?: (existingItem: any) => any\r\n            ) => {\r\n              const currentArray = getGlobalStore\r\n                .getState()\r\n                .getNestedState(stateKey, path) as any[];\r\n              const newValue = isFunction<T>(payload)\r\n                ? payload(currentArray as any)\r\n                : (payload as any);\r\n\r\n              let matchedItem: any = null;\r\n              const isUnique = !currentArray.some((item) => {\r\n                if (fields) {\r\n                  const isMatch = fields.every((field) =>\r\n                    isDeepEqual(item[field], newValue[field])\r\n                  );\r\n                  if (isMatch) {\r\n                    matchedItem = item;\r\n                  }\r\n                  return isMatch;\r\n                }\r\n                const isMatch = isDeepEqual(item, newValue);\r\n                if (isMatch) {\r\n                  matchedItem = item;\r\n                }\r\n                return isMatch;\r\n              });\r\n\r\n              if (isUnique) {\r\n                invalidateCachePath(path);\r\n                pushFunc(effectiveSetState, newValue, path, stateKey);\r\n              } else if (onMatch && matchedItem) {\r\n                const updatedItem = onMatch(matchedItem);\r\n                const updatedArray = currentArray.map((item) =>\r\n                  isDeepEqual(item, matchedItem) ? updatedItem : item\r\n                );\r\n                invalidateCachePath(path);\r\n                updateFn(effectiveSetState, updatedArray as any, path);\r\n              }\r\n            };\r\n          }\r\n\r\n          if (prop === \"cut\") {\r\n            return (index: number, options?: { waitForSync?: boolean }) => {\r\n              if (options?.waitForSync) return;\r\n              // ADDED: Invalidate cache on cut\r\n              invalidateCachePath(path);\r\n              cutFunc(effectiveSetState, path, stateKey, index);\r\n            };\r\n          }\r\n          if (prop === \"cutByValue\") {\r\n            return (value: string | number | boolean) => {\r\n              for (let index = 0; index < currentState.length; index++) {\r\n                if (currentState[index] === value) {\r\n                  cutFunc(effectiveSetState, path, stateKey, index);\r\n                }\r\n              }\r\n            };\r\n          }\r\n          if (prop === \"toggleByValue\") {\r\n            return (value: string | number | boolean) => {\r\n              const index = currentState.findIndex((item) => item === value);\r\n              if (index > -1) {\r\n                // Value exists, so cut it\r\n                cutFunc(effectiveSetState, path, stateKey, index);\r\n              } else {\r\n                // Value doesn't exist, so insert it\r\n                pushFunc(effectiveSetState, value as any, path, stateKey);\r\n              }\r\n            };\r\n          }\r\n\r\n          if (prop === \"stateFilter\") {\r\n            return (\r\n              callbackfn: (\r\n                value: InferArrayElement<T>,\r\n                index: number\r\n              ) => boolean\r\n            ) => {\r\n              const newVal = currentState.map((v: any, i: number) => ({\r\n                ...v,\r\n                __origIndex: i.toString(),\r\n              }));\r\n\r\n              const validIndices: number[] = [];\r\n              const filteredArray: Array<InferArrayElement<T>> = [];\r\n\r\n              for (let i = 0; i < newVal.length; i++) {\r\n                if (callbackfn(newVal[i], i)) {\r\n                  validIndices.push(i);\r\n                  filteredArray.push(newVal[i]);\r\n                }\r\n              }\r\n\r\n              // ADDED: Clear cache for filter operation\r\n              shapeCache.clear();\r\n              stateVersion++;\r\n\r\n              // Always include validIndices, even if it's an empty array\r\n              return rebuildStateShape(filteredArray as any, path, {\r\n                filtered: [...(meta?.filtered || []), path],\r\n                validIndices: validIndices, // Always pass validIndices, even if empty\r\n              });\r\n            };\r\n          }\r\n        }\r\n        const lastPathElement = path[path.length - 1];\r\n        if (!isNaN(Number(lastPathElement))) {\r\n          const parentPath = path.slice(0, -1);\r\n          const parentValue = getGlobalStore\r\n            .getState()\r\n            .getNestedState(stateKey, parentPath);\r\n\r\n          if (Array.isArray(parentValue) && prop === \"cut\") {\r\n            return () =>\r\n              cutFunc(\r\n                effectiveSetState,\r\n                parentPath,\r\n                stateKey,\r\n                Number(lastPathElement)\r\n              );\r\n          }\r\n        }\r\n\r\n        if (prop === \"get\") {\r\n          return () => getGlobalStore.getState().getNestedState(stateKey, path);\r\n        }\r\n        if (prop === \"$derive\") {\r\n          return (fn: any) =>\r\n            $cogsSignal({\r\n              _stateKey: stateKey,\r\n              _path: path,\r\n              _effect: fn.toString(),\r\n            });\r\n        }\r\n\r\n        if (prop === \"$derive\") {\r\n          return (fn: any) =>\r\n            $cogsSignal({\r\n              _stateKey: stateKey,\r\n              _path: path,\r\n              _effect: fn.toString(),\r\n            });\r\n        }\r\n\r\n        if (prop === \"$get\") {\r\n          return () =>\r\n            $cogsSignal({\r\n              _stateKey: stateKey,\r\n              _path: path,\r\n            });\r\n        }\r\n        if (prop === \"lastSynced\") {\r\n          const syncKey = `${stateKey}:${path.join(\".\")}`;\r\n          return getGlobalStore.getState().getSyncInfo(syncKey);\r\n        }\r\n\r\n        if (prop == \"getLocalStorage\") {\r\n          return (key: string) =>\r\n            loadFromLocalStorage(sessionId + \"-\" + stateKey + \"-\" + key);\r\n        }\r\n        if (prop === \"_selected\") {\r\n          const parentPath = path.slice(0, -1);\r\n          const parentKey = parentPath.join(\".\");\r\n          const parent = getGlobalStore\r\n            .getState()\r\n            .getNestedState(stateKey, parentPath);\r\n          if (Array.isArray(parent)) {\r\n            const currentIndex = Number(path[path.length - 1]);\r\n            return (\r\n              currentIndex ===\r\n              getGlobalStore.getState().getSelectedIndex(stateKey, parentKey)\r\n            );\r\n          }\r\n          return undefined;\r\n        }\r\n        if (prop === \"setSelected\") {\r\n          return (value: boolean) => {\r\n            const parentPath = path.slice(0, -1);\r\n            const thisIndex = Number(path[path.length - 1]);\r\n            const parentKey = parentPath.join(\".\");\r\n\r\n            if (value) {\r\n              getGlobalStore\r\n                .getState()\r\n                .setSelectedIndex(stateKey, parentKey, thisIndex);\r\n            } else {\r\n              getGlobalStore\r\n                .getState()\r\n                .setSelectedIndex(stateKey, parentKey, undefined);\r\n            }\r\n\r\n            const nested = getGlobalStore\r\n              .getState()\r\n              .getNestedState(stateKey, [...parentPath]);\r\n            updateFn(effectiveSetState, nested, parentPath);\r\n\r\n            // Invalidate cache for this path\r\n            invalidateCachePath(parentPath);\r\n          };\r\n        }\r\n        if (path.length == 0) {\r\n          if (prop === \"validateZodSchema\") {\r\n            return () => {\r\n              const init = getGlobalStore\r\n                .getState()\r\n                .getInitialOptions(stateKey)?.validation;\r\n              const addValidationError =\r\n                getGlobalStore.getState().addValidationError;\r\n\r\n              if (!init?.zodSchema) {\r\n                throw new Error(\"Zod schema not found\");\r\n              }\r\n\r\n              if (!init?.key) {\r\n                throw new Error(\"Validation key not found\");\r\n              }\r\n              removeValidationError(init.key);\r\n              const thisObject =\r\n                getGlobalStore.getState().cogsStateStore[stateKey];\r\n\r\n              try {\r\n                // First clear any existing validation errors for this schema\r\n                // This ensures we don't have stale errors\r\n                const existingErrors = getGlobalStore\r\n                  .getState()\r\n                  .getValidationErrors(init.key);\r\n                if (existingErrors && existingErrors.length > 0) {\r\n                  existingErrors.forEach(([errorPath]) => {\r\n                    if (errorPath && errorPath.startsWith(init.key!)) {\r\n                      removeValidationError(errorPath);\r\n                    }\r\n                  });\r\n                }\r\n\r\n                // Attempt to validate with Zod\r\n                const result = init.zodSchema.safeParse(thisObject);\r\n\r\n                if (!result.success) {\r\n                  // Process Zod errors and add them to the validation store\r\n                  const zodErrors = result.error.errors;\r\n\r\n                  zodErrors.forEach((error) => {\r\n                    const errorPath = error.path;\r\n                    const errorMessage = error.message;\r\n\r\n                    // Build the full path for the validation error\r\n                    // Format: validationKey.path.to.field\r\n                    const fullErrorPath = [init.key, ...errorPath].join(\".\");\r\n\r\n                    // Add the error to the store\r\n                    addValidationError(fullErrorPath, errorMessage);\r\n                  });\r\n\r\n                  notifyComponents(stateKey);\r\n\r\n                  return false;\r\n                }\r\n\r\n                return true;\r\n              } catch (error) {\r\n                console.error(\"Zod schema validation failed\", error);\r\n                return false;\r\n              }\r\n            };\r\n          }\r\n          if (prop === \"_componentId\") return componentId;\r\n          if (prop === \"getComponents\") {\r\n            return () => getGlobalStore().stateComponents.get(stateKey);\r\n          }\r\n          if (prop === \"getAllFormRefs\") {\r\n            return () => {\r\n              return formRefStore.getState().getFormRefsByStateKey(stateKey);\r\n            };\r\n          }\r\n\r\n          if (prop === \"_initialState\")\r\n            return getGlobalStore.getState().initialStateGlobal[stateKey];\r\n          if (prop === \"_serverState\")\r\n            return getGlobalStore.getState().serverState[stateKey];\r\n          if (prop === \"_isLoading\")\r\n            return getGlobalStore.getState().isLoadingGlobal[stateKey];\r\n          if (prop === \"revertToInitialState\")\r\n            return baseObj.revertToInitialState;\r\n          if (prop === \"updateInitialState\") return baseObj.updateInitialState;\r\n          if (prop === \"removeValidation\") return baseObj.removeValidation;\r\n        }\r\n        if (prop === \"getFormRef\") {\r\n          return () => {\r\n            return formRefStore\r\n              .getState()\r\n              .getFormRef(stateKey + \".\" + path.join(\".\"));\r\n          };\r\n        }\r\n\r\n        if (prop === \"validationWrapper\") {\r\n          return ({\r\n            children,\r\n            hideMessage,\r\n          }: {\r\n            children: React.ReactNode;\r\n            hideMessage?: boolean;\r\n          }) => (\r\n            <ValidationWrapper\r\n              formOpts={\r\n                hideMessage ? { validation: { message: \"\" } } : undefined\r\n              }\r\n              path={path}\r\n              validationKey={\r\n                getGlobalStore.getState().getInitialOptions(stateKey)\r\n                  ?.validation?.key || \"\"\r\n              }\r\n              stateKey={stateKey}\r\n              validIndices={meta?.validIndices}\r\n            >\r\n              {children}\r\n            </ValidationWrapper>\r\n          );\r\n        }\r\n\r\n        if (prop === \"_stateKey\") return stateKey;\r\n        if (prop === \"_path\") return path;\r\n        if (prop === \"_isServerSynced\") return baseObj._isServerSynced;\r\n\r\n        if (prop === \"update\") {\r\n          return (payload: UpdateArg<T>, opts?: UpdateOpts<T>) => {\r\n            // ADDED: Invalidate cache on update\r\n            if (opts?.debounce) {\r\n              debounce(() => {\r\n                updateFn(effectiveSetState, payload, path, \"\");\r\n                const newValue = getGlobalStore\r\n                  .getState()\r\n                  .getNestedState(stateKey, path);\r\n                if (opts?.afterUpdate) opts.afterUpdate(newValue);\r\n              }, opts.debounce);\r\n            } else {\r\n              updateFn(effectiveSetState, payload, path, \"\");\r\n              const newValue = getGlobalStore\r\n                .getState()\r\n                .getNestedState(stateKey, path);\r\n              if (opts?.afterUpdate) opts.afterUpdate(newValue);\r\n            }\r\n            invalidateCachePath(path);\r\n          };\r\n        }\r\n\r\n        if (prop === \"formElement\") {\r\n          return (child: FormControl<T>, formOpts?: FormOptsType) => {\r\n            return (\r\n              <FormControlComponent<T>\r\n                setState={effectiveSetState}\r\n                stateKey={stateKey}\r\n                path={path}\r\n                child={child}\r\n                formOpts={formOpts}\r\n              />\r\n            );\r\n          };\r\n        }\r\n\r\n        const nextPath = [...path, prop];\r\n        const nextValue = getGlobalStore\r\n          .getState()\r\n          .getNestedState(stateKey, nextPath);\r\n        return rebuildStateShape(nextValue, nextPath, meta);\r\n      },\r\n    };\r\n\r\n    const proxyInstance = new Proxy(baseFunction, handler);\r\n\r\n    shapeCache.set(cacheKey, {\r\n      proxy: proxyInstance,\r\n      stateVersion: stateVersion,\r\n    });\r\n\r\n    return proxyInstance;\r\n  }\r\n\r\n  return rebuildStateShape(\r\n    getGlobalStore.getState().getNestedState(stateKey, [])\r\n  );\r\n}\r\n\r\nexport function $cogsSignal(proxy: {\r\n  _path: string[];\r\n  _stateKey: string;\r\n  _effect?: string;\r\n}) {\r\n  return createElement(SignalRenderer, { proxy });\r\n}\r\n\r\nfunction SignalMapRenderer({\r\n  proxy,\r\n\r\n  rebuildStateShape,\r\n}: {\r\n  proxy: {\r\n    _stateKey: string;\r\n    _path: string[];\r\n    _mapFn: (\r\n      value: any,\r\n      setter: any,\r\n      index: number,\r\n      array: any[],\r\n      arraySetter: any\r\n    ) => ReactNode;\r\n  };\r\n\r\n  rebuildStateShape: (\r\n    currentState: any,\r\n    path: string[],\r\n    meta?: { filtered?: string[][]; validIndices?: number[] }\r\n  ) => any;\r\n}) {\r\n  const value = getGlobalStore().getNestedState(proxy._stateKey, proxy._path);\r\n\r\n  if (!Array.isArray(value)) {\r\n    return null;\r\n  }\r\n  const arraySetter = rebuildStateShape(\r\n    value,\r\n    proxy._path\r\n  ) as ArrayEndType<any>;\r\n  // Use existing global state management\r\n  return arraySetter.stateMapNoRender(\r\n    (item, setter, index, value, arraysetter) => {\r\n      // Execute map function in React context with existing state/proxies\r\n      return proxy._mapFn(item, setter, index, value, arraysetter);\r\n    }\r\n  );\r\n}\r\nfunction SignalRenderer({\r\n  proxy,\r\n}: {\r\n  proxy: {\r\n    _path: string[];\r\n    _stateKey: string;\r\n    _effect?: string;\r\n  };\r\n}) {\r\n  const elementRef = useRef<HTMLSpanElement>(null);\r\n  const signalId = `${proxy._stateKey}-${proxy._path.join(\".\")}`;\r\n\r\n  useEffect(() => {\r\n    const element = elementRef.current;\r\n    if (!element || !element.parentElement) return;\r\n\r\n    const parentElement = element.parentElement;\r\n    const childNodes = Array.from(parentElement.childNodes);\r\n    const position = childNodes.indexOf(element);\r\n\r\n    let parentId = parentElement.getAttribute(\"data-parent-id\");\r\n    if (!parentId) {\r\n      parentId = `parent-${crypto.randomUUID()}`;\r\n      parentElement.setAttribute(\"data-parent-id\", parentId);\r\n    }\r\n\r\n    const instanceId = `instance-${crypto.randomUUID()}`;\r\n    const elementInfo = {\r\n      instanceId,\r\n      parentId,\r\n      position,\r\n      effect: proxy._effect,\r\n    };\r\n\r\n    getGlobalStore.getState().addSignalElement(signalId, elementInfo);\r\n\r\n    // Get the raw value from the store\r\n    const value = getGlobalStore\r\n      .getState()\r\n      .getNestedState(proxy._stateKey, proxy._path);\r\n\r\n    let displayValue;\r\n    if (proxy._effect) {\r\n      try {\r\n        displayValue = new Function(\r\n          \"state\",\r\n          `return (${proxy._effect})(state)`\r\n        )(value);\r\n      } catch (err) {\r\n        console.error(\"Error evaluating effect function during mount:\", err);\r\n        displayValue = value; // Fallback to raw value\r\n      }\r\n    } else {\r\n      displayValue = value;\r\n    }\r\n\r\n    if (displayValue !== null && typeof displayValue === \"object\") {\r\n      displayValue = JSON.stringify(displayValue);\r\n    }\r\n\r\n    const textNode = document.createTextNode(String(displayValue));\r\n    element.replaceWith(textNode);\r\n  }, [proxy._stateKey, proxy._path.join(\".\"), proxy._effect]);\r\n\r\n  return createElement(\"span\", {\r\n    ref: elementRef,\r\n    style: { display: \"none\" },\r\n    \"data-signal-id\": signalId,\r\n  });\r\n}\r\nexport function $cogsSignalStore(proxy: {\r\n  _path: string[];\r\n  _stateKey: string;\r\n}) {\r\n  const value = useSyncExternalStore(\r\n    (notify) => {\r\n      const stateEntry = getGlobalStore\r\n        .getState()\r\n        .stateComponents.get(proxy._stateKey) || {\r\n        components: new Map(),\r\n      };\r\n      stateEntry.components.set(proxy._stateKey, {\r\n        forceUpdate: notify,\r\n        paths: new Set([proxy._path.join(\".\")]),\r\n      });\r\n      return () => stateEntry.components.delete(proxy._stateKey);\r\n    },\r\n    () => getGlobalStore.getState().getNestedState(proxy._stateKey, proxy._path)\r\n  );\r\n  return createElement(\"text\", {}, String(value));\r\n}\r\n"],"names":["setAndMergeOptions","stateKey","newOptions","getInitialOptions","getGlobalStore","setInitialStateOptions","initialOptions","setOptions","options","initialOptionsPart","initialOptionsPartState","mergedOptions","needToAdd","key","addStateOptions","initialState","formElements","validation","createCogsState","opt","newInitialState","statePart","transformStateFunc","useCogsState","componentId","useState","uuidv4","thiState","partialState","state","updater","useCogsStateFn","setCogsOptions","setUpdaterState","setState","getKeyState","getValidationErrors","setStateLog","updateInitialStateGlobal","addValidationError","removeValidationError","setServerSyncActions","loadFromLocalStorage","localStorageKey","storedData","error","saveToLocalStorage","thisKey","currentInitialOptions","sessionId","baseStateToSave","isFunction","storageKey","data","existingData","updateGlobalState","newState","effectiveSetState","updates","createProxyHandler","startTransition","notifyComponents","stateEntry","component","update","notifyComponent","fullComponentId","stateObject","serverSync","localStorage","middleware","reactiveDeps","reactiveType","syncUpdate","dependencies","reactiveForce","forceUpdate","useCogsConfig","noStateKey","stateLog","componentUpdatesRef","useRef","componentIdRef","latestInitialOptionsRef","useEffect","prevState","syncKey","currentInitialState","localData","localkey","newStateToUse","baseStateForStorage","isUsingLocalState","isDeepEqual","currentGlobalState","useLayoutEffect","depsKey","newStateOrFunction","path","updateObj","validationKey","pathKey","prevValue","payload","signalId","isArrayOperation","elements","arrayPath","arrayValue","getNestedValue","arraySignalId","newValue","parentId","position","effect","parent","childNodes","displayValue","arrayWithoutIndex","k","v","length","newKey","oldValue","pathToCheck","shouldUpdate","reactiveTypes","depsResult","newUpdate","prevLogs","aggregatedLogs","acc","log","uniqueKey","existing","serverStateStore","updaterFinal","useMemo","shapeCache","stateVersion","invalidateCachePath","baseObj","obj","init","newProxy","rebuildStateShape","initalOptionsGet","localKey","newUpdaterState","field","serverState","currentState","meta","cacheKey","baseFunction","handler","target","thisArg","args","prop","currentPath","thisReactiveState","initialStateAtPath","selectedIndex","compareFn","sortedArray","i","item","callbackfn","isFiltered","p","arrayToMap","val","index","thisIndex","elementProxy","createElement","SignalMapRenderer","fieldName","flattenedResults","thisValue","foundIndex","foundValue","newPath","indexValue","pushFunc","fields","onMatch","currentArray","matchedItem","isMatch","updatedItem","updatedArray","updateFn","cutFunc","value","newVal","validIndices","filteredArray","lastPathElement","parentPath","parentValue","fn","$cogsSignal","parentKey","nested","thisObject","existingErrors","errorPath","result","errorMessage","fullErrorPath","formRefStore","children","hideMessage","jsx","ValidationWrapper","opts","debounce","child","formOpts","FormControlComponent","nextPath","nextValue","proxyInstance","proxy","SignalRenderer","setter","arraysetter","elementRef","element","parentElement","elementInfo","err","textNode","$cogsSignalStore","useSyncExternalStore","notify"],"mappings":"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"}