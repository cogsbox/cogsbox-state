{"version":3,"file":"CogsState.jsx","sources":["../src/CogsState.tsx"],"sourcesContent":["\"use client\";\r\nimport {\r\n    createElement,\r\n    startTransition,\r\n    useEffect,\r\n    useLayoutEffect,\r\n    useMemo,\r\n    useRef,\r\n    useState,\r\n    useSyncExternalStore,\r\n    type ReactNode,\r\n} from \"react\";\r\n\r\nimport {\r\n    debounce,\r\n    getNestedValue,\r\n    isFunction,\r\n    updateNestedProperty,\r\n    type GenericObject,\r\n} from \"./utility.js\";\r\nimport {\r\n    cutFunc,\r\n    FormControlComponent,\r\n    pushFunc,\r\n    updateFn,\r\n    ValidationWrapper,\r\n} from \"./Functions.js\";\r\nimport { isDeepEqual, transformStateFunc } from \"./utility.js\";\r\nimport type { UseMutationResult } from \"@tanstack/react-query\";\r\nimport { v4 as uuidv4 } from \"uuid\";\r\nimport { ZodObject, type ZodRawShape } from \"zod\";\r\n\r\nimport { getGlobalStore } from \"./store.js\";\r\nimport { useCogsConfig } from \"./CogsStateClient.js\";\r\n\r\ntype Prettify<T> = { [K in keyof T]: T[K] } & {};\r\n\r\nexport type ServerSyncStatus = {\r\n    isFresh: boolean;\r\n    isFreshTime: number;\r\n    isStale: boolean;\r\n    isStaleTime: number;\r\n    isSyncing: boolean;\r\n    isSyncingTime: number;\r\n};\r\n\r\nexport type SyncInfo = {\r\n    timeStamp: number;\r\n    userId: number;\r\n};\r\n\r\nexport type FormElementParmas<T> = {\r\n    get: () => T;\r\n\r\n    set: UpdateType<T>;\r\n    syncStatus: (SyncInfo & { date: Date }) | null;\r\n    path: string[];\r\n    validationErrors: () => string[];\r\n\r\n    inputProps: {\r\n        value?: T;\r\n        onChange?: (\r\n            event: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>,\r\n        ) => void;\r\n    };\r\n};\r\n\r\nexport type StateKeys = string;\r\n\r\ntype findWithFuncType<U> = (\r\n    thisKey: keyof U,\r\n    thisValue: U[keyof U],\r\n) => EndType<U> & StateObject<U>;\r\nexport type PushArgs<U> = (\r\n    update:\r\n        | Prettify<U>\r\n        | ((prevState: NonNullable<Prettify<U>>[]) => NonNullable<Prettify<U>>),\r\n    opts?: UpdateOpts<U>,\r\n) => void;\r\n\r\ntype CutFunctionType = (\r\n    index?: number,\r\n    options?: { waitForSync?: boolean },\r\n) => void;\r\n\r\nexport type InferArrayElement<T> = T extends (infer U)[] ? U : never;\r\n\r\nexport type ArrayEndType<TShape extends unknown> = {\r\n    findWith: findWithFuncType<InferArrayElement<TShape>>;\r\n    index: (index: number) => StateObject<InferArrayElement<TShape>> & {\r\n        insert: PushArgs<InferArrayElement<TShape>>;\r\n        cut: CutFunctionType;\r\n        _index: number;\r\n    } & EndType<InferArrayElement<TShape>>;\r\n    insert: PushArgs<InferArrayElement<TShape>>;\r\n    cut: CutFunctionType;\r\n    stateMapNoRender: (\r\n        callbackfn: (\r\n            value: InferArrayElement<TShape>,\r\n            setter: StateObject<InferArrayElement<TShape>>,\r\n            index: number,\r\n            array: TShape,\r\n            arraySetter: StateObject<TShape>,\r\n        ) => void,\r\n    ) => any;\r\n    stateMap: (\r\n        callbackfn: (\r\n            value: InferArrayElement<TShape>,\r\n            setter: StateObject<InferArrayElement<TShape>>,\r\n            index: number,\r\n            array: TShape,\r\n            arraySetter: StateObject<TShape>,\r\n        ) => void,\r\n    ) => any;\r\n    $stateMap: (\r\n        callbackfn: (\r\n            value: InferArrayElement<TShape>,\r\n            setter: StateObject<InferArrayElement<TShape>>,\r\n            index: number,\r\n            array: TShape,\r\n            arraySetter: StateObject<TShape>,\r\n        ) => void,\r\n    ) => any;\r\n    stateFlattenOn: <K extends keyof InferArrayElement<TShape>>(\r\n        field: K,\r\n    ) => StateObject<InferArrayElement<InferArrayElement<TShape>[K]>[]>;\r\n    uniqueInsert: (\r\n        payload: UpdateArg<InferArrayElement<TShape>>,\r\n        fields?: (keyof InferArrayElement<TShape>)[],\r\n        onMatch?: (existingItem: any) => any,\r\n    ) => void;\r\n    stateFilter: (\r\n        callbackfn: (value: InferArrayElement<TShape>, index: number) => void,\r\n    ) => ArrayEndType<TShape>;\r\n    getSelected: () => StateObject<InferArrayElement<TShape>> | undefined;\r\n} & EndType<TShape> & {\r\n        [K in keyof (any[] extends infer T ? T : never)]: never;\r\n    };\r\n\r\nexport type UpdateType<T> = (\r\n    payload: UpdateArg<Prettify<T>>,\r\n    opts?: UpdateOpts<T>,\r\n) => void;\r\nexport type FormOptsType = {\r\n    key?: string;\r\n    validation?: {\r\n        message?: string;\r\n        stretch?: boolean;\r\n        props?: GenericObject;\r\n        disable?: boolean;\r\n    };\r\n    formElements?: boolean;\r\n    debounceTime?: number;\r\n    stateServerDifferences?: string[][];\r\n};\r\n\r\nexport type FormControl<T> = (obj: FormElementParmas<T>) => JSX.Element;\r\n\r\nexport type UpdateArg<S> = S | ((prevState: S) => S);\r\nexport type UpdateOpts<T> = {\r\n    afterUpdate?: (state: T) => void;\r\n    debounce?: number;\r\n};\r\nexport type ObjectEndType<T> = EndType<T> & {\r\n    [K in keyof T]-?: ObjectEndType<T[K]>;\r\n} & {\r\n    stateObject: (\r\n        callbackfn: (value: T, setter: StateObject<T>) => void,\r\n    ) => any;\r\n    delete: () => void;\r\n};\r\ntype EffectFunction<T, R> = (state: T) => R;\r\nexport type EndType<T, IsArrayElement = false> = {\r\n    update: UpdateType<T>;\r\n    _path: string[];\r\n    _stateKey: string;\r\n    formElement: (\r\n        validationKey: string,\r\n        control: FormControl<T>,\r\n        opts?: FormOptsType,\r\n    ) => JSX.Element;\r\n    get: () => T;\r\n    $get: () => T;\r\n    $derive: <R>(fn: EffectFunction<T, R>) => R;\r\n    _status: \"fresh\" | \"stale\" | \"synced\";\r\n    showValidationErrors: (ctx: string) => string[];\r\n    setValidation: (ctx: string) => void;\r\n    removeValidation: (ctx: string) => void;\r\n    ignoreFields: (fields: string[]) => StateObject<T>;\r\n    _selected: boolean;\r\n    setSelected: (value: boolean) => void;\r\n    validationWrapper: ({\r\n        children,\r\n        hideMessage,\r\n    }: {\r\n        children: React.ReactNode;\r\n        hideMessage?: boolean;\r\n    }) => JSX.Element;\r\n    lastSynced?: SyncInfo;\r\n} & (IsArrayElement extends true ? { cut: () => void } : {}) & {\r\n        [K in keyof (any extends infer T ? T : never)]: never;\r\n    };\r\n\r\nexport type StateObject<T> = (T extends any[]\r\n    ? ArrayEndType<T>\r\n    : T extends Record<string, unknown> | object\r\n      ? { [K in keyof T]-?: StateObject<T[K]> } & ObjectEndType<T>\r\n      : T extends string | number | boolean | null\r\n        ? T\r\n        : never) &\r\n    EndType<T, true> & {\r\n        _componentId: string | null;\r\n        _initialState: T;\r\n        updateInitialState: (newState: T | null) => {\r\n            fetchId: (field: keyof T) => string | number;\r\n        };\r\n        _isLoading: boolean;\r\n        _serverState: T;\r\n        revertToInitialState: (obj?: { validationKey?: string }) => void;\r\n        middleware: (\r\n            middles: ({\r\n                updateLog,\r\n                update,\r\n            }: {\r\n                updateLog: UpdateTypeDetail[] | undefined;\r\n                update: UpdateTypeDetail;\r\n            }) => void,\r\n        ) => void;\r\n        _isServerSynced: () => boolean;\r\n        getLocalStorage: (key: string) => LocalStorageData<T> | null;\r\n    };\r\n\r\nexport type CogsUpdate<T extends unknown> = UpdateType<T>;\r\n\r\nexport type EffectiveSetState<TStateObject> = (\r\n    newStateOrFunction:\r\n        | TStateObject\r\n        | ((prevState: TStateObject) => TStateObject),\r\n    path: string[],\r\n    updateObj: { updateType: \"update\" | \"insert\" | \"cut\" },\r\n    validationKey?: string,\r\n    opts?: UpdateOpts<TStateObject>,\r\n) => void;\r\n\r\nexport type UpdateTypeDetail = {\r\n    timeStamp: number;\r\n    stateKey: string;\r\n    updateType: \"update\" | \"insert\" | \"cut\";\r\n    path: string[];\r\n    status: \"new\" | \"sent\" | \"synced\";\r\n    oldValue: any;\r\n    newValue: any;\r\n    userId?: number;\r\n};\r\n\r\n//let globalStoreInstance: ReturnType<typeof getGlobalStore> | null = null;\r\n\r\n// export const getGlobalStore = <State extends GenericObject | GenericObject[]>(initialState?: State) => {\r\n//     if (!globalStoreInstance) {\r\n//         globalStoreInstance = cogStateGlobalStore(initialState ?? {});\r\n//     }\r\n//     return globalStoreInstance;\r\n// };\r\n\r\nexport type ActionsType<T> = {\r\n    type: \"onChange\";\r\n    action: ({ state, actionType }: { state: T; actionType: string }) => void;\r\n    debounce?: number;\r\n}[];\r\n\r\ntype ArrayToObject<T extends string[]> = Record<T[number], string>;\r\ntype CookieType<T> = {\r\n    timeStamp: number;\r\n    value: T;\r\n    cookieName: string;\r\n    OnUnMountCookie?: Boolean;\r\n};\r\nexport type CogsCookiesType<T extends string[] = string[]> = CookieType<\r\n    ArrayToObject<T>\r\n>;\r\nexport type ReactivityType = \"none\" | \"component\" | \"deps\" | \"all\";\r\n\r\nexport type OptionsType<T extends unknown = unknown> = {\r\n    serverSync?: ServerSyncType<T>;\r\n    validationKey?: string;\r\n    enableServerState?: boolean;\r\n    middleware?: ({\r\n        updateLog,\r\n        update,\r\n    }: {\r\n        updateLog: UpdateTypeDetail[] | undefined;\r\n        update: UpdateTypeDetail;\r\n    }) => void;\r\n\r\n    zodSchema?: ZodObject<ZodRawShape>;\r\n    modifyState?: (state: T) => T;\r\n    localStorage?: { key: string | ((state: T) => string) };\r\n    formElements?: FormsElementsType;\r\n    enabledSync?: (state: T) => boolean;\r\n    reactiveDeps?: (state: T) => any[] | true;\r\n    reactiveType?: ReactivityType[] | ReactivityType;\r\n    syncUpdate?: Partial<UpdateTypeDetail>;\r\n    initState?: {\r\n        localStorageKey?: string;\r\n        ctx?: Record<string, any>;\r\n        initialState: T;\r\n        dependencies?: any[]; // Just like useEffect dependencies\r\n    };\r\n};\r\nexport type ServerSyncType<T> = {\r\n    testKey?: string;\r\n    syncKey: (({ state }: { state: T }) => string) | string;\r\n    syncFunction: ({ state }: { state: T }) => void;\r\n    debounce?: number;\r\n    mutation: UseMutationResult<any, unknown, any, unknown>;\r\n    snapshot?: {\r\n        name: (({ state }: { state: T }) => string) | string;\r\n        stateKeys: StateKeys[];\r\n        currentUrl: string;\r\n        currentParams?: URLSearchParams;\r\n    };\r\n};\r\nexport type SyncActionsType<T> = {\r\n    syncKey: string;\r\n\r\n    rollBackState?: T;\r\n    actionTimeStamp: number;\r\n    retryCount?: number;\r\n    status:\r\n        | \"success\"\r\n        | \"waiting\"\r\n        | \"rolledBack\"\r\n        | \"error\"\r\n        | \"cancelled\"\r\n        | \"failed\";\r\n    snapshot?: {\r\n        name: string;\r\n        stateKeys: StateKeys[];\r\n        currentUrl: string;\r\n        currentParams?: URLSearchParams;\r\n    };\r\n};\r\n\r\nexport type ValidationWrapperOptions<T extends unknown = unknown> = {\r\n    children: React.ReactNode;\r\n    active: boolean;\r\n    stretch?: boolean;\r\n    path: string[];\r\n    message?: string;\r\n    data?: T;\r\n    key?: string;\r\n};\r\nexport type SyncRenderOptions<T extends unknown = unknown> = {\r\n    children: React.ReactNode;\r\n    time: number;\r\n    data?: T;\r\n    key?: string;\r\n};\r\n\r\ntype FormsElementsType<T extends unknown = unknown> = {\r\n    validation?: (options: ValidationWrapperOptions<T>) => React.ReactNode;\r\n    syncRender?: (options: SyncRenderOptions<T>) => React.ReactNode;\r\n};\r\n\r\nexport type InitialStateInnerType<T extends unknown = unknown> = {\r\n    initialState: T;\r\n} & OptionsType<T>;\r\n\r\nexport type InitialStateType<T> = {\r\n    [key: string]: InitialStateInnerType<T>;\r\n};\r\nexport type FunctionsToPassDownType = {\r\n    getValidationErrors: (pathArray: string) => string[];\r\n    removeValidationError: (path: string) => void;\r\n};\r\n\r\nexport type AllStateTypes<T extends unknown> = Record<string, T>;\r\n\r\nexport type CogsInitialState<T> = {\r\n    initialState: T;\r\n    formElements?: FormsElementsType<T>;\r\n};\r\n\r\nexport type TransformedStateType<T> = {\r\n    [P in keyof T]: T[P] extends CogsInitialState<infer U> ? U : T[P];\r\n};\r\n\r\nexport function addStateOptions<T extends unknown>(\r\n    initialState: T,\r\n    { formElements, zodSchema }: OptionsType<T>,\r\n) {\r\n    return { initialState: initialState, formElements, zodSchema } as T;\r\n}\r\n\r\nfunction setAndMergeOptions(stateKey: string, newOptions: OptionsType<any>) {\r\n    const getInitialOptions = getGlobalStore.getState().getInitialOptions;\r\n    const setInitialStateOptions =\r\n        getGlobalStore.getState().setInitialStateOptions;\r\n\r\n    const initialOptions = getInitialOptions(stateKey as string) || {};\r\n\r\n    setInitialStateOptions(stateKey as string, {\r\n        ...initialOptions,\r\n        ...newOptions,\r\n    });\r\n}\r\n\r\nfunction setOptions<StateKey, Opt>({\r\n    stateKey,\r\n    options,\r\n    initialOptionsPart,\r\n}: {\r\n    stateKey: StateKey;\r\n    options?: Opt;\r\n    initialOptionsPart: Record<string, any>;\r\n}) {\r\n    const initialOptions = getInitialOptions(stateKey as string) || {};\r\n    const initialOptionsPartState =\r\n        initialOptionsPart[stateKey as string] || {};\r\n    const setInitialStateOptions =\r\n        getGlobalStore.getState().setInitialStateOptions;\r\n    const mergedOptions = { ...initialOptionsPartState, ...initialOptions };\r\n\r\n    let needToAdd = false;\r\n    if (options) {\r\n        for (const key in options) {\r\n            if (!mergedOptions.hasOwnProperty(key)) {\r\n                needToAdd = true;\r\n                mergedOptions[key] = options[key as keyof typeof options];\r\n            }\r\n        }\r\n    }\r\n    if (needToAdd) {\r\n        setInitialStateOptions(stateKey as string, mergedOptions);\r\n    }\r\n}\r\n\r\nexport const createCogsState = <State extends Record<string, unknown>>(\r\n    initialState: State,\r\n    opts?: { reRenderType?: \"get\" | \"state\" | \"none\" },\r\n) => {\r\n    let newInitialState = initialState;\r\n\r\n    const [statePart, initialOptionsPart] =\r\n        transformStateFunc<State>(newInitialState);\r\n\r\n    getGlobalStore.getState().setInitialStates(statePart);\r\n    type StateKeys = keyof typeof statePart;\r\n\r\n    const useCogsState = <StateKey extends StateKeys>(\r\n        stateKey: StateKey,\r\n        options?: OptionsType<(typeof statePart)[StateKey]>,\r\n    ) => {\r\n        const [componentId] = useState(uuidv4());\r\n        setOptions({ stateKey, options, initialOptionsPart });\r\n\r\n        const thiState =\r\n            getGlobalStore.getState().cogsStateStore[stateKey as string] ||\r\n            statePart[stateKey as string];\r\n        const partialState = options?.modifyState\r\n            ? options.modifyState(thiState)\r\n            : thiState;\r\n\r\n        const [state, updater] = useCogsStateFn<(typeof statePart)[StateKey]>(\r\n            partialState,\r\n            {\r\n                stateKey: stateKey as string,\r\n                syncUpdate: options?.syncUpdate,\r\n                componentId,\r\n                localStorage: options?.localStorage,\r\n                middleware: options?.middleware,\r\n                enabledSync: options?.enabledSync,\r\n                reactiveType: options?.reactiveType,\r\n                reactiveDeps: options?.reactiveDeps,\r\n                initState: options?.initState,\r\n            },\r\n        );\r\n\r\n        return updater;\r\n    };\r\n\r\n    function setCogsOptions<StateKey extends StateKeys>(\r\n        stateKey: StateKey,\r\n        options: OptionsType<(typeof statePart)[StateKey]>,\r\n    ) {\r\n        setOptions({ stateKey, options, initialOptionsPart });\r\n    }\r\n\r\n    return { useCogsState, setCogsOptions };\r\n};\r\n\r\nconst {\r\n    setUpdaterState,\r\n    setState,\r\n    getInitialOptions,\r\n    getKeyState,\r\n    getValidationErrors,\r\n    setStateLog,\r\n    updateInitialStateGlobal,\r\n    addValidationError,\r\n    removeValidationError,\r\n    setServerSyncActions,\r\n} = getGlobalStore.getState();\r\n\r\nconst loadFromLocalStorage = (localStorageKey: string) => {\r\n    if (!localStorageKey) return null;\r\n\r\n    try {\r\n        const storedData = window.localStorage.getItem(localStorageKey);\r\n        if (!storedData) return null;\r\n\r\n        const parsedData = JSON.parse(storedData);\r\n\r\n        return parsedData;\r\n    } catch (error) {\r\n        console.error(\"Error loading from localStorage:\", error);\r\n        return null;\r\n    }\r\n};\r\n\r\nconst saveToLocalStorage = <T,>(\r\n    state: T,\r\n    thisKey: string,\r\n    currentInitialOptions: any,\r\n    sessionId?: string,\r\n) => {\r\n    if (currentInitialOptions?.initState) {\r\n        const data: LocalStorageData<T> = {\r\n            state,\r\n            lastUpdated: Date.now(),\r\n            lastSyncedWithServer:\r\n                getGlobalStore.getState().serverSyncLog[thisKey]?.[0]\r\n                    ?.timeStamp,\r\n            baseServerState: getGlobalStore.getState().serverState[thisKey],\r\n        };\r\n\r\n        const storageKey = currentInitialOptions.initState\r\n            ? `${sessionId}-${thisKey}-${currentInitialOptions.initState.localStorageKey}`\r\n            : thisKey;\r\n\r\n        window.localStorage.setItem(storageKey, JSON.stringify(data));\r\n    }\r\n};\r\n\r\ntype LocalStorageData<T> = {\r\n    state: T;\r\n    lastUpdated: number;\r\n    lastSyncedWithServer?: number;\r\n    baseServerState?: T; // Add this to track what server state our changes are based on\r\n};\r\n\r\nconst updateGlobalState = (\r\n    thisKey: string,\r\n    initialState: any,\r\n    newState: any,\r\n    effectiveSetState: EffectiveSetState<any>,\r\n    componentId: string,\r\n    sessionId?: string,\r\n) => {\r\n    // Update all global state at once\r\n    const updates = {\r\n        initialState: initialState,\r\n        updaterState: createProxyHandler(\r\n            thisKey,\r\n            effectiveSetState,\r\n            componentId,\r\n            sessionId,\r\n        ),\r\n        state: newState,\r\n    };\r\n\r\n    startTransition(() => {\r\n        updateInitialStateGlobal(thisKey, updates.initialState);\r\n        setUpdaterState(thisKey, updates.updaterState);\r\n        setState(thisKey, updates.state);\r\n    });\r\n};\r\n\r\nconst notifyComponents = (thisKey: string) => {\r\n    const stateEntry = getGlobalStore.getState().stateComponents.get(thisKey);\r\n    if (!stateEntry) return;\r\n\r\n    // Batch component updates\r\n    const updates = new Set<() => void>();\r\n    stateEntry.components.forEach((component) => {\r\n        updates.add(() => component.forceUpdate());\r\n    });\r\n\r\n    // Schedule updates in the next tick to allow batching\r\n    queueMicrotask(() => {\r\n        startTransition(() => {\r\n            updates.forEach((update) => update());\r\n        });\r\n    });\r\n};\r\n\r\nexport function useCogsStateFn<TStateObject extends unknown>(\r\n    stateObject: TStateObject,\r\n    {\r\n        stateKey,\r\n        serverSync,\r\n        zodSchema,\r\n        localStorage,\r\n        formElements,\r\n        middleware,\r\n        reactiveDeps,\r\n        reactiveType,\r\n        componentId,\r\n        initState,\r\n        syncUpdate,\r\n    }: {\r\n        stateKey?: string;\r\n        componentId?: string;\r\n    } & OptionsType<TStateObject> = {},\r\n) {\r\n    const [reactiveForce, forceUpdate] = useState({}); //this is the key to reactivity\r\n    const { sessionId } = useCogsConfig();\r\n\r\n    let noStateKey = stateKey ? false : true;\r\n    const [thisKey] = useState(stateKey ?? uuidv4());\r\n    const stateLog = getGlobalStore.getState().stateLog[thisKey];\r\n    const componentUpdatesRef = useRef(new Set<string>());\r\n    const componentIdRef = useRef(componentId ?? uuidv4());\r\n    const latestInitialOptionsRef = useRef<any>(null);\r\n    latestInitialOptionsRef.current = getInitialOptions(thisKey as string);\r\n\r\n    useEffect(() => {\r\n        if (\r\n            syncUpdate &&\r\n            syncUpdate.stateKey === thisKey &&\r\n            syncUpdate.path?.[0]\r\n        ) {\r\n            // Update the actual state value\r\n            setState(thisKey, (prevState: any) => ({\r\n                ...prevState,\r\n                [syncUpdate.path![0]!]: syncUpdate.newValue,\r\n            }));\r\n\r\n            // Create combined key and update sync info\r\n            const syncKey = `${syncUpdate.stateKey}:${syncUpdate.path.join(\".\")}`;\r\n            getGlobalStore.getState().setSyncInfo(syncKey, {\r\n                timeStamp: syncUpdate.timeStamp!,\r\n                userId: syncUpdate.userId!,\r\n            });\r\n        }\r\n    }, [syncUpdate]);\r\n\r\n    useEffect(() => {\r\n        setAndMergeOptions(thisKey as string, {\r\n            initState,\r\n        });\r\n        const localData = loadFromLocalStorage(\r\n            sessionId + \"-\" + thisKey + \"-\" + initState?.localStorageKey,\r\n        );\r\n        let newState = null;\r\n        if (initState?.initialState) {\r\n            newState = initState?.initialState;\r\n\r\n            if (localData) {\r\n                if (\r\n                    localData.lastUpdated >\r\n                    (localData.lastSyncedWithServer || 0)\r\n                ) {\r\n                    newState = localData.state;\r\n                }\r\n            }\r\n            updateGlobalState(\r\n                thisKey,\r\n                initState?.initialState,\r\n                newState,\r\n                effectiveSetState,\r\n                componentIdRef.current,\r\n                sessionId,\r\n            );\r\n        }\r\n        notifyComponents(thisKey);\r\n    }, [initState?.localStorageKey, ...(initState?.dependencies || [])]);\r\n\r\n    useLayoutEffect(() => {\r\n        if (noStateKey) {\r\n            setAndMergeOptions(thisKey as string, {\r\n                serverSync,\r\n                formElements,\r\n                zodSchema,\r\n                initState,\r\n                localStorage,\r\n                middleware,\r\n            });\r\n        }\r\n\r\n        const depsKey = `${thisKey}////${componentIdRef.current}`;\r\n        const stateEntry = getGlobalStore\r\n            .getState()\r\n            .stateComponents.get(thisKey) || {\r\n            components: new Map(),\r\n        };\r\n\r\n        stateEntry.components.set(depsKey, {\r\n            forceUpdate: () => forceUpdate({}),\r\n            paths: new Set(),\r\n            deps: [],\r\n            depsFunction: reactiveDeps || undefined,\r\n            reactiveType: reactiveType ?? [\"component\", \"deps\"],\r\n        });\r\n\r\n        getGlobalStore.getState().stateComponents.set(thisKey, stateEntry);\r\n\r\n        return () => {\r\n            const depsKey = `${thisKey}////${componentIdRef.current}`;\r\n\r\n            if (stateEntry) {\r\n                stateEntry.components.delete(depsKey);\r\n                if (stateEntry.components.size === 0) {\r\n                    getGlobalStore.getState().stateComponents.delete(thisKey);\r\n                }\r\n            }\r\n        };\r\n    }, []);\r\n\r\n    const effectiveSetState = (\r\n        newStateOrFunction:\r\n            | TStateObject\r\n            | ((prevState: TStateObject) => TStateObject),\r\n        path: string[],\r\n        updateObj: { updateType: \"insert\" | \"cut\" | \"update\" },\r\n        validationKey?: string,\r\n    ) => {\r\n        if (Array.isArray(path)) {\r\n            const pathKey = `${thisKey}-${path.join(\".\")}`;\r\n            componentUpdatesRef.current.add(pathKey);\r\n        }\r\n        setState(thisKey, (prevValue: TStateObject) => {\r\n            const payload = isFunction<TStateObject>(newStateOrFunction)\r\n                ? newStateOrFunction(prevValue as TStateObject)\r\n                : newStateOrFunction;\r\n\r\n            const signalId = `${thisKey}-${path.join(\".\")}`;\r\n            if (signalId) {\r\n                let isArrayOperation = false;\r\n                let elements = getGlobalStore\r\n                    .getState()\r\n                    .signalDomElements.get(signalId);\r\n\r\n                if (\r\n                    (!elements || elements.size === 0) &&\r\n                    (updateObj.updateType === \"insert\" ||\r\n                        updateObj.updateType === \"cut\")\r\n                ) {\r\n                    // Remove last segment (index) from path\r\n                    const arrayPath = path.slice(0, -1);\r\n                    const arrayValue = getNestedValue(payload, arrayPath);\r\n                    // If it's an array, use that path for signal\r\n                    if (Array.isArray(arrayValue)) {\r\n                        isArrayOperation = true;\r\n                        const arraySignalId = `${thisKey}-${arrayPath.join(\".\")}`;\r\n                        elements = getGlobalStore\r\n                            .getState()\r\n                            .signalDomElements.get(arraySignalId);\r\n                    }\r\n                }\r\n\r\n                if (elements) {\r\n                    const newValue = isArrayOperation\r\n                        ? getNestedValue(payload, path.slice(0, -1)) // Get array for array operations\r\n                        : getNestedValue(payload, path); // Get normal value otherwise\r\n                    elements.forEach(({ parentId, position, effect }) => {\r\n                        const parent = document.querySelector(\r\n                            `[data-parent-id=\"${parentId}\"]`,\r\n                        );\r\n                        if (parent) {\r\n                            const childNodes = Array.from(parent.childNodes);\r\n                            if (childNodes[position]) {\r\n                                const displayValue = effect\r\n                                    ? new Function(\r\n                                          \"state\",\r\n                                          `return (${effect})(state)`,\r\n                                      )(newValue)\r\n                                    : newValue;\r\n                                childNodes[position].textContent =\r\n                                    String(displayValue);\r\n                            }\r\n                        }\r\n                    });\r\n                }\r\n            }\r\n            if (\r\n                updateObj.updateType === \"update\" &&\r\n                (validationKey ||\r\n                    latestInitialOptionsRef.current?.validationKey) &&\r\n                path\r\n            ) {\r\n                removeValidationError(\r\n                    (validationKey ||\r\n                        latestInitialOptionsRef.current?.validationKey) +\r\n                        \".\" +\r\n                        path.join(\".\"),\r\n                );\r\n            }\r\n            const arrayWithoutIndex = path.slice(0, path.length - 1);\r\n            if (\r\n                updateObj.updateType === \"cut\" &&\r\n                latestInitialOptionsRef.current?.validationKey\r\n            ) {\r\n                removeValidationError(\r\n                    latestInitialOptionsRef.current?.validationKey +\r\n                        \".\" +\r\n                        arrayWithoutIndex.join(\".\"),\r\n                );\r\n            }\r\n            if (\r\n                updateObj.updateType === \"insert\" &&\r\n                latestInitialOptionsRef.current?.validationKey\r\n            ) {\r\n                let getValidation = getValidationErrors(\r\n                    latestInitialOptionsRef.current?.validationKey +\r\n                        \".\" +\r\n                        arrayWithoutIndex.join(\".\"),\r\n                );\r\n\r\n                //TODO this is untested its supposed to cahnge teh validation errors alreaady stored when a new entry is push\r\n\r\n                getValidation.filter(([k, v]) => {\r\n                    let length = k?.split(\".\").length;\r\n\r\n                    if (\r\n                        k == arrayWithoutIndex.join(\".\") &&\r\n                        length == arrayWithoutIndex.length - 1\r\n                    ) {\r\n                        //   console.log(length, pathWithoutIndex.length);\r\n                        let newKey = k + \".\" + arrayWithoutIndex;\r\n                        removeValidationError(k!);\r\n                        addValidationError(newKey, v!);\r\n                    }\r\n                });\r\n            }\r\n\r\n            const oldValue = getNestedValue(prevValue, path);\r\n            const newValue = getNestedValue(payload, path);\r\n            const pathToCheck =\r\n                updateObj.updateType === \"update\"\r\n                    ? path.join(\".\")\r\n                    : [...path].slice(0, -1).join(\".\");\r\n            const stateEntry = getGlobalStore\r\n                .getState()\r\n                .stateComponents.get(thisKey);\r\n            if (stateKey == \"products\") {\r\n                console.log(\"thisKey\", thisKey);\r\n                console.log(\"stateEntry\", stateEntry);\r\n            }\r\n            if (stateEntry) {\r\n                for (const [\r\n                    key,\r\n                    component,\r\n                ] of stateEntry.components.entries()) {\r\n                    let shouldUpdate = false;\r\n                    const reactiveTypes = Array.isArray(component.reactiveType)\r\n                        ? component.reactiveType\r\n                        : [component.reactiveType || \"component\"];\r\n\r\n                    // Skip if reactivity is disabled\r\n                    if (reactiveTypes.includes(\"none\")) {\r\n                        continue;\r\n                    }\r\n\r\n                    // Force update if \"all\" is specified\r\n                    if (reactiveTypes.includes(\"all\")) {\r\n                        component.forceUpdate();\r\n                        continue;\r\n                    }\r\n\r\n                    // Check component-level path reactivity\r\n                    if (reactiveTypes.includes(\"component\")) {\r\n                        if (\r\n                            component.paths &&\r\n                            (component.paths.has(pathToCheck) ||\r\n                                component.paths.has(\"\"))\r\n                        ) {\r\n                            shouldUpdate = true;\r\n                        }\r\n                    }\r\n                    console.log(\r\n                        \"reactiveTypes\",\r\n                        key,\r\n                        component,\r\n                        reactiveTypes,\r\n                        shouldUpdate,\r\n                    );\r\n                    // Check dependency-based reactivity\r\n                    if (!shouldUpdate && reactiveTypes.includes(\"deps\")) {\r\n                        if (component.depsFunction) {\r\n                            const depsResult = component.depsFunction(payload);\r\n\r\n                            if (typeof depsResult === \"boolean\") {\r\n                                if (depsResult) {\r\n                                    shouldUpdate = true;\r\n                                }\r\n                            } else if (\r\n                                !isDeepEqual(component.deps, depsResult)\r\n                            ) {\r\n                                console.log(\r\n                                    \"reactiveTypes\",\r\n                                    component.deps,\r\n                                    depsResult,\r\n                                    isDeepEqual(component.deps, depsResult),\r\n                                    depsResult,\r\n                                );\r\n                                component.deps = depsResult;\r\n                                shouldUpdate = true;\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    if (shouldUpdate) {\r\n                        component.forceUpdate();\r\n                    }\r\n                }\r\n            }\r\n            const timeStamp = Date.now();\r\n\r\n            const newUpdate = {\r\n                timeStamp,\r\n                stateKey: thisKey,\r\n                path,\r\n                updateType: updateObj.updateType,\r\n                status: \"new\" as const,\r\n                oldValue,\r\n                newValue,\r\n            } satisfies UpdateTypeDetail;\r\n\r\n            setStateLog(thisKey, (prevLogs) => {\r\n                const logs = [...(prevLogs ?? []), newUpdate];\r\n\r\n                // Aggregate the updates by stateKey and path\r\n                const aggregatedLogs = logs.reduce((acc, log) => {\r\n                    const uniqueKey = `${log.stateKey}:${JSON.stringify(log.path)}`;\r\n                    const existing = acc.get(uniqueKey);\r\n\r\n                    if (existing) {\r\n                        // Update the existing entry with the most recent details\r\n                        existing.timeStamp = Math.max(\r\n                            existing.timeStamp,\r\n                            log.timeStamp,\r\n                        );\r\n                        existing.newValue = log.newValue; // Overwrite with the latest value\r\n                        existing.oldValue = existing.oldValue ?? log.oldValue; // Retain the initial oldValue\r\n                        existing.updateType = log.updateType; // Update to the most recent type\r\n                    } else {\r\n                        // Add the log if no existing match is found\r\n                        acc.set(uniqueKey, { ...(log as any) });\r\n                    }\r\n\r\n                    return acc;\r\n                }, new Map<string, typeof newUpdate>());\r\n\r\n                // Convert the aggregated map back to an array\r\n                return Array.from(aggregatedLogs.values());\r\n            });\r\n\r\n            saveToLocalStorage(\r\n                payload,\r\n                thisKey,\r\n                latestInitialOptionsRef.current,\r\n                sessionId,\r\n            );\r\n\r\n            if (middleware) {\r\n                middleware({\r\n                    updateLog: stateLog,\r\n                    update: newUpdate,\r\n                });\r\n            }\r\n            if (latestInitialOptionsRef.current?.serverSync) {\r\n                const serverStateStore =\r\n                    getGlobalStore.getState().serverState[thisKey];\r\n                const serverSync = latestInitialOptionsRef.current?.serverSync;\r\n                setServerSyncActions(thisKey, {\r\n                    syncKey:\r\n                        typeof serverSync.syncKey == \"string\"\r\n                            ? serverSync.syncKey\r\n                            : serverSync.syncKey({ state: payload }),\r\n                    rollBackState: serverStateStore,\r\n                    actionTimeStamp: Date.now() + (serverSync.debounce ?? 3000),\r\n                    status: \"waiting\",\r\n                });\r\n            }\r\n\r\n            return payload;\r\n        });\r\n    };\r\n    if (!getGlobalStore.getState().updaterState[thisKey]) {\r\n        console.log(\"Initializing state for\", thisKey, stateObject); // Debug log\r\n        setUpdaterState(\r\n            thisKey,\r\n            createProxyHandler(\r\n                thisKey,\r\n                effectiveSetState,\r\n                componentIdRef.current,\r\n                sessionId,\r\n            ),\r\n        );\r\n        if (!getGlobalStore.getState().cogsStateStore[thisKey]) {\r\n            setState(thisKey, stateObject);\r\n        }\r\n        if (!getGlobalStore.getState().initialStateGlobal[thisKey]) {\r\n            updateInitialStateGlobal(thisKey, stateObject);\r\n        }\r\n    }\r\n\r\n    const updaterFinal = useMemo(() => {\r\n        // Create proxy with baseObject as target\r\n        return createProxyHandler<TStateObject>(\r\n            thisKey,\r\n            effectiveSetState,\r\n            componentIdRef.current,\r\n            sessionId,\r\n        );\r\n    }, [thisKey]);\r\n\r\n    return [getKeyState(thisKey), updaterFinal] as [\r\n        TStateObject,\r\n        StateObject<TStateObject>,\r\n    ];\r\n}\r\n\r\nfunction createProxyHandler<T>(\r\n    stateKey: string,\r\n    effectiveSetState: EffectiveSetState<T>,\r\n    componentId: string,\r\n    sessionId?: string,\r\n): StateObject<T> {\r\n    // ADDED: Enhanced cache with versioning\r\n    type CacheEntry = {\r\n        proxy: any;\r\n        stateVersion: number;\r\n    };\r\n    const shapeCache = new Map<string, CacheEntry>();\r\n    let stateVersion = 0;\r\n\r\n    // ADDED: Cache invalidation helper\r\n    const invalidateCachePath = (path: string[]) => {\r\n        const pathKey = path.join(\".\");\r\n        for (const [key] of shapeCache) {\r\n            if (key === pathKey || key.startsWith(pathKey + \".\")) {\r\n                shapeCache.delete(key);\r\n            }\r\n        }\r\n        stateVersion++;\r\n    };\r\n\r\n    const selectedIndexMap = new Map<string, number>();\r\n\r\n    const baseObj = {\r\n        removeValidation: (obj?: { validationKey?: string }) => {\r\n            if (obj?.validationKey) {\r\n                removeValidationError(obj.validationKey);\r\n            }\r\n        },\r\n\r\n        revertToInitialState: (obj?: { validationKey?: string }) => {\r\n            if (obj?.validationKey) {\r\n                removeValidationError(obj.validationKey);\r\n            }\r\n\r\n            const initialState =\r\n                getGlobalStore.getState().initialStateGlobal[stateKey];\r\n\r\n            // ADDED: Clear cache on revert\r\n            shapeCache.clear();\r\n            stateVersion++;\r\n\r\n            const newProxy = rebuildStateShape(initialState, []);\r\n\r\n            startTransition(() => {\r\n                setUpdaterState(stateKey, newProxy);\r\n                setState(stateKey, initialState);\r\n                const stateEntry = getGlobalStore\r\n                    .getState()\r\n                    .stateComponents.get(stateKey);\r\n                if (stateEntry) {\r\n                    stateEntry.components.forEach((component) => {\r\n                        component.forceUpdate();\r\n                    });\r\n                }\r\n                const initalOptionsGet = getInitialOptions(stateKey as string);\r\n                if (initalOptionsGet?.initState) {\r\n                    localStorage.removeItem(\r\n                        initalOptionsGet?.initState\r\n                            ? sessionId +\r\n                                  \"-\" +\r\n                                  stateKey +\r\n                                  \"-\" +\r\n                                  initalOptionsGet?.initState.localStorageKey\r\n                            : stateKey,\r\n                    );\r\n                }\r\n                localStorage.removeItem(stateKey);\r\n            });\r\n        },\r\n        updateInitialState: (newState: T) => {\r\n            // ADDED: Clear cache on initial state update\r\n            shapeCache.clear();\r\n            stateVersion++;\r\n\r\n            const newUpdaterState = createProxyHandler(\r\n                stateKey,\r\n                effectiveSetState,\r\n                componentId,\r\n                sessionId,\r\n            );\r\n            startTransition(() => {\r\n                updateInitialStateGlobal(stateKey, newState);\r\n                setUpdaterState(stateKey, newUpdaterState);\r\n                setState(stateKey, newState);\r\n                const stateEntry = getGlobalStore\r\n                    .getState()\r\n                    .stateComponents.get(stateKey);\r\n                if (stateEntry) {\r\n                    stateEntry.components.forEach((component) => {\r\n                        component.forceUpdate();\r\n                    });\r\n                }\r\n                localStorage.removeItem(stateKey);\r\n            });\r\n            return {\r\n                fetchId: (field: keyof T) => newUpdaterState.get()[field],\r\n            };\r\n        },\r\n        _initialState: getGlobalStore.getState().initialStateGlobal[stateKey],\r\n        _serverState: getGlobalStore.getState().serverState[stateKey],\r\n        _isLoading: getGlobalStore.getState().isLoadingGlobal[stateKey],\r\n        _isServerSynced: () => {\r\n            const serverState = getGlobalStore.getState().serverState[stateKey];\r\n            return Boolean(\r\n                serverState && isDeepEqual(serverState, getKeyState(stateKey)),\r\n            );\r\n        },\r\n    };\r\n\r\n    function rebuildStateShape(\r\n        currentState: T,\r\n        path: string[] = [],\r\n        meta?: { filtered?: string[][]; validIndices?: number[] },\r\n    ): any {\r\n        const cacheKey = path.map(String).join(\".\");\r\n\r\n        // MODIFIED: Cache check with version\r\n        const cachedEntry = shapeCache.get(cacheKey);\r\n        // if (cachedEntry?.stateVersion === stateVersion) {\r\n        //     return cachedEntry.proxy;\r\n        // }\r\n\r\n        const handler = {\r\n            get(target: any, prop: string) {\r\n                if (\r\n                    prop !== \"then\" &&\r\n                    !prop.startsWith(\"$\") &&\r\n                    prop !== \"stateMapNoRender\"\r\n                ) {\r\n                    const currentPath = path.join(\".\");\r\n                    const fullComponentId = `${stateKey}////${componentId}`;\r\n\r\n                    const stateEntry = getGlobalStore\r\n                        .getState()\r\n                        .stateComponents.get(stateKey);\r\n\r\n                    if (stateEntry) {\r\n                        const component =\r\n                            stateEntry.components.get(fullComponentId);\r\n\r\n                        if (component) {\r\n                            // Only add paths for non-root or specifically for get() at root\r\n                            if (path.length > 0 || prop === \"get\") {\r\n                                component.paths.add(currentPath);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if (Array.isArray(currentState)) {\r\n                    if (prop === \"getSelected\") {\r\n                        return () => {\r\n                            const selectedIndex = selectedIndexMap.get(\r\n                                path.join(\".\"),\r\n                            );\r\n                            if (selectedIndex === undefined) return undefined;\r\n                            return rebuildStateShape(\r\n                                currentState[selectedIndex],\r\n                                [...path, selectedIndex.toString()],\r\n                                meta,\r\n                            );\r\n                        };\r\n                    }\r\n\r\n                    if (prop === \"stateMap\" || prop === \"stateMapNoRender\") {\r\n                        return (\r\n                            callbackfn: (\r\n                                value: InferArrayElement<T>,\r\n                                setter: StateObject<InferArrayElement<T>>,\r\n                                index: number,\r\n                                array: T,\r\n                                arraySetter: StateObject<T>,\r\n                            ) => void,\r\n                        ) => {\r\n                            const isFiltered = meta?.filtered?.some(\r\n                                (p) => p.join(\".\") === path.join(\".\"),\r\n                            );\r\n                            const arrayToMap = isFiltered\r\n                                ? currentState\r\n                                : getGlobalStore\r\n                                      .getState()\r\n                                      .getNestedState(stateKey, path);\r\n\r\n                            if (prop !== \"stateMapNoRender\") {\r\n                                shapeCache.clear();\r\n                                stateVersion++;\r\n                            }\r\n\r\n                            return arrayToMap.map((val: any, index: number) => {\r\n                                const thisIndex =\r\n                                    isFiltered && val.__origIndex\r\n                                        ? val.__origIndex\r\n                                        : index;\r\n                                const elementProxy = rebuildStateShape(\r\n                                    val,\r\n                                    [...path, thisIndex.toString()],\r\n                                    meta,\r\n                                );\r\n                                return callbackfn(\r\n                                    val,\r\n                                    elementProxy,\r\n                                    index,\r\n                                    currentState as any,\r\n                                    rebuildStateShape(\r\n                                        currentState as any,\r\n                                        path,\r\n                                        meta,\r\n                                    ),\r\n                                );\r\n                            });\r\n                        };\r\n                    }\r\n                    if (prop === \"$stateMap\") {\r\n                        return (\r\n                            callbackfn: (\r\n                                value: InferArrayElement<T>,\r\n                                setter: StateObject<InferArrayElement<T>>,\r\n                                index: number,\r\n                                array: T,\r\n                                arraySetter: StateObject<T>,\r\n                            ) => void,\r\n                        ) => {\r\n                            return createElement(SignalMapRenderer, {\r\n                                proxy: {\r\n                                    _stateKey: stateKey,\r\n                                    _path: path,\r\n                                    _mapFn: callbackfn as any, // Pass the actual function, not string\r\n                                },\r\n                                effectiveSetState,\r\n                                componentId,\r\n                                rebuildStateShape,\r\n                            });\r\n                        };\r\n                    }\r\n                    if (prop === \"stateFlattenOn\") {\r\n                        return (fieldName: string) => {\r\n                            const isFiltered = meta?.filtered?.some(\r\n                                (p) => p.join(\".\") === path.join(\".\"),\r\n                            );\r\n                            const arrayToMap = isFiltered\r\n                                ? currentState\r\n                                : getGlobalStore\r\n                                      .getState()\r\n                                      .getNestedState(stateKey, path);\r\n\r\n                            // ADDED: Clear shape cache for flattening operation\r\n                            shapeCache.clear();\r\n                            stateVersion++;\r\n\r\n                            const flattenedResults = arrayToMap.flatMap(\r\n                                (val: any, index: number) => {\r\n                                    return val[fieldName] ?? [];\r\n                                },\r\n                            );\r\n\r\n                            return rebuildStateShape(\r\n                                flattenedResults,\r\n                                [...path, \"[*]\", fieldName],\r\n                                meta,\r\n                            );\r\n                        };\r\n                    }\r\n\r\n                    if (prop === \"findWith\") {\r\n                        return (\r\n                            thisKey: keyof InferArrayElement<T>,\r\n                            thisValue: InferArrayElement<T>[keyof InferArrayElement<T>],\r\n                        ) => {\r\n                            const foundIndex = currentState.findIndex(\r\n                                (obj: any) => obj[thisKey] === thisValue,\r\n                            );\r\n                            if (foundIndex === -1) return undefined;\r\n                            const foundValue = currentState[foundIndex];\r\n                            const newPath = [...path, foundIndex.toString()];\r\n                            // console.log(\r\n                            //     \"findWithfindWithfindWithfindWith\",\r\n                            //     stateKey,\r\n                            //     foundValue,\r\n                            //     newPath,\r\n                            // );\r\n                            shapeCache.clear();\r\n                            stateVersion++;\r\n\r\n                            // ADDED: Clear cache for find operation\r\n                            shapeCache.clear();\r\n                            stateVersion++;\r\n                            // Try returning without spread\r\n                            return rebuildStateShape(foundValue, newPath);\r\n                        };\r\n                    }\r\n\r\n                    if (prop === \"index\") {\r\n                        return (index: number) => {\r\n                            const indexValue = currentState[index];\r\n                            return rebuildStateShape(indexValue, [\r\n                                ...path,\r\n                                index.toString(),\r\n                            ]);\r\n                        };\r\n                    }\r\n\r\n                    if (prop === \"insert\") {\r\n                        return (payload: UpdateArg<T>) => {\r\n                            // ADDED: Invalidate cache on insert\r\n                            invalidateCachePath(path);\r\n                            pushFunc(\r\n                                effectiveSetState,\r\n                                payload,\r\n                                path,\r\n                                stateKey,\r\n                            );\r\n                            return rebuildStateShape(\r\n                                getGlobalStore.getState().cogsStateStore[\r\n                                    stateKey\r\n                                ],\r\n                                [],\r\n                            );\r\n                        };\r\n                    }\r\n\r\n                    if (prop === \"uniqueInsert\") {\r\n                        return (\r\n                            payload: UpdateArg<T>,\r\n                            fields?: (keyof InferArrayElement<T>)[],\r\n                            onMatch?: (existingItem: any) => any,\r\n                        ) => {\r\n                            const currentArray = getGlobalStore\r\n                                .getState()\r\n                                .getNestedState(stateKey, path) as any[];\r\n                            const newValue = isFunction<T>(payload)\r\n                                ? payload(currentArray as any)\r\n                                : (payload as any);\r\n\r\n                            let matchedItem: any = null;\r\n                            const isUnique = !currentArray.some((item) => {\r\n                                if (fields) {\r\n                                    const isMatch = fields.every((field) =>\r\n                                        isDeepEqual(\r\n                                            item[field],\r\n                                            newValue[field],\r\n                                        ),\r\n                                    );\r\n                                    if (isMatch) {\r\n                                        matchedItem = item;\r\n                                    }\r\n                                    return isMatch;\r\n                                }\r\n                                const isMatch = isDeepEqual(item, newValue);\r\n                                if (isMatch) {\r\n                                    matchedItem = item;\r\n                                }\r\n                                return isMatch;\r\n                            });\r\n\r\n                            if (isUnique) {\r\n                                invalidateCachePath(path);\r\n                                pushFunc(\r\n                                    effectiveSetState,\r\n                                    newValue,\r\n                                    path,\r\n                                    stateKey,\r\n                                );\r\n                            } else if (onMatch && matchedItem) {\r\n                                const updatedItem = onMatch(matchedItem);\r\n                                const updatedArray = currentArray.map((item) =>\r\n                                    isDeepEqual(item, matchedItem)\r\n                                        ? updatedItem\r\n                                        : item,\r\n                                );\r\n                                invalidateCachePath(path);\r\n                                updateFn(\r\n                                    effectiveSetState,\r\n                                    updatedArray as any,\r\n                                    path,\r\n                                );\r\n                            }\r\n                        };\r\n                    }\r\n\r\n                    if (prop === \"cut\") {\r\n                        return (\r\n                            index: number,\r\n                            options?: { waitForSync?: boolean },\r\n                        ) => {\r\n                            if (options?.waitForSync) return;\r\n                            // ADDED: Invalidate cache on cut\r\n                            invalidateCachePath(path);\r\n                            cutFunc(effectiveSetState, path, stateKey, index);\r\n                        };\r\n                    }\r\n\r\n                    if (prop === \"stateFilter\") {\r\n                        return (\r\n                            callbackfn: (\r\n                                value: InferArrayElement<T>,\r\n                                index: number,\r\n                            ) => boolean,\r\n                        ) => {\r\n                            const newVal = currentState.map(\r\n                                (v: any, i: number) => ({\r\n                                    ...v,\r\n                                    __origIndex: i.toString(),\r\n                                }),\r\n                            );\r\n\r\n                            const validIndices: number[] = [];\r\n                            const filteredArray: Array<InferArrayElement<T>> =\r\n                                [];\r\n\r\n                            for (let i = 0; i < newVal.length; i++) {\r\n                                if (callbackfn(newVal[i], i)) {\r\n                                    validIndices.push(i);\r\n                                    filteredArray.push(newVal[i]);\r\n                                }\r\n                            }\r\n\r\n                            // ADDED: Clear cache for filter operation\r\n                            shapeCache.clear();\r\n                            stateVersion++;\r\n                            return rebuildStateShape(\r\n                                filteredArray as any,\r\n                                path,\r\n                                {\r\n                                    filtered: [...(meta?.filtered || []), path],\r\n                                    validIndices, // Pass through the meta\r\n                                },\r\n                            );\r\n                        };\r\n                    }\r\n                }\r\n                const lastPathElement = path[path.length - 1];\r\n                if (!isNaN(Number(lastPathElement))) {\r\n                    const parentPath = path.slice(0, -1);\r\n                    const parentValue = getGlobalStore\r\n                        .getState()\r\n                        .getNestedState(stateKey, parentPath);\r\n\r\n                    if (Array.isArray(parentValue) && prop === \"cut\") {\r\n                        return () =>\r\n                            cutFunc(\r\n                                effectiveSetState,\r\n                                parentPath,\r\n                                stateKey,\r\n                                Number(lastPathElement),\r\n                            );\r\n                    }\r\n                }\r\n\r\n                if (prop === \"get\") {\r\n                    return () =>\r\n                        getGlobalStore\r\n                            .getState()\r\n                            .getNestedState(stateKey, path);\r\n                }\r\n                if (prop === \"$derive\") {\r\n                    return (fn: any) =>\r\n                        $cogsSignal({\r\n                            _stateKey: stateKey,\r\n                            _path: path,\r\n                            _effect: fn.toString(),\r\n                        });\r\n                }\r\n\r\n                if (prop === \"$derive\") {\r\n                    return (fn: any) =>\r\n                        $cogsSignal({\r\n                            _stateKey: stateKey,\r\n                            _path: path,\r\n                            _effect: fn.toString(),\r\n                        });\r\n                }\r\n\r\n                if (prop === \"$get\") {\r\n                    return () =>\r\n                        $cogsSignal({\r\n                            _stateKey: stateKey,\r\n                            _path: path,\r\n                        });\r\n                }\r\n                if (prop === \"lastSynced\") {\r\n                    const syncKey = `${stateKey}:${path.join(\".\")}`;\r\n                    return getGlobalStore.getState().getSyncInfo(syncKey);\r\n                }\r\n\r\n                if (prop === \"_selected\") {\r\n                    const parentPath = path.slice(0, -1);\r\n                    const parentKey = parentPath.join(\".\");\r\n                    const parent = getGlobalStore\r\n                        .getState()\r\n                        .getNestedState(stateKey, parentPath);\r\n                    if (Array.isArray(parent)) {\r\n                        const currentIndex = Number(path[path.length - 1]);\r\n                        return currentIndex === selectedIndexMap.get(parentKey);\r\n                    }\r\n                    return undefined;\r\n                }\r\n                if (prop == \"getLocalStorage\") {\r\n                    return (key: string) =>\r\n                        loadFromLocalStorage(\r\n                            sessionId + \"-\" + stateKey + \"-\" + key,\r\n                        );\r\n                }\r\n                if (prop === \"getComponents\") {\r\n                    return getGlobalStore().stateComponents.get(stateKey);\r\n                }\r\n                if (prop === \"setSelected\") {\r\n                    return (value: boolean) => {\r\n                        const parentPath = path.slice(0, -1);\r\n                        const thisIndex = Number(path[path.length - 1]);\r\n                        const parentKey = parentPath.join(\".\");\r\n                        if (value) {\r\n                            selectedIndexMap.set(parentKey, thisIndex);\r\n                        } else {\r\n                            // Optional: clear selection if false\r\n                            selectedIndexMap.delete(parentKey);\r\n                        }\r\n                        const nested = getGlobalStore\r\n                            .getState()\r\n                            .getNestedState(stateKey, [...parentPath]);\r\n                        updateFn(effectiveSetState, nested, parentPath);\r\n\r\n                        // ADDED: Invalidate cache for parent path\r\n                        invalidateCachePath(parentPath);\r\n                    };\r\n                }\r\n\r\n                if (path.length == 0) {\r\n                    if (prop == \"_componentId\") return componentId;\r\n                    if (prop === \"_initialState\")\r\n                        return getGlobalStore.getState().initialStateGlobal[\r\n                            stateKey\r\n                        ];\r\n                    if (prop === \"_serverState\")\r\n                        return getGlobalStore.getState().serverState[stateKey];\r\n                    if (prop === \"_isLoading\")\r\n                        return getGlobalStore.getState().isLoadingGlobal[\r\n                            stateKey\r\n                        ];\r\n                    if (prop === \"revertToInitialState\")\r\n                        return baseObj.revertToInitialState;\r\n                    if (prop === \"updateInitialState\")\r\n                        return baseObj.updateInitialState;\r\n                    if (prop === \"removeValidation\")\r\n                        return baseObj.removeValidation;\r\n                }\r\n\r\n                if (prop === \"validationWrapper\") {\r\n                    return ({\r\n                        children,\r\n                        hideMessage,\r\n                    }: {\r\n                        children: React.ReactNode;\r\n                        hideMessage?: boolean;\r\n                    }) => (\r\n                        <ValidationWrapper\r\n                            formOpts={\r\n                                hideMessage\r\n                                    ? { validation: { message: \"\" } }\r\n                                    : undefined\r\n                            }\r\n                            path={path}\r\n                            validationKey={\r\n                                getGlobalStore\r\n                                    .getState()\r\n                                    .getInitialOptions(stateKey)\r\n                                    ?.validationKey || \"\"\r\n                            }\r\n                            stateKey={stateKey}\r\n                            validIndices={meta?.validIndices}\r\n                        >\r\n                            {children}\r\n                        </ValidationWrapper>\r\n                    );\r\n                }\r\n\r\n                if (prop === \"_stateKey\") return stateKey;\r\n                if (prop === \"_path\") return path;\r\n                if (prop === \"_isServerSynced\") return baseObj._isServerSynced;\r\n\r\n                if (prop === \"update\") {\r\n                    return (payload: UpdateArg<T>, opts?: UpdateOpts<T>) => {\r\n                        // ADDED: Invalidate cache on update\r\n                        if (opts?.debounce) {\r\n                            debounce(() => {\r\n                                updateFn(effectiveSetState, payload, path, \"\");\r\n                                const newValue = getGlobalStore\r\n                                    .getState()\r\n                                    .getNestedState(stateKey, path);\r\n                                if (opts?.afterUpdate)\r\n                                    opts.afterUpdate(newValue);\r\n                            }, opts.debounce);\r\n                        } else {\r\n                            updateFn(effectiveSetState, payload, path, \"\");\r\n                            const newValue = getGlobalStore\r\n                                .getState()\r\n                                .getNestedState(stateKey, path);\r\n                            if (opts?.afterUpdate) opts.afterUpdate(newValue);\r\n                        }\r\n                        invalidateCachePath(path);\r\n                    };\r\n                }\r\n\r\n                if (prop === \"formElement\") {\r\n                    return (\r\n                        validationKey: string,\r\n                        child: FormControl<T>,\r\n                        formOpts?: FormOptsType,\r\n                    ) => {\r\n                        return (\r\n                            <FormControlComponent<T>\r\n                                setState={effectiveSetState}\r\n                                validationKey={validationKey}\r\n                                stateKey={stateKey}\r\n                                path={path}\r\n                                child={child}\r\n                                formOpts={formOpts}\r\n                            />\r\n                        );\r\n                    };\r\n                }\r\n\r\n                const nextPath = [...path, prop];\r\n                const nextValue = getGlobalStore\r\n                    .getState()\r\n                    .getNestedState(stateKey, nextPath);\r\n                return rebuildStateShape(nextValue, nextPath, meta);\r\n            },\r\n        };\r\n\r\n        const proxyInstance = new Proxy(baseObj as StateObject<T>, handler);\r\n\r\n        shapeCache.set(cacheKey, {\r\n            proxy: proxyInstance,\r\n            stateVersion: stateVersion,\r\n        });\r\n\r\n        return proxyInstance;\r\n    }\r\n\r\n    return rebuildStateShape(\r\n        getGlobalStore.getState().getNestedState(stateKey, []),\r\n    );\r\n}\r\n\r\nexport function $cogsSignal(proxy: {\r\n    _path: string[];\r\n    _stateKey: string;\r\n    _effect?: string;\r\n}) {\r\n    return createElement(SignalRenderer, { proxy });\r\n}\r\n\r\nfunction SignalMapRenderer({\r\n    proxy,\r\n    effectiveSetState,\r\n    componentId,\r\n    rebuildStateShape,\r\n}: {\r\n    proxy: {\r\n        _stateKey: string;\r\n        _path: string[];\r\n        _mapFn: (\r\n            value: any,\r\n            setter: any,\r\n            index: number,\r\n            array: any[],\r\n            arraySetter: any,\r\n        ) => ReactNode;\r\n    };\r\n    effectiveSetState: any;\r\n    componentId: string;\r\n    rebuildStateShape: (\r\n        currentState: any,\r\n        path: string[],\r\n        meta?: { filtered?: string[][]; validIndices?: number[] },\r\n    ) => any;\r\n}) {\r\n    const value = getGlobalStore().getNestedState(proxy._stateKey, proxy._path);\r\n    console.log(\"value\", value);\r\n    if (!Array.isArray(value)) {\r\n        return null;\r\n    }\r\n    const arraySetter = rebuildStateShape(\r\n        value,\r\n        proxy._path,\r\n    ) as ArrayEndType<any>;\r\n    // Use existing global state management\r\n    return arraySetter.stateMapNoRender(\r\n        (item, setter, index, value, arraysetter) => {\r\n            // Execute map function in React context with existing state/proxies\r\n            return proxy._mapFn(item, setter, index, value, arraysetter);\r\n        },\r\n    );\r\n}\r\nfunction SignalRenderer({\r\n    proxy,\r\n}: {\r\n    proxy: {\r\n        _path: string[];\r\n        _stateKey: string;\r\n        _effect?: string;\r\n    };\r\n}) {\r\n    const elementRef = useRef<HTMLSpanElement>(null);\r\n    const signalId = `${proxy._stateKey}-${proxy._path.join(\".\")}`;\r\n\r\n    useEffect(() => {\r\n        const element = elementRef.current;\r\n        if (!element || !element.parentElement) return;\r\n\r\n        const parentElement = element.parentElement;\r\n        const childNodes = Array.from(parentElement.childNodes);\r\n        const position = childNodes.indexOf(element);\r\n\r\n        let parentId = parentElement.getAttribute(\"data-parent-id\");\r\n        if (!parentId) {\r\n            parentId = `parent-${crypto.randomUUID()}`;\r\n            parentElement.setAttribute(\"data-parent-id\", parentId);\r\n        }\r\n\r\n        const instanceId = `instance-${crypto.randomUUID()}`;\r\n        const elementInfo = {\r\n            instanceId,\r\n            parentId,\r\n            position,\r\n            effect: proxy._effect,\r\n        };\r\n\r\n        getGlobalStore.getState().addSignalElement(signalId, elementInfo);\r\n\r\n        const value = getGlobalStore\r\n            .getState()\r\n            .getNestedState(proxy._stateKey, proxy._path);\r\n\r\n        const textNode = document.createTextNode(String(value));\r\n        element.replaceWith(textNode);\r\n    }, [proxy._stateKey, proxy._path.join(\".\"), proxy._effect]);\r\n\r\n    return createElement(\"span\", {\r\n        ref: elementRef,\r\n        style: { display: \"none\" },\r\n        \"data-signal-id\": signalId,\r\n    });\r\n}\r\nexport function $cogsSignalStore(proxy: {\r\n    _path: string[];\r\n    _stateKey: string;\r\n}) {\r\n    const value = useSyncExternalStore(\r\n        (notify) => {\r\n            const stateEntry = getGlobalStore\r\n                .getState()\r\n                .stateComponents.get(proxy._stateKey) || {\r\n                components: new Map(),\r\n            };\r\n            stateEntry.components.set(proxy._stateKey, {\r\n                forceUpdate: notify,\r\n                paths: new Set([proxy._path.join(\".\")]),\r\n            });\r\n            return () => stateEntry.components.delete(proxy._stateKey);\r\n        },\r\n        () =>\r\n            getGlobalStore\r\n                .getState()\r\n                .getNestedState(proxy._stateKey, proxy._path),\r\n    );\r\n    return createElement(\"text\", {}, String(value));\r\n}\r\n"],"names":["addStateOptions","initialState","formElements","zodSchema","setAndMergeOptions","stateKey","newOptions","getInitialOptions","getGlobalStore","setInitialStateOptions","initialOptions","setOptions","options","initialOptionsPart","initialOptionsPartState","mergedOptions","needToAdd","key","createCogsState","opts","newInitialState","statePart","transformStateFunc","useCogsState","componentId","useState","uuidv4","thiState","partialState","state","updater","useCogsStateFn","setCogsOptions","setUpdaterState","setState","getKeyState","getValidationErrors","setStateLog","updateInitialStateGlobal","addValidationError","removeValidationError","setServerSyncActions","loadFromLocalStorage","localStorageKey","storedData","error","saveToLocalStorage","thisKey","currentInitialOptions","sessionId","data","storageKey","updateGlobalState","newState","effectiveSetState","updates","createProxyHandler","startTransition","notifyComponents","stateEntry","component","update","stateObject","serverSync","localStorage","middleware","reactiveDeps","reactiveType","initState","syncUpdate","reactiveForce","forceUpdate","useCogsConfig","noStateKey","stateLog","componentUpdatesRef","useRef","componentIdRef","latestInitialOptionsRef","useEffect","prevState","syncKey","localData","useLayoutEffect","depsKey","newStateOrFunction","path","updateObj","validationKey","pathKey","prevValue","payload","isFunction","signalId","isArrayOperation","elements","arrayPath","arrayValue","getNestedValue","arraySignalId","newValue","parentId","position","effect","parent","childNodes","displayValue","arrayWithoutIndex","k","v","length","newKey","oldValue","pathToCheck","shouldUpdate","reactiveTypes","depsResult","isDeepEqual","newUpdate","prevLogs","aggregatedLogs","acc","log","uniqueKey","existing","serverStateStore","updaterFinal","useMemo","shapeCache","stateVersion","invalidateCachePath","selectedIndexMap","baseObj","obj","newProxy","rebuildStateShape","initalOptionsGet","newUpdaterState","field","serverState","currentState","meta","cacheKey","handler","target","prop","currentPath","fullComponentId","selectedIndex","callbackfn","isFiltered","p","arrayToMap","val","index","thisIndex","elementProxy","createElement","SignalMapRenderer","fieldName","flattenedResults","thisValue","foundIndex","foundValue","newPath","indexValue","pushFunc","fields","onMatch","currentArray","matchedItem","item","isMatch","updatedItem","updatedArray","updateFn","cutFunc","newVal","i","validIndices","filteredArray","lastPathElement","parentPath","parentValue","fn","$cogsSignal","parentKey","value","nested","children","hideMessage","jsx","ValidationWrapper","debounce","child","formOpts","FormControlComponent","nextPath","nextValue","proxyInstance","proxy","SignalRenderer","setter","arraysetter","elementRef","element","parentElement","elementInfo","textNode","$cogsSignalStore","useSyncExternalStore","notify"],"mappings":"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"}