{"version":3,"file":"CogsState.jsx","sources":["../src/CogsState.tsx"],"sourcesContent":["'use client';\r\n\r\nimport {\r\n  createElement,\r\n  memo,\r\n  startTransition,\r\n  useCallback,\r\n  useEffect,\r\n  useLayoutEffect,\r\n  useMemo,\r\n  useRef,\r\n  useState,\r\n  type CSSProperties,\r\n  type ReactNode,\r\n  type RefObject,\r\n} from 'react';\r\nimport { createRoot } from 'react-dom/client';\r\nimport {\r\n  debounce,\r\n  getDifferences,\r\n  isArray,\r\n  isFunction,\r\n  type GenericObject,\r\n} from './utility.js';\r\nimport { ValidationWrapper } from './Functions.js';\r\nimport { isDeepEqual, transformStateFunc } from './utility.js';\r\nimport superjson from 'superjson';\r\nimport { v4 as uuidv4 } from 'uuid';\r\nimport { z } from 'zod';\r\n\r\nimport { formRefStore, getGlobalStore, type ComponentsType } from './store.js';\r\nimport { useCogsConfig } from './CogsStateClient.js';\r\nimport { applyPatch } from 'fast-json-patch';\r\nimport { useInView } from 'react-intersection-observer';\r\n\r\ntype Prettify<T> = T extends any ? { [K in keyof T]: T[K] } : never;\r\n\r\nexport type VirtualViewOptions = {\r\n  itemHeight?: number;\r\n  overscan?: number;\r\n  stickToBottom?: boolean;\r\n  dependencies?: any[];\r\n  scrollStickTolerance?: number;\r\n};\r\n\r\n// The result now returns a real StateObject\r\nexport type VirtualStateObjectResult<T extends any[]> = {\r\n  /**\r\n   * A new, fully-functional StateObject that represents the virtualized slice.\r\n   * You can use `.get()`, `.stateMap()`, `.insert()`, `.cut()` etc. on this object.\r\n   */\r\n\r\n  virtualState: StateObject<T>;\r\n  /**\r\n   * Props to be spread onto your DOM elements to enable virtualization.\r\n   */\r\n  virtualizerProps: {\r\n    outer: { ref: RefObject<HTMLDivElement>; style: CSSProperties };\r\n    inner: { style: CSSProperties };\r\n    list: { style: CSSProperties };\r\n  };\r\n  scrollToBottom: (behavior?: ScrollBehavior) => void;\r\n  scrollToIndex: (index: number, behavior?: ScrollBehavior) => void;\r\n};\r\n\r\nexport type SyncInfo = {\r\n  timeStamp: number;\r\n  userId: number;\r\n};\r\n\r\nexport type FormElementParams<T> = StateObject<T> & {\r\n  inputProps: {\r\n    ref?: React.RefObject<any>;\r\n    value?: T extends boolean ? never : T;\r\n    onChange?: (\r\n      event: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>\r\n    ) => void;\r\n    onBlur?: () => void;\r\n  };\r\n};\r\n\r\nexport type StateKeys = string;\r\n\r\ntype findWithFuncType<U> = (\r\n  thisKey: keyof U,\r\n  thisValue: U[keyof U]\r\n) => EndType<U> & StateObject<U>;\r\n\r\ntype CutFunctionType<T> = (\r\n  index?: number,\r\n  options?: { waitForSync?: boolean }\r\n) => StateObject<T>;\r\n\r\nexport type InferArrayElement<T> = T extends (infer U)[] ? U : never;\r\ntype ArraySpecificPrototypeKeys =\r\n  | 'concat'\r\n  | 'copyWithin'\r\n  | 'fill'\r\n  | 'find'\r\n  | 'findIndex'\r\n  | 'flat'\r\n  | 'flatMap'\r\n  | 'includes'\r\n  | 'indexOf'\r\n  | 'join'\r\n  | 'keys'\r\n  | 'lastIndexOf'\r\n  | 'map'\r\n  | 'pop'\r\n  | 'push'\r\n  | 'reduce'\r\n  | 'reduceRight'\r\n  | 'reverse'\r\n  | 'shift'\r\n  | 'slice'\r\n  | 'some'\r\n  | 'sort'\r\n  | 'splice'\r\n  | 'unshift'\r\n  | 'values'\r\n  | 'entries'\r\n  | 'every'\r\n  | 'filter'\r\n  | 'forEach'\r\n  | 'with';\r\nexport type StreamOptions<T, R = T> = {\r\n  bufferSize?: number;\r\n  flushInterval?: number;\r\n  bufferStrategy?: 'sliding' | 'dropping' | 'accumulate';\r\n  store?: (buffer: T[]) => R | R[];\r\n  onFlush?: (buffer: T[]) => void;\r\n};\r\n\r\nexport type StreamHandle<T> = {\r\n  write: (data: T) => void;\r\n  writeMany: (data: T[]) => void;\r\n  flush: () => void;\r\n  close: () => void;\r\n  pause: () => void;\r\n  resume: () => void;\r\n};\r\nexport type ArrayEndType<TShape extends unknown> = {\r\n  stream: <T = Prettify<InferArrayElement<TShape>>, R = T>(\r\n    options?: StreamOptions<T, R>\r\n  ) => StreamHandle<T>;\r\n  findWith: findWithFuncType<Prettify<InferArrayElement<TShape>>>;\r\n  index: (index: number) => StateObject<Prettify<InferArrayElement<TShape>>> & {\r\n    insert: InsertTypeObj<Prettify<InferArrayElement<TShape>>>;\r\n    cut: CutFunctionType<TShape>;\r\n    _index: number;\r\n  } & EndType<Prettify<InferArrayElement<TShape>>>;\r\n  insert: InsertType<Prettify<InferArrayElement<TShape>>>;\r\n  cut: CutFunctionType<TShape>;\r\n  cutSelected: () => void;\r\n  cutByValue: (value: string | number | boolean) => void;\r\n  toggleByValue: (value: string | number | boolean) => void;\r\n  stateSort: (\r\n    compareFn: (\r\n      a: Prettify<InferArrayElement<TShape>>,\r\n      b: Prettify<InferArrayElement<TShape>>\r\n    ) => number\r\n  ) => ArrayEndType<TShape>;\r\n  useVirtualView: (\r\n    options: VirtualViewOptions\r\n  ) => VirtualStateObjectResult<Prettify<InferArrayElement<TShape>>[]>;\r\n\r\n  stateList: (\r\n    callbackfn: (\r\n      setter: StateObject<Prettify<InferArrayElement<TShape>>>,\r\n      index: number,\r\n      arraySetter: StateObject<TShape>\r\n    ) => void\r\n  ) => any;\r\n  stateMap: <U>(\r\n    callbackfn: (\r\n      setter: StateObject<Prettify<InferArrayElement<TShape>>>,\r\n      index: number,\r\n      arraySetter: StateObject<TShape>\r\n    ) => U\r\n  ) => U[];\r\n  $stateMap: (\r\n    callbackfn: (\r\n      setter: StateObject<Prettify<InferArrayElement<TShape>>>,\r\n      index: number,\r\n      arraySetter: StateObject<TShape>\r\n    ) => void\r\n  ) => any;\r\n  stateFlattenOn: <K extends keyof Prettify<InferArrayElement<TShape>>>(\r\n    field: K\r\n  ) => StateObject<InferArrayElement<Prettify<InferArrayElement<TShape>>[K]>[]>;\r\n  uniqueInsert: (\r\n    payload: InsertParams<Prettify<InferArrayElement<TShape>>>,\r\n    fields?: (keyof Prettify<InferArrayElement<TShape>>)[],\r\n    onMatch?: (existingItem: any) => any\r\n  ) => void;\r\n  stateFind: (\r\n    callbackfn: (\r\n      value: Prettify<InferArrayElement<TShape>>,\r\n      index: number\r\n    ) => boolean\r\n  ) => StateObject<Prettify<InferArrayElement<TShape>>> | undefined;\r\n  stateFilter: (\r\n    callbackfn: (\r\n      value: Prettify<InferArrayElement<TShape>>,\r\n      index: number\r\n    ) => void\r\n  ) => ArrayEndType<TShape>;\r\n  getSelected: () =>\r\n    | StateObject<Prettify<InferArrayElement<TShape>>>\r\n    | undefined;\r\n  clearSelected: () => void;\r\n  getSelectedIndex: () => number;\r\n  last: () => StateObject<Prettify<InferArrayElement<TShape>>> | undefined;\r\n} & EndType<TShape>;\r\n\r\nexport type FormOptsType = {\r\n  validation?: {\r\n    hideMessage?: boolean;\r\n    message?: string;\r\n    stretch?: boolean;\r\n    props?: GenericObject;\r\n    disable?: boolean;\r\n  };\r\n\r\n  debounceTime?: number;\r\n};\r\n\r\nexport type FormControl<T> = (obj: FormElementParams<T>) => JSX.Element;\r\n\r\nexport type UpdateArg<S> = S | ((prevState: S) => S);\r\nexport type InsertParams<S> =\r\n  | S\r\n  | ((prevState: { state: S; uuid: string }) => S);\r\nexport type UpdateType<T> = (payload: UpdateArg<T>) => void;\r\n\r\nexport type InsertType<T> = (payload: InsertParams<T>, index?: number) => void;\r\nexport type InsertTypeObj<T> = (payload: InsertParams<T>) => void;\r\nexport type ValidationError = {\r\n  path: (string | number)[];\r\n  message: string;\r\n};\r\ntype EffectFunction<T, R> = (state: T, deps: any[]) => R;\r\nexport type EndType<T, IsArrayElement = false> = {\r\n  addValidation: (errors: ValidationError[]) => void;\r\n  applyJsonPatch: (patches: any[]) => void;\r\n  update: UpdateType<T>;\r\n  _path: string[];\r\n  _stateKey: string;\r\n  formElement: (control: FormControl<T>, opts?: FormOptsType) => JSX.Element;\r\n  get: () => T;\r\n  $get: () => T;\r\n  $derive: <R>(fn: EffectFunction<T, R>) => R;\r\n\r\n  _status: 'fresh' | 'dirty' | 'synced' | 'restored' | 'unknown';\r\n  getStatus: () => 'fresh' | 'dirty' | 'synced' | 'restored' | 'unknown';\r\n\r\n  showValidationErrors: () => string[];\r\n  setValidation: (ctx: string) => void;\r\n  removeValidation: (ctx: string) => void;\r\n  ignoreFields: (fields: string[]) => StateObject<T>;\r\n  isSelected: boolean;\r\n  setSelected: (value: boolean) => void;\r\n  toggleSelected: () => void;\r\n  getFormRef: () => React.RefObject<any> | undefined;\r\n  removeStorage: () => void;\r\n  sync: () => void;\r\n  validationWrapper: ({\r\n    children,\r\n    hideMessage,\r\n  }: {\r\n    children: React.ReactNode;\r\n    hideMessage?: boolean;\r\n  }) => JSX.Element;\r\n  lastSynced?: SyncInfo;\r\n} & (IsArrayElement extends true ? { cut: () => void } : {});\r\n\r\nexport type StateObject<T> = (T extends any[]\r\n  ? ArrayEndType<T>\r\n  : T extends Record<string, unknown> | object\r\n    ? { [K in keyof T]-?: StateObject<T[K]> }\r\n    : T extends string | number | boolean | null\r\n      ? EndType<T, true>\r\n      : never) &\r\n  EndType<T, true> & {\r\n    toggle: T extends boolean ? () => void : never;\r\n    getAllFormRefs: () => Map<string, React.RefObject<any>>;\r\n    _componentId: string | null;\r\n    getComponents: () => ComponentsType;\r\n    validateZodSchema: () => void;\r\n    _initialState: T;\r\n    updateInitialState: (newState: T | null) => {\r\n      fetchId: (field: keyof T) => string | number;\r\n    };\r\n    _isLoading: boolean;\r\n    _serverState: T;\r\n    revertToInitialState: (obj?: { validationKey?: string }) => T;\r\n    getDifferences: () => string[];\r\n    middleware: (\r\n      middles: ({\r\n        updateLog,\r\n        update,\r\n      }: {\r\n        updateLog: UpdateTypeDetail[] | undefined;\r\n        update: UpdateTypeDetail;\r\n      }) => void\r\n    ) => void;\r\n\r\n    getLocalStorage: (key: string) => LocalStorageData<T> | null;\r\n  };\r\n\r\nexport type CogsUpdate<T extends unknown> = UpdateType<T>;\r\ntype EffectiveSetStateArg<\r\n  T,\r\n  UpdateType extends 'update' | 'insert' | 'cut',\r\n> = UpdateType extends 'insert'\r\n  ? T extends any[]\r\n    ? InsertParams<InferArrayElement<T>>\r\n    : never\r\n  : UpdateArg<T>;\r\n\r\ntype EffectiveSetState<TStateObject> = (\r\n  newStateOrFunction:\r\n    | EffectiveSetStateArg<TStateObject, 'update'>\r\n    | EffectiveSetStateArg<TStateObject, 'insert'>,\r\n  path: string[],\r\n  updateObj: { updateType: 'update' | 'insert' | 'cut' },\r\n  validationKey?: string\r\n) => void;\r\n\r\nexport type UpdateTypeDetail = {\r\n  timeStamp: number;\r\n  stateKey: string;\r\n  updateType: 'update' | 'insert' | 'cut';\r\n  path: string[];\r\n  status: 'new' | 'sent' | 'synced';\r\n  oldValue: any;\r\n  newValue: any;\r\n  userId?: number;\r\n};\r\n\r\nexport type ReactivityUnion = 'none' | 'component' | 'deps' | 'all';\r\nexport type ReactivityType =\r\n  | 'none'\r\n  | 'component'\r\n  | 'deps'\r\n  | 'all'\r\n  | Array<Prettify<'none' | 'component' | 'deps' | 'all'>>;\r\n\r\ntype ValidationOptionsType = {\r\n  key?: string;\r\n  zodSchema?: z.ZodTypeAny;\r\n  onBlur?: boolean;\r\n};\r\n\r\nexport type OptionsType<T extends unknown = unknown> = {\r\n  log?: boolean;\r\n  componentId?: string;\r\n  serverSync?: ServerSyncType<T>;\r\n  validation?: ValidationOptionsType;\r\n\r\n  serverState?: {\r\n    id?: string | number;\r\n    data?: T;\r\n    status?: 'pending' | 'error' | 'success' | 'loading';\r\n    timestamp?: number;\r\n    merge?:\r\n      | boolean\r\n      | {\r\n          strategy: 'append' | 'prepend' | 'diff';\r\n          key?: string; // For diff strategy - which field to use as unique identifier\r\n        };\r\n  };\r\n  sync?: {\r\n    action: (state: T) => Promise<{\r\n      success: boolean;\r\n      data?: any;\r\n      error?: any;\r\n      errors?: Array<{\r\n        path: (string | number)[];\r\n        message: string;\r\n      }>;\r\n    }>;\r\n    onSuccess?: (data: any) => void;\r\n    onError?: (error: any) => void;\r\n  };\r\n  middleware?: ({\r\n    updateLog,\r\n    update,\r\n  }: {\r\n    updateLog: UpdateTypeDetail[] | undefined;\r\n    update: UpdateTypeDetail;\r\n  }) => void;\r\n\r\n  modifyState?: (state: T) => T;\r\n  localStorage?: {\r\n    key: string | ((state: T) => string);\r\n    onChange?: (state: T) => void;\r\n  };\r\n  formElements?: FormsElementsType;\r\n\r\n  reactiveDeps?: (state: T) => any[] | true;\r\n  reactiveType?: ReactivityType;\r\n  syncUpdate?: Partial<UpdateTypeDetail>;\r\n\r\n  defaultState?: T;\r\n  dependencies?: any[];\r\n};\r\nexport type ServerSyncType<T> = {\r\n  testKey?: string;\r\n  syncKey: (({ state }: { state: T }) => string) | string;\r\n  syncFunction: ({ state }: { state: T }) => void;\r\n  debounce?: number;\r\n\r\n  snapshot?: {\r\n    name: (({ state }: { state: T }) => string) | string;\r\n    stateKeys: StateKeys[];\r\n    currentUrl: string;\r\n    currentParams?: URLSearchParams;\r\n  };\r\n};\r\n\r\nexport type ValidationWrapperOptions<T extends unknown = unknown> = {\r\n  children: React.ReactNode;\r\n  active: boolean;\r\n  stretch?: boolean;\r\n  path: string[];\r\n  message?: string;\r\n  data?: T;\r\n  key?: string;\r\n};\r\nexport type SyncRenderOptions<T extends unknown = unknown> = {\r\n  children: React.ReactNode;\r\n  time: number;\r\n  data?: T;\r\n  key?: string;\r\n};\r\n\r\ntype FormsElementsType<T extends unknown = unknown> = {\r\n  validation?: (options: ValidationWrapperOptions<T>) => React.ReactNode;\r\n  syncRender?: (options: SyncRenderOptions<T>) => React.ReactNode;\r\n};\r\n\r\nexport type InitialStateInnerType<T extends unknown = unknown> = {\r\n  initialState: T;\r\n} & OptionsType<T>;\r\n\r\nexport type InitialStateType<T> = {\r\n  [key: string]: InitialStateInnerType<T>;\r\n};\r\n\r\nexport type AllStateTypes<T extends unknown> = Record<string, T>;\r\n\r\nexport type CogsInitialState<T> = {\r\n  initialState: T;\r\n  formElements?: FormsElementsType<T>;\r\n};\r\n\r\nexport type TransformedStateType<T> = {\r\n  [P in keyof T]: T[P] extends CogsInitialState<infer U> ? U : T[P];\r\n};\r\n\r\nfunction setAndMergeOptions(stateKey: string, newOptions: OptionsType<any>) {\r\n  const getInitialOptions = getGlobalStore.getState().getInitialOptions;\r\n  const setInitialStateOptions =\r\n    getGlobalStore.getState().setInitialStateOptions;\r\n\r\n  const initialOptions = getInitialOptions(stateKey as string) || {};\r\n\r\n  setInitialStateOptions(stateKey as string, {\r\n    ...initialOptions,\r\n    ...newOptions,\r\n  });\r\n}\r\n\r\nfunction setOptions<StateKey, Opt>({\r\n  stateKey,\r\n  options,\r\n  initialOptionsPart,\r\n}: {\r\n  stateKey: StateKey;\r\n  options?: OptionsType<any>;\r\n  initialOptionsPart: Record<string, any>;\r\n}) {\r\n  const initialOptions = getInitialOptions(stateKey as string) || {};\r\n  const initialOptionsPartState = initialOptionsPart[stateKey as string] || {};\r\n  const setInitialStateOptions =\r\n    getGlobalStore.getState().setInitialStateOptions;\r\n  const mergedOptions = { ...initialOptionsPartState, ...initialOptions };\r\n\r\n  let needToAdd = false;\r\n  if (options) {\r\n    for (const key in options) {\r\n      if (!mergedOptions.hasOwnProperty(key)) {\r\n        needToAdd = true;\r\n        mergedOptions[key] = options[key as keyof typeof options];\r\n      } else {\r\n        if (\r\n          key == 'localStorage' &&\r\n          options[key] &&\r\n          mergedOptions[key].key !== options[key]?.key\r\n        ) {\r\n          needToAdd = true;\r\n          mergedOptions[key] = options[key];\r\n        }\r\n        if (\r\n          key == 'defaultState' &&\r\n          options[key] &&\r\n          mergedOptions[key] !== options[key] &&\r\n          !isDeepEqual(mergedOptions[key], options[key])\r\n        ) {\r\n          needToAdd = true;\r\n          mergedOptions[key] = options[key];\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  if (needToAdd) {\r\n    setInitialStateOptions(stateKey as string, mergedOptions);\r\n  }\r\n}\r\nexport function addStateOptions<T extends unknown>(\r\n  initialState: T,\r\n  { formElements, validation }: OptionsType<T>\r\n) {\r\n  return { initialState: initialState, formElements, validation } as T;\r\n}\r\nexport const createCogsState = <State extends Record<StateKeys, unknown>>(\r\n  initialState: State,\r\n  opt?: { formElements?: FormsElementsType; validation?: ValidationOptionsType }\r\n) => {\r\n  let newInitialState = initialState;\r\n\r\n  const [statePart, initialOptionsPart] =\r\n    transformStateFunc<State>(newInitialState);\r\n\r\n  Object.keys(statePart).forEach((key) => {\r\n    let existingOptions = initialOptionsPart[key] || {};\r\n\r\n    const mergedOptions: any = {\r\n      ...existingOptions,\r\n    };\r\n\r\n    if (opt?.formElements) {\r\n      mergedOptions.formElements = {\r\n        ...opt.formElements,\r\n        ...(existingOptions.formElements || {}),\r\n      };\r\n    }\r\n\r\n    if (opt?.validation) {\r\n      mergedOptions.validation = {\r\n        ...opt.validation,\r\n        ...(existingOptions.validation || {}),\r\n      };\r\n\r\n      if (opt.validation.key && !existingOptions.validation?.key) {\r\n        mergedOptions.validation.key = `${opt.validation.key}.${key}`;\r\n      }\r\n    }\r\n\r\n    if (Object.keys(mergedOptions).length > 0) {\r\n      const existingGlobalOptions = getInitialOptions(key);\r\n\r\n      if (!existingGlobalOptions) {\r\n        getGlobalStore.getState().setInitialStateOptions(key, mergedOptions);\r\n      } else {\r\n        // Merge with existing global options\r\n        getGlobalStore.getState().setInitialStateOptions(key, {\r\n          ...existingGlobalOptions,\r\n          ...mergedOptions,\r\n        });\r\n      }\r\n    }\r\n  });\r\n\r\n  Object.keys(statePart).forEach((key) => {\r\n    getGlobalStore.getState().initializeShadowState(key, statePart[key]);\r\n  });\r\n\r\n  type StateKeys = keyof typeof statePart;\r\n\r\n  const useCogsState = <StateKey extends StateKeys>(\r\n    stateKey: StateKey,\r\n    options?: OptionsType<(typeof statePart)[StateKey]>\r\n  ) => {\r\n    const [componentId] = useState(options?.componentId ?? uuidv4());\r\n    setOptions({\r\n      stateKey,\r\n      options,\r\n      initialOptionsPart,\r\n    });\r\n\r\n    const thiState =\r\n      getGlobalStore.getState().getShadowValue(stateKey as string) ||\r\n      statePart[stateKey as string];\r\n    const partialState = options?.modifyState\r\n      ? options.modifyState(thiState)\r\n      : thiState;\r\n\r\n    const updater = useCogsStateFn<(typeof statePart)[StateKey]>(partialState, {\r\n      stateKey: stateKey as string,\r\n      syncUpdate: options?.syncUpdate,\r\n      componentId,\r\n      localStorage: options?.localStorage,\r\n      middleware: options?.middleware,\r\n\r\n      reactiveType: options?.reactiveType,\r\n      reactiveDeps: options?.reactiveDeps,\r\n      defaultState: options?.defaultState as any,\r\n      dependencies: options?.dependencies,\r\n      serverState: options?.serverState,\r\n    });\r\n\r\n    return updater;\r\n  };\r\n\r\n  function setCogsOptions<StateKey extends StateKeys>(\r\n    stateKey: StateKey,\r\n    options: OptionsType<(typeof statePart)[StateKey]>\r\n  ) {\r\n    setOptions({ stateKey, options, initialOptionsPart });\r\n\r\n    if (options.localStorage) {\r\n      loadAndApplyLocalStorage(stateKey as string, options);\r\n    }\r\n\r\n    notifyComponents(stateKey as string);\r\n  }\r\n\r\n  return { useCogsState, setCogsOptions };\r\n};\r\n\r\nconst {\r\n  getInitialOptions,\r\n  getValidationErrors,\r\n  setStateLog,\r\n  updateInitialStateGlobal,\r\n  addValidationError,\r\n  removeValidationError,\r\n} = getGlobalStore.getState();\r\nconst saveToLocalStorage = <T,>(\r\n  state: T,\r\n  thisKey: string,\r\n  currentInitialOptions: any,\r\n  sessionId?: string,\r\n  lastSyncedWithServer?: number\r\n) => {\r\n  if (currentInitialOptions?.log) {\r\n    console.log(\r\n      'saving to localstorage',\r\n      thisKey,\r\n      currentInitialOptions.localStorage?.key,\r\n      sessionId\r\n    );\r\n  }\r\n\r\n  const key = isFunction(currentInitialOptions?.localStorage?.key)\r\n    ? currentInitialOptions.localStorage?.key(state)\r\n    : currentInitialOptions?.localStorage?.key;\r\n\r\n  if (key && sessionId) {\r\n    const storageKey = `${sessionId}-${thisKey}-${key}`;\r\n\r\n    // Get existing data to preserve lastSyncedWithServer if not explicitly updating it\r\n    let existingLastSynced: number | undefined;\r\n    try {\r\n      const existing = loadFromLocalStorage(storageKey);\r\n      existingLastSynced = existing?.lastSyncedWithServer;\r\n    } catch {\r\n      // Ignore errors, will use undefined\r\n    }\r\n    const shadowMeta = getGlobalStore.getState().getShadowMetadata(thisKey, []);\r\n\r\n    const data: LocalStorageData<T> = {\r\n      state,\r\n      lastUpdated: Date.now(),\r\n      lastSyncedWithServer: lastSyncedWithServer ?? existingLastSynced,\r\n      stateSource: shadowMeta?.stateSource,\r\n      baseServerState: shadowMeta?.baseServerState,\r\n    };\r\n\r\n    // Use SuperJSON serialize to get the json part only\r\n    const superJsonResult = superjson.serialize(data);\r\n    window.localStorage.setItem(\r\n      storageKey,\r\n      JSON.stringify(superJsonResult.json)\r\n    );\r\n  }\r\n};\r\n\r\nconst loadFromLocalStorage = (localStorageKey: string) => {\r\n  if (!localStorageKey) return null;\r\n\r\n  try {\r\n    const storedData = window.localStorage.getItem(localStorageKey);\r\n    if (!storedData) return null;\r\n\r\n    // Parse the json part back normally\r\n    const parsedData = JSON.parse(storedData);\r\n\r\n    return parsedData;\r\n  } catch (error) {\r\n    console.error('Error loading from localStorage:', error);\r\n    return null;\r\n  }\r\n};\r\nconst loadAndApplyLocalStorage = (stateKey: string, options: any) => {\r\n  const currentState = getGlobalStore.getState().getShadowValue(stateKey);\r\n  const { sessionId } = useCogsConfig();\r\n  const localkey = isFunction(options?.localStorage?.key)\r\n    ? options.localStorage.key(currentState)\r\n    : options?.localStorage?.key;\r\n\r\n  if (localkey && sessionId) {\r\n    const localData = loadFromLocalStorage(\r\n      `${sessionId}-${stateKey}-${localkey}`\r\n    );\r\n\r\n    if (\r\n      localData &&\r\n      localData.lastUpdated > (localData.lastSyncedWithServer || 0)\r\n    ) {\r\n      notifyComponents(stateKey);\r\n      return true;\r\n    }\r\n  }\r\n  return false;\r\n};\r\n\r\ntype LocalStorageData<T> = {\r\n  state: T;\r\n  lastUpdated: number;\r\n  lastSyncedWithServer?: number;\r\n  baseServerState?: T; // Keep reference to what server state this is based on\r\n  stateSource?: 'default' | 'server' | 'localStorage'; // Track origin\r\n};\r\n\r\nconst notifyComponents = (thisKey: string) => {\r\n  const stateEntry = getGlobalStore.getState().getShadowMetadata(thisKey, []);\r\n  if (!stateEntry) return;\r\n\r\n  // Batch component updates\r\n  const updates = new Set<() => void>();\r\n  stateEntry?.components?.forEach((component) => {\r\n    const reactiveTypes = component\r\n      ? Array.isArray(component.reactiveType)\r\n        ? component.reactiveType\r\n        : [component.reactiveType || 'component']\r\n      : null;\r\n    if (!reactiveTypes?.includes('none')) {\r\n      updates.add(() => component.forceUpdate());\r\n    }\r\n  });\r\n\r\n  // Schedule updates in the next tick to allow batching\r\n  queueMicrotask(() => {\r\n    updates.forEach((update) => update());\r\n  });\r\n};\r\n\r\nexport const notifyComponent = (stateKey: string, componentId: string) => {\r\n  const stateEntry = getGlobalStore.getState().getShadowMetadata(stateKey, []);\r\n  if (stateEntry) {\r\n    const fullComponentId = `${stateKey}////${componentId}`;\r\n    const component = stateEntry?.components?.get(fullComponentId);\r\n    const reactiveTypes = component\r\n      ? Array.isArray(component.reactiveType)\r\n        ? component.reactiveType\r\n        : [component.reactiveType || 'component']\r\n      : null;\r\n\r\n    // Skip if reactivity is disabled\r\n    if (reactiveTypes?.includes('none')) {\r\n      return;\r\n    }\r\n\r\n    if (component) {\r\n      // Force an update to ensure the current value is saved\r\n\r\n      component.forceUpdate();\r\n    }\r\n  }\r\n};\r\n\r\nexport function useCogsStateFn<TStateObject extends unknown>(\r\n  stateObject: TStateObject,\r\n  {\r\n    stateKey,\r\n    serverSync,\r\n    localStorage,\r\n    formElements,\r\n    reactiveDeps,\r\n    reactiveType,\r\n    componentId,\r\n    defaultState,\r\n    syncUpdate,\r\n    dependencies,\r\n    serverState,\r\n  }: {\r\n    stateKey?: string;\r\n    componentId?: string;\r\n    defaultState?: TStateObject;\r\n  } & OptionsType<TStateObject> = {}\r\n) {\r\n  const [reactiveForce, forceUpdate] = useState({}); //this is the key to reactivity\r\n  const { sessionId } = useCogsConfig();\r\n\r\n  let noStateKey = stateKey ? false : true;\r\n  const [thisKey] = useState(stateKey ?? uuidv4());\r\n  const stateLog = getGlobalStore.getState().stateLog[thisKey];\r\n  const componentUpdatesRef = useRef(new Set<string>());\r\n  const componentIdRef = useRef(componentId ?? uuidv4());\r\n  const latestInitialOptionsRef = useRef<OptionsType<TStateObject> | null>(\r\n    null\r\n  );\r\n  latestInitialOptionsRef.current = (getInitialOptions(thisKey as string) ??\r\n    null) as OptionsType<TStateObject> | null;\r\n\r\n  useEffect(() => {\r\n    if (syncUpdate && syncUpdate.stateKey === thisKey && syncUpdate.path?.[0]) {\r\n      // Update the actual state value\r\n\r\n      // Create combined key and update sync info\r\n      const syncKey = `${syncUpdate.stateKey}:${syncUpdate.path.join('.')}`;\r\n      getGlobalStore.getState().setSyncInfo(syncKey, {\r\n        timeStamp: syncUpdate.timeStamp!,\r\n        userId: syncUpdate.userId!,\r\n      });\r\n    }\r\n  }, [syncUpdate]);\r\n\r\n  const resolveInitialState = useCallback(\r\n    (\r\n      overrideOptions?: OptionsType<TStateObject>\r\n    ): {\r\n      value: TStateObject;\r\n      source: 'default' | 'server' | 'localStorage';\r\n      timestamp: number;\r\n    } => {\r\n      // If we pass in options, use them. Otherwise, get from the global store.\r\n      const optionsToUse = overrideOptions\r\n        ? { ...getInitialOptions(thisKey as string), ...overrideOptions }\r\n        : getInitialOptions(thisKey as string);\r\n\r\n      const currentOptions = optionsToUse;\r\n      const finalDefaultState =\r\n        currentOptions?.defaultState || defaultState || stateObject;\r\n\r\n      // 1. Check server state\r\n      const hasValidServerData =\r\n        currentOptions?.serverState?.status === 'success' &&\r\n        currentOptions?.serverState?.data !== undefined;\r\n\r\n      if (hasValidServerData) {\r\n        return {\r\n          value: currentOptions.serverState!.data! as any,\r\n          source: 'server',\r\n          timestamp: currentOptions.serverState!.timestamp || Date.now(),\r\n        };\r\n      }\r\n      // 2. Check localStorage\r\n      if (currentOptions?.localStorage?.key && sessionId) {\r\n        const localKey = isFunction(currentOptions.localStorage.key)\r\n          ? currentOptions.localStorage.key(finalDefaultState)\r\n          : currentOptions.localStorage.key;\r\n\r\n        const localData = loadFromLocalStorage(\r\n          `${sessionId}-${thisKey}-${localKey}`\r\n        );\r\n\r\n        if (\r\n          localData &&\r\n          localData.lastUpdated > (currentOptions?.serverState?.timestamp || 0)\r\n        ) {\r\n          return {\r\n            value: localData.state,\r\n            source: 'localStorage',\r\n            timestamp: localData.lastUpdated,\r\n          };\r\n        }\r\n      }\r\n\r\n      // 3. Use default state\r\n      return {\r\n        value: finalDefaultState || (stateObject as any),\r\n        source: 'default',\r\n        timestamp: Date.now(),\r\n      };\r\n    },\r\n    [thisKey, defaultState, stateObject, sessionId]\r\n  );\r\n\r\n  // Effect 1: When this component's serverState prop changes, broadcast it\r\n  useEffect(() => {\r\n    getGlobalStore.getState().setServerStateUpdate(thisKey, serverState);\r\n  }, [serverState, thisKey]);\r\n\r\n  // Effect 2: Listen for server state updates from ANY component\r\n  useEffect(() => {\r\n    const unsubscribe = getGlobalStore\r\n      .getState()\r\n      .subscribeToPath(thisKey, (event) => {\r\n        // REPLACEMENT STARTS HERE\r\n        if (event?.type === 'SERVER_STATE_UPDATE') {\r\n          const serverStateData = event.serverState;\r\n\r\n          if (\r\n            serverStateData?.status === 'success' &&\r\n            serverStateData.data !== undefined\r\n          ) {\r\n            const newOptions = { serverState: serverStateData };\r\n            setAndMergeOptions(thisKey, newOptions);\r\n\r\n            // Check for a merge request.\r\n            const mergeConfig =\r\n              typeof serverStateData.merge === 'object'\r\n                ? serverStateData.merge\r\n                : serverStateData.merge === true\r\n                  ? { strategy: 'append' }\r\n                  : null;\r\n\r\n            // Get the current array and the new data.\r\n            const currentState = getGlobalStore\r\n              .getState()\r\n              .getShadowValue(thisKey);\r\n            const incomingData = serverStateData.data;\r\n\r\n            // *** THE REAL FIX: PERFORM INCREMENTAL INSERTS ***\r\n            if (\r\n              mergeConfig &&\r\n              Array.isArray(currentState) &&\r\n              Array.isArray(incomingData)\r\n            ) {\r\n              const keyField = mergeConfig.key || 'id';\r\n\r\n              const existingIds = new Set(\r\n                currentState.map((item: any) => item[keyField])\r\n              );\r\n\r\n              const newUniqueItems = incomingData.filter((item: any) => {\r\n                return !existingIds.has(item[keyField]);\r\n              });\r\n              console.log('newUniqueItems', newUniqueItems);\r\n              if (newUniqueItems.length > 0) {\r\n                newUniqueItems.forEach((item) => {\r\n                  getGlobalStore\r\n                    .getState()\r\n                    .insertShadowArrayElement(thisKey, [], item);\r\n                });\r\n              } else {\r\n                // No new items, no need to do anything.\r\n                return;\r\n              }\r\n            } else {\r\n              getGlobalStore\r\n                .getState()\r\n                .initializeShadowState(thisKey, incomingData);\r\n            }\r\n\r\n            const meta = getGlobalStore\r\n              .getState()\r\n              .getShadowMetadata(thisKey, []);\r\n            getGlobalStore.getState().setShadowMetadata(thisKey, [], {\r\n              ...meta,\r\n              stateSource: 'server',\r\n              lastServerSync: serverStateData.timestamp || Date.now(),\r\n              isDirty: false,\r\n            });\r\n          }\r\n        }\r\n      });\r\n\r\n    return unsubscribe;\r\n  }, [thisKey, resolveInitialState]);\r\n\r\n  useEffect(() => {\r\n    const existingMeta = getGlobalStore\r\n      .getState()\r\n      .getShadowMetadata(thisKey, []);\r\n    if (existingMeta && existingMeta.stateSource) {\r\n      return; // Already initialized, bail out.\r\n    }\r\n\r\n    const options = getInitialOptions(thisKey as string);\r\n\r\n    if (options?.defaultState !== undefined || defaultState !== undefined) {\r\n      const finalDefaultState = options?.defaultState || defaultState;\r\n\r\n      // Only set defaultState if it's not already set\r\n      if (!options?.defaultState) {\r\n        setAndMergeOptions(thisKey as string, {\r\n          defaultState: finalDefaultState,\r\n        });\r\n      }\r\n\r\n      const { value: resolvedState, source, timestamp } = resolveInitialState();\r\n\r\n      getGlobalStore.getState().initializeShadowState(thisKey, resolvedState);\r\n\r\n      // Set shadow metadata with the correct source info\r\n      getGlobalStore.getState().setShadowMetadata(thisKey, [], {\r\n        stateSource: source,\r\n        lastServerSync: source === 'server' ? timestamp : undefined,\r\n        isDirty: false,\r\n        baseServerState: source === 'server' ? resolvedState : undefined,\r\n      });\r\n\r\n      notifyComponents(thisKey);\r\n    }\r\n  }, [thisKey, ...(dependencies || [])]);\r\n  useLayoutEffect(() => {\r\n    if (noStateKey) {\r\n      setAndMergeOptions(thisKey as string, {\r\n        serverSync,\r\n        formElements,\r\n        defaultState,\r\n        localStorage,\r\n        middleware: latestInitialOptionsRef.current?.middleware,\r\n      });\r\n    }\r\n\r\n    const componentKey = `${thisKey}////${componentIdRef.current}`;\r\n\r\n    // Register component in shadow metadata at root level\r\n    const rootMeta = getGlobalStore.getState().getShadowMetadata(thisKey, []);\r\n    const components = rootMeta?.components || new Map();\r\n\r\n    components.set(componentKey, {\r\n      forceUpdate: () => forceUpdate({}),\r\n      reactiveType: reactiveType ?? ['component', 'deps'],\r\n      paths: new Set(),\r\n      depsFunction: reactiveDeps || undefined,\r\n      deps: reactiveDeps\r\n        ? reactiveDeps(getGlobalStore.getState().getShadowValue(thisKey))\r\n        : [],\r\n      prevDeps: reactiveDeps // Initialize prevDeps with the same initial value\r\n        ? reactiveDeps(getGlobalStore.getState().getShadowValue(thisKey))\r\n        : [],\r\n    });\r\n\r\n    getGlobalStore.getState().setShadowMetadata(thisKey, [], {\r\n      ...rootMeta,\r\n      components,\r\n    });\r\n\r\n    forceUpdate({});\r\n\r\n    return () => {\r\n      const meta = getGlobalStore.getState().getShadowMetadata(thisKey, []);\r\n      const component = meta?.components?.get(componentKey);\r\n\r\n      // Remove from each path we registered to\r\n      if (component?.paths) {\r\n        component.paths.forEach((fullPath) => {\r\n          // fullPath is like \"todos.0.name\", need to split and remove stateKey\r\n          const pathParts = fullPath.split('.');\r\n          const path = pathParts.slice(1); // Remove stateKey part\r\n\r\n          const pathMeta = getGlobalStore\r\n            .getState()\r\n            .getShadowMetadata(thisKey, path);\r\n          if (pathMeta?.pathComponents) {\r\n            // Optionally clean up empty Sets\r\n\r\n            if (pathMeta.pathComponents.size === 0) {\r\n              delete pathMeta.pathComponents;\r\n              getGlobalStore\r\n                .getState()\r\n                .setShadowMetadata(thisKey, path, pathMeta);\r\n            }\r\n          }\r\n        });\r\n      }\r\n\r\n      // Remove from root components\r\n      if (meta?.components) {\r\n        getGlobalStore.getState().setShadowMetadata(thisKey, [], meta);\r\n      }\r\n    };\r\n  }, []);\r\n  const effectiveSetState = (\r\n    newStateOrFunction: UpdateArg<TStateObject> | InsertParams<TStateObject>,\r\n    path: string[],\r\n    updateObj: { updateType: 'insert' | 'cut' | 'update' },\r\n    validationKey?: string\r\n  ) => {\r\n    const fullPath = [thisKey, ...path].join('.');\r\n    if (Array.isArray(path)) {\r\n      const pathKey = `${thisKey}-${path.join('.')}`;\r\n      componentUpdatesRef.current.add(pathKey);\r\n    }\r\n    const store = getGlobalStore.getState();\r\n\r\n    // FETCH ONCE at the beginning\r\n    const shadowMeta = store.getShadowMetadata(thisKey, path);\r\n    const nestedShadowValue = store.getShadowValue(fullPath) as TStateObject;\r\n\r\n    const payload = (\r\n      updateObj.updateType === 'insert' && isFunction(newStateOrFunction)\r\n        ? newStateOrFunction({ state: nestedShadowValue, uuid: uuidv4() })\r\n        : isFunction(newStateOrFunction)\r\n          ? newStateOrFunction(nestedShadowValue)\r\n          : newStateOrFunction\r\n    ) as TStateObject;\r\n\r\n    const timeStamp = Date.now();\r\n\r\n    const newUpdate = {\r\n      timeStamp,\r\n      stateKey: thisKey,\r\n      path,\r\n      updateType: updateObj.updateType,\r\n      status: 'new' as const,\r\n      oldValue: nestedShadowValue,\r\n      newValue: payload,\r\n    } satisfies UpdateTypeDetail;\r\n\r\n    // Perform the update\r\n    switch (updateObj.updateType) {\r\n      case 'insert': {\r\n        store.insertShadowArrayElement(thisKey, path, newUpdate.newValue);\r\n        // The array at `path` has been modified. Mark it AND all its parents as dirty.\r\n        store.markAsDirty(thisKey, path, { bubble: true });\r\n        break;\r\n      }\r\n      case 'cut': {\r\n        // The item is at `path`, so the parent array is at `path.slice(0, -1)`\r\n        const parentArrayPath = path.slice(0, -1);\r\n        store.removeShadowArrayElement(thisKey, path);\r\n        // The parent array has been modified. Mark it AND all its parents as dirty.\r\n        store.markAsDirty(thisKey, parentArrayPath, { bubble: true });\r\n        break;\r\n      }\r\n      case 'update': {\r\n        store.updateShadowAtPath(thisKey, path, newUpdate.newValue);\r\n        // The item at `path` was updated. Mark it AND all its parents as dirty.\r\n        store.markAsDirty(thisKey, path, { bubble: true });\r\n        break;\r\n      }\r\n    }\r\n\r\n    // Handle signals - reuse shadowMeta from the beginning\r\n    if (shadowMeta?.signals && shadowMeta.signals.length > 0) {\r\n      // Use updatedShadowValue if we need the new value, otherwise use payload\r\n      const displayValue = updateObj.updateType === 'cut' ? null : payload;\r\n\r\n      shadowMeta.signals.forEach(({ parentId, position, effect }) => {\r\n        const parent = document.querySelector(`[data-parent-id=\"${parentId}\"]`);\r\n        if (parent) {\r\n          const childNodes = Array.from(parent.childNodes);\r\n          if (childNodes[position]) {\r\n            let finalDisplayValue = displayValue;\r\n            if (effect && displayValue !== null) {\r\n              try {\r\n                finalDisplayValue = new Function(\r\n                  'state',\r\n                  `return (${effect})(state)`\r\n                )(displayValue);\r\n              } catch (err) {\r\n                console.error('Error evaluating effect function:', err);\r\n              }\r\n            }\r\n\r\n            if (\r\n              finalDisplayValue !== null &&\r\n              finalDisplayValue !== undefined &&\r\n              typeof finalDisplayValue === 'object'\r\n            ) {\r\n              finalDisplayValue = JSON.stringify(finalDisplayValue) as any;\r\n            }\r\n\r\n            childNodes[position].textContent = String(finalDisplayValue ?? '');\r\n          }\r\n        }\r\n      });\r\n    }\r\n\r\n    // Update in effectiveSetState for insert handling:\r\n    if (updateObj.updateType === 'insert') {\r\n      // Use shadowMeta from beginning if it's an array\r\n      if (shadowMeta?.mapWrappers && shadowMeta.mapWrappers.length > 0) {\r\n        // Get fresh array keys after insert\r\n        const sourceArrayKeys =\r\n          store.getShadowMetadata(thisKey, path)?.arrayKeys || [];\r\n        const newItemKey = sourceArrayKeys[sourceArrayKeys.length - 1]!;\r\n        const newItemValue = store.getShadowValue(newItemKey);\r\n        const fullSourceArray = store.getShadowValue(\r\n          [thisKey, ...path].join('.')\r\n        );\r\n\r\n        if (!newItemKey || newItemValue === undefined) return;\r\n\r\n        shadowMeta.mapWrappers.forEach((wrapper) => {\r\n          let shouldRender = true;\r\n          let insertPosition = -1;\r\n\r\n          // Check if wrapper has transforms\r\n          if (wrapper.meta?.transforms && wrapper.meta.transforms.length > 0) {\r\n            // Check if new item passes all filters\r\n            for (const transform of wrapper.meta.transforms) {\r\n              if (transform.type === 'filter') {\r\n                if (!transform.fn(newItemValue, -1)) {\r\n                  shouldRender = false;\r\n                  break;\r\n                }\r\n              }\r\n            }\r\n\r\n            if (shouldRender) {\r\n              // Get current valid keys by applying transforms\r\n              const currentValidKeys = applyTransforms(\r\n                thisKey,\r\n                path,\r\n                wrapper.meta.transforms\r\n              );\r\n\r\n              // Find where to insert based on sort\r\n              const sortTransform = wrapper.meta.transforms.find(\r\n                (t: any) => t.type === 'sort'\r\n              );\r\n              if (sortTransform) {\r\n                // Add new item to the list and sort to find position\r\n                const allItems = currentValidKeys.map((key) => ({\r\n                  key,\r\n                  value: store.getShadowValue(key),\r\n                }));\r\n\r\n                allItems.push({ key: newItemKey, value: newItemValue });\r\n                allItems.sort((a, b) => sortTransform.fn(a.value, b.value));\r\n\r\n                insertPosition = allItems.findIndex(\r\n                  (item) => item.key === newItemKey\r\n                );\r\n              } else {\r\n                // No sort, insert at end\r\n                insertPosition = currentValidKeys.length;\r\n              }\r\n            }\r\n          } else {\r\n            // No transforms, always render at end\r\n            shouldRender = true;\r\n            insertPosition = sourceArrayKeys.length - 1;\r\n          }\r\n\r\n          if (!shouldRender) {\r\n            return; // Skip this wrapper, item doesn't pass filters\r\n          }\r\n\r\n          if (wrapper.containerRef && wrapper.containerRef.isConnected) {\r\n            const itemElement = document.createElement('div');\r\n            itemElement.setAttribute('data-item-path', newItemKey);\r\n\r\n            // Insert at correct position\r\n            const children = Array.from(wrapper.containerRef.children);\r\n            if (insertPosition >= 0 && insertPosition < children.length) {\r\n              wrapper.containerRef.insertBefore(\r\n                itemElement,\r\n                children[insertPosition]!\r\n              );\r\n            } else {\r\n              wrapper.containerRef.appendChild(itemElement);\r\n            }\r\n\r\n            const root = createRoot(itemElement);\r\n            const componentId = uuidv4();\r\n            const itemPath = newItemKey.split('.').slice(1);\r\n\r\n            const arraySetter = wrapper.rebuildStateShape({\r\n              path: wrapper.path,\r\n              currentState: fullSourceArray,\r\n              componentId: wrapper.componentId,\r\n              meta: wrapper.meta,\r\n            });\r\n\r\n            root.render(\r\n              createElement(MemoizedCogsItemWrapper, {\r\n                stateKey: thisKey,\r\n                itemComponentId: componentId,\r\n                itemPath: itemPath,\r\n                localIndex: insertPosition,\r\n                arraySetter: arraySetter,\r\n                rebuildStateShape: wrapper.rebuildStateShape,\r\n                renderFn: wrapper.mapFn,\r\n              })\r\n            );\r\n          }\r\n        });\r\n      }\r\n    }\r\n    if (updateObj.updateType === 'cut') {\r\n      const arrayPath = path.slice(0, -1);\r\n      const arrayMeta = store.getShadowMetadata(thisKey, arrayPath);\r\n\r\n      if (arrayMeta?.mapWrappers && arrayMeta.mapWrappers.length > 0) {\r\n        arrayMeta.mapWrappers.forEach((wrapper) => {\r\n          if (wrapper.containerRef && wrapper.containerRef.isConnected) {\r\n            const elementToRemove = wrapper.containerRef.querySelector(\r\n              `[data-item-path=\"${fullPath}\"]`\r\n            );\r\n            if (elementToRemove) {\r\n              elementToRemove.remove();\r\n            }\r\n          }\r\n        });\r\n      }\r\n    }\r\n    if (\r\n      updateObj.updateType === 'update' &&\r\n      (validationKey || latestInitialOptionsRef.current?.validation?.key) &&\r\n      path\r\n    ) {\r\n      removeValidationError(\r\n        (validationKey || latestInitialOptionsRef.current?.validation?.key) +\r\n          '.' +\r\n          path.join('.')\r\n      );\r\n    }\r\n    const arrayWithoutIndex = path.slice(0, path.length - 1);\r\n    if (\r\n      updateObj.updateType === 'cut' &&\r\n      latestInitialOptionsRef.current?.validation?.key\r\n    ) {\r\n      removeValidationError(\r\n        latestInitialOptionsRef.current?.validation?.key +\r\n          '.' +\r\n          arrayWithoutIndex.join('.')\r\n      );\r\n    }\r\n    if (\r\n      updateObj.updateType === 'insert' &&\r\n      latestInitialOptionsRef.current?.validation?.key\r\n    ) {\r\n      const getValidation = getValidationErrors(\r\n        latestInitialOptionsRef.current?.validation?.key +\r\n          '.' +\r\n          arrayWithoutIndex.join('.')\r\n      );\r\n\r\n      getValidation.filter((k) => {\r\n        let length = k?.split('.').length;\r\n        const v = ''; // Placeholder as `v` is not used from getValidationErrors\r\n\r\n        if (\r\n          k == arrayWithoutIndex.join('.') &&\r\n          length == arrayWithoutIndex.length - 1\r\n        ) {\r\n          let newKey = k + '.' + arrayWithoutIndex;\r\n          removeValidationError(k!);\r\n          addValidationError(newKey, v!);\r\n        }\r\n      });\r\n    }\r\n    // Assumes `isDeepEqual` is available in this scope.\r\n    // Assumes `isDeepEqual` is available in this scope.\r\n\r\n    const newState = store.getShadowValue(thisKey);\r\n    const rootMeta = store.getShadowMetadata(thisKey, []);\r\n    const notifiedComponents = new Set<string>();\r\n\r\n    if (!rootMeta?.components) {\r\n      return newState;\r\n    }\r\n\r\n    // --- PASS 1: Notify specific subscribers based on update type ---\r\n\r\n    if (updateObj.updateType === 'update') {\r\n      // ALWAYS notify components subscribed to the exact path being updated.\r\n      // This is the crucial part that handles primitives, as well as updates\r\n      // to an object or array treated as a whole.\r\n      if (shadowMeta?.pathComponents) {\r\n        shadowMeta.pathComponents.forEach((componentId) => {\r\n          // If this component was already notified, skip.\r\n          if (notifiedComponents.has(componentId)) {\r\n            return;\r\n          }\r\n          const component = rootMeta.components?.get(componentId);\r\n          if (component) {\r\n            const reactiveTypes = Array.isArray(component.reactiveType)\r\n              ? component.reactiveType\r\n              : [component.reactiveType || 'component'];\r\n\r\n            // Check if the component has reactivity enabled\r\n            if (!reactiveTypes.includes('none')) {\r\n              component.forceUpdate();\r\n              notifiedComponents.add(componentId);\r\n            }\r\n          }\r\n        });\r\n      }\r\n\r\n      // ADDITIONALLY, if the payload is an object, perform a deep-check and\r\n      // notify any components that are subscribed to specific sub-paths that changed.\r\n      if (\r\n        payload &&\r\n        typeof payload === 'object' &&\r\n        !isArray(payload) &&\r\n        nestedShadowValue &&\r\n        typeof nestedShadowValue === 'object' &&\r\n        !isArray(nestedShadowValue)\r\n      ) {\r\n        // Get a list of dot-separated paths that have changed (e.g., ['name', 'address.city'])\r\n        const changedSubPaths = getDifferences(payload, nestedShadowValue);\r\n\r\n        changedSubPaths.forEach((subPathString) => {\r\n          const subPath = subPathString.split('.');\r\n          const fullSubPath = [...path, ...subPath];\r\n\r\n          // Get the metadata (and subscribers) for this specific nested path\r\n          const subPathMeta = store.getShadowMetadata(thisKey, fullSubPath);\r\n          if (subPathMeta?.pathComponents) {\r\n            subPathMeta.pathComponents.forEach((componentId) => {\r\n              // Avoid sending a redundant update\r\n              if (notifiedComponents.has(componentId)) {\r\n                return;\r\n              }\r\n              const component = rootMeta.components?.get(componentId);\r\n              if (component) {\r\n                const reactiveTypes = Array.isArray(component.reactiveType)\r\n                  ? component.reactiveType\r\n                  : [component.reactiveType || 'component'];\r\n\r\n                if (!reactiveTypes.includes('none')) {\r\n                  component.forceUpdate();\r\n                  notifiedComponents.add(componentId);\r\n                }\r\n              }\r\n            });\r\n          }\r\n        });\r\n      }\r\n    } else if (\r\n      updateObj.updateType === 'insert' ||\r\n      updateObj.updateType === 'cut'\r\n    ) {\r\n      // For array structural changes, notify components listening to the parent array.\r\n      const parentArrayPath =\r\n        updateObj.updateType === 'insert' ? path : path.slice(0, -1);\r\n\r\n      const parentMeta = store.getShadowMetadata(thisKey, parentArrayPath);\r\n\r\n      // Handle signal updates for array length, etc.\r\n      if (parentMeta?.signals && parentMeta.signals.length > 0) {\r\n        const parentFullPath = [thisKey, ...parentArrayPath].join('.');\r\n        const parentValue = store.getShadowValue(parentFullPath);\r\n\r\n        parentMeta.signals.forEach(({ parentId, position, effect }) => {\r\n          const parent = document.querySelector(\r\n            `[data-parent-id=\"${parentId}\"]`\r\n          );\r\n          if (parent) {\r\n            const childNodes = Array.from(parent.childNodes);\r\n            if (childNodes[position]) {\r\n              let displayValue = parentValue;\r\n              if (effect) {\r\n                try {\r\n                  displayValue = new Function(\r\n                    'state',\r\n                    `return (${effect})(state)`\r\n                  )(parentValue);\r\n                } catch (err) {\r\n                  console.error('Error evaluating effect function:', err);\r\n                  displayValue = parentValue;\r\n                }\r\n              }\r\n\r\n              if (\r\n                displayValue !== null &&\r\n                displayValue !== undefined &&\r\n                typeof displayValue === 'object'\r\n              ) {\r\n                displayValue = JSON.stringify(displayValue);\r\n              }\r\n\r\n              childNodes[position].textContent = String(displayValue ?? '');\r\n            }\r\n          }\r\n        });\r\n      }\r\n\r\n      // Notify components subscribed to the array itself.\r\n      if (parentMeta?.pathComponents) {\r\n        parentMeta.pathComponents.forEach((componentId) => {\r\n          if (!notifiedComponents.has(componentId)) {\r\n            const component = rootMeta.components?.get(componentId);\r\n            if (component) {\r\n              component.forceUpdate();\r\n              notifiedComponents.add(componentId);\r\n            }\r\n          }\r\n        });\r\n      }\r\n    }\r\n\r\n    rootMeta.components.forEach((component, componentId) => {\r\n      if (notifiedComponents.has(componentId)) {\r\n        return;\r\n      }\r\n\r\n      const reactiveTypes = Array.isArray(component.reactiveType)\r\n        ? component.reactiveType\r\n        : [component.reactiveType || 'component'];\r\n\r\n      if (reactiveTypes.includes('all')) {\r\n        component.forceUpdate();\r\n        notifiedComponents.add(componentId);\r\n        return;\r\n      }\r\n\r\n      if (reactiveTypes.includes('deps')) {\r\n        if (component.depsFunction) {\r\n          const currentState = store.getShadowValue(thisKey);\r\n          const newDeps = component.depsFunction(currentState);\r\n          let shouldUpdate = false;\r\n\r\n          if (newDeps === true) {\r\n            shouldUpdate = true;\r\n          } else if (Array.isArray(newDeps)) {\r\n            if (!isDeepEqual(component.prevDeps, newDeps)) {\r\n              component.prevDeps = newDeps;\r\n              shouldUpdate = true;\r\n            }\r\n          }\r\n\r\n          if (shouldUpdate) {\r\n            component.forceUpdate();\r\n            notifiedComponents.add(componentId);\r\n          }\r\n        }\r\n      }\r\n    });\r\n    notifiedComponents.clear();\r\n    setStateLog(thisKey, (prevLogs) => {\r\n      const logs = [...(prevLogs ?? []), newUpdate];\r\n      const aggregatedLogs = new Map<string, typeof newUpdate>();\r\n\r\n      logs.forEach((log) => {\r\n        const uniqueKey = `${log.stateKey}:${JSON.stringify(log.path)}`;\r\n        const existing = aggregatedLogs.get(uniqueKey);\r\n\r\n        if (existing) {\r\n          existing.timeStamp = Math.max(existing.timeStamp, log.timeStamp);\r\n          existing.newValue = log.newValue;\r\n          existing.oldValue = existing.oldValue ?? log.oldValue;\r\n          existing.updateType = log.updateType;\r\n        } else {\r\n          aggregatedLogs.set(uniqueKey, { ...(log as any) });\r\n        }\r\n      });\r\n\r\n      return Array.from(aggregatedLogs.values());\r\n    });\r\n\r\n    saveToLocalStorage(\r\n      payload,\r\n      thisKey,\r\n      latestInitialOptionsRef.current,\r\n      sessionId\r\n    );\r\n\r\n    if (latestInitialOptionsRef.current?.middleware) {\r\n      latestInitialOptionsRef.current!.middleware({\r\n        updateLog: stateLog,\r\n        update: newUpdate,\r\n      });\r\n    }\r\n\r\n    return newState;\r\n  };\r\n\r\n  if (!getGlobalStore.getState().initialStateGlobal[thisKey]) {\r\n    updateInitialStateGlobal(thisKey, stateObject);\r\n  }\r\n\r\n  const updaterFinal = useMemo(() => {\r\n    return createProxyHandler<TStateObject>(\r\n      thisKey,\r\n      effectiveSetState,\r\n      componentIdRef.current,\r\n      sessionId\r\n    );\r\n  }, [thisKey, sessionId]);\r\n\r\n  return updaterFinal;\r\n}\r\n\r\nexport type MetaData = {\r\n  /**\r\n   * An array of the full, unique string IDs (e.g., `\"stateKey.arrayName.id:123\"`)\r\n   * of the items that belong to the current derived \"view\" of an array.\r\n   * This is the primary mechanism for tracking the state of filtered or sorted lists.\r\n   *\r\n   * - `stateFilter` populates this with only the IDs of items that passed the filter.\r\n   * - `stateSort` reorders this list to match the new sort order.\r\n   * - All subsequent chained operations (like `.get()`, `.index()`, or `.cut()`)\r\n   *   MUST consult this list first to know which items they apply to and in what order.\r\n   */\r\n  validIds?: string[];\r\n\r\n  /**\r\n   * An array of the actual filter functions that have been applied in a chain.\r\n   * This is primarily used by reactive renderers like `$stateMap` to make predictions.\r\n   *\r\n   * For example, when a new item is inserted into the original source array, a\r\n   * `$stateMap` renderer on a filtered view can use these functions to test if the\r\n   * newly inserted item should be dynamically rendered in its view.\r\n   */\r\n  transforms?: Array<{\r\n    type: 'filter' | 'sort';\r\n    fn: Function;\r\n  }>;\r\n};\r\n\r\nfunction hashTransforms(transforms: any[]) {\r\n  if (!transforms || transforms.length === 0) {\r\n    return '';\r\n  }\r\n  // This creates a string representation of the transforms AND their dependencies.\r\n  // Example: \"filter['red']sort['score','asc']\"\r\n  return transforms\r\n    .map(\r\n      (transform) =>\r\n        // Safely stringify dependencies. An empty array becomes '[]'.\r\n        `${transform.type}${JSON.stringify(transform.dependencies || [])}`\r\n    )\r\n    .join('');\r\n}\r\nconst applyTransforms = (\r\n  stateKey: string,\r\n  path: string[],\r\n  transforms?: Array<{ type: 'filter' | 'sort'; fn: Function }>\r\n): string[] => {\r\n  let arrayKeys =\r\n    getGlobalStore.getState().getShadowMetadata(stateKey, path)?.arrayKeys ||\r\n    [];\r\n\r\n  if (!transforms || transforms.length === 0) {\r\n    return arrayKeys;\r\n  }\r\n\r\n  let itemsWithKeys = arrayKeys.map((key) => ({\r\n    key,\r\n    value: getGlobalStore.getState().getShadowValue(key),\r\n  }));\r\n\r\n  for (const transform of transforms) {\r\n    if (transform.type === 'filter') {\r\n      itemsWithKeys = itemsWithKeys.filter(({ value }, index) =>\r\n        transform.fn(value, index)\r\n      );\r\n    } else if (transform.type === 'sort') {\r\n      itemsWithKeys.sort((a, b) => transform.fn(a.value, b.value));\r\n    }\r\n  }\r\n\r\n  return itemsWithKeys.map(({ key }) => key);\r\n};\r\nconst registerComponentDependency = (\r\n  stateKey: string,\r\n  componentId: string,\r\n  dependencyPath: string[]\r\n) => {\r\n  const fullComponentId = `${stateKey}////${componentId}`;\r\n  const rootMeta = getGlobalStore.getState().getShadowMetadata(stateKey, []);\r\n  const component = rootMeta?.components?.get(fullComponentId);\r\n\r\n  if (\r\n    !component ||\r\n    component.reactiveType == 'none' ||\r\n    !(\r\n      Array.isArray(component.reactiveType)\r\n        ? component.reactiveType\r\n        : [component.reactiveType]\r\n    ).includes('component')\r\n  ) {\r\n    return;\r\n  }\r\n\r\n  const pathKey = [stateKey, ...dependencyPath].join('.');\r\n\r\n  // Add to component's paths (existing logic)\r\n  component.paths.add(pathKey);\r\n\r\n  // NEW: Also store componentId at the path level\r\n  const pathMeta =\r\n    getGlobalStore.getState().getShadowMetadata(stateKey, dependencyPath) || {};\r\n  const pathComponents = pathMeta.pathComponents || new Set<string>();\r\n  pathComponents.add(fullComponentId);\r\n\r\n  getGlobalStore.getState().setShadowMetadata(stateKey, dependencyPath, {\r\n    ...pathMeta,\r\n    pathComponents,\r\n  });\r\n};\r\n\r\nconst notifySelectionComponents = (\r\n  stateKey: string,\r\n  parentPath: string[],\r\n  currentSelected?: string | undefined\r\n) => {\r\n  const store = getGlobalStore.getState();\r\n  const rootMeta = store.getShadowMetadata(stateKey, []);\r\n  const notifiedComponents = new Set<string>();\r\n\r\n  // Handle \"all\" reactive components first\r\n  if (rootMeta?.components) {\r\n    rootMeta.components.forEach((component, componentId) => {\r\n      const reactiveTypes = Array.isArray(component.reactiveType)\r\n        ? component.reactiveType\r\n        : [component.reactiveType || 'component'];\r\n\r\n      if (reactiveTypes.includes('all')) {\r\n        component.forceUpdate();\r\n        notifiedComponents.add(componentId);\r\n      }\r\n    });\r\n  }\r\n\r\n  store\r\n    .getShadowMetadata(stateKey, [...parentPath, 'getSelected'])\r\n    ?.pathComponents?.forEach((componentId) => {\r\n      const thisComp = rootMeta?.components?.get(componentId);\r\n      thisComp?.forceUpdate();\r\n    });\r\n\r\n  const parentMeta = store.getShadowMetadata(stateKey, parentPath);\r\n  for (let arrayKey of parentMeta?.arrayKeys || []) {\r\n    const key = arrayKey + '.selected';\r\n    const selectedItem = store.getShadowMetadata(\r\n      stateKey,\r\n      key.split('.').slice(1)\r\n    );\r\n    if (arrayKey == currentSelected) {\r\n      selectedItem?.pathComponents?.forEach((componentId) => {\r\n        const thisComp = rootMeta?.components?.get(componentId);\r\n        thisComp?.forceUpdate();\r\n      });\r\n    }\r\n  }\r\n};\r\nfunction createProxyHandler<T>(\r\n  stateKey: string,\r\n  effectiveSetState: EffectiveSetState<T>,\r\n  componentId: string,\r\n  sessionId?: string\r\n): StateObject<T> {\r\n  type CacheEntry = {\r\n    proxy: any;\r\n    stateVersion: number;\r\n  };\r\n\r\n  const shapeCache = new Map<string, CacheEntry>();\r\n  let stateVersion = 0;\r\n\r\n  const invalidateCachePath = (path: string[]) => {\r\n    const pathKey = path.join('.');\r\n    for (const [key] of shapeCache) {\r\n      if (key === pathKey || key.startsWith(pathKey + '.')) {\r\n        shapeCache.delete(key);\r\n      }\r\n    }\r\n    stateVersion++;\r\n  };\r\n\r\n  function rebuildStateShape({\r\n    currentState,\r\n    path = [],\r\n    meta,\r\n    componentId,\r\n  }: {\r\n    currentState: T;\r\n    path: string[];\r\n    componentId: string;\r\n    meta?: MetaData;\r\n  }): any {\r\n    const cacheKey = path.map(String).join('.');\r\n    const stateKeyPathKey = [stateKey, ...path].join('.');\r\n\r\n    currentState = getGlobalStore\r\n      .getState()\r\n      .getShadowValue(stateKeyPathKey, meta?.validIds);\r\n\r\n    type CallableStateObject<T> = {\r\n      (): T;\r\n    } & {\r\n      [key: string]: any;\r\n    };\r\n\r\n    const baseFunction = function () {\r\n      return getGlobalStore().getShadowValue(stateKey, path);\r\n    } as unknown as CallableStateObject<T>;\r\n\r\n    // We attach baseObj properties *inside* the get trap now to avoid recursion\r\n    // This is a placeholder for the proxy.\r\n\r\n    const handler = {\r\n      apply(target: any, thisArg: any, args: any[]) {\r\n        //return getGlobalStore().getShadowValue(stateKey, path);\r\n      },\r\n\r\n      get(target: any, prop: string) {\r\n        // V--------- THE CRUCIAL FIX IS HERE ---------V\r\n        // This handles requests for internal functions on the proxy,\r\n        // returning the function itself instead of treating it as state.\r\n        if (prop === '_rebuildStateShape') {\r\n          return rebuildStateShape;\r\n        }\r\n        const baseObjProps = Object.getOwnPropertyNames(baseObj);\r\n        if (baseObjProps.includes(prop) && path.length === 0) {\r\n          return (baseObj as any)[prop];\r\n        }\r\n        // ^--------- END OF FIX ---------^\r\n\r\n        if (prop === 'getDifferences') {\r\n          return () => {\r\n            const shadowMeta = getGlobalStore\r\n              .getState()\r\n              .getShadowMetadata(stateKey, []);\r\n            const currentState = getGlobalStore\r\n              .getState()\r\n              .getShadowValue(stateKey);\r\n\r\n            // Use the appropriate base state for comparison\r\n            let baseState;\r\n            if (\r\n              shadowMeta?.stateSource === 'server' &&\r\n              shadowMeta.baseServerState\r\n            ) {\r\n              baseState = shadowMeta.baseServerState;\r\n            } else {\r\n              baseState =\r\n                getGlobalStore.getState().initialStateGlobal[stateKey];\r\n            }\r\n\r\n            return getDifferences(currentState, baseState);\r\n          };\r\n        }\r\n        if (prop === 'sync' && path.length === 0) {\r\n          return async function () {\r\n            const options = getGlobalStore\r\n              .getState()\r\n              .getInitialOptions(stateKey);\r\n            const sync = options?.sync;\r\n\r\n            if (!sync) {\r\n              console.error(`No mutation defined for state key \"${stateKey}\"`);\r\n              return { success: false, error: `No mutation defined` };\r\n            }\r\n\r\n            const state = getGlobalStore\r\n              .getState()\r\n              .getShadowValue(stateKey, []);\r\n            const validationKey = options?.validation?.key;\r\n\r\n            try {\r\n              const response = await sync.action(state);\r\n              if (\r\n                response &&\r\n                !response.success &&\r\n                response.errors &&\r\n                validationKey\r\n              ) {\r\n                getGlobalStore.getState().removeValidationError(validationKey);\r\n                response.errors.forEach((error) => {\r\n                  const errorPath = [validationKey, ...error.path].join('.');\r\n                  getGlobalStore\r\n                    .getState()\r\n                    .addValidationError(errorPath, error.message);\r\n                });\r\n                notifyComponents(stateKey);\r\n              }\r\n\r\n              if (response?.success) {\r\n                // Mark as synced and not dirty\r\n                const shadowMeta = getGlobalStore\r\n                  .getState()\r\n                  .getShadowMetadata(stateKey, []);\r\n                getGlobalStore.getState().setShadowMetadata(stateKey, [], {\r\n                  ...shadowMeta,\r\n                  isDirty: false,\r\n                  lastServerSync: Date.now(),\r\n                  stateSource: 'server',\r\n                  baseServerState: state, // Update base server state\r\n                });\r\n\r\n                if (sync.onSuccess) {\r\n                  sync.onSuccess(response.data);\r\n                }\r\n              } else if (!response?.success && sync.onError)\r\n                sync.onError(response.error);\r\n\r\n              return response;\r\n            } catch (error) {\r\n              if (sync.onError) sync.onError(error);\r\n              return { success: false, error };\r\n            }\r\n          };\r\n        }\r\n        if (prop === '_status' || prop === 'getStatus') {\r\n          const getStatusFunc = () => {\r\n            const shadowMeta = getGlobalStore\r\n              .getState()\r\n              .getShadowMetadata(stateKey, []);\r\n\r\n            if (shadowMeta?.stateSource === 'server' && !shadowMeta.isDirty) {\r\n              return 'synced';\r\n            } else if (shadowMeta?.isDirty) {\r\n              return 'dirty';\r\n            } else if (shadowMeta?.stateSource === 'localStorage') {\r\n              return 'restored';\r\n            } else if (shadowMeta?.stateSource === 'default') {\r\n              return 'fresh';\r\n            }\r\n            return 'unknown';\r\n          };\r\n\r\n          return prop === '_status' ? getStatusFunc() : getStatusFunc;\r\n        }\r\n        if (prop === 'removeStorage') {\r\n          return () => {\r\n            const initialState =\r\n              getGlobalStore.getState().initialStateGlobal[stateKey];\r\n            const initalOptionsGet = getInitialOptions(stateKey as string);\r\n            const localKey = isFunction(initalOptionsGet?.localStorage?.key)\r\n              ? initalOptionsGet.localStorage.key(initialState)\r\n              : initalOptionsGet?.localStorage?.key;\r\n            const storageKey = `${sessionId}-${stateKey}-${localKey}`;\r\n            if (storageKey) localStorage.removeItem(storageKey);\r\n          };\r\n        }\r\n        if (prop === 'showValidationErrors') {\r\n          return () => {\r\n            const init = getGlobalStore\r\n              .getState()\r\n              .getInitialOptions(stateKey)?.validation;\r\n            if (!init?.key) throw new Error('Validation key not found');\r\n            return getGlobalStore\r\n              .getState()\r\n              .getValidationErrors(init.key + '.' + path.join('.'));\r\n          };\r\n        }\r\n        if (Array.isArray(currentState)) {\r\n          if (prop === 'getSelected') {\r\n            return () => {\r\n              const fullKey = stateKey + '.' + path.join('.');\r\n              registerComponentDependency(stateKey, componentId, [\r\n                ...path,\r\n                'getSelected',\r\n              ]);\r\n\r\n              const selectedIndicesMap =\r\n                getGlobalStore.getState().selectedIndicesMap;\r\n              if (!selectedIndicesMap || !selectedIndicesMap.has(fullKey)) {\r\n                return undefined;\r\n              }\r\n\r\n              const selectedItemKey = selectedIndicesMap.get(fullKey)!;\r\n              if (meta?.validIds) {\r\n                if (!meta.validIds.includes(selectedItemKey)) {\r\n                  return undefined;\r\n                }\r\n              }\r\n\r\n              const value = getGlobalStore\r\n                .getState()\r\n                .getShadowValue(selectedItemKey);\r\n\r\n              if (!value) {\r\n                return undefined;\r\n              }\r\n\r\n              return rebuildStateShape({\r\n                currentState: value,\r\n                path: selectedItemKey.split('.').slice(1) as string[],\r\n                componentId: componentId!,\r\n              });\r\n            };\r\n          }\r\n          if (prop === 'getSelectedIndex') {\r\n            return () => {\r\n              const selectedIndex = getGlobalStore\r\n                .getState()\r\n                .getSelectedIndex(\r\n                  stateKey + '.' + path.join('.'),\r\n                  meta?.validIds\r\n                );\r\n\r\n              return selectedIndex;\r\n            };\r\n          }\r\n          if (prop === 'clearSelected') {\r\n            notifySelectionComponents(stateKey, path);\r\n            return () => {\r\n              getGlobalStore.getState().clearSelectedIndex({\r\n                arrayKey: stateKey + '.' + path.join('.'),\r\n              });\r\n            };\r\n          }\r\n\r\n          if (prop === 'useVirtualView') {\r\n            return (\r\n              options: VirtualViewOptions\r\n            ): VirtualStateObjectResult<any[]> => {\r\n              const {\r\n                itemHeight = 50,\r\n                overscan = 6,\r\n                stickToBottom = false,\r\n                scrollStickTolerance = 75,\r\n              } = options;\r\n\r\n              const containerRef = useRef<HTMLDivElement | null>(null);\r\n              const [range, setRange] = useState({\r\n                startIndex: 0,\r\n                endIndex: 10,\r\n              });\r\n              const [rerender, forceUpdate] = useState({});\r\n              const initialScrollRef = useRef(true);\r\n\r\n              // Scroll state management\r\n              const scrollStateRef = useRef({\r\n                isUserScrolling: false,\r\n                lastScrollTop: 0,\r\n                scrollUpCount: 0,\r\n                isNearBottom: true,\r\n              });\r\n\r\n              // Measurement cache\r\n              const measurementCache = useRef(\r\n                new Map<string, { height: number; offset: number }>()\r\n              );\r\n\r\n              // Separate effect for handling rerender updates\r\n              useLayoutEffect(() => {\r\n                if (\r\n                  !stickToBottom ||\r\n                  !containerRef.current ||\r\n                  scrollStateRef.current.isUserScrolling\r\n                )\r\n                  return;\r\n\r\n                const container = containerRef.current;\r\n                container.scrollTo({\r\n                  top: container.scrollHeight,\r\n                  behavior: initialScrollRef.current ? 'instant' : 'smooth',\r\n                });\r\n              }, [rerender, stickToBottom]);\r\n\r\n              const arrayKeys =\r\n                getGlobalStore.getState().getShadowMetadata(stateKey, path)\r\n                  ?.arrayKeys || [];\r\n\r\n              // Calculate total height and offsets\r\n              const { totalHeight, itemOffsets } = useMemo(() => {\r\n                let runningOffset = 0;\r\n                const offsets = new Map<\r\n                  string,\r\n                  { height: number; offset: number }\r\n                >();\r\n                const allItemKeys =\r\n                  getGlobalStore.getState().getShadowMetadata(stateKey, path)\r\n                    ?.arrayKeys || [];\r\n\r\n                allItemKeys.forEach((itemKey) => {\r\n                  const itemPath = itemKey.split('.').slice(1);\r\n                  const measuredHeight =\r\n                    getGlobalStore\r\n                      .getState()\r\n                      .getShadowMetadata(stateKey, itemPath)?.virtualizer\r\n                      ?.itemHeight || itemHeight;\r\n\r\n                  offsets.set(itemKey, {\r\n                    height: measuredHeight,\r\n                    offset: runningOffset,\r\n                  });\r\n\r\n                  runningOffset += measuredHeight;\r\n                });\r\n\r\n                measurementCache.current = offsets;\r\n                return { totalHeight: runningOffset, itemOffsets: offsets };\r\n              }, [arrayKeys.length, itemHeight]);\r\n\r\n              // Improved initial positioning effect\r\n              useLayoutEffect(() => {\r\n                if (\r\n                  stickToBottom &&\r\n                  arrayKeys.length > 0 &&\r\n                  containerRef.current &&\r\n                  !scrollStateRef.current.isUserScrolling &&\r\n                  initialScrollRef.current\r\n                ) {\r\n                  const container = containerRef.current;\r\n\r\n                  // Wait for container to have dimensions\r\n                  const waitForContainer = () => {\r\n                    if (container.clientHeight > 0) {\r\n                      const visibleCount = Math.ceil(\r\n                        container.clientHeight / itemHeight\r\n                      );\r\n                      const endIndex = arrayKeys.length - 1;\r\n                      const startIndex = Math.max(\r\n                        0,\r\n                        endIndex - visibleCount - overscan\r\n                      );\r\n\r\n                      setRange({ startIndex, endIndex });\r\n\r\n                      // Ensure scroll after range is set\r\n                      requestAnimationFrame(() => {\r\n                        scrollToBottom('instant');\r\n                        initialScrollRef.current = false; // Mark initial scroll as done\r\n                      });\r\n                    } else {\r\n                      // Container not ready, try again\r\n                      requestAnimationFrame(waitForContainer);\r\n                    }\r\n                  };\r\n\r\n                  waitForContainer();\r\n                }\r\n              }, [arrayKeys.length, stickToBottom, itemHeight, overscan]);\r\n\r\n              // Combined scroll handler\r\n              const handleScroll = useCallback(() => {\r\n                const container = containerRef.current;\r\n                if (!container) return;\r\n\r\n                const currentScrollTop = container.scrollTop;\r\n                const { scrollHeight, clientHeight } = container;\r\n                const scrollState = scrollStateRef.current;\r\n\r\n                // Check if user is near bottom\r\n                const distanceFromBottom =\r\n                  scrollHeight - (currentScrollTop + clientHeight);\r\n                const wasNearBottom = scrollState.isNearBottom;\r\n                scrollState.isNearBottom =\r\n                  distanceFromBottom <= scrollStickTolerance;\r\n\r\n                // Detect scroll direction\r\n                if (currentScrollTop < scrollState.lastScrollTop) {\r\n                  // User scrolled up\r\n                  scrollState.scrollUpCount++;\r\n\r\n                  if (scrollState.scrollUpCount > 3 && wasNearBottom) {\r\n                    // User has deliberately scrolled away from bottom\r\n                    scrollState.isUserScrolling = true;\r\n                    console.log('User scrolled away from bottom');\r\n                  }\r\n                } else if (scrollState.isNearBottom) {\r\n                  // Reset if we're back near the bottom\r\n                  scrollState.isUserScrolling = false;\r\n                  scrollState.scrollUpCount = 0;\r\n                }\r\n\r\n                scrollState.lastScrollTop = currentScrollTop;\r\n\r\n                // Update visible range\r\n                let newStartIndex = 0;\r\n                for (let i = 0; i < arrayKeys.length; i++) {\r\n                  const itemKey = arrayKeys[i];\r\n                  const item = measurementCache.current.get(itemKey!);\r\n                  if (item && item.offset + item.height > currentScrollTop) {\r\n                    newStartIndex = i;\r\n                    break;\r\n                  }\r\n                }\r\n\r\n                // Only update if range actually changed\r\n                if (newStartIndex !== range.startIndex) {\r\n                  const visibleCount = Math.ceil(clientHeight / itemHeight);\r\n                  setRange({\r\n                    startIndex: Math.max(0, newStartIndex - overscan),\r\n                    endIndex: Math.min(\r\n                      arrayKeys.length - 1,\r\n                      newStartIndex + visibleCount + overscan\r\n                    ),\r\n                  });\r\n                }\r\n              }, [\r\n                arrayKeys.length,\r\n                range.startIndex,\r\n                itemHeight,\r\n                overscan,\r\n                scrollStickTolerance,\r\n              ]);\r\n\r\n              // Set up scroll listener\r\n              useEffect(() => {\r\n                const container = containerRef.current;\r\n                if (!container || !stickToBottom) return;\r\n\r\n                container.addEventListener('scroll', handleScroll, {\r\n                  passive: true,\r\n                });\r\n\r\n                return () => {\r\n                  container.removeEventListener('scroll', handleScroll);\r\n                };\r\n              }, [handleScroll, stickToBottom]);\r\n              const scrollToBottom = useCallback(\r\n                (behavior: ScrollBehavior = 'smooth') => {\r\n                  const container = containerRef.current;\r\n                  if (!container) return;\r\n\r\n                  // Reset scroll state\r\n                  scrollStateRef.current.isUserScrolling = false;\r\n                  scrollStateRef.current.isNearBottom = true;\r\n                  scrollStateRef.current.scrollUpCount = 0;\r\n\r\n                  const performScroll = () => {\r\n                    // Multiple attempts to ensure we hit the bottom\r\n                    const attemptScroll = (attempts = 0) => {\r\n                      if (attempts > 5) return; // Prevent infinite loops\r\n\r\n                      const currentHeight = container.scrollHeight;\r\n                      const currentScroll = container.scrollTop;\r\n                      const clientHeight = container.clientHeight;\r\n\r\n                      // Check if we're already at the bottom\r\n                      if (currentScroll + clientHeight >= currentHeight - 1) {\r\n                        return;\r\n                      }\r\n\r\n                      container.scrollTo({\r\n                        top: currentHeight,\r\n                        behavior: behavior,\r\n                      });\r\n\r\n                      // In slow environments, check again after a short delay\r\n                      setTimeout(() => {\r\n                        const newHeight = container.scrollHeight;\r\n                        const newScroll = container.scrollTop;\r\n\r\n                        // If height changed or we're not at bottom, try again\r\n                        if (\r\n                          newHeight !== currentHeight ||\r\n                          newScroll + clientHeight < newHeight - 1\r\n                        ) {\r\n                          attemptScroll(attempts + 1);\r\n                        }\r\n                      }, 50);\r\n                    };\r\n\r\n                    attemptScroll();\r\n                  };\r\n\r\n                  // Use requestIdleCallback for better performance in slow environments\r\n                  if ('requestIdleCallback' in window) {\r\n                    requestIdleCallback(performScroll, { timeout: 100 });\r\n                  } else {\r\n                    // Fallback to rAF chain\r\n                    requestAnimationFrame(() => {\r\n                      requestAnimationFrame(performScroll);\r\n                    });\r\n                  }\r\n                },\r\n                []\r\n              );\r\n              // Auto-scroll to bottom when new content arrives\r\n              // Consolidated auto-scroll effect with debouncing\r\n              useEffect(() => {\r\n                if (!stickToBottom || !containerRef.current) return;\r\n\r\n                const container = containerRef.current;\r\n                const scrollState = scrollStateRef.current;\r\n\r\n                // Debounced scroll function\r\n                let scrollTimeout: NodeJS.Timeout;\r\n                const debouncedScrollToBottom = () => {\r\n                  clearTimeout(scrollTimeout);\r\n                  scrollTimeout = setTimeout(() => {\r\n                    if (\r\n                      !scrollState.isUserScrolling &&\r\n                      scrollState.isNearBottom\r\n                    ) {\r\n                      scrollToBottom(\r\n                        initialScrollRef.current ? 'instant' : 'smooth'\r\n                      );\r\n                    }\r\n                  }, 100);\r\n                };\r\n\r\n                // Single MutationObserver for all DOM changes\r\n                const observer = new MutationObserver(() => {\r\n                  if (!scrollState.isUserScrolling) {\r\n                    debouncedScrollToBottom();\r\n                  }\r\n                });\r\n\r\n                observer.observe(container, {\r\n                  childList: true,\r\n                  subtree: true,\r\n                  attributes: true,\r\n                  attributeFilter: ['style', 'class'], // More specific than just 'height'\r\n                });\r\n\r\n                // Handle image loads with event delegation\r\n                const handleImageLoad = (e: Event) => {\r\n                  if (\r\n                    e.target instanceof HTMLImageElement &&\r\n                    !scrollState.isUserScrolling\r\n                  ) {\r\n                    debouncedScrollToBottom();\r\n                  }\r\n                };\r\n\r\n                container.addEventListener('load', handleImageLoad, true);\r\n\r\n                // Initial scroll with proper timing\r\n                if (initialScrollRef.current) {\r\n                  // For initial load, wait for next tick to ensure DOM is ready\r\n                  setTimeout(() => {\r\n                    scrollToBottom('instant');\r\n                  }, 0);\r\n                } else {\r\n                  debouncedScrollToBottom();\r\n                }\r\n\r\n                return () => {\r\n                  clearTimeout(scrollTimeout);\r\n                  observer.disconnect();\r\n                  container.removeEventListener('load', handleImageLoad, true);\r\n                };\r\n              }, [stickToBottom, arrayKeys.length, scrollToBottom]);\r\n              // Create virtual state\r\n              const virtualState = useMemo(() => {\r\n                const store = getGlobalStore.getState();\r\n                const sourceArray = store.getShadowValue(\r\n                  [stateKey, ...path].join('.')\r\n                ) as any[];\r\n                const currentKeys =\r\n                  store.getShadowMetadata(stateKey, path)?.arrayKeys || [];\r\n\r\n                const slicedArray = sourceArray.slice(\r\n                  range.startIndex,\r\n                  range.endIndex + 1\r\n                );\r\n                const slicedIds = currentKeys.slice(\r\n                  range.startIndex,\r\n                  range.endIndex + 1\r\n                );\r\n\r\n                return rebuildStateShape({\r\n                  currentState: slicedArray as any,\r\n                  path,\r\n                  componentId: componentId!,\r\n                  meta: { ...meta, validIds: slicedIds },\r\n                });\r\n              }, [range.startIndex, range.endIndex, arrayKeys.length]);\r\n\r\n              return {\r\n                virtualState,\r\n                virtualizerProps: {\r\n                  outer: {\r\n                    ref: containerRef,\r\n                    style: {\r\n                      overflowY: 'auto',\r\n                      height: '100%',\r\n                      position: 'relative',\r\n                    },\r\n                  },\r\n                  inner: {\r\n                    style: {\r\n                      height: `${totalHeight}px`,\r\n                      position: 'relative',\r\n                    },\r\n                  },\r\n                  list: {\r\n                    style: {\r\n                      transform: `translateY(${\r\n                        measurementCache.current.get(\r\n                          arrayKeys[range.startIndex]!\r\n                        )?.offset || 0\r\n                      }px)`,\r\n                    },\r\n                  },\r\n                },\r\n                scrollToBottom,\r\n                scrollToIndex: (\r\n                  index: number,\r\n                  behavior: ScrollBehavior = 'smooth'\r\n                ) => {\r\n                  if (containerRef.current && arrayKeys[index]) {\r\n                    const offset =\r\n                      measurementCache.current.get(arrayKeys[index]!)?.offset ||\r\n                      0;\r\n                    containerRef.current.scrollTo({ top: offset, behavior });\r\n                  }\r\n                },\r\n              };\r\n            };\r\n          }\r\n          if (prop === 'stateMap') {\r\n            return (\r\n              callbackfn: (\r\n                setter: any,\r\n                index: number,\r\n\r\n                arraySetter: any\r\n              ) => void\r\n            ) => {\r\n              const [arrayKeys, setArrayKeys] = useState<any>(\r\n                meta?.validIds ??\r\n                  getGlobalStore.getState().getShadowMetadata(stateKey, path)\r\n                    ?.arrayKeys\r\n              );\r\n              // getGlobalStore.getState().subscribeToPath(stateKeyPathKey, () => {\r\n              //   console.log(\r\n              //     \"stateKeyPathKeyccccccccccccccccc\",\r\n              //     stateKeyPathKey\r\n              //   );\r\n              //   setArrayKeys(\r\n              //     getGlobalStore.getState().getShadowMetadata(stateKey, path)\r\n              //   );\r\n              // });\r\n\r\n              const shadowValue = getGlobalStore\r\n                .getState()\r\n                .getShadowValue(stateKeyPathKey, meta?.validIds) as any[];\r\n              if (!arrayKeys) {\r\n                throw new Error('No array keys found for mapping');\r\n              }\r\n              const arraySetter = rebuildStateShape({\r\n                currentState: shadowValue as any,\r\n                path,\r\n                componentId: componentId!,\r\n                meta,\r\n              });\r\n\r\n              return shadowValue.map((item, index) => {\r\n                const itemPath = arrayKeys[index]?.split('.').slice(1);\r\n                const itemSetter = rebuildStateShape({\r\n                  currentState: item,\r\n                  path: itemPath as any,\r\n                  componentId: componentId!,\r\n                  meta,\r\n                });\r\n\r\n                return callbackfn(\r\n                  itemSetter,\r\n                  index,\r\n\r\n                  arraySetter\r\n                );\r\n              });\r\n            };\r\n          }\r\n\r\n          if (prop === '$stateMap') {\r\n            return (callbackfn: any) =>\r\n              createElement(SignalMapRenderer, {\r\n                proxy: {\r\n                  _stateKey: stateKey,\r\n                  _path: path,\r\n                  _mapFn: callbackfn,\r\n                  _meta: meta,\r\n                },\r\n                rebuildStateShape,\r\n              });\r\n          }\r\n          if (prop === 'stateFilter') {\r\n            return (callbackfn: (value: any, index: number) => boolean) => {\r\n              const arrayKeys =\r\n                meta?.validIds ??\r\n                getGlobalStore.getState().getShadowMetadata(stateKey, path)\r\n                  ?.arrayKeys;\r\n\r\n              if (!arrayKeys) {\r\n                throw new Error('No array keys found for filtering.');\r\n              }\r\n\r\n              const newValidIds: string[] = [];\r\n              const filteredArray = currentState.filter(\r\n                (val: any, index: number) => {\r\n                  const didPass = callbackfn(val, index);\r\n                  if (didPass) {\r\n                    newValidIds.push(arrayKeys[index]!);\r\n                    return true;\r\n                  }\r\n                  return false;\r\n                }\r\n              );\r\n\r\n              return rebuildStateShape({\r\n                currentState: filteredArray as any,\r\n                path,\r\n                componentId: componentId!,\r\n                meta: {\r\n                  validIds: newValidIds,\r\n                  transforms: [\r\n                    ...(meta?.transforms || []),\r\n                    {\r\n                      type: 'filter',\r\n                      fn: callbackfn,\r\n                    },\r\n                  ],\r\n                },\r\n              });\r\n            };\r\n          }\r\n          if (prop === 'stateSort') {\r\n            return (compareFn: (a: any, b: any) => number) => {\r\n              const arrayKeys =\r\n                meta?.validIds ??\r\n                getGlobalStore.getState().getShadowMetadata(stateKey, path)\r\n                  ?.arrayKeys;\r\n              if (!arrayKeys) {\r\n                throw new Error('No array keys found for sorting');\r\n              }\r\n              const itemsWithIds = currentState.map((item, index) => ({\r\n                item,\r\n                key: arrayKeys[index],\r\n              }));\r\n\r\n              itemsWithIds\r\n                .sort((a, b) => compareFn(a.item, b.item))\r\n                .filter(Boolean);\r\n\r\n              return rebuildStateShape({\r\n                currentState: itemsWithIds.map((i) => i.item) as any,\r\n                path,\r\n                componentId: componentId!,\r\n                meta: {\r\n                  validIds: itemsWithIds.map((i) => i.key) as string[],\r\n                  transforms: [\r\n                    ...(meta?.transforms || []),\r\n                    { type: 'sort', fn: compareFn },\r\n                  ],\r\n                },\r\n              });\r\n            };\r\n          }\r\n          // In createProxyHandler, inside the get trap where you have other array methods:\r\n          if (prop === 'stream') {\r\n            return function <U = InferArrayElement<T>, R = U>(\r\n              options: StreamOptions<U, R> = {}\r\n            ): StreamHandle<U> {\r\n              const {\r\n                bufferSize = 100,\r\n                flushInterval = 100,\r\n                bufferStrategy = 'accumulate',\r\n                store,\r\n                onFlush,\r\n              } = options;\r\n\r\n              let buffer: U[] = [];\r\n              let isPaused = false;\r\n              let flushTimer: NodeJS.Timeout | null = null;\r\n\r\n              const addToBuffer = (item: U) => {\r\n                if (isPaused) return;\r\n\r\n                if (\r\n                  bufferStrategy === 'sliding' &&\r\n                  buffer.length >= bufferSize\r\n                ) {\r\n                  buffer.shift();\r\n                } else if (\r\n                  bufferStrategy === 'dropping' &&\r\n                  buffer.length >= bufferSize\r\n                ) {\r\n                  return;\r\n                }\r\n\r\n                buffer.push(item);\r\n\r\n                if (buffer.length >= bufferSize) {\r\n                  flushBuffer();\r\n                }\r\n              };\r\n\r\n              const flushBuffer = () => {\r\n                if (buffer.length === 0) return;\r\n\r\n                const toFlush = [...buffer];\r\n                buffer = [];\r\n\r\n                if (store) {\r\n                  const result = store(toFlush);\r\n                  if (result !== undefined) {\r\n                    const items = Array.isArray(result) ? result : [result];\r\n                    items.forEach((item) => {\r\n                      effectiveSetState(item as any, path, {\r\n                        updateType: 'insert',\r\n                      });\r\n                    });\r\n                  }\r\n                } else {\r\n                  toFlush.forEach((item) => {\r\n                    effectiveSetState(item as any, path, {\r\n                      updateType: 'insert',\r\n                    });\r\n                  });\r\n                }\r\n\r\n                onFlush?.(toFlush);\r\n              };\r\n\r\n              if (flushInterval > 0) {\r\n                flushTimer = setInterval(flushBuffer, flushInterval);\r\n              }\r\n\r\n              const streamId = uuidv4();\r\n              const currentMeta =\r\n                getGlobalStore.getState().getShadowMetadata(stateKey, path) ||\r\n                {};\r\n              const streams = currentMeta.streams || new Map();\r\n              streams.set(streamId, { buffer, flushTimer });\r\n\r\n              getGlobalStore.getState().setShadowMetadata(stateKey, path, {\r\n                ...currentMeta,\r\n                streams,\r\n              });\r\n\r\n              return {\r\n                write: (data: U) => addToBuffer(data),\r\n                writeMany: (data: U[]) => data.forEach(addToBuffer),\r\n                flush: () => flushBuffer(),\r\n                pause: () => {\r\n                  isPaused = true;\r\n                },\r\n                resume: () => {\r\n                  isPaused = false;\r\n                  if (buffer.length > 0) flushBuffer();\r\n                },\r\n                close: () => {\r\n                  flushBuffer();\r\n                  if (flushTimer) clearInterval(flushTimer);\r\n\r\n                  const meta = getGlobalStore\r\n                    .getState()\r\n                    .getShadowMetadata(stateKey, path);\r\n                  if (meta?.streams) {\r\n                    meta.streams.delete(streamId);\r\n                  }\r\n                },\r\n              };\r\n            };\r\n          }\r\n\r\n          if (prop === 'stateList') {\r\n            return (\r\n              callbackfn: (\r\n                setter: any,\r\n                index: number,\r\n                arraySetter: any\r\n              ) => ReactNode\r\n            ) => {\r\n              const StateListWrapper = () => {\r\n                const componentIdsRef = useRef<Map<string, string>>(new Map());\r\n\r\n                const cacheKey =\r\n                  meta?.transforms && meta.transforms.length > 0\r\n                    ? `${componentId}-${hashTransforms(meta.transforms)}`\r\n                    : `${componentId}-base`;\r\n\r\n                const [updateTrigger, forceUpdate] = useState({});\r\n\r\n                const { validIds, arrayValues } = useMemo(() => {\r\n                  const cached = getGlobalStore\r\n                    .getState()\r\n                    .getShadowMetadata(stateKey, path)\r\n                    ?.transformCaches?.get(cacheKey);\r\n\r\n                  let freshValidIds: string[];\r\n\r\n                  if (cached && cached.validIds) {\r\n                    freshValidIds = cached.validIds;\r\n                  } else {\r\n                    freshValidIds = applyTransforms(\r\n                      stateKey,\r\n                      path,\r\n                      meta?.transforms\r\n                    );\r\n\r\n                    getGlobalStore\r\n                      .getState()\r\n                      .setTransformCache(stateKey, path, cacheKey, {\r\n                        validIds: freshValidIds,\r\n                        computedAt: Date.now(),\r\n                        transforms: meta?.transforms || [],\r\n                      });\r\n                  }\r\n\r\n                  const freshValues = getGlobalStore\r\n                    .getState()\r\n                    .getShadowValue(stateKeyPathKey, freshValidIds);\r\n\r\n                  return {\r\n                    validIds: freshValidIds,\r\n                    arrayValues: freshValues || [],\r\n                  };\r\n                }, [cacheKey, updateTrigger]);\r\n\r\n                useEffect(() => {\r\n                  const unsubscribe = getGlobalStore\r\n                    .getState()\r\n                    .subscribeToPath(stateKeyPathKey, (e) => {\r\n                      // A data change has occurred for the source array.\r\n                      console.log('statelsit subscribed to path', e);\r\n                      if (e.type === 'GET_SELECTED') {\r\n                        return;\r\n                      }\r\n                      const shadowMeta = getGlobalStore\r\n                        .getState()\r\n                        .getShadowMetadata(stateKey, path);\r\n\r\n                      const caches = shadowMeta?.transformCaches;\r\n                      if (caches) {\r\n                        // Iterate over ALL keys in the cache map.\r\n                        for (const key of caches.keys()) {\r\n                          // If the key belongs to this component instance, delete it.\r\n                          // This purges caches for 'sort by name', 'sort by score', etc.\r\n                          if (key.startsWith(componentId)) {\r\n                            caches.delete(key);\r\n                          }\r\n                        }\r\n                      }\r\n                      if (e.type === 'INSERT') {\r\n                        forceUpdate({});\r\n                      }\r\n                    });\r\n\r\n                  return () => {\r\n                    unsubscribe();\r\n                  };\r\n\r\n                  // This effect's logic now depends on the componentId to perform the purge.\r\n                }, [componentId, stateKeyPathKey]);\r\n\r\n                if (!Array.isArray(arrayValues)) {\r\n                  return null;\r\n                }\r\n\r\n                const arraySetter = rebuildStateShape({\r\n                  currentState: arrayValues as any,\r\n                  path,\r\n                  componentId: componentId!,\r\n                  meta: {\r\n                    ...meta,\r\n                    validIds: validIds,\r\n                  },\r\n                });\r\n\r\n                return (\r\n                  <>\r\n                    {arrayValues.map((item, localIndex) => {\r\n                      const itemKey = validIds[localIndex];\r\n\r\n                      if (!itemKey) {\r\n                        return null;\r\n                      }\r\n\r\n                      let itemComponentId =\r\n                        componentIdsRef.current.get(itemKey);\r\n                      if (!itemComponentId) {\r\n                        itemComponentId = uuidv4();\r\n                        componentIdsRef.current.set(itemKey, itemComponentId);\r\n                      }\r\n\r\n                      const itemPath = itemKey.split('.').slice(1);\r\n\r\n                      return createElement(MemoizedCogsItemWrapper, {\r\n                        key: itemKey,\r\n                        stateKey,\r\n                        itemComponentId,\r\n                        itemPath,\r\n                        localIndex,\r\n                        arraySetter,\r\n                        rebuildStateShape,\r\n                        renderFn: callbackfn,\r\n                      });\r\n                    })}\r\n                  </>\r\n                );\r\n              };\r\n\r\n              return <StateListWrapper />;\r\n            };\r\n          }\r\n          if (prop === 'stateFlattenOn') {\r\n            return (fieldName: string) => {\r\n              const arrayToMap = currentState as any[];\r\n              shapeCache.clear();\r\n              stateVersion++;\r\n              const flattenedResults = arrayToMap.flatMap(\r\n                (val: any) => val[fieldName] ?? []\r\n              );\r\n              return rebuildStateShape({\r\n                currentState: flattenedResults as any,\r\n                path: [...path, '[*]', fieldName],\r\n                componentId: componentId!,\r\n                meta,\r\n              });\r\n            };\r\n          }\r\n          if (prop === 'index') {\r\n            return (index: number) => {\r\n              const arrayKeys = getGlobalStore\r\n                .getState()\r\n                .getShadowMetadata(stateKey, path)\r\n                ?.arrayKeys?.filter(\r\n                  (key) =>\r\n                    !meta?.validIds ||\r\n                    (meta?.validIds && meta?.validIds?.includes(key))\r\n                );\r\n              const itemId = arrayKeys?.[index];\r\n              if (!itemId) return undefined;\r\n              const value = getGlobalStore\r\n                .getState()\r\n                .getShadowValue(itemId, meta?.validIds);\r\n              const state = rebuildStateShape({\r\n                currentState: value,\r\n                path: itemId.split('.').slice(1) as string[],\r\n                componentId: componentId!,\r\n                meta,\r\n              });\r\n              return state;\r\n            };\r\n          }\r\n          if (prop === 'last') {\r\n            return () => {\r\n              const currentArray = getGlobalStore\r\n                .getState()\r\n                .getShadowValue(stateKey, path) as any[];\r\n              if (currentArray.length === 0) return undefined;\r\n              const lastIndex = currentArray.length - 1;\r\n              const lastValue = currentArray[lastIndex];\r\n              const newPath = [...path, lastIndex.toString()];\r\n              return rebuildStateShape({\r\n                currentState: lastValue,\r\n                path: newPath,\r\n                componentId: componentId!,\r\n                meta,\r\n              });\r\n            };\r\n          }\r\n          if (prop === 'insert') {\r\n            return (\r\n              payload: InsertParams<InferArrayElement<T>>,\r\n              index?: number\r\n            ) => {\r\n              effectiveSetState(payload as any, path, { updateType: 'insert' });\r\n              return rebuildStateShape({\r\n                currentState: getGlobalStore\r\n                  .getState()\r\n                  .getShadowValue(stateKey, path),\r\n                path,\r\n                componentId: componentId!,\r\n                meta,\r\n              });\r\n            };\r\n          }\r\n          if (prop === 'uniqueInsert') {\r\n            return (\r\n              payload: UpdateArg<T>,\r\n              fields?: (keyof InferArrayElement<T>)[],\r\n              onMatch?: (existingItem: any) => any\r\n            ) => {\r\n              const currentArray = getGlobalStore\r\n                .getState()\r\n                .getShadowValue(stateKey, path) as any[];\r\n              const newValue = isFunction<T>(payload)\r\n                ? payload(currentArray as any)\r\n                : (payload as any);\r\n\r\n              let matchedItem: any = null;\r\n              const isUnique = !currentArray.some((item) => {\r\n                const isMatch = fields\r\n                  ? fields.every((field) =>\r\n                      isDeepEqual(item[field], newValue[field])\r\n                    )\r\n                  : isDeepEqual(item, newValue);\r\n                if (isMatch) matchedItem = item;\r\n                return isMatch;\r\n              });\r\n\r\n              if (isUnique) {\r\n                invalidateCachePath(path);\r\n                effectiveSetState(newValue, path, { updateType: 'insert' });\r\n              } else if (onMatch && matchedItem) {\r\n                const updatedItem = onMatch(matchedItem);\r\n                const updatedArray = currentArray.map((item) =>\r\n                  isDeepEqual(item, matchedItem) ? updatedItem : item\r\n                );\r\n                invalidateCachePath(path);\r\n                effectiveSetState(updatedArray as any, path, {\r\n                  updateType: 'update',\r\n                });\r\n              }\r\n            };\r\n          }\r\n\r\n          if (prop === 'cut') {\r\n            return (index?: number, options?: { waitForSync?: boolean }) => {\r\n              const validKeys =\r\n                meta?.validIds ??\r\n                getGlobalStore.getState().getShadowMetadata(stateKey, path)\r\n                  ?.arrayKeys;\r\n\r\n              if (!validKeys || validKeys.length === 0) return;\r\n\r\n              const indexToCut =\r\n                index == -1\r\n                  ? validKeys.length - 1\r\n                  : index !== undefined\r\n                    ? index\r\n                    : validKeys.length - 1;\r\n\r\n              const fullIdToCut = validKeys[indexToCut];\r\n              if (!fullIdToCut) return; // Index out of bounds\r\n\r\n              const pathForCut = fullIdToCut.split('.').slice(1);\r\n              effectiveSetState(currentState, pathForCut, {\r\n                updateType: 'cut',\r\n              });\r\n            };\r\n          }\r\n          if (prop === 'cutSelected') {\r\n            return () => {\r\n              const baseArrayKeys =\r\n                getGlobalStore.getState().getShadowMetadata(stateKey, path)\r\n                  ?.arrayKeys || [];\r\n              const validKeys = applyTransforms(\r\n                stateKey,\r\n                path,\r\n                meta?.transforms\r\n              );\r\n              console.log('validKeys', validKeys);\r\n              if (!validKeys || validKeys.length === 0) return;\r\n\r\n              const indexKeyToCut = getGlobalStore\r\n                .getState()\r\n                .selectedIndicesMap.get(stateKeyPathKey);\r\n\r\n              let indexToCut = validKeys.findIndex(\r\n                (key) => key === indexKeyToCut\r\n              );\r\n              console.log('indexToCut', indexToCut);\r\n              const pathForCut = validKeys[\r\n                indexToCut == -1 ? validKeys.length - 1 : indexToCut\r\n              ]\r\n                ?.split('.')\r\n                .slice(1);\r\n              console.log('pathForCut', pathForCut);\r\n              effectiveSetState(currentState, pathForCut!, {\r\n                updateType: 'cut',\r\n              });\r\n            };\r\n          }\r\n          if (prop === 'cutByValue') {\r\n            return (value: string | number | boolean) => {\r\n              // Step 1: Get the list of all unique keys for the current view.\r\n              const arrayMeta = getGlobalStore\r\n                .getState()\r\n                .getShadowMetadata(stateKey, path);\r\n              const relevantKeys = meta?.validIds ?? arrayMeta?.arrayKeys;\r\n\r\n              if (!relevantKeys) return;\r\n\r\n              let keyToCut: string | null = null;\r\n\r\n              // Step 2: Iterate through the KEYS, get the value for each, and find the match.\r\n              for (const key of relevantKeys) {\r\n                const itemValue = getGlobalStore.getState().getShadowValue(key);\r\n                if (itemValue === value) {\r\n                  keyToCut = key;\r\n                  break; // We found the key, no need to search further.\r\n                }\r\n              }\r\n\r\n              // Step 3: If we found a matching key, use it to perform the cut.\r\n              if (keyToCut) {\r\n                const itemPath = keyToCut.split('.').slice(1);\r\n                effectiveSetState(null as any, itemPath, { updateType: 'cut' });\r\n              }\r\n            };\r\n          }\r\n\r\n          if (prop === 'toggleByValue') {\r\n            return (value: string | number | boolean) => {\r\n              // Step 1: Get the list of all unique keys for the current view.\r\n              const arrayMeta = getGlobalStore\r\n                .getState()\r\n                .getShadowMetadata(stateKey, path);\r\n              const relevantKeys = meta?.validIds ?? arrayMeta?.arrayKeys;\r\n\r\n              if (!relevantKeys) return;\r\n\r\n              let keyToCut: string | null = null;\r\n\r\n              // Step 2: Iterate through the KEYS to find the one matching the value. This is the robust way.\r\n              for (const key of relevantKeys) {\r\n                const itemValue = getGlobalStore.getState().getShadowValue(key);\r\n                console.log('itemValue sdasdasdasd', itemValue);\r\n                if (itemValue === value) {\r\n                  keyToCut = key;\r\n                  break; // Found it!\r\n                }\r\n              }\r\n              console.log('itemValue keyToCut', keyToCut);\r\n              // Step 3: Act based on whether the key was found.\r\n              if (keyToCut) {\r\n                // Item exists, so we CUT it using its *actual* key.\r\n                const itemPath = keyToCut.split('.').slice(1);\r\n                console.log('itemValue keyToCut', keyToCut);\r\n                effectiveSetState(value as any, itemPath, {\r\n                  updateType: 'cut',\r\n                });\r\n              } else {\r\n                // Item does not exist, so we INSERT it.\r\n                effectiveSetState(value as any, path, { updateType: 'insert' });\r\n              }\r\n            };\r\n          }\r\n          if (prop === 'findWith') {\r\n            return (\r\n              searchKey: keyof InferArrayElement<T>,\r\n              searchValue: any\r\n            ) => {\r\n              const arrayKeys = getGlobalStore\r\n                .getState()\r\n                .getShadowMetadata(stateKey, path)?.arrayKeys;\r\n\r\n              if (!arrayKeys) {\r\n                throw new Error('No array keys found for sorting');\r\n              }\r\n\r\n              let value = null;\r\n              let foundPath: string[] = [];\r\n\r\n              for (const fullPath of arrayKeys) {\r\n                let shadowValue = getGlobalStore\r\n                  .getState()\r\n                  .getShadowValue(fullPath, meta?.validIds);\r\n                if (shadowValue && shadowValue[searchKey] === searchValue) {\r\n                  value = shadowValue;\r\n                  foundPath = fullPath.split('.').slice(1);\r\n                  break;\r\n                }\r\n              }\r\n\r\n              return rebuildStateShape({\r\n                currentState: value as any,\r\n                path: foundPath,\r\n                componentId: componentId!,\r\n                meta,\r\n              });\r\n            };\r\n          }\r\n        }\r\n\r\n        if (prop === 'cut') {\r\n          let shadowValue = getGlobalStore\r\n            .getState()\r\n            .getShadowValue(path.join('.'));\r\n\r\n          return () => {\r\n            effectiveSetState(shadowValue, path, { updateType: 'cut' });\r\n          };\r\n        }\r\n\r\n        if (prop === 'get') {\r\n          return () => {\r\n            registerComponentDependency(stateKey, componentId, path);\r\n            return getGlobalStore\r\n              .getState()\r\n              .getShadowValue(stateKeyPathKey, meta?.validIds);\r\n          };\r\n        }\r\n        if (prop === '$derive') {\r\n          return (fn: any) =>\r\n            $cogsSignal({\r\n              _stateKey: stateKey,\r\n              _path: path,\r\n              _effect: fn.toString(),\r\n              _meta: meta,\r\n            });\r\n        }\r\n        // in CogsState.ts -> createProxyHandler -> handler -> get\r\n\r\n        if (prop === '$get') {\r\n          return () =>\r\n            $cogsSignal({ _stateKey: stateKey, _path: path, _meta: meta });\r\n        }\r\n        if (prop === 'lastSynced') {\r\n          const syncKey = `${stateKey}:${path.join('.')}`;\r\n          return getGlobalStore.getState().getSyncInfo(syncKey);\r\n        }\r\n        if (prop == 'getLocalStorage') {\r\n          return (key: string) =>\r\n            loadFromLocalStorage(sessionId + '-' + stateKey + '-' + key);\r\n        }\r\n\r\n        if (prop === 'isSelected') {\r\n          const parentPath = [stateKey, ...path].slice(0, -1);\r\n          notifySelectionComponents(stateKey, path, undefined);\r\n          if (\r\n            Array.isArray(\r\n              getGlobalStore\r\n                .getState()\r\n                .getShadowValue(parentPath.join('.'), meta?.validIds)\r\n            )\r\n          ) {\r\n            const itemId = path[path.length - 1];\r\n            const fullParentKey = parentPath.join('.');\r\n\r\n            const selectedItemKey = getGlobalStore\r\n              .getState()\r\n              .selectedIndicesMap.get(fullParentKey);\r\n\r\n            const fullItemKey = stateKey + '.' + path.join('.');\r\n\r\n            return selectedItemKey === fullItemKey;\r\n          }\r\n          return undefined;\r\n        }\r\n\r\n        // Then use it in both:\r\n        if (prop === 'setSelected') {\r\n          return (value: boolean) => {\r\n            const parentPath = path.slice(0, -1);\r\n            const fullParentKey = stateKey + '.' + parentPath.join('.');\r\n            const fullItemKey = stateKey + '.' + path.join('.');\r\n\r\n            notifySelectionComponents(stateKey, parentPath, undefined);\r\n\r\n            const selectedIndex = getGlobalStore\r\n              .getState()\r\n              .selectedIndicesMap.get(fullParentKey);\r\n\r\n            if (value) {\r\n              getGlobalStore\r\n                .getState()\r\n                .setSelectedIndex(fullParentKey, fullItemKey);\r\n            }\r\n          };\r\n        }\r\n\r\n        if (prop === 'toggleSelected') {\r\n          return () => {\r\n            const parentPath = path.slice(0, -1);\r\n            const fullParentKey = stateKey + '.' + parentPath.join('.');\r\n            const fullItemKey = stateKey + '.' + path.join('.');\r\n\r\n            const currentSelected = getGlobalStore\r\n              .getState()\r\n              .selectedIndicesMap.get(fullParentKey);\r\n\r\n            if (currentSelected === fullItemKey) {\r\n              getGlobalStore\r\n                .getState()\r\n                .clearSelectedIndex({ arrayKey: fullParentKey });\r\n            } else {\r\n              getGlobalStore\r\n                .getState()\r\n                .setSelectedIndex(fullParentKey, fullItemKey);\r\n            }\r\n          };\r\n        }\r\n        if (prop === '_componentId') {\r\n          return componentId;\r\n        }\r\n        if (path.length == 0) {\r\n          if (prop === 'addValidation') {\r\n            return (errors: ValidationError[]) => {\r\n              const init = getGlobalStore\r\n                .getState()\r\n                .getInitialOptions(stateKey)?.validation;\r\n              if (!init?.key) throw new Error('Validation key not found');\r\n              removeValidationError(init.key);\r\n              errors.forEach((error) => {\r\n                const fullErrorPath = [init.key, ...error.path].join('.');\r\n                addValidationError(fullErrorPath, error.message);\r\n              });\r\n              notifyComponents(stateKey);\r\n            };\r\n          }\r\n          if (prop === 'applyJsonPatch') {\r\n            return (patches: any[]) => {\r\n              const currentState = getGlobalStore\r\n                .getState()\r\n                .getShadowValue(stateKeyPathKey, meta?.validIds);\r\n              const newState = applyPatch(currentState, patches).newDocument;\r\n\r\n              notifyComponents(stateKey);\r\n            };\r\n          }\r\n          if (prop === 'validateZodSchema') {\r\n            return () => {\r\n              const init = getGlobalStore\r\n                .getState()\r\n                .getInitialOptions(stateKey)?.validation;\r\n              if (!init?.zodSchema || !init?.key)\r\n                throw new Error('Zod schema or validation key not found');\r\n\r\n              removeValidationError(init.key);\r\n              const thisObject = getGlobalStore\r\n                .getState()\r\n                .getShadowValue(stateKey);\r\n              const result = init.zodSchema.safeParse(thisObject);\r\n\r\n              if (!result.success) {\r\n                result.error.errors.forEach((error) => {\r\n                  const fullErrorPath = [init.key, ...error.path].join('.');\r\n                  addValidationError(fullErrorPath, error.message);\r\n                });\r\n                notifyComponents(stateKey);\r\n                return false;\r\n              }\r\n              return true;\r\n            };\r\n          }\r\n\r\n          if (prop === 'getComponents')\r\n            return () =>\r\n              getGlobalStore.getState().getShadowMetadata(stateKey, [])\r\n                ?.components;\r\n          if (prop === 'getAllFormRefs')\r\n            return () =>\r\n              formRefStore.getState().getFormRefsByStateKey(stateKey);\r\n        }\r\n        if (prop === 'getFormRef') {\r\n          return () =>\r\n            formRefStore.getState().getFormRef(stateKey + '.' + path.join('.'));\r\n        }\r\n        if (prop === 'validationWrapper') {\r\n          return ({\r\n            children,\r\n            hideMessage,\r\n          }: {\r\n            children: React.ReactNode;\r\n            hideMessage?: boolean;\r\n          }) => (\r\n            <ValidationWrapper\r\n              formOpts={\r\n                hideMessage ? { validation: { message: '' } } : undefined\r\n              }\r\n              path={path}\r\n              stateKey={stateKey}\r\n            >\r\n              {children}\r\n            </ValidationWrapper>\r\n          );\r\n        }\r\n        if (prop === '_stateKey') return stateKey;\r\n        if (prop === '_path') return path;\r\n        if (prop === 'update') {\r\n          return (payload: UpdateArg<T>) => {\r\n            effectiveSetState(payload as any, path, { updateType: 'update' });\r\n          };\r\n        }\r\n        if (prop === 'toggle') {\r\n          const currentValueAtPath = getGlobalStore\r\n            .getState()\r\n            .getShadowValue([stateKey, ...path].join('.'));\r\n\r\n          console.log('currentValueAtPath', currentValueAtPath);\r\n          if (typeof currentState != 'boolean') {\r\n            throw new Error('toggle() can only be used on boolean values');\r\n          }\r\n          return () => {\r\n            effectiveSetState(!currentValueAtPath as any, path, {\r\n              updateType: 'update',\r\n            });\r\n          };\r\n        }\r\n        if (prop === 'formElement') {\r\n          return (child: FormControl<T>, formOpts?: FormOptsType) => {\r\n            return (\r\n              <ValidationWrapper\r\n                formOpts={formOpts}\r\n                path={path}\r\n                stateKey={stateKey}\r\n              >\r\n                <FormElementWrapper\r\n                  stateKey={stateKey}\r\n                  path={path}\r\n                  rebuildStateShape={rebuildStateShape}\r\n                  setState={effectiveSetState}\r\n                  formOpts={formOpts}\r\n                  renderFn={child as any}\r\n                />\r\n              </ValidationWrapper>\r\n            );\r\n          };\r\n        }\r\n        const nextPath = [...path, prop];\r\n        const nextValue = getGlobalStore\r\n          .getState()\r\n          .getShadowValue(stateKey, nextPath);\r\n        return rebuildStateShape({\r\n          currentState: nextValue,\r\n          path: nextPath,\r\n          componentId: componentId!,\r\n          meta,\r\n        });\r\n      },\r\n    };\r\n\r\n    const proxyInstance = new Proxy(baseFunction, handler);\r\n    shapeCache.set(cacheKey, {\r\n      proxy: proxyInstance,\r\n      stateVersion: stateVersion,\r\n    });\r\n    return proxyInstance;\r\n  }\r\n\r\n  const baseObj = {\r\n    removeValidation: (obj?: { validationKey?: string }) => {\r\n      if (obj?.validationKey) {\r\n        removeValidationError(obj.validationKey);\r\n      }\r\n    },\r\n    revertToInitialState: (obj?: { validationKey?: string }) => {\r\n      const init = getGlobalStore\r\n        .getState()\r\n        .getInitialOptions(stateKey)?.validation;\r\n      if (init?.key) {\r\n        removeValidationError(init.key);\r\n      }\r\n\r\n      if (obj?.validationKey) {\r\n        removeValidationError(obj.validationKey);\r\n      }\r\n\r\n      const shadowMeta = getGlobalStore\r\n        .getState()\r\n        .getShadowMetadata(stateKey, []);\r\n      let revertState;\r\n\r\n      if (shadowMeta?.stateSource === 'server' && shadowMeta.baseServerState) {\r\n        // Revert to last known server state\r\n        revertState = shadowMeta.baseServerState;\r\n      } else {\r\n        // Revert to initial/default state\r\n        revertState = getGlobalStore.getState().initialStateGlobal[stateKey];\r\n      }\r\n      const initialState =\r\n        getGlobalStore.getState().initialStateGlobal[stateKey];\r\n\r\n      getGlobalStore.getState().clearSelectedIndexesForState(stateKey);\r\n      shapeCache.clear();\r\n      stateVersion++;\r\n      getGlobalStore.getState().initializeShadowState(stateKey, initialState);\r\n      const newProxy = rebuildStateShape({\r\n        currentState: initialState,\r\n        path: [],\r\n        componentId: componentId!,\r\n      });\r\n      const initalOptionsGet = getInitialOptions(stateKey as string);\r\n      const localKey = isFunction(initalOptionsGet?.localStorage?.key)\r\n        ? initalOptionsGet?.localStorage?.key(initialState)\r\n        : initalOptionsGet?.localStorage?.key;\r\n\r\n      const storageKey = `${sessionId}-${stateKey}-${localKey}`;\r\n\r\n      if (storageKey) {\r\n        localStorage.removeItem(storageKey);\r\n      }\r\n\r\n      const stateEntry = getGlobalStore\r\n        .getState()\r\n        .getShadowMetadata(stateKey, []);\r\n      if (stateEntry) {\r\n        stateEntry?.components?.forEach((component) => {\r\n          component.forceUpdate();\r\n        });\r\n      }\r\n\r\n      return initialState;\r\n    },\r\n    updateInitialState: (newState: T) => {\r\n      shapeCache.clear();\r\n      stateVersion++;\r\n\r\n      const newUpdaterState = createProxyHandler(\r\n        stateKey,\r\n        effectiveSetState,\r\n        componentId,\r\n        sessionId\r\n      );\r\n      const initialState =\r\n        getGlobalStore.getState().initialStateGlobal[stateKey];\r\n      const initalOptionsGet = getInitialOptions(stateKey as string);\r\n      const localKey = isFunction(initalOptionsGet?.localStorage?.key)\r\n        ? initalOptionsGet?.localStorage?.key(initialState)\r\n        : initalOptionsGet?.localStorage?.key;\r\n\r\n      const storageKey = `${sessionId}-${stateKey}-${localKey}`;\r\n\r\n      if (localStorage.getItem(storageKey)) {\r\n        localStorage.removeItem(storageKey);\r\n      }\r\n      startTransition(() => {\r\n        updateInitialStateGlobal(stateKey, newState);\r\n        getGlobalStore.getState().initializeShadowState(stateKey, newState);\r\n\r\n        const stateEntry = getGlobalStore\r\n          .getState()\r\n          .getShadowMetadata(stateKey, []);\r\n\r\n        if (stateEntry) {\r\n          stateEntry?.components?.forEach((component) => {\r\n            component.forceUpdate();\r\n          });\r\n        }\r\n      });\r\n\r\n      return {\r\n        fetchId: (field: keyof T) => (newUpdaterState.get() as any)[field],\r\n      };\r\n    },\r\n  };\r\n  const returnShape = rebuildStateShape({\r\n    currentState: getGlobalStore.getState().getShadowValue(stateKey, []),\r\n    componentId,\r\n    path: [],\r\n  });\r\n\r\n  return returnShape;\r\n}\r\n\r\nexport function $cogsSignal(proxy: {\r\n  _path: string[];\r\n  _stateKey: string;\r\n  _effect?: string;\r\n\r\n  _meta?: MetaData;\r\n}) {\r\n  return createElement(SignalRenderer, { proxy });\r\n}\r\n\r\nfunction SignalMapRenderer({\r\n  proxy,\r\n  rebuildStateShape,\r\n}: {\r\n  proxy: {\r\n    _stateKey: string;\r\n    _path: string[];\r\n    _meta?: MetaData;\r\n    _mapFn: (\r\n      setter: any,\r\n      index: number,\r\n\r\n      arraySetter: any\r\n    ) => ReactNode;\r\n  };\r\n  rebuildStateShape: (stuff: {\r\n    currentState: any;\r\n    path: string[];\r\n    componentId: string;\r\n    meta?: MetaData;\r\n  }) => any;\r\n}): JSX.Element | null {\r\n  const containerRef = useRef<HTMLDivElement>(null);\r\n  const instanceIdRef = useRef<string>(`map-${crypto.randomUUID()}`);\r\n  const isSetupRef = useRef(false);\r\n  const rootsMapRef = useRef<Map<string, any>>(new Map());\r\n\r\n  // Setup effect - store the map function in shadow metadata\r\n  useEffect(() => {\r\n    const container = containerRef.current;\r\n    if (!container || isSetupRef.current) return;\r\n\r\n    const timeoutId = setTimeout(() => {\r\n      // Store map wrapper in metadata\r\n      const currentMeta =\r\n        getGlobalStore\r\n          .getState()\r\n          .getShadowMetadata(proxy._stateKey, proxy._path) || {};\r\n\r\n      const mapWrappers = currentMeta.mapWrappers || [];\r\n      mapWrappers.push({\r\n        instanceId: instanceIdRef.current,\r\n        mapFn: proxy._mapFn,\r\n        containerRef: container,\r\n        rebuildStateShape: rebuildStateShape,\r\n        path: proxy._path,\r\n        componentId: instanceIdRef.current,\r\n        meta: proxy._meta,\r\n      });\r\n\r\n      getGlobalStore\r\n        .getState()\r\n        .setShadowMetadata(proxy._stateKey, proxy._path, {\r\n          ...currentMeta,\r\n          mapWrappers,\r\n        });\r\n\r\n      isSetupRef.current = true;\r\n\r\n      // Initial render\r\n      renderInitialItems();\r\n    }, 0);\r\n\r\n    // Cleanup\r\n    return () => {\r\n      clearTimeout(timeoutId);\r\n      if (instanceIdRef.current) {\r\n        const currentMeta =\r\n          getGlobalStore\r\n            .getState()\r\n            .getShadowMetadata(proxy._stateKey, proxy._path) || {};\r\n        if (currentMeta.mapWrappers) {\r\n          currentMeta.mapWrappers = currentMeta.mapWrappers.filter(\r\n            (w) => w.instanceId !== instanceIdRef.current\r\n          );\r\n          getGlobalStore\r\n            .getState()\r\n            .setShadowMetadata(proxy._stateKey, proxy._path, currentMeta);\r\n        }\r\n      }\r\n      rootsMapRef.current.forEach((root) => root.unmount());\r\n    };\r\n  }, []);\r\n\r\n  const renderInitialItems = () => {\r\n    const container = containerRef.current;\r\n    if (!container) return;\r\n\r\n    const value = getGlobalStore\r\n      .getState()\r\n      .getShadowValue(\r\n        [proxy._stateKey, ...proxy._path].join('.'),\r\n        proxy._meta?.validIds\r\n      ) as any[];\r\n\r\n    if (!Array.isArray(value)) return;\r\n\r\n    // --- BUG FIX IS HERE ---\r\n    // Prioritize the filtered IDs from the meta object, just like the regular `stateMap`.\r\n    // This ensures the keys match the filtered data.\r\n    const arrayKeys =\r\n      proxy._meta?.validIds ??\r\n      getGlobalStore.getState().getShadowMetadata(proxy._stateKey, proxy._path)\r\n        ?.arrayKeys ??\r\n      [];\r\n    // --- END OF FIX ---\r\n\r\n    const arraySetter = rebuildStateShape({\r\n      currentState: value,\r\n      path: proxy._path,\r\n      componentId: instanceIdRef.current,\r\n      meta: proxy._meta,\r\n    });\r\n\r\n    value.forEach((item, index) => {\r\n      const itemKey = arrayKeys[index]!; // Now this will be the correct key for the filtered item\r\n      if (!itemKey) return; // Safeguard if there's a mismatch\r\n\r\n      const itemComponentId = uuidv4();\r\n      const itemElement = document.createElement('div');\r\n\r\n      itemElement.setAttribute('data-item-path', itemKey);\r\n      container.appendChild(itemElement);\r\n\r\n      const root = createRoot(itemElement);\r\n      rootsMapRef.current.set(itemKey, root);\r\n\r\n      const itemPath = itemKey.split('.').slice(1) as string[];\r\n\r\n      // Render CogsItemWrapper instead of direct render\r\n      root.render(\r\n        createElement(MemoizedCogsItemWrapper, {\r\n          stateKey: proxy._stateKey,\r\n          itemComponentId: itemComponentId,\r\n          itemPath: itemPath,\r\n          localIndex: index,\r\n          arraySetter: arraySetter,\r\n          rebuildStateShape: rebuildStateShape,\r\n          renderFn: proxy._mapFn,\r\n        })\r\n      );\r\n    });\r\n  };\r\n\r\n  return <div ref={containerRef} data-map-container={instanceIdRef.current} />;\r\n}\r\n\r\nfunction SignalRenderer({\r\n  proxy,\r\n}: {\r\n  proxy: {\r\n    _path: string[];\r\n    _stateKey: string;\r\n    _effect?: string;\r\n    _meta?: MetaData;\r\n  };\r\n}) {\r\n  const elementRef = useRef<HTMLSpanElement>(null);\r\n  const instanceIdRef = useRef<string | null>(null);\r\n  const isSetupRef = useRef(false);\r\n  const signalId = `${proxy._stateKey}-${proxy._path.join('.')}`;\r\n  const value = getGlobalStore\r\n    .getState()\r\n    .getShadowValue(\r\n      [proxy._stateKey, ...proxy._path].join('.'),\r\n      proxy._meta?.validIds\r\n    );\r\n\r\n  // Setup effect - runs only once\r\n  useEffect(() => {\r\n    const element = elementRef.current;\r\n    if (!element || isSetupRef.current) return;\r\n\r\n    const timeoutId = setTimeout(() => {\r\n      if (!element.parentElement) {\r\n        console.warn('Parent element not found for signal', signalId);\r\n        return;\r\n      }\r\n\r\n      const parentElement = element.parentElement;\r\n      const childNodes = Array.from(parentElement.childNodes);\r\n      const position = childNodes.indexOf(element);\r\n\r\n      let parentId = parentElement.getAttribute('data-parent-id');\r\n      if (!parentId) {\r\n        parentId = `parent-${crypto.randomUUID()}`;\r\n        parentElement.setAttribute('data-parent-id', parentId);\r\n      }\r\n\r\n      instanceIdRef.current = `instance-${crypto.randomUUID()}`;\r\n\r\n      // Store signal info in shadow metadata\r\n      const currentMeta =\r\n        getGlobalStore\r\n          .getState()\r\n          .getShadowMetadata(proxy._stateKey, proxy._path) || {};\r\n      const signals = currentMeta.signals || [];\r\n      signals.push({\r\n        instanceId: instanceIdRef.current,\r\n        parentId,\r\n        position,\r\n        effect: proxy._effect,\r\n      });\r\n\r\n      getGlobalStore\r\n        .getState()\r\n        .setShadowMetadata(proxy._stateKey, proxy._path, {\r\n          ...currentMeta,\r\n          signals,\r\n        });\r\n\r\n      let displayValue = value;\r\n      if (proxy._effect) {\r\n        try {\r\n          displayValue = new Function(\r\n            'state',\r\n            `return (${proxy._effect})(state)`\r\n          )(value);\r\n        } catch (err) {\r\n          console.error('Error evaluating effect function:', err);\r\n        }\r\n      }\r\n\r\n      if (displayValue !== null && typeof displayValue === 'object') {\r\n        displayValue = JSON.stringify(displayValue);\r\n      }\r\n      const textNode = document.createTextNode(String(displayValue ?? ''));\r\n      element.replaceWith(textNode);\r\n      isSetupRef.current = true;\r\n    }, 0);\r\n\r\n    return () => {\r\n      clearTimeout(timeoutId);\r\n      if (instanceIdRef.current) {\r\n        const currentMeta =\r\n          getGlobalStore\r\n            .getState()\r\n            .getShadowMetadata(proxy._stateKey, proxy._path) || {};\r\n        if (currentMeta.signals) {\r\n          currentMeta.signals = currentMeta.signals.filter(\r\n            (s) => s.instanceId !== instanceIdRef.current\r\n          );\r\n          getGlobalStore\r\n            .getState()\r\n            .setShadowMetadata(proxy._stateKey, proxy._path, currentMeta);\r\n        }\r\n      }\r\n    };\r\n  }, []);\r\n\r\n  return createElement('span', {\r\n    ref: elementRef,\r\n    style: { display: 'contents' },\r\n    'data-signal-id': signalId,\r\n  });\r\n}\r\n\r\nconst MemoizedCogsItemWrapper = memo(\r\n  ListItemWrapper,\r\n  (prevProps, nextProps) => {\r\n    // Re-render if any of these change:\r\n    return (\r\n      prevProps.itemPath.join('.') === nextProps.itemPath.join('.') &&\r\n      prevProps.stateKey === nextProps.stateKey &&\r\n      prevProps.itemComponentId === nextProps.itemComponentId &&\r\n      prevProps.localIndex === nextProps.localIndex\r\n    );\r\n  }\r\n);\r\n\r\nconst useImageLoaded = (ref: RefObject<HTMLElement>): boolean => {\r\n  const [loaded, setLoaded] = useState(false);\r\n\r\n  useLayoutEffect(() => {\r\n    if (!ref.current) {\r\n      setLoaded(true);\r\n      return;\r\n    }\r\n\r\n    const images = Array.from(ref.current.querySelectorAll('img'));\r\n\r\n    // If there are no images, we are \"loaded\" immediately.\r\n    if (images.length === 0) {\r\n      setLoaded(true);\r\n      return;\r\n    }\r\n\r\n    let loadedCount = 0;\r\n    const handleImageLoad = () => {\r\n      loadedCount++;\r\n      if (loadedCount === images.length) {\r\n        setLoaded(true);\r\n      }\r\n    };\r\n\r\n    images.forEach((image) => {\r\n      if (image.complete) {\r\n        handleImageLoad();\r\n      } else {\r\n        image.addEventListener('load', handleImageLoad);\r\n        image.addEventListener('error', handleImageLoad);\r\n      }\r\n    });\r\n\r\n    return () => {\r\n      images.forEach((image) => {\r\n        image.removeEventListener('load', handleImageLoad);\r\n        image.removeEventListener('error', handleImageLoad);\r\n      });\r\n    };\r\n  }, [ref.current]);\r\n\r\n  return loaded;\r\n};\r\n\r\nfunction ListItemWrapper({\r\n  stateKey,\r\n  itemComponentId,\r\n  itemPath,\r\n  localIndex,\r\n  arraySetter,\r\n  rebuildStateShape,\r\n  renderFn,\r\n}: {\r\n  stateKey: string;\r\n  itemComponentId: string;\r\n  itemPath: string[];\r\n  localIndex: number;\r\n  arraySetter: any;\r\n\r\n  rebuildStateShape: (options: {\r\n    currentState: any;\r\n    path: string[];\r\n    componentId: string;\r\n    meta?: any;\r\n  }) => any;\r\n  renderFn: (\r\n    setter: any,\r\n    index: number,\r\n\r\n    arraySetter: any\r\n  ) => React.ReactNode;\r\n}) {\r\n  const [, forceUpdate] = useState({});\r\n  const { ref: inViewRef, inView } = useInView();\r\n  const elementRef = useRef<HTMLDivElement | null>(null);\r\n\r\n  const imagesLoaded = useImageLoaded(elementRef);\r\n  const hasReportedInitialHeight = useRef(false);\r\n  const fullKey = [stateKey, ...itemPath].join('.');\r\n  useRegisterComponent(stateKey, itemComponentId, forceUpdate);\r\n  const setRefs = useCallback(\r\n    (element: HTMLDivElement | null) => {\r\n      elementRef.current = element;\r\n      inViewRef(element); // This is the ref from useInView\r\n    },\r\n    [inViewRef]\r\n  );\r\n\r\n  useEffect(() => {\r\n    getGlobalStore.getState().subscribeToPath(fullKey, (e) => {\r\n      forceUpdate({});\r\n    });\r\n  }, []);\r\n  useEffect(() => {\r\n    if (!inView || !imagesLoaded || hasReportedInitialHeight.current) {\r\n      return;\r\n    }\r\n\r\n    const element = elementRef.current;\r\n    if (element && element.offsetHeight > 0) {\r\n      hasReportedInitialHeight.current = true;\r\n      const newHeight = element.offsetHeight;\r\n\r\n      getGlobalStore.getState().setShadowMetadata(stateKey, itemPath, {\r\n        virtualizer: {\r\n          itemHeight: newHeight,\r\n          domRef: element,\r\n        },\r\n      });\r\n\r\n      const arrayPath = itemPath.slice(0, -1);\r\n      const arrayPathKey = [stateKey, ...arrayPath].join('.');\r\n      getGlobalStore.getState().notifyPathSubscribers(arrayPathKey, {\r\n        type: 'ITEMHEIGHT',\r\n        itemKey: itemPath.join('.'),\r\n\r\n        ref: elementRef.current,\r\n      });\r\n    }\r\n  }, [inView, imagesLoaded, stateKey, itemPath]);\r\n\r\n  const fullItemPath = [stateKey, ...itemPath].join('.');\r\n  const itemValue = getGlobalStore.getState().getShadowValue(fullItemPath);\r\n\r\n  if (itemValue === undefined) {\r\n    return null;\r\n  }\r\n\r\n  const itemSetter = rebuildStateShape({\r\n    currentState: itemValue,\r\n    path: itemPath,\r\n    componentId: itemComponentId,\r\n  });\r\n  const children = renderFn(itemSetter, localIndex, arraySetter);\r\n\r\n  return <div ref={setRefs}>{children}</div>;\r\n}\r\nfunction FormElementWrapper({\r\n  stateKey,\r\n  path,\r\n  rebuildStateShape,\r\n  renderFn,\r\n  formOpts,\r\n  setState,\r\n}: {\r\n  stateKey: string;\r\n  path: string[];\r\n  rebuildStateShape: (options: {\r\n    currentState: any;\r\n    path: string[];\r\n    componentId: string;\r\n    meta?: any;\r\n  }) => any;\r\n  renderFn: (params: FormElementParams<any>) => React.ReactNode;\r\n  formOpts?: FormOptsType;\r\n  setState: any;\r\n}) {\r\n  const [componentId] = useState(() => uuidv4());\r\n  const [, forceUpdate] = useState({});\r\n\r\n  const stateKeyPathKey = [stateKey, ...path].join('.');\r\n  useRegisterComponent(stateKey, componentId, forceUpdate);\r\n  const globalStateValue = getGlobalStore\r\n    .getState()\r\n    .getShadowValue(stateKeyPathKey);\r\n  const [localValue, setLocalValue] = useState<any>(globalStateValue);\r\n  const isCurrentlyDebouncing = useRef(false);\r\n  const debounceTimeoutRef = useRef<NodeJS.Timeout | null>(null);\r\n\r\n  useEffect(() => {\r\n    if (\r\n      !isCurrentlyDebouncing.current &&\r\n      !isDeepEqual(globalStateValue, localValue)\r\n    ) {\r\n      setLocalValue(globalStateValue);\r\n    }\r\n  }, [globalStateValue]);\r\n\r\n  useEffect(() => {\r\n    const unsubscribe = getGlobalStore\r\n      .getState()\r\n      .subscribeToPath(stateKeyPathKey, (newValue) => {\r\n        forceUpdate({});\r\n      });\r\n    return () => {\r\n      unsubscribe();\r\n      if (debounceTimeoutRef.current) {\r\n        clearTimeout(debounceTimeoutRef.current);\r\n        isCurrentlyDebouncing.current = false;\r\n      }\r\n    };\r\n  }, []);\r\n\r\n  const debouncedUpdate = useCallback(\r\n    (newValue: any) => {\r\n      setLocalValue(newValue);\r\n      isCurrentlyDebouncing.current = true;\r\n\r\n      if (debounceTimeoutRef.current) {\r\n        clearTimeout(debounceTimeoutRef.current);\r\n      }\r\n\r\n      const debounceTime = formOpts?.debounceTime ?? 200;\r\n\r\n      debounceTimeoutRef.current = setTimeout(() => {\r\n        isCurrentlyDebouncing.current = false;\r\n        setState(newValue, path, { updateType: 'update' });\r\n      }, debounceTime);\r\n    },\r\n    [setState, path, formOpts?.debounceTime]\r\n  );\r\n\r\n  const immediateUpdate = useCallback(() => {\r\n    if (debounceTimeoutRef.current) {\r\n      clearTimeout(debounceTimeoutRef.current);\r\n      isCurrentlyDebouncing.current = false;\r\n      setState(localValue, path, { updateType: 'update' });\r\n    }\r\n  }, [setState, path, localValue]);\r\n\r\n  const baseState = rebuildStateShape({\r\n    currentState: globalStateValue,\r\n    path: path,\r\n    componentId: componentId,\r\n  });\r\n\r\n  const stateWithInputProps = new Proxy(baseState, {\r\n    get(target, prop) {\r\n      if (prop === 'inputProps') {\r\n        return {\r\n          value: localValue ?? '',\r\n          onChange: (e: any) => {\r\n            debouncedUpdate(e.target.value);\r\n          },\r\n          onBlur: immediateUpdate,\r\n          ref: formRefStore\r\n            .getState()\r\n            .getFormRef(stateKey + '.' + path.join('.')),\r\n        };\r\n      }\r\n\r\n      return target[prop];\r\n    },\r\n  });\r\n\r\n  return <>{renderFn(stateWithInputProps)}</>;\r\n}\r\n\r\nfunction useRegisterComponent(\r\n  stateKey: string,\r\n  componentId: string,\r\n  forceUpdate: (o: object) => void\r\n) {\r\n  const fullComponentId = `${stateKey}////${componentId}`;\r\n\r\n  useLayoutEffect(() => {\r\n    const rootMeta = getGlobalStore.getState().getShadowMetadata(stateKey, []);\r\n    const components = rootMeta?.components || new Map();\r\n\r\n    components.set(fullComponentId, {\r\n      forceUpdate: () => forceUpdate({}),\r\n      paths: new Set(),\r\n      reactiveType: ['component'],\r\n    });\r\n\r\n    getGlobalStore.getState().setShadowMetadata(stateKey, [], {\r\n      ...rootMeta,\r\n      components,\r\n    });\r\n\r\n    return () => {\r\n      const meta = getGlobalStore.getState().getShadowMetadata(stateKey, []);\r\n      if (meta?.components) {\r\n        meta.components.delete(fullComponentId);\r\n      }\r\n    };\r\n  }, [stateKey, fullComponentId]);\r\n}\r\n"],"names":["setAndMergeOptions","stateKey","newOptions","getInitialOptions","getGlobalStore","setInitialStateOptions","initialOptions","setOptions","options","initialOptionsPart","initialOptionsPartState","mergedOptions","needToAdd","key","isDeepEqual","addStateOptions","initialState","formElements","validation","createCogsState","opt","newInitialState","statePart","transformStateFunc","existingOptions","existingGlobalOptions","useCogsState","componentId","useState","uuidv4","thiState","partialState","useCogsStateFn","setCogsOptions","loadAndApplyLocalStorage","notifyComponents","getValidationErrors","setStateLog","updateInitialStateGlobal","addValidationError","removeValidationError","saveToLocalStorage","state","thisKey","currentInitialOptions","sessionId","lastSyncedWithServer","isFunction","storageKey","existingLastSynced","loadFromLocalStorage","shadowMeta","data","superJsonResult","superjson","localStorageKey","storedData","error","currentState","useCogsConfig","localkey","localData","stateEntry","updates","component","update","notifyComponent","fullComponentId","stateObject","serverSync","localStorage","reactiveDeps","reactiveType","defaultState","syncUpdate","dependencies","serverState","reactiveForce","forceUpdate","noStateKey","stateLog","componentUpdatesRef","useRef","componentIdRef","latestInitialOptionsRef","useEffect","syncKey","resolveInitialState","useCallback","overrideOptions","currentOptions","finalDefaultState","localKey","event","serverStateData","mergeConfig","incomingData","keyField","existingIds","item","newUniqueItems","meta","existingMeta","resolvedState","source","timestamp","useLayoutEffect","componentKey","rootMeta","components","fullPath","path","pathMeta","effectiveSetState","newStateOrFunction","updateObj","validationKey","pathKey","store","nestedShadowValue","payload","newUpdate","parentArrayPath","displayValue","parentId","position","effect","parent","childNodes","finalDisplayValue","err","sourceArrayKeys","newItemKey","newItemValue","fullSourceArray","wrapper","shouldRender","insertPosition","transform","currentValidKeys","applyTransforms","sortTransform","t","allItems","a","b","itemElement","children","root","createRoot","itemPath","arraySetter","createElement","MemoizedCogsItemWrapper","arrayPath","arrayMeta","elementToRemove","arrayWithoutIndex","length","v","newKey","newState","notifiedComponents","isArray","getDifferences","subPathString","subPath","fullSubPath","subPathMeta","parentMeta","parentFullPath","parentValue","reactiveTypes","newDeps","shouldUpdate","prevLogs","logs","aggregatedLogs","log","uniqueKey","existing","useMemo","createProxyHandler","hashTransforms","transforms","arrayKeys","itemsWithKeys","value","index","registerComponentDependency","dependencyPath","pathComponents","notifySelectionComponents","parentPath","currentSelected","arrayKey","selectedItem","shapeCache","stateVersion","invalidateCachePath","rebuildStateShape","cacheKey","stateKeyPathKey","baseFunction","handler","target","thisArg","args","prop","baseObj","baseState","sync","response","errorPath","getStatusFunc","initalOptionsGet","init","fullKey","selectedIndicesMap","selectedItemKey","itemHeight","overscan","stickToBottom","scrollStickTolerance","containerRef","range","setRange","rerender","initialScrollRef","scrollStateRef","measurementCache","container","totalHeight","itemOffsets","runningOffset","offsets","itemKey","measuredHeight","waitForContainer","visibleCount","endIndex","startIndex","scrollToBottom","handleScroll","currentScrollTop","scrollHeight","clientHeight","scrollState","distanceFromBottom","wasNearBottom","newStartIndex","i","behavior","performScroll","attemptScroll","attempts","currentHeight","currentScroll","newHeight","newScroll","scrollTimeout","debouncedScrollToBottom","observer","handleImageLoad","e","sourceArray","currentKeys","slicedArray","slicedIds","offset","callbackfn","setArrayKeys","shadowValue","itemSetter","SignalMapRenderer","newValidIds","filteredArray","val","compareFn","itemsWithIds","bufferSize","flushInterval","bufferStrategy","onFlush","buffer","isPaused","flushTimer","addToBuffer","flushBuffer","toFlush","result","streamId","currentMeta","streams","componentIdsRef","updateTrigger","validIds","arrayValues","cached","freshValidIds","freshValues","unsubscribe","caches","jsx","Fragment","localIndex","itemComponentId","fieldName","arrayToMap","flattenedResults","itemId","currentArray","lastIndex","lastValue","newPath","fields","onMatch","newValue","matchedItem","isMatch","field","updatedItem","updatedArray","validKeys","indexToCut","fullIdToCut","pathForCut","indexKeyToCut","relevantKeys","keyToCut","itemValue","searchKey","searchValue","foundPath","fn","$cogsSignal","fullParentKey","fullItemKey","errors","fullErrorPath","patches","applyPatch","thisObject","formRefStore","hideMessage","ValidationWrapper","currentValueAtPath","child","formOpts","FormElementWrapper","nextPath","nextValue","proxyInstance","obj","newUpdaterState","startTransition","proxy","SignalRenderer","instanceIdRef","isSetupRef","rootsMapRef","timeoutId","mapWrappers","renderInitialItems","w","elementRef","signalId","element","parentElement","signals","textNode","s","memo","ListItemWrapper","prevProps","nextProps","useImageLoaded","ref","loaded","setLoaded","images","loadedCount","image","renderFn","inViewRef","inView","useInView","imagesLoaded","hasReportedInitialHeight","useRegisterComponent","setRefs","arrayPathKey","fullItemPath","setState","globalStateValue","localValue","setLocalValue","isCurrentlyDebouncing","debounceTimeoutRef","debouncedUpdate","debounceTime","immediateUpdate","stateWithInputProps"],"mappings":"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"}