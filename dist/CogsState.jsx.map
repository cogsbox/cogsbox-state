{"version":3,"file":"CogsState.jsx","sources":["../src/CogsState.tsx"],"sourcesContent":["'use client';\r\n\r\nimport {\r\n  createElement,\r\n  memo,\r\n  startTransition,\r\n  useCallback,\r\n  useEffect,\r\n  useLayoutEffect,\r\n  useMemo,\r\n  useRef,\r\n  useState,\r\n  type CSSProperties,\r\n  type ReactNode,\r\n  type RefObject,\r\n} from 'react';\r\nimport { createRoot } from 'react-dom/client';\r\nimport {\r\n  debounce,\r\n  getDifferences,\r\n  isArray,\r\n  isFunction,\r\n  type GenericObject,\r\n} from './utility.js';\r\nimport { ValidationWrapper } from './Functions.js';\r\nimport { isDeepEqual, transformStateFunc } from './utility.js';\r\nimport superjson from 'superjson';\r\nimport { v4 as uuidv4 } from 'uuid';\r\n\r\nimport {\r\n  formRefStore,\r\n  getGlobalStore,\r\n  ValidationStatus,\r\n  type ComponentsType,\r\n} from './store.js';\r\nimport { useCogsConfig } from './CogsStateClient.js';\r\nimport { Operation } from 'fast-json-patch';\r\nimport { useInView } from 'react-intersection-observer';\r\nimport * as z3 from 'zod/v3';\r\nimport * as z4 from 'zod/v4';\r\nimport z from 'zod';\r\n\r\ntype Prettify<T> = T extends any ? { [K in keyof T]: T[K] } : never;\r\n\r\nexport type VirtualViewOptions = {\r\n  itemHeight?: number;\r\n  overscan?: number;\r\n  stickToBottom?: boolean;\r\n  dependencies?: any[];\r\n  scrollStickTolerance?: number;\r\n};\r\n\r\n// The result now returns a real StateObject\r\nexport type VirtualStateObjectResult<T extends any[]> = {\r\n  /**\r\n   * A new, fully-functional StateObject that represents the virtualized slice.\r\n   * You can use `.get()`, `.stateMap()`, `.insert()`, `.cut()` etc. on this object.\r\n   */\r\n\r\n  virtualState: StateObject<T>;\r\n  /**\r\n   * Props to be spread onto your DOM elements to enable virtualization.\r\n   */\r\n  virtualizerProps: {\r\n    outer: { ref: RefObject<HTMLDivElement>; style: CSSProperties };\r\n    inner: { style: CSSProperties };\r\n    list: { style: CSSProperties };\r\n  };\r\n  scrollToBottom: (behavior?: ScrollBehavior) => void;\r\n  scrollToIndex: (index: number, behavior?: ScrollBehavior) => void;\r\n};\r\n\r\nexport type SyncInfo = {\r\n  timeStamp: number;\r\n  userId: number;\r\n};\r\n\r\nexport type FormElementParams<T> = StateObject<T> & {\r\n  inputProps: {\r\n    ref?: React.RefObject<any>;\r\n    value?: T extends boolean ? never : T;\r\n    onChange?: (\r\n      event: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>\r\n    ) => void;\r\n    onBlur?: () => void;\r\n  };\r\n};\r\n\r\nexport type StateKeys = string;\r\n\r\ntype findWithFuncType<U> = (\r\n  thisKey: keyof U,\r\n  thisValue: U[keyof U]\r\n) => EndType<U> & StateObject<U>;\r\n\r\ntype CutFunctionType<T> = (\r\n  index?: number,\r\n  options?: { waitForSync?: boolean }\r\n) => StateObject<T>;\r\n\r\nexport type InferArrayElement<T> = T extends (infer U)[] ? U : never;\r\ntype ArraySpecificPrototypeKeys =\r\n  | 'concat'\r\n  | 'copyWithin'\r\n  | 'fill'\r\n  | 'find'\r\n  | 'findIndex'\r\n  | 'flat'\r\n  | 'flatMap'\r\n  | 'includes'\r\n  | 'indexOf'\r\n  | 'join'\r\n  | 'keys'\r\n  | 'lastIndexOf'\r\n  | 'map'\r\n  | 'pop'\r\n  | 'push'\r\n  | 'reduce'\r\n  | 'reduceRight'\r\n  | 'reverse'\r\n  | 'shift'\r\n  | 'slice'\r\n  | 'some'\r\n  | 'sort'\r\n  | 'splice'\r\n  | 'unshift'\r\n  | 'values'\r\n  | 'entries'\r\n  | 'every'\r\n  | 'filter'\r\n  | 'forEach'\r\n  | 'with';\r\nexport type StreamOptions<T, R = T> = {\r\n  bufferSize?: number;\r\n  flushInterval?: number;\r\n  bufferStrategy?: 'sliding' | 'dropping' | 'accumulate';\r\n  store?: (buffer: T[]) => R | R[];\r\n  onFlush?: (buffer: T[]) => void;\r\n};\r\n\r\nexport type StreamHandle<T> = {\r\n  write: (data: T) => void;\r\n  writeMany: (data: T[]) => void;\r\n  flush: () => void;\r\n  close: () => void;\r\n  pause: () => void;\r\n  resume: () => void;\r\n};\r\nexport type ArrayEndType<TShape extends unknown> = {\r\n  stream: <T = Prettify<InferArrayElement<TShape>>, R = T>(\r\n    options?: StreamOptions<T, R>\r\n  ) => StreamHandle<T>;\r\n  findWith: findWithFuncType<Prettify<InferArrayElement<TShape>>>;\r\n  index: (index: number) => StateObject<Prettify<InferArrayElement<TShape>>> & {\r\n    insert: InsertTypeObj<Prettify<InferArrayElement<TShape>>>;\r\n    cut: CutFunctionType<TShape>;\r\n    _index: number;\r\n  } & EndType<Prettify<InferArrayElement<TShape>>>;\r\n  insert: InsertType<Prettify<InferArrayElement<TShape>>>;\r\n  cut: CutFunctionType<TShape>;\r\n  cutSelected: () => void;\r\n  cutByValue: (value: string | number | boolean) => void;\r\n  toggleByValue: (value: string | number | boolean) => void;\r\n  stateSort: (\r\n    compareFn: (\r\n      a: Prettify<InferArrayElement<TShape>>,\r\n      b: Prettify<InferArrayElement<TShape>>\r\n    ) => number\r\n  ) => ArrayEndType<TShape>;\r\n  useVirtualView: (\r\n    options: VirtualViewOptions\r\n  ) => VirtualStateObjectResult<Prettify<InferArrayElement<TShape>>[]>;\r\n\r\n  stateList: (\r\n    callbackfn: (\r\n      setter: StateObject<Prettify<InferArrayElement<TShape>>>,\r\n      index: number,\r\n      arraySetter: StateObject<TShape>\r\n    ) => void\r\n  ) => any;\r\n  stateMap: <U>(\r\n    callbackfn: (\r\n      setter: StateObject<Prettify<InferArrayElement<TShape>>>,\r\n      index: number,\r\n      arraySetter: StateObject<TShape>\r\n    ) => U\r\n  ) => U[];\r\n  $stateMap: (\r\n    callbackfn: (\r\n      setter: StateObject<Prettify<InferArrayElement<TShape>>>,\r\n      index: number,\r\n      arraySetter: StateObject<TShape>\r\n    ) => void\r\n  ) => any;\r\n  stateFlattenOn: <K extends keyof Prettify<InferArrayElement<TShape>>>(\r\n    field: K\r\n  ) => StateObject<InferArrayElement<Prettify<InferArrayElement<TShape>>[K]>[]>;\r\n  uniqueInsert: (\r\n    payload: InsertParams<Prettify<InferArrayElement<TShape>>>,\r\n    fields?: (keyof Prettify<InferArrayElement<TShape>>)[],\r\n    onMatch?: (existingItem: any) => any\r\n  ) => void;\r\n  stateFind: (\r\n    callbackfn: (\r\n      value: Prettify<InferArrayElement<TShape>>,\r\n      index: number\r\n    ) => boolean\r\n  ) => StateObject<Prettify<InferArrayElement<TShape>>> | undefined;\r\n  stateFilter: (\r\n    callbackfn: (\r\n      value: Prettify<InferArrayElement<TShape>>,\r\n      index: number\r\n    ) => void\r\n  ) => ArrayEndType<TShape>;\r\n  getSelected: () =>\r\n    | StateObject<Prettify<InferArrayElement<TShape>>>\r\n    | undefined;\r\n  clearSelected: () => void;\r\n  getSelectedIndex: () => number;\r\n  last: () => StateObject<Prettify<InferArrayElement<TShape>>> | undefined;\r\n} & EndType<TShape>;\r\n\r\nexport type FormOptsType = {\r\n  validation?: {\r\n    hideMessage?: boolean;\r\n    message?: string;\r\n\r\n    props?: GenericObject;\r\n    disable?: boolean;\r\n  };\r\n\r\n  debounceTime?: number;\r\n  sync?: {\r\n    allowInvalidValues?: boolean; // default: false\r\n  };\r\n};\r\n\r\nexport type FormControl<T> = (obj: FormElementParams<T>) => JSX.Element;\r\n\r\nexport type UpdateArg<S> = S | ((prevState: S) => S);\r\nexport type InsertParams<S> =\r\n  | S\r\n  | ((prevState: { state: S; uuid: string }) => S);\r\nexport type UpdateType<T> = (payload: UpdateArg<T>) => { synced: () => void };\r\n\r\nexport type InsertType<T> = (payload: InsertParams<T>, index?: number) => void;\r\nexport type InsertTypeObj<T> = (payload: InsertParams<T>) => void;\r\nexport type ValidationError = {\r\n  path: (string | number)[];\r\n  message: string;\r\n};\r\ntype EffectFunction<T, R> = (state: T, deps: any[]) => R;\r\nexport type EndType<T, IsArrayElement = false> = {\r\n  addZodValidation: (errors: ValidationError[]) => void;\r\n  clearZodValidation: (paths?: string[]) => void;\r\n  applyJsonPatch: (patches: any[]) => void;\r\n  update: UpdateType<T>;\r\n  _path: string[];\r\n  _stateKey: string;\r\n  formElement: (control: FormControl<T>, opts?: FormOptsType) => JSX.Element;\r\n  get: () => T;\r\n  getState: () => T;\r\n  $get: () => T;\r\n  $derive: <R>(fn: EffectFunction<T, R>) => R;\r\n\r\n  _status: 'fresh' | 'dirty' | 'synced' | 'restored' | 'unknown';\r\n  getStatus: () => 'fresh' | 'dirty' | 'synced' | 'restored' | 'unknown';\r\n\r\n  showValidationErrors: () => string[];\r\n  setValidation: (ctx: string) => void;\r\n  removeValidation: (ctx: string) => void;\r\n  ignoreFields: (fields: string[]) => StateObject<T>;\r\n  isSelected: boolean;\r\n  setSelected: (value: boolean) => void;\r\n  toggleSelected: () => void;\r\n  getFormRef: () => React.RefObject<any> | undefined;\r\n  removeStorage: () => void;\r\n  sync: () => void;\r\n  validationWrapper: ({\r\n    children,\r\n    hideMessage,\r\n  }: {\r\n    children: React.ReactNode;\r\n    hideMessage?: boolean;\r\n  }) => JSX.Element;\r\n  lastSynced?: SyncInfo;\r\n} & (IsArrayElement extends true ? { cutThis: () => void } : {});\r\n\r\nexport type StateObject<T> = (T extends any[]\r\n  ? ArrayEndType<T>\r\n  : T extends Record<string, unknown> | object\r\n    ? { [K in keyof T]-?: StateObject<T[K]> }\r\n    : T extends string | number | boolean | null\r\n      ? EndType<T, true>\r\n      : never) &\r\n  EndType<T, true> & {\r\n    toggle: T extends boolean ? () => void : never;\r\n    getAllFormRefs: () => Map<string, React.RefObject<any>>;\r\n    _componentId: string | null;\r\n    getComponents: () => ComponentsType;\r\n\r\n    _initialState: T;\r\n    updateInitialState: (newState: T | null) => {\r\n      fetchId: (field: keyof T) => string | number;\r\n    };\r\n    _isLoading: boolean;\r\n    _serverState: T;\r\n    revertToInitialState: (obj?: { validationKey?: string }) => T;\r\n    getDifferences: () => string[];\r\n    middleware: (\r\n      middles: ({\r\n        updateLog,\r\n        update,\r\n      }: {\r\n        updateLog: UpdateTypeDetail[] | undefined;\r\n        update: UpdateTypeDetail;\r\n      }) => void\r\n    ) => void;\r\n\r\n    getLocalStorage: (key: string) => LocalStorageData<T> | null;\r\n  };\r\n\r\nexport type CogsUpdate<T extends unknown> = UpdateType<T>;\r\ntype EffectiveSetStateArg<\r\n  T,\r\n  UpdateType extends 'update' | 'insert' | 'cut',\r\n> = UpdateType extends 'insert'\r\n  ? T extends any[]\r\n    ? InsertParams<InferArrayElement<T>>\r\n    : never\r\n  : UpdateArg<T>;\r\ntype UpdateOptions = {\r\n  updateType: 'insert' | 'cut' | 'update';\r\n\r\n  sync?: boolean;\r\n};\r\ntype EffectiveSetState<TStateObject> = (\r\n  newStateOrFunction:\r\n    | EffectiveSetStateArg<TStateObject, 'update'>\r\n    | EffectiveSetStateArg<TStateObject, 'insert'>,\r\n  path: string[],\r\n  updateObj: UpdateOptions,\r\n  validationKey?: string\r\n) => void;\r\n\r\nexport type UpdateTypeDetail = {\r\n  timeStamp: number;\r\n  stateKey: string;\r\n  updateType: 'update' | 'insert' | 'cut';\r\n  path: string[];\r\n  status: 'new' | 'sent' | 'synced';\r\n  oldValue: any;\r\n  newValue: any;\r\n  userId?: number;\r\n};\r\n\r\nexport type ReactivityUnion = 'none' | 'component' | 'deps' | 'all';\r\nexport type ReactivityType =\r\n  | 'none'\r\n  | 'component'\r\n  | 'deps'\r\n  | 'all'\r\n  | Array<Prettify<'none' | 'component' | 'deps' | 'all'>>;\r\n\r\n// Define the return type of the sync hook locally\r\ntype SyncApi = {\r\n  updateState: (data: { operation: any }) => void;\r\n  connected: boolean;\r\n  clientId: string | null;\r\n  subscribers: string[];\r\n};\r\ntype ValidationOptionsType = {\r\n  key?: string;\r\n  zodSchemaV3?: z3.ZodType<any, any, any>;\r\n  zodSchemaV4?: z4.ZodType<any, any, any>;\r\n\r\n  onBlur?: boolean;\r\n};\r\ntype UseSyncType<T> = (state: T, a: SyncOptionsType<any>) => SyncApi;\r\ntype SyncOptionsType<TApiParams> = {\r\n  apiParams: TApiParams;\r\n  stateKey?: string;\r\n  stateRoom:\r\n    | number\r\n    | string\r\n    | (({ clientId }: { clientId: string }) => string | null);\r\n  connect?: boolean;\r\n  inMemoryState?: boolean;\r\n};\r\nexport type OptionsType<T extends unknown = unknown, TApiParams = never> = {\r\n  log?: boolean;\r\n  componentId?: string;\r\n  syncOptions?: SyncOptionsType<TApiParams>;\r\n\r\n  validation?: ValidationOptionsType;\r\n  serverState?: {\r\n    id?: string | number;\r\n    data?: T;\r\n    status?: 'pending' | 'error' | 'success' | 'loading';\r\n    timestamp?: number;\r\n    merge?:\r\n      | boolean\r\n      | {\r\n          strategy: 'append' | 'prepend' | 'diff';\r\n          key?: string;\r\n        };\r\n  };\r\n\r\n  sync?: {\r\n    action: (state: T) => Promise<{\r\n      success: boolean;\r\n      data?: any;\r\n      error?: any;\r\n      errors?: Array<{\r\n        path: (string | number)[];\r\n        message: string;\r\n      }>;\r\n    }>;\r\n    onSuccess?: (data: any) => void;\r\n    onError?: (error: any) => void;\r\n  };\r\n  middleware?: ({ update }: { update: UpdateTypeDetail }) => void;\r\n\r\n  modifyState?: (state: T) => T;\r\n  localStorage?: {\r\n    key: string | ((state: T) => string);\r\n    onChange?: (state: T) => void;\r\n  };\r\n  formElements?: FormsElementsType<T>;\r\n\r\n  reactiveDeps?: (state: T) => any[] | true;\r\n  reactiveType?: ReactivityType;\r\n  syncUpdate?: Partial<UpdateTypeDetail>;\r\n\r\n  defaultState?: T;\r\n\r\n  dependencies?: any[];\r\n};\r\n\r\nexport type SyncRenderOptions<T extends unknown = unknown> = {\r\n  children: React.ReactNode;\r\n  time: number;\r\n  data?: T;\r\n  key?: string;\r\n};\r\n\r\ntype FormsElementsType<T> = {\r\n  validation?: (options: {\r\n    children: React.ReactNode;\r\n    status: ValidationStatus; // Instead of 'active' boolean\r\n\r\n    path: string[];\r\n    message?: string;\r\n    data?: T;\r\n    key?: string;\r\n  }) => React.ReactNode;\r\n  syncRender?: (options: SyncRenderOptions<T>) => React.ReactNode;\r\n};\r\n\r\nexport type InitialStateInnerType<T extends unknown = unknown> = {\r\n  initialState: T;\r\n} & OptionsType<T>;\r\n\r\nexport type InitialStateType<T> = {\r\n  [key: string]: InitialStateInnerType<T>;\r\n};\r\n\r\nexport type AllStateTypes<T extends unknown> = Record<string, T>;\r\n\r\nexport type CogsInitialState<T> = {\r\n  initialState: T;\r\n  formElements?: FormsElementsType<T>;\r\n};\r\n\r\nexport type TransformedStateType<T> = {\r\n  [P in keyof T]: T[P] extends CogsInitialState<infer U> ? U : T[P];\r\n};\r\n\r\nfunction setAndMergeOptions(stateKey: string, newOptions: OptionsType<any>) {\r\n  const getInitialOptions = getGlobalStore.getState().getInitialOptions;\r\n  const setInitialStateOptions =\r\n    getGlobalStore.getState().setInitialStateOptions;\r\n\r\n  const initialOptions = getInitialOptions(stateKey as string) || {};\r\n\r\n  setInitialStateOptions(stateKey as string, {\r\n    ...initialOptions,\r\n    ...newOptions,\r\n  });\r\n}\r\nfunction setOptions<StateKey, Opt>({\r\n  stateKey,\r\n  options,\r\n  initialOptionsPart,\r\n}: {\r\n  stateKey: StateKey;\r\n  options?: OptionsType<any>;\r\n  initialOptionsPart: Record<string, any>;\r\n}) {\r\n  const initialOptions = getInitialOptions(stateKey as string) || {};\r\n  const initialOptionsPartState = initialOptionsPart[stateKey as string] || {};\r\n  const setInitialStateOptions =\r\n    getGlobalStore.getState().setInitialStateOptions;\r\n  const mergedOptions = { ...initialOptionsPartState, ...initialOptions };\r\n\r\n  let needToAdd = false;\r\n  if (options) {\r\n    for (const key in options) {\r\n      if (!mergedOptions.hasOwnProperty(key)) {\r\n        needToAdd = true;\r\n        mergedOptions[key] = options[key as keyof typeof options];\r\n      } else {\r\n        if (\r\n          key == 'localStorage' &&\r\n          options[key] &&\r\n          mergedOptions[key].key !== options[key]?.key\r\n        ) {\r\n          needToAdd = true;\r\n          mergedOptions[key] = options[key];\r\n        }\r\n        if (\r\n          key == 'defaultState' &&\r\n          options[key] &&\r\n          mergedOptions[key] !== options[key] &&\r\n          !isDeepEqual(mergedOptions[key], options[key])\r\n        ) {\r\n          needToAdd = true;\r\n          mergedOptions[key] = options[key];\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  // Always preserve syncOptions if it exists in mergedOptions but not in options\r\n  if (\r\n    mergedOptions.syncOptions &&\r\n    (!options || !options.hasOwnProperty('syncOptions'))\r\n  ) {\r\n    needToAdd = true;\r\n  }\r\n\r\n  if (needToAdd) {\r\n    setInitialStateOptions(stateKey as string, mergedOptions);\r\n  }\r\n}\r\n\r\nexport function addStateOptions<T extends unknown>(\r\n  initialState: T,\r\n  { formElements, validation }: OptionsType<T>\r\n) {\r\n  return { initialState: initialState, formElements, validation } as T;\r\n}\r\n\r\n// Define the type for the options setter using the Transformed state\r\ntype SetCogsOptionsFunc<T extends Record<string, any>> = <\r\n  StateKey extends keyof TransformedStateType<T>,\r\n>(\r\n  stateKey: StateKey,\r\n  options: OptionsType<TransformedStateType<T>[StateKey]>\r\n) => void;\r\n\r\nexport const createCogsState = <State extends Record<StateKeys, unknown>>(\r\n  initialState: State,\r\n  opt?: {\r\n    formElements?: FormsElementsType<State>;\r\n    validation?: ValidationOptionsType;\r\n    __fromSyncSchema?: boolean;\r\n    __syncNotifications?: Record<string, Function>;\r\n    __apiParamsMap?: Record<string, any>;\r\n    __useSync?: UseSyncType<State>;\r\n    __syncSchemas?: Record<string, any>;\r\n  }\r\n) => {\r\n  let newInitialState = initialState;\r\n  console.log('optsc', opt?.__useSync);\r\n  const [statePart, initialOptionsPart] =\r\n    transformStateFunc<State>(newInitialState);\r\n\r\n  // Store notifications if provided\r\n  if (opt?.__fromSyncSchema && opt?.__syncNotifications) {\r\n    getGlobalStore\r\n      .getState()\r\n      .setInitialStateOptions('__notifications', opt.__syncNotifications);\r\n  }\r\n\r\n  // Store apiParams map if provided\r\n  if (opt?.__fromSyncSchema && opt?.__apiParamsMap) {\r\n    getGlobalStore\r\n      .getState()\r\n      .setInitialStateOptions('__apiParamsMap', opt.__apiParamsMap);\r\n  }\r\n\r\n  // ... rest of your existing createCogsState code unchanged ...\r\n\r\n  Object.keys(statePart).forEach((key) => {\r\n    let existingOptions = initialOptionsPart[key] || {};\r\n\r\n    const mergedOptions: any = {\r\n      ...existingOptions,\r\n    };\r\n\r\n    if (opt?.formElements) {\r\n      mergedOptions.formElements = {\r\n        ...opt.formElements,\r\n        ...(existingOptions.formElements || {}),\r\n      };\r\n    }\r\n\r\n    if (opt?.validation) {\r\n      mergedOptions.validation = {\r\n        ...opt.validation,\r\n        ...(existingOptions.validation || {}),\r\n      };\r\n\r\n      if (opt.validation.key && !existingOptions.validation?.key) {\r\n        mergedOptions.validation.key = `${opt.validation.key}.${key}`;\r\n      }\r\n    }\r\n    if (opt?.__syncSchemas?.[key]?.schemas?.validation) {\r\n      mergedOptions.validation = {\r\n        zodSchemaV4: opt.__syncSchemas[key].schemas.validation,\r\n        ...existingOptions.validation,\r\n      };\r\n    }\r\n    if (Object.keys(mergedOptions).length > 0) {\r\n      const existingGlobalOptions = getInitialOptions(key);\r\n\r\n      if (!existingGlobalOptions) {\r\n        getGlobalStore.getState().setInitialStateOptions(key, mergedOptions);\r\n      } else {\r\n        // Merge with existing global options\r\n        getGlobalStore.getState().setInitialStateOptions(key, {\r\n          ...existingGlobalOptions,\r\n          ...mergedOptions,\r\n        });\r\n      }\r\n    }\r\n  });\r\n\r\n  Object.keys(statePart).forEach((key) => {\r\n    getGlobalStore.getState().initializeShadowState(key, statePart[key]);\r\n  });\r\n\r\n  type StateKeys = keyof typeof statePart;\r\n\r\n  const useCogsState = <StateKey extends StateKeys>(\r\n    stateKey: StateKey,\r\n    options?: Prettify<OptionsType<(typeof statePart)[StateKey]>>\r\n  ) => {\r\n    console.time('useCogsState');\r\n    const [componentId] = useState(options?.componentId ?? uuidv4());\r\n\r\n    setOptions({\r\n      stateKey,\r\n      options,\r\n      initialOptionsPart,\r\n    });\r\n    const thiState =\r\n      getGlobalStore.getState().getShadowValue(stateKey as string) ||\r\n      statePart[stateKey as string];\r\n    const partialState = options?.modifyState\r\n      ? options.modifyState(thiState)\r\n      : thiState;\r\n\r\n    console.timeEnd('useCogsState');\r\n\r\n    const updater = useCogsStateFn<(typeof statePart)[StateKey]>(partialState, {\r\n      stateKey: stateKey as string,\r\n      syncUpdate: options?.syncUpdate,\r\n      componentId,\r\n      localStorage: options?.localStorage,\r\n      middleware: options?.middleware,\r\n      reactiveType: options?.reactiveType,\r\n      reactiveDeps: options?.reactiveDeps,\r\n      defaultState: options?.defaultState as any,\r\n      dependencies: options?.dependencies,\r\n      serverState: options?.serverState,\r\n      syncOptions: options?.syncOptions,\r\n      __useSync: opt?.__useSync as UseSyncType<(typeof statePart)[StateKey]>,\r\n    });\r\n\r\n    return updater;\r\n  };\r\n\r\n  function setCogsOptions<StateKey extends StateKeys>(\r\n    stateKey: StateKey,\r\n    options: OptionsType<(typeof statePart)[StateKey]>\r\n  ) {\r\n    setOptions({ stateKey, options, initialOptionsPart });\r\n\r\n    if (options.localStorage) {\r\n      loadAndApplyLocalStorage(stateKey as string, options);\r\n    }\r\n\r\n    notifyComponents(stateKey as string);\r\n  }\r\n\r\n  return { useCogsState, setCogsOptions } as CogsApi<State, never>;\r\n};\r\ntype UseCogsStateHook<\r\n  T extends Record<string, any>,\r\n  TApiParamsMap extends Record<string, any> = never,\r\n> = <StateKey extends keyof TransformedStateType<T> & string>(\r\n  stateKey: StateKey,\r\n  options?: [TApiParamsMap] extends [never]\r\n    ? // When TApiParamsMap is never (no sync)\r\n      Prettify<OptionsType<TransformedStateType<T>[StateKey]>>\r\n    : // When TApiParamsMap exists (sync enabled)\r\n      StateKey extends keyof TApiParamsMap\r\n      ? Prettify<\r\n          OptionsType<\r\n            TransformedStateType<T>[StateKey],\r\n            TApiParamsMap[StateKey]\r\n          > & {\r\n            syncOptions: Prettify<SyncOptionsType<TApiParamsMap[StateKey]>>;\r\n          }\r\n        >\r\n      : Prettify<OptionsType<TransformedStateType<T>[StateKey]>>\r\n) => StateObject<TransformedStateType<T>[StateKey]>;\r\n\r\n// Update CogsApi to default to never instead of Record<string, never>\r\ntype CogsApi<\r\n  T extends Record<string, any>,\r\n  TApiParamsMap extends Record<string, any> = never,\r\n> = {\r\n  useCogsState: UseCogsStateHook<T, TApiParamsMap>;\r\n  setCogsOptions: SetCogsOptionsFunc<T>;\r\n};\r\ntype GetParamType<SchemaEntry> = SchemaEntry extends {\r\n  api?: { queryData?: { _paramType?: infer P } };\r\n}\r\n  ? P\r\n  : never;\r\n\r\nexport function createCogsStateFromSync<\r\n  TSyncSchema extends {\r\n    schemas: Record<\r\n      string,\r\n      {\r\n        schemas: { defaultValues: any };\r\n        api?: {\r\n          queryData?: any;\r\n        };\r\n        [key: string]: any;\r\n      }\r\n    >;\r\n    notifications: Record<string, any>;\r\n  },\r\n>(\r\n  syncSchema: TSyncSchema,\r\n  useSync: UseSyncType<any>\r\n): CogsApi<\r\n  {\r\n    [K in keyof TSyncSchema['schemas']]: TSyncSchema['schemas'][K]['schemas']['defaultValues'];\r\n  },\r\n  {\r\n    [K in keyof TSyncSchema['schemas']]: GetParamType<\r\n      TSyncSchema['schemas'][K]\r\n    >;\r\n  }\r\n> {\r\n  const schemas = syncSchema.schemas;\r\n  const initialState: any = {};\r\n  const apiParamsMap: any = {};\r\n\r\n  // Extract defaultValues AND apiParams from each entry\r\n  for (const key in schemas) {\r\n    const entry = schemas[key];\r\n    initialState[key] = entry?.schemas?.defaultValues || {};\r\n\r\n    // Extract apiParams from the api.queryData._paramType\r\n    if (entry?.api?.queryData?._paramType) {\r\n      apiParamsMap[key] = entry.api.queryData._paramType;\r\n    }\r\n  }\r\n\r\n  return createCogsState(initialState, {\r\n    __fromSyncSchema: true,\r\n    __syncNotifications: syncSchema.notifications,\r\n    __apiParamsMap: apiParamsMap,\r\n    __useSync: useSync,\r\n    __syncSchemas: schemas,\r\n  }) as any;\r\n}\r\nconst {\r\n  getInitialOptions,\r\n\r\n  addStateLog,\r\n  updateInitialStateGlobal,\r\n} = getGlobalStore.getState();\r\nconst saveToLocalStorage = <T,>(\r\n  state: T,\r\n  thisKey: string,\r\n  currentInitialOptions: any,\r\n  sessionId?: string,\r\n  lastSyncedWithServer?: number\r\n) => {\r\n  if (currentInitialOptions?.log) {\r\n    console.log(\r\n      'saving to localstorage',\r\n      thisKey,\r\n      currentInitialOptions.localStorage?.key,\r\n      sessionId\r\n    );\r\n  }\r\n\r\n  const key = isFunction(currentInitialOptions?.localStorage?.key)\r\n    ? currentInitialOptions.localStorage?.key(state)\r\n    : currentInitialOptions?.localStorage?.key;\r\n\r\n  if (key && sessionId) {\r\n    const storageKey = `${sessionId}-${thisKey}-${key}`;\r\n\r\n    // Get existing data to preserve lastSyncedWithServer if not explicitly updating it\r\n    let existingLastSynced: number | undefined;\r\n    try {\r\n      const existing = loadFromLocalStorage(storageKey);\r\n      existingLastSynced = existing?.lastSyncedWithServer;\r\n    } catch {\r\n      // Ignore errors, will use undefined\r\n    }\r\n    const shadowMeta = getGlobalStore.getState().getShadowMetadata(thisKey, []);\r\n\r\n    const data: LocalStorageData<T> = {\r\n      state,\r\n      lastUpdated: Date.now(),\r\n      lastSyncedWithServer: lastSyncedWithServer ?? existingLastSynced,\r\n      stateSource: shadowMeta?.stateSource,\r\n      baseServerState: shadowMeta?.baseServerState,\r\n    };\r\n\r\n    // Use SuperJSON serialize to get the json part only\r\n    const superJsonResult = superjson.serialize(data);\r\n    window.localStorage.setItem(\r\n      storageKey,\r\n      JSON.stringify(superJsonResult.json)\r\n    );\r\n  }\r\n};\r\n\r\nconst loadFromLocalStorage = (localStorageKey: string) => {\r\n  if (!localStorageKey) return null;\r\n\r\n  try {\r\n    const storedData = window.localStorage.getItem(localStorageKey);\r\n    if (!storedData) return null;\r\n\r\n    // Parse the json part back normally\r\n    const parsedData = JSON.parse(storedData);\r\n\r\n    return parsedData;\r\n  } catch (error) {\r\n    console.error('Error loading from localStorage:', error);\r\n    return null;\r\n  }\r\n};\r\nconst loadAndApplyLocalStorage = (stateKey: string, options: any) => {\r\n  const currentState = getGlobalStore.getState().getShadowValue(stateKey);\r\n  const { sessionId } = useCogsConfig();\r\n  const localkey = isFunction(options?.localStorage?.key)\r\n    ? options.localStorage.key(currentState)\r\n    : options?.localStorage?.key;\r\n\r\n  if (localkey && sessionId) {\r\n    const localData = loadFromLocalStorage(\r\n      `${sessionId}-${stateKey}-${localkey}`\r\n    );\r\n\r\n    if (\r\n      localData &&\r\n      localData.lastUpdated > (localData.lastSyncedWithServer || 0)\r\n    ) {\r\n      notifyComponents(stateKey);\r\n      return true;\r\n    }\r\n  }\r\n  return false;\r\n};\r\n\r\ntype LocalStorageData<T> = {\r\n  state: T;\r\n  lastUpdated: number;\r\n  lastSyncedWithServer?: number;\r\n  baseServerState?: T; // Keep reference to what server state this is based on\r\n  stateSource?: 'default' | 'server' | 'localStorage'; // Track origin\r\n};\r\n\r\nconst notifyComponents = (thisKey: string) => {\r\n  const stateEntry = getGlobalStore.getState().getShadowMetadata(thisKey, []);\r\n  if (!stateEntry) return;\r\n\r\n  // Batch component updates\r\n  const updates = new Set<() => void>();\r\n  stateEntry?.components?.forEach((component) => {\r\n    const reactiveTypes = component\r\n      ? Array.isArray(component.reactiveType)\r\n        ? component.reactiveType\r\n        : [component.reactiveType || 'component']\r\n      : null;\r\n    if (!reactiveTypes?.includes('none')) {\r\n      updates.add(() => component.forceUpdate());\r\n    }\r\n  });\r\n\r\n  // Schedule updates in the next tick to allow batching\r\n  queueMicrotask(() => {\r\n    updates.forEach((update) => update());\r\n  });\r\n};\r\n\r\nexport const notifyComponent = (stateKey: string, componentId: string) => {\r\n  const stateEntry = getGlobalStore.getState().getShadowMetadata(stateKey, []);\r\n  if (stateEntry) {\r\n    const fullComponentId = `${stateKey}////${componentId}`;\r\n    const component = stateEntry?.components?.get(fullComponentId);\r\n    const reactiveTypes = component\r\n      ? Array.isArray(component.reactiveType)\r\n        ? component.reactiveType\r\n        : [component.reactiveType || 'component']\r\n      : null;\r\n\r\n    // Skip if reactivity is disabled\r\n    if (reactiveTypes?.includes('none')) {\r\n      return;\r\n    }\r\n\r\n    if (component) {\r\n      // Force an update to ensure the current value is saved\r\n\r\n      component.forceUpdate();\r\n    }\r\n  }\r\n};\r\nfunction markEntireStateAsServerSynced(\r\n  stateKey: string,\r\n  path: string[],\r\n  data: any,\r\n  timestamp: number\r\n) {\r\n  const store = getGlobalStore.getState();\r\n\r\n  // Mark current path as synced\r\n  const currentMeta = store.getShadowMetadata(stateKey, path);\r\n  store.setShadowMetadata(stateKey, path, {\r\n    ...currentMeta,\r\n    isDirty: false,\r\n    stateSource: 'server',\r\n    lastServerSync: timestamp || Date.now(),\r\n  });\r\n\r\n  // If it's an array, mark each item as synced\r\n  if (Array.isArray(data)) {\r\n    const arrayMeta = store.getShadowMetadata(stateKey, path);\r\n    if (arrayMeta?.arrayKeys) {\r\n      arrayMeta.arrayKeys.forEach((itemKey, index) => {\r\n        const itemPath = itemKey.split('.').slice(1);\r\n        const itemData = data[index];\r\n        if (itemData !== undefined) {\r\n          markEntireStateAsServerSynced(\r\n            stateKey,\r\n            itemPath,\r\n            itemData,\r\n            timestamp\r\n          );\r\n        }\r\n      });\r\n    }\r\n  }\r\n  // If it's an object, mark each field as synced\r\n  else if (data && typeof data === 'object' && data.constructor === Object) {\r\n    Object.keys(data).forEach((key) => {\r\n      const fieldPath = [...path, key];\r\n      const fieldData = data[key];\r\n      markEntireStateAsServerSynced(stateKey, fieldPath, fieldData, timestamp);\r\n    });\r\n  }\r\n}\r\nlet updateBatchQueue = new Map<string, Array<UpdateArg<any>>>();\r\nlet batchFlushScheduled = false;\r\nexport function useCogsStateFn<TStateObject extends unknown>(\r\n  stateObject: TStateObject,\r\n  {\r\n    stateKey,\r\n\r\n    localStorage,\r\n    formElements,\r\n    reactiveDeps,\r\n    reactiveType,\r\n    componentId,\r\n    defaultState,\r\n    syncUpdate,\r\n    dependencies,\r\n    serverState,\r\n    __useSync,\r\n    syncOptions,\r\n  }: {\r\n    stateKey?: string;\r\n    componentId?: string;\r\n    defaultState?: TStateObject;\r\n    __useSync?: UseSyncType<TStateObject>;\r\n    syncOptions?: SyncOptionsType<any>;\r\n  } & OptionsType<TStateObject> = {}\r\n) {\r\n  console.time('useCogsStateFn top');\r\n  const [reactiveForce, forceUpdate] = useState({}); //this is the key to reactivity\r\n  const { sessionId } = useCogsConfig();\r\n  let noStateKey = stateKey ? false : true;\r\n  const [thisKey] = useState(stateKey ?? uuidv4());\r\n  const componentIdRef = useRef(componentId ?? uuidv4());\r\n  const latestInitialOptionsRef = useRef<OptionsType<TStateObject> | null>(\r\n    null\r\n  );\r\n  latestInitialOptionsRef.current = (getInitialOptions(thisKey as string) ??\r\n    null) as OptionsType<TStateObject> | null;\r\n\r\n  useEffect(() => {\r\n    if (syncUpdate && syncUpdate.stateKey === thisKey && syncUpdate.path?.[0]) {\r\n      const syncKey = `${syncUpdate.stateKey}:${syncUpdate.path.join('.')}`;\r\n      getGlobalStore.getState().setSyncInfo(syncKey, {\r\n        timeStamp: syncUpdate.timeStamp!,\r\n        userId: syncUpdate.userId!,\r\n      });\r\n    }\r\n  }, [syncUpdate]);\r\n\r\n  const resolveInitialState = useCallback(\r\n    (\r\n      overrideOptions?: OptionsType<TStateObject>\r\n    ): {\r\n      value: TStateObject;\r\n      source: 'default' | 'server' | 'localStorage';\r\n      timestamp: number;\r\n    } => {\r\n      // If we pass in options, use them. Otherwise, get from the global store.\r\n      const optionsToUse = overrideOptions\r\n        ? { ...getInitialOptions(thisKey as string), ...overrideOptions }\r\n        : getInitialOptions(thisKey as string);\r\n\r\n      const currentOptions = optionsToUse;\r\n      const finalDefaultState =\r\n        currentOptions?.defaultState || defaultState || stateObject;\r\n\r\n      // 1. Check server state\r\n      const hasValidServerData =\r\n        currentOptions?.serverState?.status === 'success' &&\r\n        currentOptions?.serverState?.data !== undefined;\r\n\r\n      if (hasValidServerData) {\r\n        return {\r\n          value: currentOptions.serverState!.data! as any,\r\n          source: 'server',\r\n          timestamp: currentOptions.serverState!.timestamp || Date.now(),\r\n        };\r\n      }\r\n      // 2. Check localStorage\r\n      if (currentOptions?.localStorage?.key && sessionId) {\r\n        const localKey = isFunction(currentOptions.localStorage.key)\r\n          ? currentOptions.localStorage.key(finalDefaultState)\r\n          : currentOptions.localStorage.key;\r\n\r\n        const localData = loadFromLocalStorage(\r\n          `${sessionId}-${thisKey}-${localKey}`\r\n        );\r\n\r\n        if (\r\n          localData &&\r\n          localData.lastUpdated > (currentOptions?.serverState?.timestamp || 0)\r\n        ) {\r\n          return {\r\n            value: localData.state,\r\n            source: 'localStorage',\r\n            timestamp: localData.lastUpdated,\r\n          };\r\n        }\r\n      }\r\n\r\n      // 3. Use default state\r\n      return {\r\n        value: finalDefaultState || (stateObject as any),\r\n        source: 'default',\r\n        timestamp: Date.now(),\r\n      };\r\n    },\r\n    [thisKey, defaultState, stateObject, sessionId]\r\n  );\r\n\r\n  // Effect 1: When this component's serverState prop changes, broadcast it\r\n  useEffect(() => {\r\n    getGlobalStore.getState().setServerStateUpdate(thisKey, serverState);\r\n  }, [serverState, thisKey]);\r\n\r\n  // Effect 2: Listen for server state updates from ANY component\r\n  useEffect(() => {\r\n    const unsubscribe = getGlobalStore\r\n      .getState()\r\n      .subscribeToPath(thisKey, (event) => {\r\n        if (event?.type === 'SERVER_STATE_UPDATE') {\r\n          const serverStateData = event.serverState;\r\n          console.log('SERVER_STATE_UPDATE', event);\r\n          if (\r\n            serverStateData?.status === 'success' &&\r\n            serverStateData.data !== undefined\r\n          ) {\r\n            const newOptions = { serverState: serverStateData };\r\n            setAndMergeOptions(thisKey, newOptions);\r\n\r\n            const mergeConfig =\r\n              typeof serverStateData.merge === 'object'\r\n                ? serverStateData.merge\r\n                : serverStateData.merge === true\r\n                  ? { strategy: 'append' }\r\n                  : null;\r\n\r\n            const currentState = getGlobalStore\r\n              .getState()\r\n              .getShadowValue(thisKey);\r\n            const incomingData = serverStateData.data;\r\n            if (\r\n              mergeConfig &&\r\n              Array.isArray(currentState) &&\r\n              Array.isArray(incomingData)\r\n            ) {\r\n              const keyField = mergeConfig.key;\r\n              const existingIds = new Set(\r\n                currentState.map((item: any) => item[keyField])\r\n              );\r\n\r\n              const newUniqueItems = incomingData.filter((item: any) => {\r\n                return !existingIds.has(item[keyField]);\r\n              });\r\n\r\n              if (newUniqueItems.length > 0) {\r\n                newUniqueItems.forEach((item) => {\r\n                  getGlobalStore\r\n                    .getState()\r\n                    .insertShadowArrayElement(thisKey, [], item);\r\n\r\n                  // MARK NEW SERVER ITEMS AS SYNCED\r\n                  const arrayMeta = getGlobalStore\r\n                    .getState()\r\n                    .getShadowMetadata(thisKey, []);\r\n\r\n                  if (arrayMeta?.arrayKeys) {\r\n                    const newItemKey =\r\n                      arrayMeta.arrayKeys[arrayMeta.arrayKeys.length - 1];\r\n                    if (newItemKey) {\r\n                      const newItemPath = newItemKey.split('.').slice(1);\r\n\r\n                      // Mark the new server item as synced, not dirty\r\n                      getGlobalStore\r\n                        .getState()\r\n                        .setShadowMetadata(thisKey, newItemPath, {\r\n                          isDirty: false,\r\n                          stateSource: 'server',\r\n                          lastServerSync:\r\n                            serverStateData.timestamp || Date.now(),\r\n                        });\r\n\r\n                      // Also mark all its child fields as synced if it's an object\r\n                      const itemValue = getGlobalStore\r\n                        .getState()\r\n                        .getShadowValue(newItemKey);\r\n                      if (\r\n                        itemValue &&\r\n                        typeof itemValue === 'object' &&\r\n                        !Array.isArray(itemValue)\r\n                      ) {\r\n                        Object.keys(itemValue).forEach((fieldKey) => {\r\n                          const fieldPath = [...newItemPath, fieldKey];\r\n                          getGlobalStore\r\n                            .getState()\r\n                            .setShadowMetadata(thisKey, fieldPath, {\r\n                              isDirty: false,\r\n                              stateSource: 'server',\r\n                              lastServerSync:\r\n                                serverStateData.timestamp || Date.now(),\r\n                            });\r\n                        });\r\n                      }\r\n                    }\r\n                  }\r\n                });\r\n              }\r\n            } else {\r\n              // For replace strategy or initial load\r\n              getGlobalStore\r\n                .getState()\r\n                .initializeShadowState(thisKey, incomingData);\r\n\r\n              // Mark the entire state tree as synced from server\r\n              markEntireStateAsServerSynced(\r\n                thisKey,\r\n                [],\r\n                incomingData,\r\n                serverStateData.timestamp\r\n              );\r\n            }\r\n\r\n            const meta = getGlobalStore\r\n              .getState()\r\n              .getShadowMetadata(thisKey, []);\r\n            getGlobalStore.getState().setShadowMetadata(thisKey, [], {\r\n              ...meta,\r\n              stateSource: 'server',\r\n              lastServerSync: serverStateData.timestamp || Date.now(),\r\n              isDirty: false,\r\n            });\r\n          }\r\n        }\r\n      });\r\n\r\n    return unsubscribe;\r\n  }, [thisKey, resolveInitialState]);\r\n\r\n  useEffect(() => {\r\n    const existingMeta = getGlobalStore\r\n      .getState()\r\n      .getShadowMetadata(thisKey, []);\r\n    if (existingMeta && existingMeta.stateSource) {\r\n      return; // Already initialized, bail out.\r\n    }\r\n\r\n    const options = getInitialOptions(thisKey as string);\r\n\r\n    if (options?.defaultState !== undefined || defaultState !== undefined) {\r\n      const finalDefaultState = options?.defaultState || defaultState;\r\n\r\n      // Only set defaultState if it's not already set\r\n      if (!options?.defaultState) {\r\n        setAndMergeOptions(thisKey as string, {\r\n          defaultState: finalDefaultState,\r\n        });\r\n      }\r\n\r\n      const { value: resolvedState, source, timestamp } = resolveInitialState();\r\n\r\n      getGlobalStore.getState().initializeShadowState(thisKey, resolvedState);\r\n\r\n      // Set shadow metadata with the correct source info\r\n      getGlobalStore.getState().setShadowMetadata(thisKey, [], {\r\n        stateSource: source,\r\n        lastServerSync: source === 'server' ? timestamp : undefined,\r\n        isDirty: false,\r\n        baseServerState: source === 'server' ? resolvedState : undefined,\r\n      });\r\n\r\n      notifyComponents(thisKey);\r\n    }\r\n  }, [thisKey, ...(dependencies || [])]);\r\n\r\n  useLayoutEffect(() => {\r\n    if (noStateKey) {\r\n      setAndMergeOptions(thisKey as string, {\r\n        formElements,\r\n        defaultState,\r\n        localStorage,\r\n        middleware: latestInitialOptionsRef.current?.middleware,\r\n      });\r\n    }\r\n\r\n    const componentKey = `${thisKey}////${componentIdRef.current}`;\r\n\r\n    // Register component in shadow metadata at root level\r\n    const rootMeta = getGlobalStore.getState().getShadowMetadata(thisKey, []);\r\n    const components = rootMeta?.components || new Map();\r\n\r\n    components.set(componentKey, {\r\n      forceUpdate: () => forceUpdate({}),\r\n      reactiveType: reactiveType ?? ['component', 'deps'],\r\n      paths: new Set(),\r\n      depsFunction: reactiveDeps || undefined,\r\n      deps: reactiveDeps\r\n        ? reactiveDeps(getGlobalStore.getState().getShadowValue(thisKey))\r\n        : [],\r\n      prevDeps: reactiveDeps // Initialize prevDeps with the same initial value\r\n        ? reactiveDeps(getGlobalStore.getState().getShadowValue(thisKey))\r\n        : [],\r\n    });\r\n\r\n    getGlobalStore.getState().setShadowMetadata(thisKey, [], {\r\n      ...rootMeta,\r\n      components,\r\n    });\r\n    forceUpdate({});\r\n    return () => {\r\n      const meta = getGlobalStore.getState().getShadowMetadata(thisKey, []);\r\n      const component = meta?.components?.get(componentKey);\r\n\r\n      // Remove from each path we registered to\r\n      if (component?.paths) {\r\n        component.paths.forEach((fullPath) => {\r\n          // fullPath is like \"todos.0.name\", need to split and remove stateKey\r\n          const pathParts = fullPath.split('.');\r\n          const path = pathParts.slice(1); // Remove stateKey part\r\n\r\n          const pathMeta = getGlobalStore\r\n            .getState()\r\n            .getShadowMetadata(thisKey, path);\r\n          if (pathMeta?.pathComponents) {\r\n            // Optionally clean up empty Sets\r\n\r\n            if (pathMeta.pathComponents.size === 0) {\r\n              delete pathMeta.pathComponents;\r\n              getGlobalStore\r\n                .getState()\r\n                .setShadowMetadata(thisKey, path, pathMeta);\r\n            }\r\n          }\r\n        });\r\n      }\r\n\r\n      // Remove from root components\r\n      if (meta?.components) {\r\n        getGlobalStore.getState().setShadowMetadata(thisKey, [], meta);\r\n      }\r\n    };\r\n  }, []);\r\n\r\n  const syncApiRef = useRef<SyncApi | null>(null);\r\n  console.timeEnd('useCogsStateFn top');\r\n\r\n  const effectiveSetState = (\r\n    newStateOrFunction: UpdateArg<TStateObject> | InsertParams<TStateObject>,\r\n    path: string[],\r\n    updateObj: UpdateOptions\r\n  ) => {\r\n    console.time('top of effectiveSetState');\r\n    const fullPath = [thisKey, ...path].join('.');\r\n    const store = getGlobalStore.getState();\r\n\r\n    const shadowMeta = store.getShadowMetadata(thisKey, path);\r\n    const nestedShadowValue = store.getShadowValue(fullPath) as TStateObject;\r\n    console.timeEnd('top of effectiveSetState');\r\n\r\n    console.time('top of payload');\r\n    const payload = (\r\n      updateObj.updateType === 'insert' && isFunction(newStateOrFunction)\r\n        ? newStateOrFunction({ state: nestedShadowValue, uuid: uuidv4() })\r\n        : isFunction(newStateOrFunction)\r\n          ? newStateOrFunction(nestedShadowValue)\r\n          : newStateOrFunction\r\n    ) as TStateObject;\r\n\r\n    const timeStamp = Date.now();\r\n\r\n    const newUpdate = {\r\n      timeStamp,\r\n      stateKey: thisKey,\r\n      path,\r\n      updateType: updateObj.updateType,\r\n      status: 'new' as const,\r\n      oldValue: nestedShadowValue,\r\n      newValue: payload,\r\n    } satisfies UpdateTypeDetail;\r\n    console.timeEnd('top of payload');\r\n\r\n    console.time('switch in effectiveSetState');\r\n    // Perform the update\r\n    switch (updateObj.updateType) {\r\n      case 'insert': {\r\n        store.insertShadowArrayElement(thisKey, path, newUpdate.newValue);\r\n        store.markAsDirty(thisKey, path, { bubble: true });\r\n        const arrayMeta = shadowMeta;\r\n        if (arrayMeta?.arrayKeys) {\r\n          const newItemKey =\r\n            arrayMeta.arrayKeys[arrayMeta.arrayKeys.length - 1];\r\n          if (newItemKey) {\r\n            const newItemPath = newItemKey.split('.').slice(1); // Remove stateKey\r\n            store.markAsDirty(thisKey, newItemPath, { bubble: false });\r\n          }\r\n        }\r\n        break;\r\n      }\r\n      case 'cut': {\r\n        const parentArrayPath = path.slice(0, -1);\r\n\r\n        store.removeShadowArrayElement(thisKey, path);\r\n        store.markAsDirty(thisKey, parentArrayPath, { bubble: true });\r\n        break;\r\n      }\r\n      case 'update': {\r\n        store.updateShadowAtPath(thisKey, path, newUpdate.newValue);\r\n        store.markAsDirty(thisKey, path, { bubble: true });\r\n        break;\r\n      }\r\n    }\r\n    console.timeEnd('switch in effectiveSetState');\r\n    const shouldSync = updateObj.sync !== false;\r\n    console.time('signals');\r\n\r\n    if (shouldSync && syncApiRef.current && syncApiRef.current.connected) {\r\n      syncApiRef.current.updateState({ operation: newUpdate });\r\n    }\r\n    // Handle signals - reuse shadowMeta from the beginning\r\n    if (shadowMeta?.signals && shadowMeta.signals.length > 0) {\r\n      // Use updatedShadowValue if we need the new value, otherwise use payload\r\n      const displayValue = updateObj.updateType === 'cut' ? null : payload;\r\n\r\n      shadowMeta.signals.forEach(({ parentId, position, effect }) => {\r\n        const parent = document.querySelector(`[data-parent-id=\"${parentId}\"]`);\r\n        if (parent) {\r\n          const childNodes = Array.from(parent.childNodes);\r\n          if (childNodes[position]) {\r\n            let finalDisplayValue = displayValue;\r\n            if (effect && displayValue !== null) {\r\n              try {\r\n                finalDisplayValue = new Function(\r\n                  'state',\r\n                  `return (${effect})(state)`\r\n                )(displayValue);\r\n              } catch (err) {\r\n                console.error('Error evaluating effect function:', err);\r\n              }\r\n            }\r\n\r\n            if (\r\n              finalDisplayValue !== null &&\r\n              finalDisplayValue !== undefined &&\r\n              typeof finalDisplayValue === 'object'\r\n            ) {\r\n              finalDisplayValue = JSON.stringify(finalDisplayValue) as any;\r\n            }\r\n\r\n            childNodes[position].textContent = String(finalDisplayValue ?? '');\r\n          }\r\n        }\r\n      });\r\n    }\r\n\r\n    // Update in effectiveSetState for insert handling:\r\n    if (updateObj.updateType === 'insert') {\r\n      // Use shadowMeta from beginning if it's an array\r\n      if (shadowMeta?.mapWrappers && shadowMeta.mapWrappers.length > 0) {\r\n        // Get fresh array keys after insert\r\n        const sourceArrayKeys =\r\n          store.getShadowMetadata(thisKey, path)?.arrayKeys || [];\r\n        const newItemKey = sourceArrayKeys[sourceArrayKeys.length - 1]!;\r\n        const newItemValue = store.getShadowValue(newItemKey);\r\n        const fullSourceArray = store.getShadowValue(\r\n          [thisKey, ...path].join('.')\r\n        );\r\n\r\n        if (!newItemKey || newItemValue === undefined) return;\r\n\r\n        shadowMeta.mapWrappers.forEach((wrapper) => {\r\n          let shouldRender = true;\r\n          let insertPosition = -1;\r\n\r\n          // Check if wrapper has transforms\r\n          if (wrapper.meta?.transforms && wrapper.meta.transforms.length > 0) {\r\n            // Check if new item passes all filters\r\n            for (const transform of wrapper.meta.transforms) {\r\n              if (transform.type === 'filter') {\r\n                if (!transform.fn(newItemValue, -1)) {\r\n                  shouldRender = false;\r\n                  break;\r\n                }\r\n              }\r\n            }\r\n\r\n            if (shouldRender) {\r\n              // Get current valid keys by applying transforms\r\n              const currentValidKeys = applyTransforms(\r\n                thisKey,\r\n                path,\r\n                wrapper.meta.transforms\r\n              );\r\n\r\n              // Find where to insert based on sort\r\n              const sortTransform = wrapper.meta.transforms.find(\r\n                (t: any) => t.type === 'sort'\r\n              );\r\n              if (sortTransform) {\r\n                // Add new item to the list and sort to find position\r\n                const allItems = currentValidKeys.map((key) => ({\r\n                  key,\r\n                  value: store.getShadowValue(key),\r\n                }));\r\n\r\n                allItems.push({ key: newItemKey, value: newItemValue });\r\n                allItems.sort((a, b) => sortTransform.fn(a.value, b.value));\r\n\r\n                insertPosition = allItems.findIndex(\r\n                  (item) => item.key === newItemKey\r\n                );\r\n              } else {\r\n                // No sort, insert at end\r\n                insertPosition = currentValidKeys.length;\r\n              }\r\n            }\r\n          } else {\r\n            // No transforms, always render at end\r\n            shouldRender = true;\r\n            insertPosition = sourceArrayKeys.length - 1;\r\n          }\r\n\r\n          if (!shouldRender) {\r\n            return; // Skip this wrapper, item doesn't pass filters\r\n          }\r\n\r\n          if (wrapper.containerRef && wrapper.containerRef.isConnected) {\r\n            const itemElement = document.createElement('div');\r\n            itemElement.setAttribute('data-item-path', newItemKey);\r\n\r\n            // Insert at correct position\r\n            const children = Array.from(wrapper.containerRef.children);\r\n            if (insertPosition >= 0 && insertPosition < children.length) {\r\n              wrapper.containerRef.insertBefore(\r\n                itemElement,\r\n                children[insertPosition]!\r\n              );\r\n            } else {\r\n              wrapper.containerRef.appendChild(itemElement);\r\n            }\r\n\r\n            const root = createRoot(itemElement);\r\n            const componentId = uuidv4();\r\n            const itemPath = newItemKey.split('.').slice(1);\r\n\r\n            const arraySetter = wrapper.rebuildStateShape({\r\n              path: wrapper.path,\r\n              currentState: fullSourceArray,\r\n              componentId: wrapper.componentId,\r\n              meta: wrapper.meta,\r\n            });\r\n\r\n            root.render(\r\n              createElement(MemoizedCogsItemWrapper, {\r\n                stateKey: thisKey,\r\n                itemComponentId: componentId,\r\n                itemPath: itemPath,\r\n                localIndex: insertPosition,\r\n                arraySetter: arraySetter,\r\n                rebuildStateShape: wrapper.rebuildStateShape,\r\n                renderFn: wrapper.mapFn,\r\n              })\r\n            );\r\n          }\r\n        });\r\n      }\r\n    }\r\n\r\n    if (updateObj.updateType === 'cut') {\r\n      const arrayPath = path.slice(0, -1);\r\n      const arrayMeta = store.getShadowMetadata(thisKey, arrayPath);\r\n\r\n      if (arrayMeta?.mapWrappers && arrayMeta.mapWrappers.length > 0) {\r\n        arrayMeta.mapWrappers.forEach((wrapper) => {\r\n          if (wrapper.containerRef && wrapper.containerRef.isConnected) {\r\n            const elementToRemove = wrapper.containerRef.querySelector(\r\n              `[data-item-path=\"${fullPath}\"]`\r\n            );\r\n            if (elementToRemove) {\r\n              elementToRemove.remove();\r\n            }\r\n          }\r\n        });\r\n      }\r\n    }\r\n    console.timeEnd('signals');\r\n\r\n    console.time('notify');\r\n    const rootMeta = store.getShadowMetadata(thisKey, []);\r\n    const notifiedComponents = new Set<string>();\r\n\r\n    if (!rootMeta?.components) {\r\n      return;\r\n    }\r\n\r\n    // --- PASS 1: Notify specific subscribers based on update type ---\r\n\r\n    if (updateObj.updateType === 'update') {\r\n      // --- Bubble-up Notification ---\r\n      // When a nested property changes, notify components listening at that exact path,\r\n      // and also \"bubble up\" to notify components listening on parent paths.\r\n      // e.g., an update to `user.address.street` notifies listeners of `street`, `address`, and `user`.\r\n      let currentPath = [...path]; // Create a mutable copy of the path\r\n\r\n      while (true) {\r\n        const currentPathMeta = store.getShadowMetadata(thisKey, currentPath);\r\n\r\n        if (currentPathMeta?.pathComponents) {\r\n          currentPathMeta.pathComponents.forEach((componentId) => {\r\n            if (notifiedComponents.has(componentId)) {\r\n              return; // Avoid sending redundant notifications\r\n            }\r\n            const component = rootMeta.components?.get(componentId);\r\n            if (component) {\r\n              const reactiveTypes = Array.isArray(component.reactiveType)\r\n                ? component.reactiveType\r\n                : [component.reactiveType || 'component'];\r\n\r\n              // This notification logic applies to components that depend on object structures.\r\n              if (!reactiveTypes.includes('none')) {\r\n                component.forceUpdate();\r\n                notifiedComponents.add(componentId);\r\n              }\r\n            }\r\n          });\r\n        }\r\n\r\n        if (currentPath.length === 0) {\r\n          break; // We've reached the root, stop bubbling.\r\n        }\r\n        currentPath.pop(); // Go up one level for the next iteration.\r\n      }\r\n\r\n      // ADDITIONALLY, if the payload is an object, perform a deep-check and\r\n      // notify any components that are subscribed to specific sub-paths that changed.\r\n      if (\r\n        payload &&\r\n        typeof payload === 'object' &&\r\n        !isArray(payload) &&\r\n        nestedShadowValue &&\r\n        typeof nestedShadowValue === 'object' &&\r\n        !isArray(nestedShadowValue)\r\n      ) {\r\n        // Get a list of dot-separated paths that have changed (e.g., ['name', 'address.city'])\r\n        const changedSubPaths = getDifferences(payload, nestedShadowValue);\r\n\r\n        changedSubPaths.forEach((subPathString) => {\r\n          const subPath = subPathString.split('.');\r\n          const fullSubPath = [...path, ...subPath];\r\n\r\n          // Get the metadata (and subscribers) for this specific nested path\r\n          const subPathMeta = store.getShadowMetadata(thisKey, fullSubPath);\r\n          if (subPathMeta?.pathComponents) {\r\n            subPathMeta.pathComponents.forEach((componentId) => {\r\n              // Avoid sending a redundant update\r\n              if (notifiedComponents.has(componentId)) {\r\n                return;\r\n              }\r\n              const component = rootMeta.components?.get(componentId);\r\n              if (component) {\r\n                const reactiveTypes = Array.isArray(component.reactiveType)\r\n                  ? component.reactiveType\r\n                  : [component.reactiveType || 'component'];\r\n\r\n                if (!reactiveTypes.includes('none')) {\r\n                  component.forceUpdate();\r\n                  notifiedComponents.add(componentId);\r\n                }\r\n              }\r\n            });\r\n          }\r\n        });\r\n      }\r\n    } else if (\r\n      updateObj.updateType === 'insert' ||\r\n      updateObj.updateType === 'cut'\r\n    ) {\r\n      // For array structural changes, notify components listening to the parent array.\r\n      const parentArrayPath =\r\n        updateObj.updateType === 'insert' ? path : path.slice(0, -1);\r\n\r\n      const parentMeta = store.getShadowMetadata(thisKey, parentArrayPath);\r\n\r\n      // Handle signal updates for array length, etc.\r\n      if (parentMeta?.signals && parentMeta.signals.length > 0) {\r\n        const parentFullPath = [thisKey, ...parentArrayPath].join('.');\r\n        const parentValue = store.getShadowValue(parentFullPath);\r\n\r\n        parentMeta.signals.forEach(({ parentId, position, effect }) => {\r\n          const parent = document.querySelector(\r\n            `[data-parent-id=\"${parentId}\"]`\r\n          );\r\n          if (parent) {\r\n            const childNodes = Array.from(parent.childNodes);\r\n            if (childNodes[position]) {\r\n              let displayValue = parentValue;\r\n              if (effect) {\r\n                try {\r\n                  displayValue = new Function(\r\n                    'state',\r\n                    `return (${effect})(state)`\r\n                  )(parentValue);\r\n                } catch (err) {\r\n                  console.error('Error evaluating effect function:', err);\r\n                  displayValue = parentValue;\r\n                }\r\n              }\r\n\r\n              if (\r\n                displayValue !== null &&\r\n                displayValue !== undefined &&\r\n                typeof displayValue === 'object'\r\n              ) {\r\n                displayValue = JSON.stringify(displayValue);\r\n              }\r\n\r\n              childNodes[position].textContent = String(displayValue ?? '');\r\n            }\r\n          }\r\n        });\r\n      }\r\n\r\n      // Notify components subscribed to the array itself.\r\n      if (parentMeta?.pathComponents) {\r\n        parentMeta.pathComponents.forEach((componentId) => {\r\n          if (!notifiedComponents.has(componentId)) {\r\n            const component = rootMeta.components?.get(componentId);\r\n            if (component) {\r\n              component.forceUpdate();\r\n              notifiedComponents.add(componentId);\r\n            }\r\n          }\r\n        });\r\n      }\r\n    }\r\n\r\n    rootMeta.components.forEach((component, componentId) => {\r\n      if (notifiedComponents.has(componentId)) {\r\n        return;\r\n      }\r\n\r\n      const reactiveTypes = Array.isArray(component.reactiveType)\r\n        ? component.reactiveType\r\n        : [component.reactiveType || 'component'];\r\n\r\n      if (reactiveTypes.includes('all')) {\r\n        component.forceUpdate();\r\n        notifiedComponents.add(componentId);\r\n        return;\r\n      }\r\n\r\n      if (reactiveTypes.includes('deps')) {\r\n        if (component.depsFunction) {\r\n          const currentState = store.getShadowValue(thisKey);\r\n          const newDeps = component.depsFunction(currentState);\r\n          let shouldUpdate = false;\r\n\r\n          if (newDeps === true) {\r\n            shouldUpdate = true;\r\n          } else if (Array.isArray(newDeps)) {\r\n            if (!isDeepEqual(component.prevDeps, newDeps)) {\r\n              component.prevDeps = newDeps;\r\n              shouldUpdate = true;\r\n            }\r\n          }\r\n\r\n          if (shouldUpdate) {\r\n            component.forceUpdate();\r\n            notifiedComponents.add(componentId);\r\n          }\r\n        }\r\n      }\r\n    });\r\n    notifiedComponents.clear();\r\n    console.timeEnd('notify');\r\n    console.time('end stuff');\r\n    addStateLog(thisKey, newUpdate);\r\n\r\n    saveToLocalStorage(\r\n      payload,\r\n      thisKey,\r\n      latestInitialOptionsRef.current,\r\n      sessionId\r\n    );\r\n\r\n    if (latestInitialOptionsRef.current?.middleware) {\r\n      latestInitialOptionsRef.current!.middleware({\r\n        update: newUpdate,\r\n      });\r\n    }\r\n    console.timeEnd('end stuff');\r\n  };\r\n\r\n  if (!getGlobalStore.getState().initialStateGlobal[thisKey]) {\r\n    updateInitialStateGlobal(thisKey, stateObject);\r\n  }\r\n\r\n  const updaterFinal = useMemo(() => {\r\n    console.time('createProxyHandler');\r\n    const handler = createProxyHandler<TStateObject>(\r\n      thisKey,\r\n      effectiveSetState,\r\n      componentIdRef.current,\r\n      sessionId\r\n    );\r\n    console.timeEnd('createProxyHandler'); // <--- AND THIS\r\n    return handler;\r\n  }, [thisKey, sessionId]);\r\n\r\n  const cogsSyncFn = __useSync;\r\n  const syncOpt = latestInitialOptionsRef.current?.syncOptions;\r\n\r\n  if (cogsSyncFn) {\r\n    syncApiRef.current = cogsSyncFn(\r\n      updaterFinal as any,\r\n      syncOpt ?? ({} as any)\r\n    );\r\n  }\r\n\r\n  return updaterFinal;\r\n}\r\n\r\nexport type MetaData = {\r\n  /**\r\n   * An array of the full, unique string IDs (e.g., `\"stateKey.arrayName.id:123\"`)\r\n   * of the items that belong to the current derived \"view\" of an array.\r\n   * This is the primary mechanism for tracking the state of filtered or sorted lists.\r\n   *\r\n   * - `stateFilter` populates this with only the IDs of items that passed the filter.\r\n   * - `stateSort` reorders this list to match the new sort order.\r\n   * - All subsequent chained operations (like `.get()`, `.index()`, or `.cut()`)\r\n   *   MUST consult this list first to know which items they apply to and in what order.\r\n   */\r\n  validIds?: string[];\r\n\r\n  /**\r\n   * An array of the actual filter functions that have been applied in a chain.\r\n   * This is primarily used by reactive renderers like `$stateMap` to make predictions.\r\n   *\r\n   * For example, when a new item is inserted into the original source array, a\r\n   * `$stateMap` renderer on a filtered view can use these functions to test if the\r\n   * newly inserted item should be dynamically rendered in its view.\r\n   */\r\n  transforms?: Array<{\r\n    type: 'filter' | 'sort';\r\n    fn: Function;\r\n  }>;\r\n};\r\n\r\nfunction hashTransforms(transforms: any[]) {\r\n  if (!transforms || transforms.length === 0) {\r\n    return '';\r\n  }\r\n  // This creates a string representation of the transforms AND their dependencies.\r\n  // Example: \"filter['red']sort['score','asc']\"\r\n  return transforms\r\n    .map(\r\n      (transform) =>\r\n        // Safely stringify dependencies. An empty array becomes '[]'.\r\n        `${transform.type}${JSON.stringify(transform.dependencies || [])}`\r\n    )\r\n    .join('');\r\n}\r\nconst applyTransforms = (\r\n  stateKey: string,\r\n  path: string[],\r\n  transforms?: Array<{ type: 'filter' | 'sort'; fn: Function }>\r\n): string[] => {\r\n  let arrayKeys =\r\n    getGlobalStore.getState().getShadowMetadata(stateKey, path)?.arrayKeys ||\r\n    [];\r\n\r\n  if (!transforms || transforms.length === 0) {\r\n    return arrayKeys;\r\n  }\r\n\r\n  let itemsWithKeys = arrayKeys.map((key) => ({\r\n    key,\r\n    value: getGlobalStore.getState().getShadowValue(key),\r\n  }));\r\n\r\n  for (const transform of transforms) {\r\n    if (transform.type === 'filter') {\r\n      itemsWithKeys = itemsWithKeys.filter(({ value }, index) =>\r\n        transform.fn(value, index)\r\n      );\r\n    } else if (transform.type === 'sort') {\r\n      itemsWithKeys.sort((a, b) => transform.fn(a.value, b.value));\r\n    }\r\n  }\r\n\r\n  return itemsWithKeys.map(({ key }) => key);\r\n};\r\nconst registerComponentDependency = (\r\n  stateKey: string,\r\n  componentId: string,\r\n  dependencyPath: string[]\r\n) => {\r\n  const fullComponentId = `${stateKey}////${componentId}`;\r\n  const { addPathComponent, getShadowMetadata } = getGlobalStore.getState();\r\n\r\n  // First, check if the component should even be registered.\r\n  // This check is safe to do outside the setter.\r\n  const rootMeta = getShadowMetadata(stateKey, []);\r\n  const component = rootMeta?.components?.get(fullComponentId);\r\n\r\n  if (\r\n    !component ||\r\n    component.reactiveType === 'none' ||\r\n    !(\r\n      Array.isArray(component.reactiveType)\r\n        ? component.reactiveType\r\n        : [component.reactiveType]\r\n    ).includes('component')\r\n  ) {\r\n    return;\r\n  }\r\n\r\n  // Now, call the single, safe, atomic function to perform the update.\r\n  addPathComponent(stateKey, dependencyPath, fullComponentId);\r\n};\r\nconst notifySelectionComponents = (\r\n  stateKey: string,\r\n  parentPath: string[],\r\n  currentSelected?: string | undefined\r\n) => {\r\n  const store = getGlobalStore.getState();\r\n  const rootMeta = store.getShadowMetadata(stateKey, []);\r\n  const notifiedComponents = new Set<string>();\r\n\r\n  // Handle \"all\" reactive components first\r\n  if (rootMeta?.components) {\r\n    rootMeta.components.forEach((component, componentId) => {\r\n      const reactiveTypes = Array.isArray(component.reactiveType)\r\n        ? component.reactiveType\r\n        : [component.reactiveType || 'component'];\r\n\r\n      if (reactiveTypes.includes('all')) {\r\n        component.forceUpdate();\r\n        notifiedComponents.add(componentId);\r\n      }\r\n    });\r\n  }\r\n\r\n  store\r\n    .getShadowMetadata(stateKey, [...parentPath, 'getSelected'])\r\n    ?.pathComponents?.forEach((componentId) => {\r\n      const thisComp = rootMeta?.components?.get(componentId);\r\n      thisComp?.forceUpdate();\r\n    });\r\n\r\n  const parentMeta = store.getShadowMetadata(stateKey, parentPath);\r\n  for (let arrayKey of parentMeta?.arrayKeys || []) {\r\n    const key = arrayKey + '.selected';\r\n    const selectedItem = store.getShadowMetadata(\r\n      stateKey,\r\n      key.split('.').slice(1)\r\n    );\r\n    if (arrayKey == currentSelected) {\r\n      selectedItem?.pathComponents?.forEach((componentId) => {\r\n        const thisComp = rootMeta?.components?.get(componentId);\r\n        thisComp?.forceUpdate();\r\n      });\r\n    }\r\n  }\r\n};\r\n\r\nfunction createProxyHandler<T>(\r\n  stateKey: string,\r\n  effectiveSetState: EffectiveSetState<T>,\r\n  componentId: string,\r\n  sessionId?: string\r\n): StateObject<T> {\r\n  const proxyCache = new Map<string, any>();\r\n  let stateVersion = 0;\r\n  console.time('rebuildStateShape Outer');\r\n\r\n  let recursionTimerName: string | null = null;\r\n\r\n  function rebuildStateShape({\r\n    path = [],\r\n    meta,\r\n    componentId,\r\n  }: {\r\n    path: string[];\r\n    componentId: string;\r\n    meta?: MetaData;\r\n  }): any {\r\n    console.time('rebuildStateShape Inner');\r\n    const derivationSignature = meta\r\n      ? JSON.stringify(meta.validIds || meta.transforms)\r\n      : '';\r\n    const cacheKey = path.join('.') + ':' + derivationSignature;\r\n    console.log('PROXY CACHE KEY ', cacheKey);\r\n    if (proxyCache.has(cacheKey)) {\r\n      console.log('PROXY CACHE HIT');\r\n      return proxyCache.get(cacheKey);\r\n    }\r\n    const stateKeyPathKey = [stateKey, ...path].join('.');\r\n\r\n    type CallableStateObject<T> = {\r\n      (): T;\r\n    } & {\r\n      [key: string]: any;\r\n    };\r\n\r\n    const baseFunction = function () {\r\n      return getGlobalStore().getShadowValue(stateKey, path);\r\n    } as unknown as CallableStateObject<T>;\r\n\r\n    // We attach baseObj properties *inside* the get trap now to avoid recursion\r\n    // This is a placeholder for the proxy.\r\n\r\n    const handler = {\r\n      apply(target: any, thisArg: any, args: any[]) {\r\n        //return getGlobalStore().getShadowValue(stateKey, path);\r\n      },\r\n\r\n      get(target: any, prop: string) {\r\n        if (path.length === 0) {\r\n          // Create a unique name for this specific timer instance\r\n          recursionTimerName = `Recursion-${Math.random()}`;\r\n          console.time(recursionTimerName);\r\n        }\r\n        if (prop === '_rebuildStateShape') {\r\n          return rebuildStateShape;\r\n        }\r\n        const baseObjProps = Object.getOwnPropertyNames(baseObj);\r\n        if (baseObjProps.includes(prop) && path.length === 0) {\r\n          return (baseObj as any)[prop];\r\n        }\r\n        // ^--------- END OF FIX ---------^\r\n\r\n        if (prop === 'getDifferences') {\r\n          return () => {\r\n            const shadowMeta = getGlobalStore\r\n              .getState()\r\n              .getShadowMetadata(stateKey, []);\r\n            const currentState = getGlobalStore\r\n              .getState()\r\n              .getShadowValue(stateKey);\r\n\r\n            // Use the appropriate base state for comparison\r\n            let baseState;\r\n            if (\r\n              shadowMeta?.stateSource === 'server' &&\r\n              shadowMeta.baseServerState\r\n            ) {\r\n              baseState = shadowMeta.baseServerState;\r\n            } else {\r\n              baseState =\r\n                getGlobalStore.getState().initialStateGlobal[stateKey];\r\n            }\r\n\r\n            return getDifferences(currentState, baseState);\r\n          };\r\n        }\r\n        if (prop === 'sync' && path.length === 0) {\r\n          return async function () {\r\n            const options = getGlobalStore\r\n              .getState()\r\n              .getInitialOptions(stateKey);\r\n            const sync = options?.sync;\r\n\r\n            if (!sync) {\r\n              console.error(`No mutation defined for state key \"${stateKey}\"`);\r\n              return { success: false, error: `No mutation defined` };\r\n            }\r\n\r\n            const state = getGlobalStore\r\n              .getState()\r\n              .getShadowValue(stateKey, []);\r\n            const validationKey = options?.validation?.key;\r\n\r\n            try {\r\n              const response = await sync.action(state);\r\n              if (\r\n                response &&\r\n                !response.success &&\r\n                response.errors &&\r\n                validationKey\r\n              ) {\r\n                //  getGlobalStore.getState().removeValidationError(validationKey);\r\n                // response.errors.forEach((error) => {\r\n                //   const errorPath = [validationKey, ...error.path].join('.');\r\n                //   getGlobalStore\r\n                //     .getState()\r\n                //     .addValidationError(errorPath, error.message);\r\n                // });\r\n                //   notifyComponents(stateKey);\r\n              }\r\n\r\n              if (response?.success) {\r\n                // Mark as synced and not dirty\r\n                const shadowMeta = getGlobalStore\r\n                  .getState()\r\n                  .getShadowMetadata(stateKey, []);\r\n                getGlobalStore.getState().setShadowMetadata(stateKey, [], {\r\n                  ...shadowMeta,\r\n                  isDirty: false,\r\n                  lastServerSync: Date.now(),\r\n                  stateSource: 'server',\r\n                  baseServerState: state, // Update base server state\r\n                });\r\n\r\n                if (sync.onSuccess) {\r\n                  sync.onSuccess(response.data);\r\n                }\r\n              } else if (!response?.success && sync.onError)\r\n                sync.onError(response.error);\r\n\r\n              return response;\r\n            } catch (error) {\r\n              if (sync.onError) sync.onError(error);\r\n              return { success: false, error };\r\n            }\r\n          };\r\n        }\r\n        // Fixed getStatus function in createProxyHandler\r\n        if (prop === '_status' || prop === 'getStatus') {\r\n          const getStatusFunc = () => {\r\n            const shadowMeta = getGlobalStore\r\n              .getState()\r\n              .getShadowMetadata(stateKey, path);\r\n            const value = getGlobalStore\r\n              .getState()\r\n              .getShadowValue(stateKeyPathKey);\r\n\r\n            // Priority 1: Explicitly dirty items\r\n            if (shadowMeta?.isDirty === true) {\r\n              return 'dirty';\r\n            }\r\n\r\n            // Priority 2: Explicitly synced items (isDirty: false)\r\n            if (shadowMeta?.isDirty === false) {\r\n              return 'synced';\r\n            }\r\n\r\n            // Priority 3: Items from server source (should be synced even without explicit isDirty flag)\r\n            if (shadowMeta?.stateSource === 'server') {\r\n              return 'synced';\r\n            }\r\n\r\n            // Priority 4: Items restored from localStorage\r\n            if (shadowMeta?.stateSource === 'localStorage') {\r\n              return 'restored';\r\n            }\r\n\r\n            // Priority 5: Items from default/initial state\r\n            if (shadowMeta?.stateSource === 'default') {\r\n              return 'fresh';\r\n            }\r\n\r\n            // Priority 6: Check if this is part of initial server load\r\n            // Look up the tree to see if parent has server source\r\n            const rootMeta = getGlobalStore\r\n              .getState()\r\n              .getShadowMetadata(stateKey, []);\r\n            if (rootMeta?.stateSource === 'server' && !shadowMeta?.isDirty) {\r\n              return 'synced';\r\n            }\r\n\r\n            // Priority 7: If no metadata exists but value exists, it's probably fresh\r\n            if (value !== undefined && !shadowMeta) {\r\n              return 'fresh';\r\n            }\r\n\r\n            // Fallback\r\n            return 'unknown';\r\n          };\r\n\r\n          return prop === '_status' ? getStatusFunc() : getStatusFunc;\r\n        }\r\n        if (prop === 'removeStorage') {\r\n          return () => {\r\n            const initialState =\r\n              getGlobalStore.getState().initialStateGlobal[stateKey];\r\n            const initalOptionsGet = getInitialOptions(stateKey as string);\r\n            const localKey = isFunction(initalOptionsGet?.localStorage?.key)\r\n              ? initalOptionsGet.localStorage.key(initialState)\r\n              : initalOptionsGet?.localStorage?.key;\r\n            const storageKey = `${sessionId}-${stateKey}-${localKey}`;\r\n            if (storageKey) localStorage.removeItem(storageKey);\r\n          };\r\n        }\r\n        if (prop === 'showValidationErrors') {\r\n          return () => {\r\n            const meta = getGlobalStore\r\n              .getState()\r\n              .getShadowMetadata(stateKey, path);\r\n            if (\r\n              meta?.validation?.status === 'VALIDATION_FAILED' &&\r\n              meta.validation.message\r\n            ) {\r\n              return [meta.validation.message];\r\n            }\r\n            return [];\r\n          };\r\n        }\r\n\r\n        if (prop === 'getSelected') {\r\n          return () => {\r\n            const fullKey = stateKey + '.' + path.join('.');\r\n            registerComponentDependency(stateKey, componentId, [\r\n              ...path,\r\n              'getSelected',\r\n            ]);\r\n\r\n            const selectedIndicesMap =\r\n              getGlobalStore.getState().selectedIndicesMap;\r\n            if (!selectedIndicesMap || !selectedIndicesMap.has(fullKey)) {\r\n              return undefined;\r\n            }\r\n\r\n            const selectedItemKey = selectedIndicesMap.get(fullKey)!;\r\n            if (meta?.validIds) {\r\n              if (!meta.validIds.includes(selectedItemKey)) {\r\n                return undefined;\r\n              }\r\n            }\r\n\r\n            const value = getGlobalStore\r\n              .getState()\r\n              .getShadowValue(selectedItemKey);\r\n\r\n            if (!value) {\r\n              return undefined;\r\n            }\r\n\r\n            return rebuildStateShape({\r\n              path: selectedItemKey.split('.').slice(1) as string[],\r\n              componentId: componentId!,\r\n            });\r\n          };\r\n        }\r\n        if (prop === 'getSelectedIndex') {\r\n          return () => {\r\n            const selectedIndex = getGlobalStore\r\n              .getState()\r\n              .getSelectedIndex(\r\n                stateKey + '.' + path.join('.'),\r\n                meta?.validIds\r\n              );\r\n\r\n            return selectedIndex;\r\n          };\r\n        }\r\n        if (prop === 'clearSelected') {\r\n          notifySelectionComponents(stateKey, path);\r\n          return () => {\r\n            getGlobalStore.getState().clearSelectedIndex({\r\n              arrayKey: stateKey + '.' + path.join('.'),\r\n            });\r\n          };\r\n        }\r\n\r\n        if (prop === 'useVirtualView') {\r\n          return (\r\n            options: VirtualViewOptions\r\n          ): VirtualStateObjectResult<any[]> => {\r\n            const {\r\n              itemHeight = 50,\r\n              overscan = 6,\r\n              stickToBottom = false,\r\n              scrollStickTolerance = 75,\r\n            } = options;\r\n\r\n            const containerRef = useRef<HTMLDivElement | null>(null);\r\n            const [range, setRange] = useState({\r\n              startIndex: 0,\r\n              endIndex: 10,\r\n            });\r\n            const [rerender, forceUpdate] = useState({});\r\n            const initialScrollRef = useRef(true);\r\n\r\n            // Scroll state management\r\n            const scrollStateRef = useRef({\r\n              isUserScrolling: false,\r\n              lastScrollTop: 0,\r\n              scrollUpCount: 0,\r\n              isNearBottom: true,\r\n            });\r\n\r\n            // Measurement cache\r\n            const measurementCache = useRef(\r\n              new Map<string, { height: number; offset: number }>()\r\n            );\r\n\r\n            // Separate effect for handling rerender updates\r\n            useLayoutEffect(() => {\r\n              if (\r\n                !stickToBottom ||\r\n                !containerRef.current ||\r\n                scrollStateRef.current.isUserScrolling\r\n              )\r\n                return;\r\n\r\n              const container = containerRef.current;\r\n              container.scrollTo({\r\n                top: container.scrollHeight,\r\n                behavior: initialScrollRef.current ? 'instant' : 'smooth',\r\n              });\r\n            }, [rerender, stickToBottom]);\r\n\r\n            const arrayKeys =\r\n              getGlobalStore.getState().getShadowMetadata(stateKey, path)\r\n                ?.arrayKeys || [];\r\n\r\n            // Calculate total height and offsets\r\n            const { totalHeight, itemOffsets } = useMemo(() => {\r\n              let runningOffset = 0;\r\n              const offsets = new Map<\r\n                string,\r\n                { height: number; offset: number }\r\n              >();\r\n              const allItemKeys =\r\n                getGlobalStore.getState().getShadowMetadata(stateKey, path)\r\n                  ?.arrayKeys || [];\r\n\r\n              allItemKeys.forEach((itemKey) => {\r\n                const itemPath = itemKey.split('.').slice(1);\r\n                const measuredHeight =\r\n                  getGlobalStore\r\n                    .getState()\r\n                    .getShadowMetadata(stateKey, itemPath)?.virtualizer\r\n                    ?.itemHeight || itemHeight;\r\n\r\n                offsets.set(itemKey, {\r\n                  height: measuredHeight,\r\n                  offset: runningOffset,\r\n                });\r\n\r\n                runningOffset += measuredHeight;\r\n              });\r\n\r\n              measurementCache.current = offsets;\r\n              return { totalHeight: runningOffset, itemOffsets: offsets };\r\n            }, [arrayKeys.length, itemHeight]);\r\n\r\n            // Improved initial positioning effect\r\n            useLayoutEffect(() => {\r\n              if (\r\n                stickToBottom &&\r\n                arrayKeys.length > 0 &&\r\n                containerRef.current &&\r\n                !scrollStateRef.current.isUserScrolling &&\r\n                initialScrollRef.current\r\n              ) {\r\n                const container = containerRef.current;\r\n\r\n                // Wait for container to have dimensions\r\n                const waitForContainer = () => {\r\n                  if (container.clientHeight > 0) {\r\n                    const visibleCount = Math.ceil(\r\n                      container.clientHeight / itemHeight\r\n                    );\r\n                    const endIndex = arrayKeys.length - 1;\r\n                    const startIndex = Math.max(\r\n                      0,\r\n                      endIndex - visibleCount - overscan\r\n                    );\r\n\r\n                    setRange({ startIndex, endIndex });\r\n\r\n                    // Ensure scroll after range is set\r\n                    requestAnimationFrame(() => {\r\n                      scrollToBottom('instant');\r\n                      initialScrollRef.current = false; // Mark initial scroll as done\r\n                    });\r\n                  } else {\r\n                    // Container not ready, try again\r\n                    requestAnimationFrame(waitForContainer);\r\n                  }\r\n                };\r\n\r\n                waitForContainer();\r\n              }\r\n            }, [arrayKeys.length, stickToBottom, itemHeight, overscan]);\r\n\r\n            // Combined scroll handler\r\n            const handleScroll = useCallback(() => {\r\n              const container = containerRef.current;\r\n              if (!container) return;\r\n\r\n              const currentScrollTop = container.scrollTop;\r\n              const { scrollHeight, clientHeight } = container;\r\n              const scrollState = scrollStateRef.current;\r\n\r\n              // Check if user is near bottom\r\n              const distanceFromBottom =\r\n                scrollHeight - (currentScrollTop + clientHeight);\r\n              const wasNearBottom = scrollState.isNearBottom;\r\n              scrollState.isNearBottom =\r\n                distanceFromBottom <= scrollStickTolerance;\r\n\r\n              // Detect scroll direction\r\n              if (currentScrollTop < scrollState.lastScrollTop) {\r\n                // User scrolled up\r\n                scrollState.scrollUpCount++;\r\n\r\n                if (scrollState.scrollUpCount > 3 && wasNearBottom) {\r\n                  // User has deliberately scrolled away from bottom\r\n                  scrollState.isUserScrolling = true;\r\n                  console.log('User scrolled away from bottom');\r\n                }\r\n              } else if (scrollState.isNearBottom) {\r\n                // Reset if we're back near the bottom\r\n                scrollState.isUserScrolling = false;\r\n                scrollState.scrollUpCount = 0;\r\n              }\r\n\r\n              scrollState.lastScrollTop = currentScrollTop;\r\n\r\n              // Update visible range\r\n              let newStartIndex = 0;\r\n              for (let i = 0; i < arrayKeys.length; i++) {\r\n                const itemKey = arrayKeys[i];\r\n                const item = measurementCache.current.get(itemKey!);\r\n                if (item && item.offset + item.height > currentScrollTop) {\r\n                  newStartIndex = i;\r\n                  break;\r\n                }\r\n              }\r\n\r\n              // Only update if range actually changed\r\n              if (newStartIndex !== range.startIndex) {\r\n                const visibleCount = Math.ceil(clientHeight / itemHeight);\r\n                setRange({\r\n                  startIndex: Math.max(0, newStartIndex - overscan),\r\n                  endIndex: Math.min(\r\n                    arrayKeys.length - 1,\r\n                    newStartIndex + visibleCount + overscan\r\n                  ),\r\n                });\r\n              }\r\n            }, [\r\n              arrayKeys.length,\r\n              range.startIndex,\r\n              itemHeight,\r\n              overscan,\r\n              scrollStickTolerance,\r\n            ]);\r\n\r\n            // Set up scroll listener\r\n            useEffect(() => {\r\n              const container = containerRef.current;\r\n              if (!container || !stickToBottom) return;\r\n\r\n              container.addEventListener('scroll', handleScroll, {\r\n                passive: true,\r\n              });\r\n\r\n              return () => {\r\n                container.removeEventListener('scroll', handleScroll);\r\n              };\r\n            }, [handleScroll, stickToBottom]);\r\n            const scrollToBottom = useCallback(\r\n              (behavior: ScrollBehavior = 'smooth') => {\r\n                const container = containerRef.current;\r\n                if (!container) return;\r\n\r\n                // Reset scroll state\r\n                scrollStateRef.current.isUserScrolling = false;\r\n                scrollStateRef.current.isNearBottom = true;\r\n                scrollStateRef.current.scrollUpCount = 0;\r\n\r\n                const performScroll = () => {\r\n                  // Multiple attempts to ensure we hit the bottom\r\n                  const attemptScroll = (attempts = 0) => {\r\n                    if (attempts > 5) return; // Prevent infinite loops\r\n\r\n                    const currentHeight = container.scrollHeight;\r\n                    const currentScroll = container.scrollTop;\r\n                    const clientHeight = container.clientHeight;\r\n\r\n                    // Check if we're already at the bottom\r\n                    if (currentScroll + clientHeight >= currentHeight - 1) {\r\n                      return;\r\n                    }\r\n\r\n                    container.scrollTo({\r\n                      top: currentHeight,\r\n                      behavior: behavior,\r\n                    });\r\n\r\n                    // In slow environments, check again after a short delay\r\n                    setTimeout(() => {\r\n                      const newHeight = container.scrollHeight;\r\n                      const newScroll = container.scrollTop;\r\n\r\n                      // If height changed or we're not at bottom, try again\r\n                      if (\r\n                        newHeight !== currentHeight ||\r\n                        newScroll + clientHeight < newHeight - 1\r\n                      ) {\r\n                        attemptScroll(attempts + 1);\r\n                      }\r\n                    }, 50);\r\n                  };\r\n\r\n                  attemptScroll();\r\n                };\r\n\r\n                // Use requestIdleCallback for better performance in slow environments\r\n                if ('requestIdleCallback' in window) {\r\n                  requestIdleCallback(performScroll, { timeout: 100 });\r\n                } else {\r\n                  // Fallback to rAF chain\r\n                  requestAnimationFrame(() => {\r\n                    requestAnimationFrame(performScroll);\r\n                  });\r\n                }\r\n              },\r\n              []\r\n            );\r\n            // Auto-scroll to bottom when new content arrives\r\n            // Consolidated auto-scroll effect with debouncing\r\n            useEffect(() => {\r\n              if (!stickToBottom || !containerRef.current) return;\r\n\r\n              const container = containerRef.current;\r\n              const scrollState = scrollStateRef.current;\r\n\r\n              // Debounced scroll function\r\n              let scrollTimeout: NodeJS.Timeout;\r\n              const debouncedScrollToBottom = () => {\r\n                clearTimeout(scrollTimeout);\r\n                scrollTimeout = setTimeout(() => {\r\n                  if (\r\n                    !scrollState.isUserScrolling &&\r\n                    scrollState.isNearBottom\r\n                  ) {\r\n                    scrollToBottom(\r\n                      initialScrollRef.current ? 'instant' : 'smooth'\r\n                    );\r\n                  }\r\n                }, 100);\r\n              };\r\n\r\n              // Single MutationObserver for all DOM changes\r\n              const observer = new MutationObserver(() => {\r\n                if (!scrollState.isUserScrolling) {\r\n                  debouncedScrollToBottom();\r\n                }\r\n              });\r\n\r\n              observer.observe(container, {\r\n                childList: true,\r\n                subtree: true,\r\n                attributes: true,\r\n                attributeFilter: ['style', 'class'], // More specific than just 'height'\r\n              });\r\n\r\n              // Handle image loads with event delegation\r\n              const handleImageLoad = (e: Event) => {\r\n                if (\r\n                  e.target instanceof HTMLImageElement &&\r\n                  !scrollState.isUserScrolling\r\n                ) {\r\n                  debouncedScrollToBottom();\r\n                }\r\n              };\r\n\r\n              container.addEventListener('load', handleImageLoad, true);\r\n\r\n              // Initial scroll with proper timing\r\n              if (initialScrollRef.current) {\r\n                // For initial load, wait for next tick to ensure DOM is ready\r\n                setTimeout(() => {\r\n                  scrollToBottom('instant');\r\n                }, 0);\r\n              } else {\r\n                debouncedScrollToBottom();\r\n              }\r\n\r\n              return () => {\r\n                clearTimeout(scrollTimeout);\r\n                observer.disconnect();\r\n                container.removeEventListener('load', handleImageLoad, true);\r\n              };\r\n            }, [stickToBottom, arrayKeys.length, scrollToBottom]);\r\n            // Create virtual state\r\n            const virtualState = useMemo(() => {\r\n              const store = getGlobalStore.getState();\r\n              const sourceArray = store.getShadowValue(\r\n                [stateKey, ...path].join('.')\r\n              ) as any[];\r\n              const currentKeys =\r\n                store.getShadowMetadata(stateKey, path)?.arrayKeys || [];\r\n\r\n              const slicedArray = sourceArray.slice(\r\n                range.startIndex,\r\n                range.endIndex + 1\r\n              );\r\n              const slicedIds = currentKeys.slice(\r\n                range.startIndex,\r\n                range.endIndex + 1\r\n              );\r\n\r\n              return rebuildStateShape({\r\n                path,\r\n                componentId: componentId!,\r\n                meta: { ...meta, validIds: slicedIds },\r\n              });\r\n            }, [range.startIndex, range.endIndex, arrayKeys.length]);\r\n\r\n            return {\r\n              virtualState,\r\n              virtualizerProps: {\r\n                outer: {\r\n                  ref: containerRef,\r\n                  style: {\r\n                    overflowY: 'auto',\r\n                    height: '100%',\r\n                    position: 'relative',\r\n                  },\r\n                },\r\n                inner: {\r\n                  style: {\r\n                    height: `${totalHeight}px`,\r\n                    position: 'relative',\r\n                  },\r\n                },\r\n                list: {\r\n                  style: {\r\n                    transform: `translateY(${\r\n                      measurementCache.current.get(arrayKeys[range.startIndex]!)\r\n                        ?.offset || 0\r\n                    }px)`,\r\n                  },\r\n                },\r\n              },\r\n              scrollToBottom,\r\n              scrollToIndex: (\r\n                index: number,\r\n                behavior: ScrollBehavior = 'smooth'\r\n              ) => {\r\n                if (containerRef.current && arrayKeys[index]) {\r\n                  const offset =\r\n                    measurementCache.current.get(arrayKeys[index]!)?.offset ||\r\n                    0;\r\n                  containerRef.current.scrollTo({ top: offset, behavior });\r\n                }\r\n              },\r\n            };\r\n          };\r\n        }\r\n        if (prop === 'stateMap') {\r\n          return (\r\n            callbackfn: (\r\n              setter: any,\r\n              index: number,\r\n\r\n              arraySetter: any\r\n            ) => void\r\n          ) => {\r\n            const [arrayKeys, setArrayKeys] = useState<any>(\r\n              meta?.validIds ??\r\n                getGlobalStore.getState().getShadowMetadata(stateKey, path)\r\n                  ?.arrayKeys\r\n            );\r\n            // getGlobalStore.getState().subscribeToPath(stateKeyPathKey, () => {\r\n            //   console.log(\r\n            //     \"stateKeyPathKeyccccccccccccccccc\",\r\n            //     stateKeyPathKey\r\n            //   );\r\n            //   setArrayKeys(\r\n            //     getGlobalStore.getState().getShadowMetadata(stateKey, path)\r\n            //   );\r\n            // });\r\n\r\n            const shadowValue = getGlobalStore\r\n              .getState()\r\n              .getShadowValue(stateKeyPathKey, meta?.validIds) as any[];\r\n            if (!arrayKeys) {\r\n              throw new Error('No array keys found for mapping');\r\n            }\r\n            const arraySetter = rebuildStateShape({\r\n              path,\r\n              componentId: componentId!,\r\n              meta,\r\n            });\r\n\r\n            return shadowValue.map((item, index) => {\r\n              const itemPath = arrayKeys[index]?.split('.').slice(1);\r\n              const itemSetter = rebuildStateShape({\r\n                path: itemPath as any,\r\n                componentId: componentId!,\r\n                meta,\r\n              });\r\n\r\n              return callbackfn(\r\n                itemSetter,\r\n                index,\r\n\r\n                arraySetter\r\n              );\r\n            });\r\n          };\r\n        }\r\n\r\n        if (prop === '$stateMap') {\r\n          return (callbackfn: any) =>\r\n            createElement(SignalMapRenderer, {\r\n              proxy: {\r\n                _stateKey: stateKey,\r\n                _path: path,\r\n                _mapFn: callbackfn,\r\n                _meta: meta,\r\n              },\r\n              rebuildStateShape,\r\n            });\r\n        } // In createProxyHandler -> handler -> get -> if (Array.isArray(currentState))\r\n\r\n        if (prop === 'stateFind') {\r\n          return (\r\n            callbackfn: (value: any, index: number) => boolean\r\n          ): StateObject<any> | undefined => {\r\n            // 1. Use the correct set of keys: filtered/sorted from meta, or all keys from the store.\r\n            const arrayKeys =\r\n              meta?.validIds ??\r\n              getGlobalStore.getState().getShadowMetadata(stateKey, path)\r\n                ?.arrayKeys;\r\n\r\n            if (!arrayKeys) {\r\n              return undefined;\r\n            }\r\n\r\n            // 2. Iterate through the keys, get the value for each, and run the callback.\r\n            for (let i = 0; i < arrayKeys.length; i++) {\r\n              const itemKey = arrayKeys[i];\r\n              if (!itemKey) continue; // Safety check\r\n\r\n              const itemValue = getGlobalStore\r\n                .getState()\r\n                .getShadowValue(itemKey);\r\n\r\n              // 3. If the callback returns true, we've found our item.\r\n              if (callbackfn(itemValue, i)) {\r\n                // Get the item's path relative to the stateKey (e.g., ['messages', '42'] -> ['42'])\r\n                const itemPath = itemKey.split('.').slice(1);\r\n\r\n                // 4. Rebuild a new, fully functional StateObject for just that item and return it.\r\n                return rebuildStateShape({\r\n                  path: itemPath,\r\n                  componentId: componentId,\r\n                  meta, // Pass along meta for potential further chaining\r\n                });\r\n              }\r\n            }\r\n\r\n            // 5. If the loop finishes without finding anything, return undefined.\r\n            return undefined;\r\n          };\r\n        }\r\n        if (prop === 'stateFilter') {\r\n          return (callbackfn: (value: any, index: number) => boolean) => {\r\n            const currentState = getGlobalStore\r\n              .getState()\r\n              .getShadowValue([stateKey, ...path].join('.'), meta?.validIds);\r\n            if (!Array.isArray(currentState)) return [];\r\n            const arrayKeys =\r\n              meta?.validIds ??\r\n              getGlobalStore.getState().getShadowMetadata(stateKey, path)\r\n                ?.arrayKeys;\r\n\r\n            if (!arrayKeys) {\r\n              throw new Error('No array keys found for filtering.');\r\n            }\r\n\r\n            const newValidIds: string[] = [];\r\n            const filteredArray = currentState.filter(\r\n              (val: any, index: number) => {\r\n                const didPass = callbackfn(val, index);\r\n                if (didPass) {\r\n                  newValidIds.push(arrayKeys[index]!);\r\n                  return true;\r\n                }\r\n                return false;\r\n              }\r\n            );\r\n\r\n            return rebuildStateShape({\r\n              path,\r\n              componentId: componentId!,\r\n              meta: {\r\n                validIds: newValidIds,\r\n                transforms: [\r\n                  ...(meta?.transforms || []),\r\n                  {\r\n                    type: 'filter',\r\n                    fn: callbackfn,\r\n                  },\r\n                ],\r\n              },\r\n            });\r\n          };\r\n        }\r\n        if (prop === 'stateSort') {\r\n          return (compareFn: (a: any, b: any) => number) => {\r\n            const currentState = getGlobalStore\r\n              .getState()\r\n              .getShadowValue([stateKey, ...path].join('.'), meta?.validIds);\r\n            if (!Array.isArray(currentState)) return []; // Guard clause\r\n            const arrayKeys =\r\n              meta?.validIds ??\r\n              getGlobalStore.getState().getShadowMetadata(stateKey, path)\r\n                ?.arrayKeys;\r\n            if (!arrayKeys) {\r\n              throw new Error('No array keys found for sorting');\r\n            }\r\n            const itemsWithIds = currentState.map((item, index) => ({\r\n              item,\r\n              key: arrayKeys[index],\r\n            }));\r\n\r\n            itemsWithIds\r\n              .sort((a, b) => compareFn(a.item, b.item))\r\n              .filter(Boolean);\r\n\r\n            return rebuildStateShape({\r\n              path,\r\n              componentId: componentId!,\r\n              meta: {\r\n                validIds: itemsWithIds.map((i) => i.key) as string[],\r\n                transforms: [\r\n                  ...(meta?.transforms || []),\r\n                  { type: 'sort', fn: compareFn },\r\n                ],\r\n              },\r\n            });\r\n          };\r\n        }\r\n        // In createProxyHandler, inside the get trap where you have other array methods:\r\n        if (prop === 'stream') {\r\n          return function <U = InferArrayElement<T>, R = U>(\r\n            options: StreamOptions<U, R> = {}\r\n          ): StreamHandle<U> {\r\n            const {\r\n              bufferSize = 100,\r\n              flushInterval = 100,\r\n              bufferStrategy = 'accumulate',\r\n              store,\r\n              onFlush,\r\n            } = options;\r\n\r\n            let buffer: U[] = [];\r\n            let isPaused = false;\r\n            let flushTimer: NodeJS.Timeout | null = null;\r\n\r\n            const addToBuffer = (item: U) => {\r\n              if (isPaused) return;\r\n\r\n              if (bufferStrategy === 'sliding' && buffer.length >= bufferSize) {\r\n                buffer.shift();\r\n              } else if (\r\n                bufferStrategy === 'dropping' &&\r\n                buffer.length >= bufferSize\r\n              ) {\r\n                return;\r\n              }\r\n\r\n              buffer.push(item);\r\n\r\n              if (buffer.length >= bufferSize) {\r\n                flushBuffer();\r\n              }\r\n            };\r\n\r\n            const flushBuffer = () => {\r\n              if (buffer.length === 0) return;\r\n\r\n              const toFlush = [...buffer];\r\n              buffer = [];\r\n\r\n              if (store) {\r\n                const result = store(toFlush);\r\n                if (result !== undefined) {\r\n                  const items = Array.isArray(result) ? result : [result];\r\n                  items.forEach((item) => {\r\n                    effectiveSetState(item as any, path, {\r\n                      updateType: 'insert',\r\n                    });\r\n                  });\r\n                }\r\n              } else {\r\n                toFlush.forEach((item) => {\r\n                  effectiveSetState(item as any, path, {\r\n                    updateType: 'insert',\r\n                  });\r\n                });\r\n              }\r\n\r\n              onFlush?.(toFlush);\r\n            };\r\n\r\n            if (flushInterval > 0) {\r\n              flushTimer = setInterval(flushBuffer, flushInterval);\r\n            }\r\n\r\n            const streamId = uuidv4();\r\n            const currentMeta =\r\n              getGlobalStore.getState().getShadowMetadata(stateKey, path) || {};\r\n            const streams = currentMeta.streams || new Map();\r\n            streams.set(streamId, { buffer, flushTimer });\r\n\r\n            getGlobalStore.getState().setShadowMetadata(stateKey, path, {\r\n              ...currentMeta,\r\n              streams,\r\n            });\r\n\r\n            return {\r\n              write: (data: U) => addToBuffer(data),\r\n              writeMany: (data: U[]) => data.forEach(addToBuffer),\r\n              flush: () => flushBuffer(),\r\n              pause: () => {\r\n                isPaused = true;\r\n              },\r\n              resume: () => {\r\n                isPaused = false;\r\n                if (buffer.length > 0) flushBuffer();\r\n              },\r\n              close: () => {\r\n                flushBuffer();\r\n                if (flushTimer) clearInterval(flushTimer);\r\n\r\n                const meta = getGlobalStore\r\n                  .getState()\r\n                  .getShadowMetadata(stateKey, path);\r\n                if (meta?.streams) {\r\n                  meta.streams.delete(streamId);\r\n                }\r\n              },\r\n            };\r\n          };\r\n        }\r\n\r\n        if (prop === 'stateList') {\r\n          return (\r\n            callbackfn: (\r\n              setter: any,\r\n              index: number,\r\n              arraySetter: any\r\n            ) => ReactNode\r\n          ) => {\r\n            const StateListWrapper = () => {\r\n              const componentIdsRef = useRef<Map<string, string>>(new Map());\r\n\r\n              const cacheKey =\r\n                meta?.transforms && meta.transforms.length > 0\r\n                  ? `${componentId}-${hashTransforms(meta.transforms)}`\r\n                  : `${componentId}-base`;\r\n\r\n              const [updateTrigger, forceUpdate] = useState({});\r\n\r\n              const { validIds, arrayValues } = useMemo(() => {\r\n                const cached = getGlobalStore\r\n                  .getState()\r\n                  .getShadowMetadata(stateKey, path)\r\n                  ?.transformCaches?.get(cacheKey);\r\n\r\n                let freshValidIds: string[];\r\n\r\n                if (cached && cached.validIds) {\r\n                  freshValidIds = cached.validIds;\r\n                } else {\r\n                  freshValidIds = applyTransforms(\r\n                    stateKey,\r\n                    path,\r\n                    meta?.transforms\r\n                  );\r\n\r\n                  getGlobalStore\r\n                    .getState()\r\n                    .setTransformCache(stateKey, path, cacheKey, {\r\n                      validIds: freshValidIds,\r\n                      computedAt: Date.now(),\r\n                      transforms: meta?.transforms || [],\r\n                    });\r\n                }\r\n\r\n                const freshValues = getGlobalStore\r\n                  .getState()\r\n                  .getShadowValue(stateKeyPathKey, freshValidIds);\r\n\r\n                return {\r\n                  validIds: freshValidIds,\r\n                  arrayValues: freshValues || [],\r\n                };\r\n              }, [cacheKey, updateTrigger]);\r\n\r\n              useEffect(() => {\r\n                const unsubscribe = getGlobalStore\r\n                  .getState()\r\n                  .subscribeToPath(stateKeyPathKey, (e) => {\r\n                    // A data change has occurred for the source array.\r\n\r\n                    if (e.type === 'GET_SELECTED') {\r\n                      return;\r\n                    }\r\n                    const shadowMeta = getGlobalStore\r\n                      .getState()\r\n                      .getShadowMetadata(stateKey, path);\r\n\r\n                    const caches = shadowMeta?.transformCaches;\r\n                    if (caches) {\r\n                      // Iterate over ALL keys in the cache map.\r\n                      for (const key of caches.keys()) {\r\n                        // If the key belongs to this component instance, delete it.\r\n                        // This purges caches for 'sort by name', 'sort by score', etc.\r\n                        if (key.startsWith(componentId)) {\r\n                          caches.delete(key);\r\n                        }\r\n                      }\r\n                    }\r\n\r\n                    if (\r\n                      e.type === 'INSERT' ||\r\n                      e.type === 'REMOVE' ||\r\n                      e.type === 'CLEAR_SELECTION'\r\n                    ) {\r\n                      forceUpdate({});\r\n                    }\r\n                  });\r\n\r\n                return () => {\r\n                  unsubscribe();\r\n                };\r\n\r\n                // This effect's logic now depends on the componentId to perform the purge.\r\n              }, [componentId, stateKeyPathKey]);\r\n\r\n              if (!Array.isArray(arrayValues)) {\r\n                return null;\r\n              }\r\n\r\n              const arraySetter = rebuildStateShape({\r\n                path,\r\n                componentId: componentId!,\r\n                meta: {\r\n                  ...meta,\r\n                  validIds: validIds,\r\n                },\r\n              });\r\n\r\n              return (\r\n                <>\r\n                  {arrayValues.map((item, localIndex) => {\r\n                    const itemKey = validIds[localIndex];\r\n\r\n                    if (!itemKey) {\r\n                      return null;\r\n                    }\r\n\r\n                    let itemComponentId = componentIdsRef.current.get(itemKey);\r\n                    if (!itemComponentId) {\r\n                      itemComponentId = uuidv4();\r\n                      componentIdsRef.current.set(itemKey, itemComponentId);\r\n                    }\r\n\r\n                    const itemPath = itemKey.split('.').slice(1);\r\n\r\n                    return createElement(MemoizedCogsItemWrapper, {\r\n                      key: itemKey,\r\n                      stateKey,\r\n                      itemComponentId,\r\n                      itemPath,\r\n                      localIndex,\r\n                      arraySetter,\r\n                      rebuildStateShape,\r\n                      renderFn: callbackfn,\r\n                    });\r\n                  })}\r\n                </>\r\n              );\r\n            };\r\n\r\n            return <StateListWrapper />;\r\n          };\r\n        }\r\n        if (prop === 'stateFlattenOn') {\r\n          return (fieldName: string) => {\r\n            const currentState = getGlobalStore\r\n              .getState()\r\n              .getShadowValue([stateKey, ...path].join('.'), meta?.validIds);\r\n            if (!Array.isArray(currentState)) return []; // Guard clause\r\n            const arrayToMap = currentState as any[];\r\n\r\n            stateVersion++;\r\n            const flattenedResults = arrayToMap.flatMap(\r\n              (val: any) => val[fieldName] ?? []\r\n            );\r\n            return rebuildStateShape({\r\n              path: [...path, '[*]', fieldName],\r\n              componentId: componentId!,\r\n              meta,\r\n            });\r\n          };\r\n        }\r\n        if (prop === 'index') {\r\n          return (index: number) => {\r\n            const arrayKeys = getGlobalStore\r\n              .getState()\r\n              .getShadowMetadata(stateKey, path)\r\n              ?.arrayKeys?.filter(\r\n                (key) =>\r\n                  !meta?.validIds ||\r\n                  (meta?.validIds && meta?.validIds?.includes(key))\r\n              );\r\n            const itemId = arrayKeys?.[index];\r\n            if (!itemId) return undefined;\r\n            const value = getGlobalStore\r\n              .getState()\r\n              .getShadowValue(itemId, meta?.validIds);\r\n            const state = rebuildStateShape({\r\n              path: itemId.split('.').slice(1) as string[],\r\n              componentId: componentId!,\r\n              meta,\r\n            });\r\n            return state;\r\n          };\r\n        }\r\n        if (prop === 'last') {\r\n          return () => {\r\n            const currentArray = getGlobalStore\r\n              .getState()\r\n              .getShadowValue(stateKey, path) as any[];\r\n            if (currentArray.length === 0) return undefined;\r\n            const lastIndex = currentArray.length - 1;\r\n            const lastValue = currentArray[lastIndex];\r\n            const newPath = [...path, lastIndex.toString()];\r\n            return rebuildStateShape({\r\n              path: newPath,\r\n              componentId: componentId!,\r\n              meta,\r\n            });\r\n          };\r\n        }\r\n        if (prop === 'insert') {\r\n          return (\r\n            payload: InsertParams<InferArrayElement<T>>,\r\n            index?: number\r\n          ) => {\r\n            effectiveSetState(payload as any, path, { updateType: 'insert' });\r\n            return rebuildStateShape({\r\n              path,\r\n              componentId: componentId!,\r\n              meta,\r\n            });\r\n          };\r\n        }\r\n        if (prop === 'uniqueInsert') {\r\n          return (\r\n            payload: UpdateArg<T>,\r\n            fields?: (keyof InferArrayElement<T>)[],\r\n            onMatch?: (existingItem: any) => any\r\n          ) => {\r\n            const currentArray = getGlobalStore\r\n              .getState()\r\n              .getShadowValue(stateKey, path) as any[];\r\n            const newValue = isFunction<T>(payload)\r\n              ? payload(currentArray as any)\r\n              : (payload as any);\r\n\r\n            let matchedItem: any = null;\r\n            const isUnique = !currentArray.some((item) => {\r\n              const isMatch = fields\r\n                ? fields.every((field) =>\r\n                    isDeepEqual(item[field], newValue[field])\r\n                  )\r\n                : isDeepEqual(item, newValue);\r\n              if (isMatch) matchedItem = item;\r\n              return isMatch;\r\n            });\r\n\r\n            if (isUnique) {\r\n              effectiveSetState(newValue, path, { updateType: 'insert' });\r\n            } else if (onMatch && matchedItem) {\r\n              const updatedItem = onMatch(matchedItem);\r\n              const updatedArray = currentArray.map((item) =>\r\n                isDeepEqual(item, matchedItem) ? updatedItem : item\r\n              );\r\n\r\n              effectiveSetState(updatedArray as any, path, {\r\n                updateType: 'update',\r\n              });\r\n            }\r\n          };\r\n        }\r\n\r\n        if (prop === 'cut') {\r\n          return (index?: number, options?: { waitForSync?: boolean }) => {\r\n            const currentState = getGlobalStore\r\n              .getState()\r\n              .getShadowValue([stateKey, ...path].join('.'), meta?.validIds);\r\n            const validKeys =\r\n              meta?.validIds ??\r\n              getGlobalStore.getState().getShadowMetadata(stateKey, path)\r\n                ?.arrayKeys;\r\n\r\n            if (!validKeys || validKeys.length === 0) return;\r\n\r\n            const indexToCut =\r\n              index == -1\r\n                ? validKeys.length - 1\r\n                : index !== undefined\r\n                  ? index\r\n                  : validKeys.length - 1;\r\n\r\n            const fullIdToCut = validKeys[indexToCut];\r\n            if (!fullIdToCut) return; // Index out of bounds\r\n\r\n            const pathForCut = fullIdToCut.split('.').slice(1);\r\n            effectiveSetState(currentState, pathForCut, {\r\n              updateType: 'cut',\r\n            });\r\n          };\r\n        }\r\n        if (prop === 'cutSelected') {\r\n          return () => {\r\n            const validKeys = applyTransforms(stateKey, path, meta?.transforms);\r\n            const currentState = getGlobalStore\r\n              .getState()\r\n              .getShadowValue([stateKey, ...path].join('.'), meta?.validIds);\r\n            if (!validKeys || validKeys.length === 0) return;\r\n\r\n            const indexKeyToCut = getGlobalStore\r\n              .getState()\r\n              .selectedIndicesMap.get(stateKeyPathKey);\r\n\r\n            let indexToCut = validKeys.findIndex(\r\n              (key) => key === indexKeyToCut\r\n            );\r\n\r\n            const pathForCut = validKeys[\r\n              indexToCut == -1 ? validKeys.length - 1 : indexToCut\r\n            ]\r\n              ?.split('.')\r\n              .slice(1);\r\n            getGlobalStore\r\n              .getState()\r\n              .clearSelectedIndex({ arrayKey: stateKeyPathKey });\r\n            const parentPath = pathForCut?.slice(0, -1)!;\r\n            notifySelectionComponents(stateKey, parentPath);\r\n            effectiveSetState(currentState, pathForCut!, {\r\n              updateType: 'cut',\r\n            });\r\n          };\r\n        }\r\n        if (prop === 'cutByValue') {\r\n          return (value: string | number | boolean) => {\r\n            // Step 1: Get the list of all unique keys for the current view.\r\n            const arrayMeta = getGlobalStore\r\n              .getState()\r\n              .getShadowMetadata(stateKey, path);\r\n            const relevantKeys = meta?.validIds ?? arrayMeta?.arrayKeys;\r\n\r\n            if (!relevantKeys) return;\r\n\r\n            let keyToCut: string | null = null;\r\n\r\n            // Step 2: Iterate through the KEYS, get the value for each, and find the match.\r\n            for (const key of relevantKeys) {\r\n              const itemValue = getGlobalStore.getState().getShadowValue(key);\r\n              if (itemValue === value) {\r\n                keyToCut = key;\r\n                break; // We found the key, no need to search further.\r\n              }\r\n            }\r\n\r\n            // Step 3: If we found a matching key, use it to perform the cut.\r\n            if (keyToCut) {\r\n              const itemPath = keyToCut.split('.').slice(1);\r\n              effectiveSetState(null as any, itemPath, { updateType: 'cut' });\r\n            }\r\n          };\r\n        }\r\n\r\n        if (prop === 'toggleByValue') {\r\n          return (value: string | number | boolean) => {\r\n            // Step 1: Get the list of all unique keys for the current view.\r\n            const arrayMeta = getGlobalStore\r\n              .getState()\r\n              .getShadowMetadata(stateKey, path);\r\n            const relevantKeys = meta?.validIds ?? arrayMeta?.arrayKeys;\r\n\r\n            if (!relevantKeys) return;\r\n\r\n            let keyToCut: string | null = null;\r\n\r\n            // Step 2: Iterate through the KEYS to find the one matching the value. This is the robust way.\r\n            for (const key of relevantKeys) {\r\n              const itemValue = getGlobalStore.getState().getShadowValue(key);\r\n              console.log('itemValue sdasdasdasd', itemValue);\r\n              if (itemValue === value) {\r\n                keyToCut = key;\r\n                break; // Found it!\r\n              }\r\n            }\r\n            console.log('itemValue keyToCut', keyToCut);\r\n            // Step 3: Act based on whether the key was found.\r\n            if (keyToCut) {\r\n              // Item exists, so we CUT it using its *actual* key.\r\n              const itemPath = keyToCut.split('.').slice(1);\r\n              console.log('itemValue keyToCut', keyToCut);\r\n              effectiveSetState(value as any, itemPath, {\r\n                updateType: 'cut',\r\n              });\r\n            } else {\r\n              // Item does not exist, so we INSERT it.\r\n              effectiveSetState(value as any, path, { updateType: 'insert' });\r\n            }\r\n          };\r\n        }\r\n        if (prop === 'findWith') {\r\n          return (searchKey: keyof InferArrayElement<T>, searchValue: any) => {\r\n            const arrayKeys = getGlobalStore\r\n              .getState()\r\n              .getShadowMetadata(stateKey, path)?.arrayKeys;\r\n\r\n            if (!arrayKeys) {\r\n              throw new Error('No array keys found for sorting');\r\n            }\r\n\r\n            let value = null;\r\n            let foundPath: string[] = [];\r\n\r\n            for (const fullPath of arrayKeys) {\r\n              let shadowValue = getGlobalStore\r\n                .getState()\r\n                .getShadowValue(fullPath, meta?.validIds);\r\n              if (shadowValue && shadowValue[searchKey] === searchValue) {\r\n                value = shadowValue;\r\n                foundPath = fullPath.split('.').slice(1);\r\n                break;\r\n              }\r\n            }\r\n\r\n            return rebuildStateShape({\r\n              path: foundPath,\r\n              componentId: componentId!,\r\n              meta,\r\n            });\r\n          };\r\n        }\r\n\r\n        if (prop === 'cutThis') {\r\n          let shadowValue = getGlobalStore\r\n            .getState()\r\n            .getShadowValue(path.join('.'));\r\n\r\n          return () => {\r\n            effectiveSetState(shadowValue, path, { updateType: 'cut' });\r\n          };\r\n        }\r\n\r\n        if (prop === 'get') {\r\n          return () => {\r\n            registerComponentDependency(stateKey, componentId, path);\r\n            return getGlobalStore\r\n              .getState()\r\n              .getShadowValue(stateKeyPathKey, meta?.validIds);\r\n          };\r\n        }\r\n        if (prop === 'getState') {\r\n          return () => {\r\n            return getGlobalStore\r\n              .getState()\r\n              .getShadowValue(stateKeyPathKey, meta?.validIds);\r\n          };\r\n        }\r\n\r\n        if (prop === '$derive') {\r\n          return (fn: any) =>\r\n            $cogsSignal({\r\n              _stateKey: stateKey,\r\n              _path: path,\r\n              _effect: fn.toString(),\r\n              _meta: meta,\r\n            });\r\n        }\r\n        // in CogsState.ts -> createProxyHandler -> handler -> get\r\n\r\n        if (prop === '$get') {\r\n          return () =>\r\n            $cogsSignal({ _stateKey: stateKey, _path: path, _meta: meta });\r\n        }\r\n        if (prop === 'lastSynced') {\r\n          const syncKey = `${stateKey}:${path.join('.')}`;\r\n          return getGlobalStore.getState().getSyncInfo(syncKey);\r\n        }\r\n        if (prop == 'getLocalStorage') {\r\n          return (key: string) =>\r\n            loadFromLocalStorage(sessionId + '-' + stateKey + '-' + key);\r\n        }\r\n\r\n        if (prop === 'isSelected') {\r\n          const parentPath = [stateKey, ...path].slice(0, -1);\r\n          notifySelectionComponents(stateKey, path, undefined);\r\n          if (\r\n            Array.isArray(\r\n              getGlobalStore\r\n                .getState()\r\n                .getShadowValue(parentPath.join('.'), meta?.validIds)\r\n            )\r\n          ) {\r\n            const itemId = path[path.length - 1];\r\n            const fullParentKey = parentPath.join('.');\r\n\r\n            const selectedItemKey = getGlobalStore\r\n              .getState()\r\n              .selectedIndicesMap.get(fullParentKey);\r\n\r\n            const fullItemKey = stateKey + '.' + path.join('.');\r\n\r\n            return selectedItemKey === fullItemKey;\r\n          }\r\n          return undefined;\r\n        }\r\n\r\n        // Then use it in both:\r\n        if (prop === 'setSelected') {\r\n          return (value: boolean) => {\r\n            const parentPath = path.slice(0, -1);\r\n            const fullParentKey = stateKey + '.' + parentPath.join('.');\r\n            const fullItemKey = stateKey + '.' + path.join('.');\r\n\r\n            notifySelectionComponents(stateKey, parentPath, undefined);\r\n\r\n            const selectedIndex = getGlobalStore\r\n              .getState()\r\n              .selectedIndicesMap.get(fullParentKey);\r\n\r\n            if (value) {\r\n              getGlobalStore\r\n                .getState()\r\n                .setSelectedIndex(fullParentKey, fullItemKey);\r\n            }\r\n          };\r\n        }\r\n\r\n        if (prop === 'toggleSelected') {\r\n          return () => {\r\n            const parentPath = path.slice(0, -1);\r\n            const fullParentKey = stateKey + '.' + parentPath.join('.');\r\n            const fullItemKey = stateKey + '.' + path.join('.');\r\n\r\n            const currentSelected = getGlobalStore\r\n              .getState()\r\n              .selectedIndicesMap.get(fullParentKey);\r\n\r\n            if (currentSelected === fullItemKey) {\r\n              getGlobalStore\r\n                .getState()\r\n                .clearSelectedIndex({ arrayKey: fullParentKey });\r\n            } else {\r\n              getGlobalStore\r\n                .getState()\r\n                .setSelectedIndex(fullParentKey, fullItemKey);\r\n            }\r\n          };\r\n        }\r\n        if (prop === '_componentId') {\r\n          return componentId;\r\n        }\r\n        if (path.length == 0) {\r\n          if (prop === 'addZodValidation') {\r\n            return (zodErrors: any[]) => {\r\n              const init = getGlobalStore\r\n                .getState()\r\n                .getInitialOptions(stateKey)?.validation;\r\n\r\n              // For each error, set shadow metadata\r\n              zodErrors.forEach((error) => {\r\n                const currentMeta =\r\n                  getGlobalStore\r\n                    .getState()\r\n                    .getShadowMetadata(stateKey, error.path) || {};\r\n\r\n                getGlobalStore\r\n                  .getState()\r\n                  .setShadowMetadata(stateKey, error.path, {\r\n                    ...currentMeta,\r\n                    validation: {\r\n                      status: 'VALIDATION_FAILED',\r\n                      message: error.message,\r\n                      validatedValue: undefined,\r\n                    },\r\n                  });\r\n                getGlobalStore.getState().notifyPathSubscribers(error.path, {\r\n                  type: 'VALIDATION_FAILED',\r\n                  message: error.message,\r\n                  validatedValue: undefined,\r\n                });\r\n              });\r\n            };\r\n          }\r\n          if (prop === 'clearZodValidation') {\r\n            return (path?: string[]) => {\r\n              // Clear specific paths\r\n              if (!path) {\r\n                throw new Error('clearZodValidation requires a path');\r\n                return;\r\n              }\r\n              const currentMeta =\r\n                getGlobalStore.getState().getShadowMetadata(stateKey, path) ||\r\n                {};\r\n\r\n              if (currentMeta.validation) {\r\n                getGlobalStore.getState().setShadowMetadata(stateKey, path, {\r\n                  ...currentMeta,\r\n                  validation: undefined,\r\n                });\r\n\r\n                getGlobalStore\r\n                  .getState()\r\n                  .notifyPathSubscribers([stateKey, ...path].join('.'), {\r\n                    type: 'VALIDATION_CLEARED',\r\n                  });\r\n              }\r\n            };\r\n          }\r\n          if (prop === 'applyJsonPatch') {\r\n            return (patches: Operation[]) => {\r\n              const store = getGlobalStore.getState();\r\n              const rootMeta = store.getShadowMetadata(stateKey, []);\r\n              if (!rootMeta?.components) return;\r\n\r\n              const convertPath = (jsonPath: string): string[] => {\r\n                if (!jsonPath || jsonPath === '/') return [];\r\n                return jsonPath\r\n                  .split('/')\r\n                  .slice(1)\r\n                  .map((p) => p.replace(/~1/g, '/').replace(/~0/g, '~'));\r\n              };\r\n\r\n              const notifiedComponents = new Set<string>();\r\n\r\n              for (const patch of patches) {\r\n                const relativePath = convertPath(patch.path);\r\n\r\n                switch (patch.op) {\r\n                  case 'add':\r\n                  case 'replace': {\r\n                    const { value } = patch as {\r\n                      op: 'add' | 'replace';\r\n                      path: string;\r\n                      value: any;\r\n                    };\r\n                    store.updateShadowAtPath(stateKey, relativePath, value);\r\n                    store.markAsDirty(stateKey, relativePath, { bubble: true });\r\n\r\n                    // Bubble up - notify components at this path and all parent paths\r\n                    let currentPath = [...relativePath];\r\n                    while (true) {\r\n                      const pathMeta = store.getShadowMetadata(\r\n                        stateKey,\r\n                        currentPath\r\n                      );\r\n\r\n                      if (pathMeta?.pathComponents) {\r\n                        pathMeta.pathComponents.forEach((componentId) => {\r\n                          if (!notifiedComponents.has(componentId)) {\r\n                            const component =\r\n                              rootMeta.components?.get(componentId);\r\n                            if (component) {\r\n                              component.forceUpdate();\r\n                              notifiedComponents.add(componentId);\r\n                            }\r\n                          }\r\n                        });\r\n                      }\r\n\r\n                      if (currentPath.length === 0) break;\r\n                      currentPath.pop(); // Go up one level\r\n                    }\r\n                    break;\r\n                  }\r\n                  case 'remove': {\r\n                    const parentPath = relativePath.slice(0, -1);\r\n                    store.removeShadowArrayElement(stateKey, relativePath);\r\n                    store.markAsDirty(stateKey, parentPath, { bubble: true });\r\n\r\n                    // Bubble up from parent path\r\n                    let currentPath = [...parentPath];\r\n                    while (true) {\r\n                      const pathMeta = store.getShadowMetadata(\r\n                        stateKey,\r\n                        currentPath\r\n                      );\r\n                      if (pathMeta?.pathComponents) {\r\n                        pathMeta.pathComponents.forEach((componentId) => {\r\n                          if (!notifiedComponents.has(componentId)) {\r\n                            const component =\r\n                              rootMeta.components?.get(componentId);\r\n                            if (component) {\r\n                              component.forceUpdate();\r\n                              notifiedComponents.add(componentId);\r\n                            }\r\n                          }\r\n                        });\r\n                      }\r\n\r\n                      if (currentPath.length === 0) break;\r\n                      currentPath.pop();\r\n                    }\r\n                    break;\r\n                  }\r\n                }\r\n              }\r\n            };\r\n          }\r\n\r\n          if (prop === 'getComponents')\r\n            return () =>\r\n              getGlobalStore.getState().getShadowMetadata(stateKey, [])\r\n                ?.components;\r\n          if (prop === 'getAllFormRefs')\r\n            return () =>\r\n              formRefStore.getState().getFormRefsByStateKey(stateKey);\r\n        }\r\n        if (prop === 'getFormRef') {\r\n          return () =>\r\n            formRefStore.getState().getFormRef(stateKey + '.' + path.join('.'));\r\n        }\r\n        if (prop === 'validationWrapper') {\r\n          return ({\r\n            children,\r\n            hideMessage,\r\n          }: {\r\n            children: React.ReactNode;\r\n            hideMessage?: boolean;\r\n          }) => (\r\n            <ValidationWrapper\r\n              formOpts={\r\n                hideMessage ? { validation: { message: '' } } : undefined\r\n              }\r\n              path={path}\r\n              stateKey={stateKey}\r\n            >\r\n              {children}\r\n            </ValidationWrapper>\r\n          );\r\n        }\r\n        if (prop === '_stateKey') return stateKey;\r\n        if (prop === '_path') return path;\r\n        if (prop === 'update') {\r\n          if (recursionTimerName) {\r\n            console.timeEnd(recursionTimerName);\r\n            recursionTimerName = null;\r\n          }\r\n\r\n          return (payload: UpdateArg<T>) => {\r\n            // Check if we're in a React event handler\r\n            const error = new Error();\r\n            const stack = error.stack || '';\r\n            const inReactEvent =\r\n              stack.includes('onClick') ||\r\n              stack.includes('dispatchEvent') ||\r\n              stack.includes('batchedUpdates');\r\n\r\n            // Only batch if we're in a React event\r\n            if (inReactEvent) {\r\n              const batchKey = `${stateKey}.${path.join('.')}`;\r\n\r\n              // Schedule flush if not already scheduled\r\n              if (!batchFlushScheduled) {\r\n                updateBatchQueue.clear();\r\n                batchFlushScheduled = true;\r\n\r\n                queueMicrotask(() => {\r\n                  // Process all batched updates\r\n                  for (const [key, updates] of updateBatchQueue) {\r\n                    const parts = key.split('.');\r\n                    const batchStateKey = parts[0];\r\n                    const batchPath = parts.slice(1);\r\n\r\n                    // Compose all updates for this path\r\n                    const composedUpdate = updates.reduce(\r\n                      (composed, update) => {\r\n                        if (\r\n                          typeof update === 'function' &&\r\n                          typeof composed === 'function'\r\n                        ) {\r\n                          // Compose functions\r\n                          return (state: any) => update(composed(state));\r\n                        }\r\n                        // If not functions, last one wins\r\n                        return update;\r\n                      }\r\n                    );\r\n\r\n                    // Call effectiveSetState ONCE with composed update\r\n                    effectiveSetState(composedUpdate as any, batchPath, {\r\n                      updateType: 'update',\r\n                    });\r\n                  }\r\n\r\n                  updateBatchQueue.clear();\r\n                  batchFlushScheduled = false;\r\n                });\r\n              }\r\n\r\n              // Add to batch\r\n              const existing = updateBatchQueue.get(batchKey) || [];\r\n              existing.push(payload);\r\n              updateBatchQueue.set(batchKey, existing);\r\n            } else {\r\n              // NOT in React event - execute immediately\r\n              console.time('update inner');\r\n              effectiveSetState(payload as any, path, { updateType: 'update' });\r\n              console.timeEnd('update inner');\r\n            }\r\n\r\n            return {\r\n              synced: () => {\r\n                const shadowMeta = getGlobalStore\r\n                  .getState()\r\n                  .getShadowMetadata(stateKey, path);\r\n\r\n                getGlobalStore.getState().setShadowMetadata(stateKey, path, {\r\n                  ...shadowMeta,\r\n                  isDirty: false,\r\n                  stateSource: 'server',\r\n                  lastServerSync: Date.now(),\r\n                });\r\n\r\n                const fullPath = [stateKey, ...path].join('.');\r\n                getGlobalStore.getState().notifyPathSubscribers(fullPath, {\r\n                  type: 'SYNC_STATUS_CHANGE',\r\n                  isDirty: false,\r\n                });\r\n              },\r\n            };\r\n          };\r\n        }\r\n\r\n        if (prop === 'toggle') {\r\n          const currentValueAtPath = getGlobalStore\r\n            .getState()\r\n            .getShadowValue([stateKey, ...path].join('.'), meta?.validIds);\r\n\r\n          if (typeof currentValueAtPath != 'boolean') {\r\n            throw new Error('toggle() can only be used on boolean values');\r\n          }\r\n          return () => {\r\n            effectiveSetState(!currentValueAtPath as any, path, {\r\n              updateType: 'update',\r\n            });\r\n          };\r\n        }\r\n        if (prop === 'formElement') {\r\n          return (child: FormControl<T>, formOpts?: FormOptsType) => {\r\n            return (\r\n              <FormElementWrapper\r\n                stateKey={stateKey}\r\n                path={path}\r\n                rebuildStateShape={rebuildStateShape}\r\n                setState={effectiveSetState}\r\n                formOpts={formOpts}\r\n                renderFn={child as any}\r\n              />\r\n            );\r\n          };\r\n        }\r\n        const nextPath = [...path, prop];\r\n        const nextValue = getGlobalStore\r\n          .getState()\r\n          .getShadowValue(stateKey, nextPath);\r\n        return rebuildStateShape({\r\n          path: nextPath,\r\n          componentId: componentId!,\r\n          meta,\r\n        });\r\n      },\r\n    };\r\n\r\n    const proxyInstance = new Proxy(baseFunction, handler);\r\n    proxyCache.set(cacheKey, proxyInstance);\r\n    console.timeEnd('rebuildStateShape Inner');\r\n    return proxyInstance;\r\n  }\r\n  console.timeEnd('rebuildStateShape Outer');\r\n\r\n  const baseObj = {\r\n    revertToInitialState: (obj?: { validationKey?: string }) => {\r\n      const init = getGlobalStore\r\n        .getState()\r\n        .getInitialOptions(stateKey)?.validation;\r\n\r\n      const shadowMeta = getGlobalStore\r\n        .getState()\r\n        .getShadowMetadata(stateKey, []);\r\n      let revertState;\r\n\r\n      if (shadowMeta?.stateSource === 'server' && shadowMeta.baseServerState) {\r\n        // Revert to last known server state\r\n        revertState = shadowMeta.baseServerState;\r\n      } else {\r\n        // Revert to initial/default state\r\n        revertState = getGlobalStore.getState().initialStateGlobal[stateKey];\r\n      }\r\n      const initialState =\r\n        getGlobalStore.getState().initialStateGlobal[stateKey];\r\n\r\n      getGlobalStore.getState().clearSelectedIndexesForState(stateKey);\r\n\r\n      stateVersion++;\r\n      getGlobalStore.getState().initializeShadowState(stateKey, initialState);\r\n      rebuildStateShape({\r\n        path: [],\r\n        componentId: componentId!,\r\n      });\r\n      const initalOptionsGet = getInitialOptions(stateKey as string);\r\n      const localKey = isFunction(initalOptionsGet?.localStorage?.key)\r\n        ? initalOptionsGet?.localStorage?.key(initialState)\r\n        : initalOptionsGet?.localStorage?.key;\r\n\r\n      const storageKey = `${sessionId}-${stateKey}-${localKey}`;\r\n\r\n      if (storageKey) {\r\n        localStorage.removeItem(storageKey);\r\n      }\r\n\r\n      const stateEntry = getGlobalStore\r\n        .getState()\r\n        .getShadowMetadata(stateKey, []);\r\n      if (stateEntry) {\r\n        stateEntry?.components?.forEach((component) => {\r\n          component.forceUpdate();\r\n        });\r\n      }\r\n\r\n      return initialState;\r\n    },\r\n    updateInitialState: (newState: T) => {\r\n      stateVersion++;\r\n\r\n      const newUpdaterState = createProxyHandler(\r\n        stateKey,\r\n        effectiveSetState,\r\n        componentId,\r\n        sessionId\r\n      );\r\n      const initialState =\r\n        getGlobalStore.getState().initialStateGlobal[stateKey];\r\n      const initalOptionsGet = getInitialOptions(stateKey as string);\r\n      const localKey = isFunction(initalOptionsGet?.localStorage?.key)\r\n        ? initalOptionsGet?.localStorage?.key(initialState)\r\n        : initalOptionsGet?.localStorage?.key;\r\n\r\n      const storageKey = `${sessionId}-${stateKey}-${localKey}`;\r\n\r\n      if (localStorage.getItem(storageKey)) {\r\n        localStorage.removeItem(storageKey);\r\n      }\r\n      startTransition(() => {\r\n        updateInitialStateGlobal(stateKey, newState);\r\n        getGlobalStore.getState().initializeShadowState(stateKey, newState);\r\n\r\n        const stateEntry = getGlobalStore\r\n          .getState()\r\n          .getShadowMetadata(stateKey, []);\r\n\r\n        if (stateEntry) {\r\n          stateEntry?.components?.forEach((component) => {\r\n            component.forceUpdate();\r\n          });\r\n        }\r\n      });\r\n\r\n      return {\r\n        fetchId: (field: keyof T) => (newUpdaterState.get() as any)[field],\r\n      };\r\n    },\r\n  };\r\n  const returnShape = rebuildStateShape({\r\n    componentId,\r\n    path: [],\r\n  });\r\n\r\n  return returnShape;\r\n}\r\n\r\nexport function $cogsSignal(proxy: {\r\n  _path: string[];\r\n  _stateKey: string;\r\n  _effect?: string;\r\n\r\n  _meta?: MetaData;\r\n}) {\r\n  return createElement(SignalRenderer, { proxy });\r\n}\r\n\r\nfunction SignalMapRenderer({\r\n  proxy,\r\n  rebuildStateShape,\r\n}: {\r\n  proxy: {\r\n    _stateKey: string;\r\n    _path: string[];\r\n    _meta?: MetaData;\r\n    _mapFn: (\r\n      setter: any,\r\n      index: number,\r\n\r\n      arraySetter: any\r\n    ) => ReactNode;\r\n  };\r\n  rebuildStateShape: (stuff: {\r\n    currentState: any;\r\n    path: string[];\r\n    componentId: string;\r\n    meta?: MetaData;\r\n  }) => any;\r\n}): JSX.Element | null {\r\n  const containerRef = useRef<HTMLDivElement>(null);\r\n  const instanceIdRef = useRef<string>(`map-${crypto.randomUUID()}`);\r\n  const isSetupRef = useRef(false);\r\n  const rootsMapRef = useRef<Map<string, any>>(new Map());\r\n\r\n  // Setup effect - store the map function in shadow metadata\r\n  useEffect(() => {\r\n    const container = containerRef.current;\r\n    if (!container || isSetupRef.current) return;\r\n\r\n    const timeoutId = setTimeout(() => {\r\n      // Store map wrapper in metadata\r\n      const currentMeta =\r\n        getGlobalStore\r\n          .getState()\r\n          .getShadowMetadata(proxy._stateKey, proxy._path) || {};\r\n\r\n      const mapWrappers = currentMeta.mapWrappers || [];\r\n      mapWrappers.push({\r\n        instanceId: instanceIdRef.current,\r\n        mapFn: proxy._mapFn,\r\n        containerRef: container,\r\n        rebuildStateShape: rebuildStateShape,\r\n        path: proxy._path,\r\n        componentId: instanceIdRef.current,\r\n        meta: proxy._meta,\r\n      });\r\n\r\n      getGlobalStore\r\n        .getState()\r\n        .setShadowMetadata(proxy._stateKey, proxy._path, {\r\n          ...currentMeta,\r\n          mapWrappers,\r\n        });\r\n\r\n      isSetupRef.current = true;\r\n\r\n      // Initial render\r\n      renderInitialItems();\r\n    }, 0);\r\n\r\n    // Cleanup\r\n    return () => {\r\n      clearTimeout(timeoutId);\r\n      if (instanceIdRef.current) {\r\n        const currentMeta =\r\n          getGlobalStore\r\n            .getState()\r\n            .getShadowMetadata(proxy._stateKey, proxy._path) || {};\r\n        if (currentMeta.mapWrappers) {\r\n          currentMeta.mapWrappers = currentMeta.mapWrappers.filter(\r\n            (w) => w.instanceId !== instanceIdRef.current\r\n          );\r\n          getGlobalStore\r\n            .getState()\r\n            .setShadowMetadata(proxy._stateKey, proxy._path, currentMeta);\r\n        }\r\n      }\r\n      rootsMapRef.current.forEach((root) => root.unmount());\r\n    };\r\n  }, []);\r\n\r\n  const renderInitialItems = () => {\r\n    const container = containerRef.current;\r\n    if (!container) return;\r\n\r\n    const value = getGlobalStore\r\n      .getState()\r\n      .getShadowValue(\r\n        [proxy._stateKey, ...proxy._path].join('.'),\r\n        proxy._meta?.validIds\r\n      ) as any[];\r\n\r\n    if (!Array.isArray(value)) return;\r\n\r\n    // --- BUG FIX IS HERE ---\r\n    // Prioritize the filtered IDs from the meta object, just like the regular `stateMap`.\r\n    // This ensures the keys match the filtered data.\r\n    const arrayKeys =\r\n      proxy._meta?.validIds ??\r\n      getGlobalStore.getState().getShadowMetadata(proxy._stateKey, proxy._path)\r\n        ?.arrayKeys ??\r\n      [];\r\n    // --- END OF FIX ---\r\n\r\n    const arraySetter = rebuildStateShape({\r\n      currentState: value,\r\n      path: proxy._path,\r\n      componentId: instanceIdRef.current,\r\n      meta: proxy._meta,\r\n    });\r\n\r\n    value.forEach((item, index) => {\r\n      const itemKey = arrayKeys[index]!; // Now this will be the correct key for the filtered item\r\n      if (!itemKey) return; // Safeguard if there's a mismatch\r\n\r\n      const itemComponentId = uuidv4();\r\n      const itemElement = document.createElement('div');\r\n\r\n      itemElement.setAttribute('data-item-path', itemKey);\r\n      container.appendChild(itemElement);\r\n\r\n      const root = createRoot(itemElement);\r\n      rootsMapRef.current.set(itemKey, root);\r\n\r\n      const itemPath = itemKey.split('.').slice(1) as string[];\r\n\r\n      // Render CogsItemWrapper instead of direct render\r\n      root.render(\r\n        createElement(MemoizedCogsItemWrapper, {\r\n          stateKey: proxy._stateKey,\r\n          itemComponentId: itemComponentId,\r\n          itemPath: itemPath,\r\n          localIndex: index,\r\n          arraySetter: arraySetter,\r\n          rebuildStateShape: rebuildStateShape,\r\n          renderFn: proxy._mapFn,\r\n        })\r\n      );\r\n    });\r\n  };\r\n\r\n  return <div ref={containerRef} data-map-container={instanceIdRef.current} />;\r\n}\r\n\r\nfunction SignalRenderer({\r\n  proxy,\r\n}: {\r\n  proxy: {\r\n    _path: string[];\r\n    _stateKey: string;\r\n    _effect?: string;\r\n    _meta?: MetaData;\r\n  };\r\n}) {\r\n  const elementRef = useRef<HTMLSpanElement>(null);\r\n  const instanceIdRef = useRef<string | null>(null);\r\n  const isSetupRef = useRef(false);\r\n  const signalId = `${proxy._stateKey}-${proxy._path.join('.')}`;\r\n  const value = getGlobalStore\r\n    .getState()\r\n    .getShadowValue(\r\n      [proxy._stateKey, ...proxy._path].join('.'),\r\n      proxy._meta?.validIds\r\n    );\r\n\r\n  // Setup effect - runs only once\r\n  useEffect(() => {\r\n    const element = elementRef.current;\r\n    if (!element || isSetupRef.current) return;\r\n\r\n    const timeoutId = setTimeout(() => {\r\n      if (!element.parentElement) {\r\n        console.warn('Parent element not found for signal', signalId);\r\n        return;\r\n      }\r\n\r\n      const parentElement = element.parentElement;\r\n      const childNodes = Array.from(parentElement.childNodes);\r\n      const position = childNodes.indexOf(element);\r\n\r\n      let parentId = parentElement.getAttribute('data-parent-id');\r\n      if (!parentId) {\r\n        parentId = `parent-${crypto.randomUUID()}`;\r\n        parentElement.setAttribute('data-parent-id', parentId);\r\n      }\r\n\r\n      instanceIdRef.current = `instance-${crypto.randomUUID()}`;\r\n\r\n      // Store signal info in shadow metadata\r\n      const currentMeta =\r\n        getGlobalStore\r\n          .getState()\r\n          .getShadowMetadata(proxy._stateKey, proxy._path) || {};\r\n      const signals = currentMeta.signals || [];\r\n      signals.push({\r\n        instanceId: instanceIdRef.current,\r\n        parentId,\r\n        position,\r\n        effect: proxy._effect,\r\n      });\r\n\r\n      getGlobalStore\r\n        .getState()\r\n        .setShadowMetadata(proxy._stateKey, proxy._path, {\r\n          ...currentMeta,\r\n          signals,\r\n        });\r\n\r\n      let displayValue = value;\r\n      if (proxy._effect) {\r\n        try {\r\n          displayValue = new Function(\r\n            'state',\r\n            `return (${proxy._effect})(state)`\r\n          )(value);\r\n        } catch (err) {\r\n          console.error('Error evaluating effect function:', err);\r\n        }\r\n      }\r\n\r\n      if (displayValue !== null && typeof displayValue === 'object') {\r\n        displayValue = JSON.stringify(displayValue);\r\n      }\r\n      const textNode = document.createTextNode(String(displayValue ?? ''));\r\n      element.replaceWith(textNode);\r\n      isSetupRef.current = true;\r\n    }, 0);\r\n\r\n    return () => {\r\n      clearTimeout(timeoutId);\r\n      if (instanceIdRef.current) {\r\n        const currentMeta =\r\n          getGlobalStore\r\n            .getState()\r\n            .getShadowMetadata(proxy._stateKey, proxy._path) || {};\r\n        if (currentMeta.signals) {\r\n          currentMeta.signals = currentMeta.signals.filter(\r\n            (s) => s.instanceId !== instanceIdRef.current\r\n          );\r\n          getGlobalStore\r\n            .getState()\r\n            .setShadowMetadata(proxy._stateKey, proxy._path, currentMeta);\r\n        }\r\n      }\r\n    };\r\n  }, []);\r\n\r\n  return createElement('span', {\r\n    ref: elementRef,\r\n    style: { display: 'contents' },\r\n    'data-signal-id': signalId,\r\n  });\r\n}\r\n\r\nconst MemoizedCogsItemWrapper = memo(\r\n  ListItemWrapper,\r\n  (prevProps, nextProps) => {\r\n    // Re-render if any of these change:\r\n    return (\r\n      prevProps.itemPath.join('.') === nextProps.itemPath.join('.') &&\r\n      prevProps.stateKey === nextProps.stateKey &&\r\n      prevProps.itemComponentId === nextProps.itemComponentId &&\r\n      prevProps.localIndex === nextProps.localIndex\r\n    );\r\n  }\r\n);\r\n\r\nconst useImageLoaded = (ref: RefObject<HTMLElement>): boolean => {\r\n  const [loaded, setLoaded] = useState(false);\r\n\r\n  useLayoutEffect(() => {\r\n    if (!ref.current) {\r\n      setLoaded(true);\r\n      return;\r\n    }\r\n\r\n    const images = Array.from(ref.current.querySelectorAll('img'));\r\n\r\n    // If there are no images, we are \"loaded\" immediately.\r\n    if (images.length === 0) {\r\n      setLoaded(true);\r\n      return;\r\n    }\r\n\r\n    let loadedCount = 0;\r\n    const handleImageLoad = () => {\r\n      loadedCount++;\r\n      if (loadedCount === images.length) {\r\n        setLoaded(true);\r\n      }\r\n    };\r\n\r\n    images.forEach((image) => {\r\n      if (image.complete) {\r\n        handleImageLoad();\r\n      } else {\r\n        image.addEventListener('load', handleImageLoad);\r\n        image.addEventListener('error', handleImageLoad);\r\n      }\r\n    });\r\n\r\n    return () => {\r\n      images.forEach((image) => {\r\n        image.removeEventListener('load', handleImageLoad);\r\n        image.removeEventListener('error', handleImageLoad);\r\n      });\r\n    };\r\n  }, [ref.current]);\r\n\r\n  return loaded;\r\n};\r\n\r\nfunction ListItemWrapper({\r\n  stateKey,\r\n  itemComponentId,\r\n  itemPath,\r\n  localIndex,\r\n  arraySetter,\r\n  rebuildStateShape,\r\n  renderFn,\r\n}: {\r\n  stateKey: string;\r\n  itemComponentId: string;\r\n  itemPath: string[];\r\n  localIndex: number;\r\n  arraySetter: any;\r\n\r\n  rebuildStateShape: (options: {\r\n    currentState: any;\r\n    path: string[];\r\n    componentId: string;\r\n    meta?: any;\r\n  }) => any;\r\n  renderFn: (\r\n    setter: any,\r\n    index: number,\r\n\r\n    arraySetter: any\r\n  ) => React.ReactNode;\r\n}) {\r\n  const [, forceUpdate] = useState({});\r\n  const { ref: inViewRef, inView } = useInView();\r\n  const elementRef = useRef<HTMLDivElement | null>(null);\r\n\r\n  const imagesLoaded = useImageLoaded(elementRef);\r\n  const hasReportedInitialHeight = useRef(false);\r\n  const fullKey = [stateKey, ...itemPath].join('.');\r\n  useRegisterComponent(stateKey, itemComponentId, forceUpdate);\r\n\r\n  const setRefs = useCallback(\r\n    (element: HTMLDivElement | null) => {\r\n      elementRef.current = element;\r\n      inViewRef(element); // This is the ref from useInView\r\n    },\r\n    [inViewRef]\r\n  );\r\n\r\n  useEffect(() => {\r\n    getGlobalStore.getState().subscribeToPath(fullKey, (e) => {\r\n      forceUpdate({});\r\n    });\r\n  }, []);\r\n  useEffect(() => {\r\n    if (!inView || !imagesLoaded || hasReportedInitialHeight.current) {\r\n      return;\r\n    }\r\n\r\n    const element = elementRef.current;\r\n    if (element && element.offsetHeight > 0) {\r\n      hasReportedInitialHeight.current = true;\r\n      const newHeight = element.offsetHeight;\r\n\r\n      getGlobalStore.getState().setShadowMetadata(stateKey, itemPath, {\r\n        virtualizer: {\r\n          itemHeight: newHeight,\r\n          domRef: element,\r\n        },\r\n      });\r\n\r\n      const arrayPath = itemPath.slice(0, -1);\r\n      const arrayPathKey = [stateKey, ...arrayPath].join('.');\r\n      getGlobalStore.getState().notifyPathSubscribers(arrayPathKey, {\r\n        type: 'ITEMHEIGHT',\r\n        itemKey: itemPath.join('.'),\r\n\r\n        ref: elementRef.current,\r\n      });\r\n    }\r\n  }, [inView, imagesLoaded, stateKey, itemPath]);\r\n\r\n  const fullItemPath = [stateKey, ...itemPath].join('.');\r\n  const itemValue = getGlobalStore.getState().getShadowValue(fullItemPath);\r\n\r\n  if (itemValue === undefined) {\r\n    return null;\r\n  }\r\n\r\n  const itemSetter = rebuildStateShape({\r\n    currentState: itemValue,\r\n    path: itemPath,\r\n    componentId: itemComponentId,\r\n  });\r\n  const children = renderFn(itemSetter, localIndex, arraySetter);\r\n\r\n  return <div ref={setRefs}>{children}</div>;\r\n}\r\n\r\nfunction FormElementWrapper({\r\n  stateKey,\r\n  path,\r\n  rebuildStateShape,\r\n  renderFn,\r\n  formOpts,\r\n  setState,\r\n}: {\r\n  stateKey: string;\r\n  path: string[];\r\n  rebuildStateShape: (options: {\r\n    currentState: any;\r\n    path: string[];\r\n    componentId: string;\r\n    meta?: any;\r\n  }) => any;\r\n  renderFn: (params: FormElementParams<any>) => React.ReactNode;\r\n  formOpts?: FormOptsType;\r\n  setState: any;\r\n}) {\r\n  const [componentId] = useState(() => uuidv4());\r\n  const [, forceUpdate] = useState({});\r\n\r\n  const stateKeyPathKey = [stateKey, ...path].join('.');\r\n  useRegisterComponent(stateKey, componentId, forceUpdate);\r\n  const globalStateValue = getGlobalStore\r\n    .getState()\r\n    .getShadowValue(stateKeyPathKey);\r\n  const [localValue, setLocalValue] = useState<any>(globalStateValue);\r\n  const isCurrentlyDebouncing = useRef(false);\r\n  const debounceTimeoutRef = useRef<NodeJS.Timeout | null>(null);\r\n\r\n  useEffect(() => {\r\n    if (\r\n      !isCurrentlyDebouncing.current &&\r\n      !isDeepEqual(globalStateValue, localValue)\r\n    ) {\r\n      setLocalValue(globalStateValue);\r\n    }\r\n  }, [globalStateValue]);\r\n\r\n  useEffect(() => {\r\n    const unsubscribe = getGlobalStore\r\n      .getState()\r\n      .subscribeToPath(stateKeyPathKey, (newValue) => {\r\n        if (!isCurrentlyDebouncing.current && localValue !== newValue) {\r\n          forceUpdate({});\r\n        }\r\n      });\r\n    return () => {\r\n      unsubscribe();\r\n      if (debounceTimeoutRef.current) {\r\n        clearTimeout(debounceTimeoutRef.current);\r\n        isCurrentlyDebouncing.current = false;\r\n      }\r\n    };\r\n  }, []);\r\n\r\n  const debouncedUpdate = useCallback(\r\n    (newValue: any) => {\r\n      const currentType = typeof globalStateValue;\r\n      if (currentType === 'number' && typeof newValue === 'string') {\r\n        newValue = newValue === '' ? 0 : Number(newValue);\r\n      }\r\n      setLocalValue(newValue);\r\n      isCurrentlyDebouncing.current = true;\r\n\r\n      if (debounceTimeoutRef.current) {\r\n        clearTimeout(debounceTimeoutRef.current);\r\n      }\r\n\r\n      const debounceTime = formOpts?.debounceTime ?? 200;\r\n\r\n      debounceTimeoutRef.current = setTimeout(() => {\r\n        isCurrentlyDebouncing.current = false;\r\n\r\n        // Update state\r\n        setState(newValue, path, { updateType: 'update' });\r\n\r\n        // Perform LIVE validation (gentle)\r\n        const { getInitialOptions, setShadowMetadata, getShadowMetadata } =\r\n          getGlobalStore.getState();\r\n        const validationOptions = getInitialOptions(stateKey)?.validation;\r\n        const zodSchema =\r\n          validationOptions?.zodSchemaV4 || validationOptions?.zodSchemaV3;\r\n\r\n        if (zodSchema) {\r\n          const fullState = getGlobalStore.getState().getShadowValue(stateKey);\r\n          const result = zodSchema.safeParse(fullState);\r\n\r\n          const currentMeta = getShadowMetadata(stateKey, path) || {};\r\n\r\n          if (!result.success) {\r\n            const errors =\r\n              'issues' in result.error\r\n                ? result.error.issues\r\n                : (result.error as any).errors;\r\n            const pathErrors = errors.filter(\r\n              (error: any) =>\r\n                JSON.stringify(error.path) === JSON.stringify(path)\r\n            );\r\n\r\n            if (pathErrors.length > 0) {\r\n              setShadowMetadata(stateKey, path, {\r\n                ...currentMeta,\r\n                validation: {\r\n                  status: 'INVALID_LIVE',\r\n                  message: pathErrors[0]?.message,\r\n                  validatedValue: newValue,\r\n                },\r\n              });\r\n            } else {\r\n              // This field has no errors - clear validation\r\n              setShadowMetadata(stateKey, path, {\r\n                ...currentMeta,\r\n                validation: {\r\n                  status: 'VALID_LIVE',\r\n                  validatedValue: newValue,\r\n                  message: undefined,\r\n                },\r\n              });\r\n            }\r\n          } else {\r\n            // Validation passed - clear any existing errors\r\n            setShadowMetadata(stateKey, path, {\r\n              ...currentMeta,\r\n              validation: {\r\n                status: 'VALID_LIVE',\r\n                validatedValue: newValue,\r\n                message: undefined,\r\n              },\r\n            });\r\n          }\r\n        }\r\n      }, debounceTime);\r\n      forceUpdate({});\r\n    },\r\n    [setState, path, formOpts?.debounceTime, stateKey]\r\n  );\r\n\r\n  // --- NEW onBlur HANDLER ---\r\n  // This replaces the old commented-out method with a modern approach.\r\n  const handleBlur = useCallback(async () => {\r\n    console.log('handleBlur triggered');\r\n\r\n    // Commit any pending changes\r\n    if (debounceTimeoutRef.current) {\r\n      clearTimeout(debounceTimeoutRef.current);\r\n      debounceTimeoutRef.current = null;\r\n      isCurrentlyDebouncing.current = false;\r\n      setState(localValue, path, { updateType: 'update' });\r\n    }\r\n\r\n    const { getInitialOptions } = getGlobalStore.getState();\r\n    const validationOptions = getInitialOptions(stateKey)?.validation;\r\n    const zodSchema =\r\n      validationOptions?.zodSchemaV4 || validationOptions?.zodSchemaV3;\r\n\r\n    if (!zodSchema) return;\r\n\r\n    // Get the full path including stateKey\r\n\r\n    // Update validation state to \"validating\"\r\n    const currentMeta = getGlobalStore\r\n      .getState()\r\n      .getShadowMetadata(stateKey, path);\r\n    getGlobalStore.getState().setShadowMetadata(stateKey, path, {\r\n      ...currentMeta,\r\n      validation: {\r\n        status: 'DIRTY',\r\n        validatedValue: localValue,\r\n      },\r\n    });\r\n\r\n    // Validate full state\r\n    const fullState = getGlobalStore.getState().getShadowValue(stateKey);\r\n    const result = zodSchema.safeParse(fullState);\r\n    console.log('result ', result);\r\n    if (!result.success) {\r\n      const errors =\r\n        'issues' in result.error\r\n          ? result.error.issues\r\n          : (result.error as any).errors;\r\n\r\n      console.log('All validation errors:', errors);\r\n      console.log('Current blur path:', path);\r\n\r\n      // Find errors for this specific path\r\n      const pathErrors = errors.filter((error: any) => {\r\n        console.log('Processing error:', error);\r\n\r\n        // For array paths, we need to translate indices to ULIDs\r\n        if (path.some((p) => p.startsWith('id:'))) {\r\n          console.log('Detected array path with ULID');\r\n\r\n          // This is an array item path like [\"id:xyz\", \"name\"]\r\n          const parentPath = path[0]!.startsWith('id:')\r\n            ? []\r\n            : path.slice(0, -1);\r\n\r\n          console.log('Parent path:', parentPath);\r\n\r\n          const arrayMeta = getGlobalStore\r\n            .getState()\r\n            .getShadowMetadata(stateKey, parentPath);\r\n\r\n          console.log('Array metadata:', arrayMeta);\r\n\r\n          if (arrayMeta?.arrayKeys) {\r\n            const itemKey = [stateKey, ...path.slice(0, -1)].join('.');\r\n            const itemIndex = arrayMeta.arrayKeys.indexOf(itemKey);\r\n\r\n            console.log('Item key:', itemKey, 'Index:', itemIndex);\r\n\r\n            // Compare with Zod path\r\n            const zodPath = [...parentPath, itemIndex, ...path.slice(-1)];\r\n            const match =\r\n              JSON.stringify(error.path) === JSON.stringify(zodPath);\r\n\r\n            console.log('Zod path comparison:', {\r\n              zodPath,\r\n              errorPath: error.path,\r\n              match,\r\n            });\r\n            return match;\r\n          }\r\n        }\r\n\r\n        const directMatch = JSON.stringify(error.path) === JSON.stringify(path);\r\n        console.log('Direct path comparison:', {\r\n          errorPath: error.path,\r\n          currentPath: path,\r\n          match: directMatch,\r\n        });\r\n        return directMatch;\r\n      });\r\n\r\n      console.log('Filtered path errors:', pathErrors);\r\n      // Update shadow metadata with validation result\r\n      getGlobalStore.getState().setShadowMetadata(stateKey, path, {\r\n        ...currentMeta,\r\n        validation: {\r\n          status: 'VALIDATION_FAILED',\r\n          message: pathErrors[0]?.message,\r\n          validatedValue: localValue,\r\n        },\r\n      });\r\n    } else {\r\n      // Validation passed\r\n      getGlobalStore.getState().setShadowMetadata(stateKey, path, {\r\n        ...currentMeta,\r\n        validation: {\r\n          status: 'VALID_PENDING_SYNC',\r\n          validatedValue: localValue,\r\n        },\r\n      });\r\n    }\r\n    forceUpdate({});\r\n  }, [stateKey, path, localValue, setState]);\r\n\r\n  const baseState = rebuildStateShape({\r\n    currentState: globalStateValue,\r\n    path: path,\r\n    componentId: componentId,\r\n  });\r\n\r\n  const stateWithInputProps = new Proxy(baseState, {\r\n    get(target, prop) {\r\n      if (prop === 'inputProps') {\r\n        return {\r\n          value: localValue ?? '',\r\n          onChange: (e: any) => {\r\n            debouncedUpdate(e.target.value);\r\n          },\r\n          // 5. Wire the new onBlur handler to the input props.\r\n          onBlur: handleBlur,\r\n          ref: formRefStore\r\n            .getState()\r\n            .getFormRef(stateKey + '.' + path.join('.')),\r\n        };\r\n      }\r\n\r\n      return target[prop];\r\n    },\r\n  });\r\n\r\n  return (\r\n    <ValidationWrapper formOpts={formOpts} path={path} stateKey={stateKey}>\r\n      {renderFn(stateWithInputProps)}\r\n    </ValidationWrapper>\r\n  );\r\n}\r\nfunction useRegisterComponent(\r\n  stateKey: string,\r\n  componentId: string,\r\n  forceUpdate: (o: object) => void\r\n) {\r\n  const fullComponentId = `${stateKey}////${componentId}`;\r\n\r\n  useLayoutEffect(() => {\r\n    const { registerComponent, unregisterComponent } =\r\n      getGlobalStore.getState();\r\n\r\n    // Call the safe, centralized function to register\r\n    registerComponent(stateKey, fullComponentId, {\r\n      forceUpdate: () => forceUpdate({}),\r\n      paths: new Set(),\r\n      reactiveType: ['component'],\r\n    });\r\n\r\n    // The cleanup now calls the safe, centralized unregister function\r\n    return () => {\r\n      unregisterComponent(stateKey, fullComponentId);\r\n    };\r\n  }, [stateKey, fullComponentId]); // Dependencies are stable and correct\r\n}\r\n"],"names":["setAndMergeOptions","stateKey","newOptions","getInitialOptions","getGlobalStore","setInitialStateOptions","initialOptions","setOptions","options","initialOptionsPart","initialOptionsPartState","mergedOptions","needToAdd","key","isDeepEqual","addStateOptions","initialState","formElements","validation","createCogsState","opt","newInitialState","statePart","transformStateFunc","existingOptions","existingGlobalOptions","useCogsState","componentId","useState","uuidv4","thiState","partialState","useCogsStateFn","setCogsOptions","loadAndApplyLocalStorage","notifyComponents","createCogsStateFromSync","syncSchema","useSync","schemas","apiParamsMap","entry","addStateLog","updateInitialStateGlobal","saveToLocalStorage","state","thisKey","currentInitialOptions","sessionId","lastSyncedWithServer","isFunction","storageKey","existingLastSynced","loadFromLocalStorage","shadowMeta","data","superJsonResult","superjson","localStorageKey","storedData","error","currentState","useCogsConfig","localkey","localData","stateEntry","updates","component","update","notifyComponent","fullComponentId","markEntireStateAsServerSynced","path","timestamp","store","currentMeta","arrayMeta","itemKey","index","itemPath","itemData","fieldPath","fieldData","updateBatchQueue","batchFlushScheduled","stateObject","localStorage","reactiveDeps","reactiveType","defaultState","syncUpdate","dependencies","serverState","__useSync","syncOptions","reactiveForce","forceUpdate","noStateKey","componentIdRef","useRef","latestInitialOptionsRef","useEffect","syncKey","resolveInitialState","useCallback","overrideOptions","currentOptions","finalDefaultState","localKey","event","serverStateData","mergeConfig","incomingData","keyField","existingIds","item","newUniqueItems","newItemKey","newItemPath","itemValue","fieldKey","meta","existingMeta","resolvedState","source","useLayoutEffect","componentKey","rootMeta","components","fullPath","pathMeta","syncApiRef","effectiveSetState","newStateOrFunction","updateObj","nestedShadowValue","payload","newUpdate","parentArrayPath","shouldSync","displayValue","parentId","position","effect","parent","childNodes","finalDisplayValue","err","sourceArrayKeys","newItemValue","fullSourceArray","wrapper","shouldRender","insertPosition","transform","currentValidKeys","applyTransforms","sortTransform","t","allItems","a","b","itemElement","children","root","createRoot","arraySetter","createElement","MemoizedCogsItemWrapper","arrayPath","elementToRemove","notifiedComponents","currentPath","currentPathMeta","isArray","getDifferences","subPathString","subPath","fullSubPath","subPathMeta","parentMeta","parentFullPath","parentValue","reactiveTypes","newDeps","shouldUpdate","updaterFinal","useMemo","handler","createProxyHandler","cogsSyncFn","syncOpt","hashTransforms","transforms","arrayKeys","itemsWithKeys","value","registerComponentDependency","dependencyPath","addPathComponent","getShadowMetadata","notifySelectionComponents","parentPath","currentSelected","arrayKey","selectedItem","proxyCache","recursionTimerName","rebuildStateShape","derivationSignature","cacheKey","stateKeyPathKey","baseFunction","target","thisArg","args","prop","baseObj","baseState","sync","validationKey","response","getStatusFunc","initalOptionsGet","fullKey","selectedIndicesMap","selectedItemKey","itemHeight","overscan","stickToBottom","scrollStickTolerance","containerRef","range","setRange","rerender","initialScrollRef","scrollStateRef","measurementCache","container","totalHeight","itemOffsets","runningOffset","offsets","measuredHeight","waitForContainer","visibleCount","endIndex","startIndex","scrollToBottom","handleScroll","currentScrollTop","scrollHeight","clientHeight","scrollState","distanceFromBottom","wasNearBottom","newStartIndex","i","behavior","performScroll","attemptScroll","attempts","currentHeight","currentScroll","newHeight","newScroll","scrollTimeout","debouncedScrollToBottom","observer","handleImageLoad","e","sourceArray","currentKeys","slicedIds","offset","callbackfn","setArrayKeys","shadowValue","itemSetter","SignalMapRenderer","newValidIds","val","compareFn","itemsWithIds","bufferSize","flushInterval","bufferStrategy","onFlush","buffer","isPaused","flushTimer","addToBuffer","flushBuffer","toFlush","result","streamId","streams","componentIdsRef","updateTrigger","validIds","arrayValues","cached","freshValidIds","freshValues","unsubscribe","caches","jsx","Fragment","localIndex","itemComponentId","fieldName","itemId","currentArray","lastIndex","newPath","fields","onMatch","newValue","matchedItem","isMatch","field","updatedItem","updatedArray","validKeys","indexToCut","fullIdToCut","pathForCut","indexKeyToCut","relevantKeys","keyToCut","searchKey","searchValue","foundPath","fn","$cogsSignal","fullParentKey","fullItemKey","zodErrors","patches","convertPath","jsonPath","p","patch","relativePath","formRefStore","hideMessage","ValidationWrapper","stack","batchKey","parts","batchPath","composedUpdate","composed","existing","currentValueAtPath","child","formOpts","FormElementWrapper","nextPath","proxyInstance","obj","newState","newUpdaterState","startTransition","proxy","SignalRenderer","instanceIdRef","isSetupRef","rootsMapRef","timeoutId","mapWrappers","renderInitialItems","w","elementRef","signalId","element","parentElement","signals","textNode","s","memo","ListItemWrapper","prevProps","nextProps","useImageLoaded","ref","loaded","setLoaded","images","loadedCount","image","renderFn","inViewRef","inView","useInView","imagesLoaded","hasReportedInitialHeight","useRegisterComponent","setRefs","arrayPathKey","fullItemPath","setState","globalStateValue","localValue","setLocalValue","isCurrentlyDebouncing","debounceTimeoutRef","debouncedUpdate","debounceTime","setShadowMetadata","validationOptions","zodSchema","fullState","pathErrors","handleBlur","errors","itemIndex","zodPath","match","directMatch","stateWithInputProps","registerComponent","unregisterComponent"],"mappings":"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"}