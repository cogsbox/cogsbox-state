{"version":3,"file":"CogsState.jsx","sources":["../src/CogsState.tsx"],"sourcesContent":["\"use client\";\r\n\r\nimport {\r\n  createElement,\r\n  startTransition,\r\n  useCallback,\r\n  useEffect,\r\n  useLayoutEffect,\r\n  useMemo,\r\n  useRef,\r\n  useState,\r\n  useSyncExternalStore,\r\n  type CSSProperties,\r\n  type ReactNode,\r\n  type RefObject,\r\n} from \"react\";\r\n\r\nimport {\r\n  debounce,\r\n  getDifferences,\r\n  getNestedValue,\r\n  isFunction,\r\n  type GenericObject,\r\n} from \"./utility.js\";\r\nimport {\r\n  cutFunc,\r\n  FormControlComponent,\r\n  pushFunc,\r\n  updateFn,\r\n  ValidationWrapper,\r\n} from \"./Functions.js\";\r\nimport { isDeepEqual, transformStateFunc } from \"./utility.js\";\r\nimport superjson from \"superjson\";\r\nimport { v4 as uuidv4 } from \"uuid\";\r\nimport { z } from \"zod\";\r\n\r\nimport { formRefStore, getGlobalStore, type ComponentsType } from \"./store.js\";\r\nimport { useCogsConfig } from \"./CogsStateClient.js\";\r\nimport { applyPatch } from \"fast-json-patch\";\r\nimport useMeasure from \"react-use-measure\";\r\nimport { ulid } from \"ulid\";\r\n\r\ntype Prettify<T> = { [K in keyof T]: T[K] } & {};\r\n\r\nexport type VirtualViewOptions = {\r\n  itemHeight?: number;\r\n  overscan?: number;\r\n  stickToBottom?: boolean;\r\n  dependencies?: any[];\r\n};\r\n\r\n// The result now returns a real StateObject\r\nexport type VirtualStateObjectResult<T extends any[]> = {\r\n  /**\r\n   * A new, fully-functional StateObject that represents the virtualized slice.\r\n   * You can use `.get()`, `.stateMap()`, `.insert()`, `.cut()` etc. on this object.\r\n   */\r\n  virtualState: StateObject<T>;\r\n  /**\r\n   * Props to be spread onto your DOM elements to enable virtualization.\r\n   */\r\n  virtualizerProps: {\r\n    outer: { ref: RefObject<HTMLDivElement>; style: CSSProperties };\r\n    inner: { style: CSSProperties };\r\n    list: { style: CSSProperties };\r\n  };\r\n  scrollToBottom: (behavior?: ScrollBehavior) => void;\r\n  scrollToIndex: (index: number, behavior?: ScrollBehavior) => void;\r\n};\r\n\r\nexport type ServerSyncStatus = {\r\n  isFresh: boolean;\r\n  isFreshTime: number;\r\n  isStale: boolean;\r\n  isStaleTime: number;\r\n  isSyncing: boolean;\r\n  isSyncingTime: number;\r\n};\r\n\r\nexport type SyncInfo = {\r\n  timeStamp: number;\r\n  userId: number;\r\n};\r\n\r\nexport type FormElementParams<T> = {\r\n  get: () => T;\r\n\r\n  set: UpdateType<T>;\r\n  syncStatus: (SyncInfo & { date: Date }) | null;\r\n  path: string[];\r\n  validationErrors: () => string[];\r\n  addValidationError: (message?: string) => void;\r\n\r\n  inputProps: {\r\n    ref?: React.RefObject<any>;\r\n    value?: T extends boolean ? never : T;\r\n    onChange?: (\r\n      event: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>\r\n    ) => void;\r\n    onBlur?: () => void;\r\n  };\r\n};\r\n\r\nexport type StateKeys = string;\r\n\r\ntype findWithFuncType<U> = (\r\n  thisKey: keyof U,\r\n  thisValue: U[keyof U]\r\n) => EndType<U> & StateObject<U>;\r\nexport type PushArgs<U, T> = (\r\n  update:\r\n    | Prettify<U>\r\n    | ((prevState: NonNullable<Prettify<U>>[]) => NonNullable<Prettify<U>>),\r\n  opts?: UpdateOpts<U>\r\n) => StateObject<T>;\r\n\r\ntype CutFunctionType<T> = (\r\n  index?: number,\r\n  options?: { waitForSync?: boolean }\r\n) => StateObject<T>;\r\n\r\nexport type InferArrayElement<T> = T extends (infer U)[] ? U : never;\r\ntype ArraySpecificPrototypeKeys =\r\n  | \"concat\"\r\n  | \"copyWithin\"\r\n  | \"fill\"\r\n  | \"find\"\r\n  | \"findIndex\"\r\n  | \"flat\"\r\n  | \"flatMap\"\r\n  | \"includes\"\r\n  | \"indexOf\"\r\n  | \"join\"\r\n  | \"keys\"\r\n  | \"lastIndexOf\"\r\n  | \"map\"\r\n  | \"pop\"\r\n  | \"push\"\r\n  | \"reduce\"\r\n  | \"reduceRight\"\r\n  | \"reverse\"\r\n  | \"shift\"\r\n  | \"slice\"\r\n  | \"some\"\r\n  | \"sort\"\r\n  | \"splice\"\r\n  | \"unshift\"\r\n  | \"values\"\r\n  | \"entries\"\r\n  | \"every\"\r\n  | \"filter\"\r\n  | \"forEach\"\r\n  | \"with\";\r\n\r\nexport type ArrayEndType<TShape extends unknown> = {\r\n  findWith: findWithFuncType<InferArrayElement<TShape>>;\r\n  index: (index: number) => StateObject<InferArrayElement<TShape>> & {\r\n    insert: PushArgs<InferArrayElement<TShape>, TShape>;\r\n    cut: CutFunctionType<TShape>;\r\n    _index: number;\r\n  } & EndType<InferArrayElement<TShape>>;\r\n  insert: PushArgs<InferArrayElement<TShape>, TShape>;\r\n  cut: CutFunctionType<TShape>;\r\n  cutByValue: (value: string | number | boolean) => void;\r\n  toggleByValue: (value: string | number | boolean) => void;\r\n  stateSort: (\r\n    compareFn: (\r\n      a: InferArrayElement<TShape>,\r\n      b: InferArrayElement<TShape>\r\n    ) => number\r\n  ) => ArrayEndType<TShape>;\r\n  useVirtualView: (\r\n    options: VirtualViewOptions\r\n  ) => VirtualStateObjectResult<InferArrayElement<TShape>[]>;\r\n\r\n  stateMapNoRender: (\r\n    callbackfn: (\r\n      value: InferArrayElement<TShape>,\r\n      setter: StateObject<InferArrayElement<TShape>>,\r\n      index: number,\r\n      array: TShape,\r\n      arraySetter: StateObject<TShape>\r\n    ) => void\r\n  ) => any;\r\n  stateList: (\r\n    callbackfn: (\r\n      value: InferArrayElement<TShape>,\r\n      setter: StateObject<InferArrayElement<TShape>>,\r\n      index: { localIndex: number; originalIndex: number },\r\n      array: TShape,\r\n      arraySetter: StateObject<TShape>\r\n    ) => void\r\n  ) => any;\r\n  stateMap: (\r\n    callbackfn: (\r\n      value: InferArrayElement<TShape>,\r\n      setter: StateObject<InferArrayElement<TShape>>,\r\n      index: number,\r\n      array: TShape,\r\n      arraySetter: StateObject<TShape>\r\n    ) => void\r\n  ) => any;\r\n  $stateMap: (\r\n    callbackfn: (\r\n      value: InferArrayElement<TShape>,\r\n      setter: StateObject<InferArrayElement<TShape>>,\r\n      index: number,\r\n      array: TShape,\r\n      arraySetter: StateObject<TShape>\r\n    ) => void\r\n  ) => any;\r\n  stateFlattenOn: <K extends keyof InferArrayElement<TShape>>(\r\n    field: K\r\n  ) => StateObject<InferArrayElement<InferArrayElement<TShape>[K]>[]>;\r\n  uniqueInsert: (\r\n    payload: UpdateArg<InferArrayElement<TShape>>,\r\n    fields?: (keyof InferArrayElement<TShape>)[],\r\n    onMatch?: (existingItem: any) => any\r\n  ) => void;\r\n  stateFind: (\r\n    callbackfn: (value: InferArrayElement<TShape>, index: number) => boolean\r\n  ) => StateObject<InferArrayElement<TShape>> | undefined;\r\n  stateFilter: (\r\n    callbackfn: (value: InferArrayElement<TShape>, index: number) => void\r\n  ) => ArrayEndType<TShape>;\r\n  getSelected: () => StateObject<InferArrayElement<TShape>> | undefined;\r\n  clearSelected: () => void;\r\n  getSelectedIndex: () => number;\r\n  last: () => StateObject<InferArrayElement<TShape>> | undefined;\r\n} & EndType<TShape>;\r\n\r\nexport type FormOptsType = {\r\n  validation?: {\r\n    hideMessage?: boolean;\r\n    message?: string;\r\n    stretch?: boolean;\r\n    props?: GenericObject;\r\n    disable?: boolean;\r\n  };\r\n\r\n  debounceTime?: number;\r\n};\r\n\r\nexport type FormControl<T> = (obj: FormElementParams<T>) => JSX.Element;\r\n\r\nexport type UpdateArg<S> = S | ((prevState: S) => S);\r\n\r\nexport type UpdateType<T> = (\r\n  payload: UpdateArg<T>,\r\n  opts?: UpdateOpts<T>\r\n) => void;\r\n\r\nexport type UpdateOpts<T> = {\r\n  afterUpdate?: (state: T) => void;\r\n  debounce?: number;\r\n};\r\nexport type ObjectEndType<T> = EndType<T> & {\r\n  [K in keyof T]-?: ObjectEndType<T[K]>;\r\n} & {\r\n  stateObject: (callbackfn: (value: T, setter: StateObject<T>) => void) => any;\r\n  delete: () => void;\r\n};\r\nexport type ValidationError = {\r\n  path: (string | number)[];\r\n  message: string;\r\n};\r\ntype EffectFunction<T, R> = (state: T) => R;\r\nexport type EndType<T, IsArrayElement = false> = {\r\n  addValidation: (errors: ValidationError[]) => void;\r\n  applyJsonPatch: (patches: any[]) => void;\r\n  update: UpdateType<T>;\r\n  _path: string[];\r\n  _stateKey: string;\r\n  formElement: (control: FormControl<T>, opts?: FormOptsType) => JSX.Element;\r\n  get: () => T;\r\n  $get: () => T;\r\n  $derive: <R>(fn: EffectFunction<T, R>) => R;\r\n  _status: \"fresh\" | \"stale\" | \"synced\";\r\n  getStatus: () => \"fresh\" | \"stale\";\r\n\r\n  showValidationErrors: () => string[];\r\n  setValidation: (ctx: string) => void;\r\n  removeValidation: (ctx: string) => void;\r\n  ignoreFields: (fields: string[]) => StateObject<T>;\r\n  _selected: boolean;\r\n  setSelected: (value: boolean) => void;\r\n  toggleSelected: () => void;\r\n  getFormRef: () => React.RefObject<any> | undefined;\r\n  removeStorage: () => void;\r\n  sync: () => void;\r\n  validationWrapper: ({\r\n    children,\r\n    hideMessage,\r\n  }: {\r\n    children: React.ReactNode;\r\n    hideMessage?: boolean;\r\n  }) => JSX.Element;\r\n  lastSynced?: SyncInfo;\r\n} & (IsArrayElement extends true ? { cut: () => void } : {});\r\n\r\nexport type StateObject<T> = (T extends any[]\r\n  ? ArrayEndType<T>\r\n  : T extends Record<string, unknown> | object\r\n    ? { [K in keyof T]-?: StateObject<T[K]> } & ObjectEndType<T>\r\n    : T extends string | number | boolean | null\r\n      ? T\r\n      : never) &\r\n  EndType<T, true> & {\r\n    getAllFormRefs: () => Map<string, React.RefObject<any>>;\r\n    _componentId: string | null;\r\n    getComponents: () => ComponentsType;\r\n    validateZodSchema: () => void;\r\n    _initialState: T;\r\n    updateInitialState: (newState: T | null) => {\r\n      fetchId: (field: keyof T) => string | number;\r\n    };\r\n    _isLoading: boolean;\r\n    _serverState: T;\r\n    revertToInitialState: (obj?: { validationKey?: string }) => T;\r\n    getDifferences: () => string[];\r\n    middleware: (\r\n      middles: ({\r\n        updateLog,\r\n        update,\r\n      }: {\r\n        updateLog: UpdateTypeDetail[] | undefined;\r\n        update: UpdateTypeDetail;\r\n      }) => void\r\n    ) => void;\r\n    _isServerSynced: () => boolean;\r\n    getLocalStorage: (key: string) => LocalStorageData<T> | null;\r\n  };\r\n\r\nexport type CogsUpdate<T extends unknown> = UpdateType<T>;\r\n\r\nexport type EffectiveSetState<TStateObject> = (\r\n  newStateOrFunction: UpdateArg<TStateObject>,\r\n  path: string[],\r\n  updateObj: { updateType: \"update\" | \"insert\" | \"cut\" },\r\n  validationKey?: string,\r\n  opts?: UpdateOpts<TStateObject>\r\n) => void;\r\n\r\nexport type UpdateTypeDetail = {\r\n  timeStamp: number;\r\n  stateKey: string;\r\n  updateType: \"update\" | \"insert\" | \"cut\";\r\n  path: string[];\r\n  status: \"new\" | \"sent\" | \"synced\";\r\n  oldValue: any;\r\n  newValue: any;\r\n  userId?: number;\r\n};\r\n\r\nexport type ActionsType<T> = {\r\n  type: \"onChange\";\r\n  action: ({ state, actionType }: { state: T; actionType: string }) => void;\r\n  debounce?: number;\r\n}[];\r\n\r\ntype ArrayToObject<T extends string[]> = Record<T[number], string>;\r\ntype CookieType<T> = {\r\n  timeStamp: number;\r\n  value: T;\r\n  cookieName: string;\r\n  OnUnMountCookie?: Boolean;\r\n};\r\nexport type CogsCookiesType<T extends string[] = string[]> = CookieType<\r\n  ArrayToObject<T>\r\n>;\r\nexport type ReactivityType = \"none\" | \"component\" | \"deps\" | \"all\";\r\n\r\ntype ValidationOptionsType = {\r\n  key?: string;\r\n  zodSchema?: z.ZodTypeAny;\r\n  onBlur?: boolean;\r\n};\r\n\r\nexport type OptionsType<T extends unknown = unknown> = {\r\n  log?: boolean;\r\n  componentId?: string;\r\n  serverSync?: ServerSyncType<T>;\r\n  validation?: ValidationOptionsType;\r\n  enableServerState?: boolean;\r\n  serverState?: {\r\n    id?: string | number;\r\n    data?: T;\r\n    status?: \"pending\" | \"error\" | \"success\";\r\n  };\r\n  sync?: {\r\n    action: (state: T) => Promise<{\r\n      success: boolean;\r\n      data?: any;\r\n      error?: any;\r\n      errors?: Array<{\r\n        path: (string | number)[];\r\n        message: string;\r\n      }>;\r\n    }>;\r\n    onSuccess?: (data: any) => void;\r\n    onError?: (error: any) => void;\r\n  };\r\n  middleware?: ({\r\n    updateLog,\r\n    update,\r\n  }: {\r\n    updateLog: UpdateTypeDetail[] | undefined;\r\n    update: UpdateTypeDetail;\r\n  }) => void;\r\n\r\n  modifyState?: (state: T) => T;\r\n  localStorage?: {\r\n    key: string | ((state: T) => string);\r\n    onChange?: (state: T) => void;\r\n  };\r\n  formElements?: FormsElementsType;\r\n  enabledSync?: (state: T) => boolean;\r\n  reactiveDeps?: (state: T) => any[] | true;\r\n  reactiveType?: ReactivityType[] | ReactivityType;\r\n  syncUpdate?: Partial<UpdateTypeDetail>;\r\n\r\n  initialState?: T;\r\n  dependencies?: any[];\r\n};\r\nexport type ServerSyncType<T> = {\r\n  testKey?: string;\r\n  syncKey: (({ state }: { state: T }) => string) | string;\r\n  syncFunction: ({ state }: { state: T }) => void;\r\n  debounce?: number;\r\n\r\n  snapshot?: {\r\n    name: (({ state }: { state: T }) => string) | string;\r\n    stateKeys: StateKeys[];\r\n    currentUrl: string;\r\n    currentParams?: URLSearchParams;\r\n  };\r\n};\r\nexport type SyncActionsType<T> = {\r\n  syncKey: string;\r\n\r\n  rollBackState?: T;\r\n  actionTimeStamp: number;\r\n  retryCount?: number;\r\n  status:\r\n    | \"success\"\r\n    | \"waiting\"\r\n    | \"rolledBack\"\r\n    | \"error\"\r\n    | \"cancelled\"\r\n    | \"failed\";\r\n  snapshot?: {\r\n    name: string;\r\n    stateKeys: StateKeys[];\r\n    currentUrl: string;\r\n    currentParams?: URLSearchParams;\r\n  };\r\n};\r\n\r\nexport type ValidationWrapperOptions<T extends unknown = unknown> = {\r\n  children: React.ReactNode;\r\n  active: boolean;\r\n  stretch?: boolean;\r\n  path: string[];\r\n  message?: string;\r\n  data?: T;\r\n  key?: string;\r\n};\r\nexport type SyncRenderOptions<T extends unknown = unknown> = {\r\n  children: React.ReactNode;\r\n  time: number;\r\n  data?: T;\r\n  key?: string;\r\n};\r\n\r\ntype FormsElementsType<T extends unknown = unknown> = {\r\n  validation?: (options: ValidationWrapperOptions<T>) => React.ReactNode;\r\n  syncRender?: (options: SyncRenderOptions<T>) => React.ReactNode;\r\n};\r\n\r\nexport type InitialStateInnerType<T extends unknown = unknown> = {\r\n  initialState: T;\r\n} & OptionsType<T>;\r\n\r\nexport type InitialStateType<T> = {\r\n  [key: string]: InitialStateInnerType<T>;\r\n};\r\n\r\nexport type AllStateTypes<T extends unknown> = Record<string, T>;\r\n\r\nexport type CogsInitialState<T> = {\r\n  initialState: T;\r\n  formElements?: FormsElementsType<T>;\r\n};\r\n\r\nexport type TransformedStateType<T> = {\r\n  [P in keyof T]: T[P] extends CogsInitialState<infer U> ? U : T[P];\r\n};\r\n\r\nfunction setAndMergeOptions(stateKey: string, newOptions: OptionsType<any>) {\r\n  const getInitialOptions = getGlobalStore.getState().getInitialOptions;\r\n  const setInitialStateOptions =\r\n    getGlobalStore.getState().setInitialStateOptions;\r\n\r\n  const initialOptions = getInitialOptions(stateKey as string) || {};\r\n\r\n  setInitialStateOptions(stateKey as string, {\r\n    ...initialOptions,\r\n    ...newOptions,\r\n  });\r\n}\r\n\r\n// Fix for the setOptions function\r\nfunction setOptions<StateKey, Opt>({\r\n  stateKey,\r\n  options,\r\n  initialOptionsPart,\r\n}: {\r\n  stateKey: StateKey;\r\n  options?: OptionsType<any>;\r\n  initialOptionsPart: Record<string, any>;\r\n}) {\r\n  const initialOptions = getInitialOptions(stateKey as string) || {};\r\n  const initialOptionsPartState = initialOptionsPart[stateKey as string] || {};\r\n  const setInitialStateOptions =\r\n    getGlobalStore.getState().setInitialStateOptions;\r\n  const mergedOptions = { ...initialOptionsPartState, ...initialOptions };\r\n\r\n  let needToAdd = false;\r\n  if (options) {\r\n    for (const key in options) {\r\n      if (!mergedOptions.hasOwnProperty(key)) {\r\n        needToAdd = true;\r\n        mergedOptions[key] = options[key as keyof typeof options];\r\n      } else {\r\n        if (\r\n          key == \"localStorage\" &&\r\n          options[key] &&\r\n          mergedOptions[key].key !== options[key]?.key\r\n        ) {\r\n          needToAdd = true;\r\n          mergedOptions[key] = options[key];\r\n        }\r\n        if (\r\n          key == \"initialState\" &&\r\n          options[key] &&\r\n          mergedOptions[key] !== options[key] && // Different references\r\n          !isDeepEqual(mergedOptions[key], options[key]) // And different values\r\n        ) {\r\n          needToAdd = true;\r\n          mergedOptions[key] = options[key];\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  if (needToAdd) {\r\n    setInitialStateOptions(stateKey as string, mergedOptions);\r\n  }\r\n}\r\nexport function addStateOptions<T extends unknown>(\r\n  initialState: T,\r\n  { formElements, validation }: OptionsType<T>\r\n) {\r\n  return { initialState: initialState, formElements, validation } as T;\r\n}\r\n\r\nexport const createCogsState = <State extends Record<StateKeys, unknown>>(\r\n  initialState: State,\r\n  opt?: { formElements?: FormsElementsType; validation?: ValidationOptionsType }\r\n) => {\r\n  let newInitialState = initialState;\r\n\r\n  // Extract state parts and options using transformStateFunc\r\n  const [statePart, initialOptionsPart] =\r\n    transformStateFunc<State>(newInitialState);\r\n\r\n  // Apply global formElements as defaults to each state key's options\r\n  if (\r\n    Object.keys(initialOptionsPart).length > 0 ||\r\n    (opt && Object.keys(opt).length > 0)\r\n  ) {\r\n    Object.keys(initialOptionsPart).forEach((key) => {\r\n      // Get the existing options for this state key\r\n      initialOptionsPart[key] = initialOptionsPart[key] || {};\r\n\r\n      initialOptionsPart[key].formElements = {\r\n        ...opt?.formElements, // Global defaults first\r\n        ...opt?.validation,\r\n        ...(initialOptionsPart[key].formElements || {}), // State-specific overrides\r\n      };\r\n      const existingOptions = getInitialOptions(key);\r\n\r\n      if (!existingOptions) {\r\n        getGlobalStore\r\n          .getState()\r\n          .setInitialStateOptions(key, initialOptionsPart[key]);\r\n      }\r\n    });\r\n  }\r\n\r\n  getGlobalStore.getState().setInitialStates(statePart);\r\n  getGlobalStore.getState().setCreatedState(statePart);\r\n  type StateKeys = keyof typeof statePart;\r\n\r\n  const useCogsState = <StateKey extends StateKeys>(\r\n    stateKey: StateKey,\r\n    options?: OptionsType<(typeof statePart)[StateKey]>\r\n  ) => {\r\n    const [componentId] = useState(options?.componentId ?? uuidv4());\r\n\r\n    setOptions({\r\n      stateKey,\r\n      options,\r\n      initialOptionsPart,\r\n    });\r\n\r\n    const thiState =\r\n      getGlobalStore.getState().cogsStateStore[stateKey as string] ||\r\n      statePart[stateKey as string];\r\n    const partialState = options?.modifyState\r\n      ? options.modifyState(thiState)\r\n      : thiState;\r\n\r\n    const [state, updater] = useCogsStateFn<(typeof statePart)[StateKey]>(\r\n      partialState,\r\n      {\r\n        stateKey: stateKey as string,\r\n        syncUpdate: options?.syncUpdate,\r\n        componentId,\r\n        localStorage: options?.localStorage,\r\n        middleware: options?.middleware,\r\n        enabledSync: options?.enabledSync,\r\n        reactiveType: options?.reactiveType,\r\n        reactiveDeps: options?.reactiveDeps,\r\n        initialState: options?.initialState as any,\r\n        dependencies: options?.dependencies,\r\n        serverState: options?.serverState,\r\n      }\r\n    );\r\n\r\n    return updater;\r\n  };\r\n\r\n  function setCogsOptions<StateKey extends StateKeys>(\r\n    stateKey: StateKey,\r\n    options: OptionsType<(typeof statePart)[StateKey]>\r\n  ) {\r\n    setOptions({ stateKey, options, initialOptionsPart });\r\n\r\n    if (options.localStorage) {\r\n      loadAndApplyLocalStorage(stateKey as string, options);\r\n    }\r\n\r\n    notifyComponents(stateKey as string);\r\n  }\r\n\r\n  return { useCogsState, setCogsOptions };\r\n};\r\n\r\nconst {\r\n  setUpdaterState,\r\n  setState,\r\n  getInitialOptions,\r\n  getKeyState,\r\n  getValidationErrors,\r\n  setStateLog,\r\n  updateInitialStateGlobal,\r\n  addValidationError,\r\n  removeValidationError,\r\n  setServerSyncActions,\r\n} = getGlobalStore.getState();\r\nconst saveToLocalStorage = <T,>(\r\n  state: T,\r\n  thisKey: string,\r\n  currentInitialOptions: any,\r\n  sessionId?: string,\r\n  lastSyncedWithServer?: number\r\n) => {\r\n  if (currentInitialOptions?.log) {\r\n    console.log(\r\n      \"saving to localstorage\",\r\n      thisKey,\r\n      currentInitialOptions.localStorage?.key,\r\n      sessionId\r\n    );\r\n  }\r\n\r\n  const key = isFunction(currentInitialOptions?.localStorage?.key)\r\n    ? currentInitialOptions.localStorage?.key(state)\r\n    : currentInitialOptions?.localStorage?.key;\r\n\r\n  if (key && sessionId) {\r\n    const storageKey = `${sessionId}-${thisKey}-${key}`;\r\n\r\n    // Get existing data to preserve lastSyncedWithServer if not explicitly updating it\r\n    let existingLastSynced: number | undefined;\r\n    try {\r\n      const existing = loadFromLocalStorage(storageKey);\r\n      existingLastSynced = existing?.lastSyncedWithServer;\r\n    } catch {\r\n      // Ignore errors, will use undefined\r\n    }\r\n\r\n    const data: LocalStorageData<T> = {\r\n      state,\r\n      lastUpdated: Date.now(),\r\n      lastSyncedWithServer: lastSyncedWithServer ?? existingLastSynced,\r\n    };\r\n\r\n    // Use SuperJSON serialize to get the json part only\r\n    const superJsonResult = superjson.serialize(data);\r\n    window.localStorage.setItem(\r\n      storageKey,\r\n      JSON.stringify(superJsonResult.json)\r\n    );\r\n  }\r\n};\r\n\r\nconst loadFromLocalStorage = (localStorageKey: string) => {\r\n  if (!localStorageKey) return null;\r\n\r\n  try {\r\n    const storedData = window.localStorage.getItem(localStorageKey);\r\n    if (!storedData) return null;\r\n\r\n    // Parse the json part back normally\r\n    const parsedData = JSON.parse(storedData);\r\n\r\n    return parsedData;\r\n  } catch (error) {\r\n    console.error(\"Error loading from localStorage:\", error);\r\n    return null;\r\n  }\r\n};\r\nconst loadAndApplyLocalStorage = (stateKey: string, options: any) => {\r\n  const currentState = getGlobalStore.getState().cogsStateStore[stateKey];\r\n  const { sessionId } = useCogsConfig();\r\n  const localkey = isFunction(options?.localStorage?.key)\r\n    ? options.localStorage.key(currentState)\r\n    : options?.localStorage?.key;\r\n\r\n  if (localkey && sessionId) {\r\n    const localData = loadFromLocalStorage(\r\n      `${sessionId}-${stateKey}-${localkey}`\r\n    );\r\n\r\n    if (\r\n      localData &&\r\n      localData.lastUpdated > (localData.lastSyncedWithServer || 0)\r\n    ) {\r\n      setState(stateKey, localData.state);\r\n\r\n      notifyComponents(stateKey);\r\n      return true;\r\n    }\r\n  }\r\n  return false;\r\n};\r\n\r\ntype LocalStorageData<T> = {\r\n  state: T;\r\n  lastUpdated: number;\r\n  lastSyncedWithServer?: number;\r\n  baseServerState?: T; // Add this to track what server state our changes are based on\r\n};\r\n\r\nconst updateGlobalState = (\r\n  thisKey: string,\r\n  initialState: any,\r\n  newState: any,\r\n  effectiveSetState: EffectiveSetState<any>,\r\n  componentId: string,\r\n  sessionId?: string\r\n) => {\r\n  // Update all global state at once\r\n  const updates = {\r\n    initialState: initialState,\r\n    updaterState: createProxyHandler(\r\n      thisKey,\r\n      effectiveSetState,\r\n      componentId,\r\n      sessionId\r\n    ),\r\n    state: newState,\r\n  };\r\n\r\n  updateInitialStateGlobal(thisKey, updates.initialState);\r\n  setUpdaterState(thisKey, updates.updaterState);\r\n  setState(thisKey, updates.state);\r\n};\r\n\r\nconst notifyComponents = (thisKey: string) => {\r\n  const stateEntry = getGlobalStore.getState().stateComponents.get(thisKey);\r\n  if (!stateEntry) return;\r\n\r\n  // Batch component updates\r\n  const updates = new Set<() => void>();\r\n  stateEntry.components.forEach((component) => {\r\n    const reactiveTypes = component\r\n      ? Array.isArray(component.reactiveType)\r\n        ? component.reactiveType\r\n        : [component.reactiveType || \"component\"]\r\n      : null;\r\n    if (!reactiveTypes?.includes(\"none\")) {\r\n      updates.add(() => component.forceUpdate());\r\n    }\r\n  });\r\n\r\n  // Schedule updates in the next tick to allow batching\r\n  queueMicrotask(() => {\r\n    updates.forEach((update) => update());\r\n  });\r\n};\r\n\r\nexport const notifyComponent = (stateKey: string, componentId: string) => {\r\n  const stateEntry = getGlobalStore.getState().stateComponents.get(stateKey);\r\n  if (stateEntry) {\r\n    const fullComponentId = `${stateKey}////${componentId}`;\r\n    const component = stateEntry.components.get(fullComponentId);\r\n    const reactiveTypes = component\r\n      ? Array.isArray(component.reactiveType)\r\n        ? component.reactiveType\r\n        : [component.reactiveType || \"component\"]\r\n      : null;\r\n\r\n    // Skip if reactivity is disabled\r\n    if (reactiveTypes?.includes(\"none\")) {\r\n      return;\r\n    }\r\n\r\n    if (component) {\r\n      // Force an update to ensure the current value is saved\r\n\r\n      component.forceUpdate();\r\n    }\r\n  }\r\n};\r\nconst getUpdateValues = (\r\n  updateType: string,\r\n  prevValue: any,\r\n  payload: any,\r\n  path: string[]\r\n) => {\r\n  switch (updateType) {\r\n    case \"update\":\r\n      return {\r\n        oldValue: getNestedValue(prevValue, path),\r\n        newValue: getNestedValue(payload, path),\r\n      };\r\n    case \"insert\":\r\n      return {\r\n        oldValue: null, // or undefined\r\n        newValue: getNestedValue(payload, path),\r\n      };\r\n    case \"cut\":\r\n      return {\r\n        oldValue: getNestedValue(prevValue, path),\r\n        newValue: null, // or undefined\r\n      };\r\n    default:\r\n      return { oldValue: null, newValue: null };\r\n  }\r\n};\r\nexport function useCogsStateFn<TStateObject extends unknown>(\r\n  stateObject: TStateObject,\r\n  {\r\n    stateKey,\r\n    serverSync,\r\n    localStorage,\r\n    formElements,\r\n    reactiveDeps,\r\n    reactiveType,\r\n    componentId,\r\n    initialState,\r\n    syncUpdate,\r\n    dependencies,\r\n    serverState,\r\n  }: {\r\n    stateKey?: string;\r\n    componentId?: string;\r\n    initialState?: TStateObject;\r\n  } & OptionsType<TStateObject> = {}\r\n) {\r\n  const [reactiveForce, forceUpdate] = useState({}); //this is the key to reactivity\r\n  const { sessionId } = useCogsConfig();\r\n\r\n  let noStateKey = stateKey ? false : true;\r\n  const [thisKey] = useState(stateKey ?? uuidv4());\r\n  const stateLog = getGlobalStore.getState().stateLog[thisKey];\r\n  const componentUpdatesRef = useRef(new Set<string>());\r\n  const componentIdRef = useRef(componentId ?? uuidv4());\r\n  const latestInitialOptionsRef = useRef<OptionsType<TStateObject> | null>(\r\n    null\r\n  );\r\n  latestInitialOptionsRef.current = (getInitialOptions(thisKey as string) ??\r\n    null) as OptionsType<TStateObject> | null;\r\n\r\n  useEffect(() => {\r\n    if (syncUpdate && syncUpdate.stateKey === thisKey && syncUpdate.path?.[0]) {\r\n      // Update the actual state value\r\n      setState(thisKey, (prevState: any) => ({\r\n        ...prevState,\r\n        [syncUpdate.path![0]!]: syncUpdate.newValue,\r\n      }));\r\n\r\n      // Create combined key and update sync info\r\n      const syncKey = `${syncUpdate.stateKey}:${syncUpdate.path.join(\".\")}`;\r\n      getGlobalStore.getState().setSyncInfo(syncKey, {\r\n        timeStamp: syncUpdate.timeStamp!,\r\n        userId: syncUpdate.userId!,\r\n      });\r\n    }\r\n  }, [syncUpdate]);\r\n  useEffect(() => {\r\n    // Only proceed if initialState is provided\r\n    if (initialState) {\r\n      setAndMergeOptions(thisKey as string, {\r\n        initialState,\r\n      });\r\n\r\n      const options = latestInitialOptionsRef.current;\r\n      const hasServerId = options?.serverState?.id !== undefined;\r\n      const hasServerData =\r\n        hasServerId &&\r\n        options?.serverState?.status === \"success\" &&\r\n        options?.serverState?.data;\r\n\r\n      const currentGloballyStoredInitialState =\r\n        getGlobalStore.getState().initialStateGlobal[thisKey];\r\n\r\n      const initialStateChanged =\r\n        (currentGloballyStoredInitialState &&\r\n          !isDeepEqual(currentGloballyStoredInitialState, initialState)) ||\r\n        !currentGloballyStoredInitialState;\r\n\r\n      if (!initialStateChanged && !hasServerData) {\r\n        return;\r\n      }\r\n\r\n      let localData = null;\r\n      const localkey = isFunction(options?.localStorage?.key)\r\n        ? options?.localStorage?.key(initialState)\r\n        : options?.localStorage?.key;\r\n\r\n      if (localkey && sessionId) {\r\n        localData = loadFromLocalStorage(`${sessionId}-${thisKey}-${localkey}`);\r\n      }\r\n\r\n      let newState = initialState;\r\n      let isFromServer = false;\r\n\r\n      const serverTimestamp = hasServerData ? Date.now() : 0;\r\n      const localTimestamp = localData?.lastUpdated || 0;\r\n      const lastSyncTimestamp = localData?.lastSyncedWithServer || 0;\r\n\r\n      if (hasServerData && serverTimestamp > localTimestamp) {\r\n        newState = options.serverState!.data!;\r\n        isFromServer = true;\r\n      } else if (localData && localTimestamp > lastSyncTimestamp) {\r\n        newState = localData.state;\r\n        if (options?.localStorage?.onChange) {\r\n          options?.localStorage?.onChange(newState);\r\n        }\r\n      }\r\n      getGlobalStore.getState().initializeShadowState(thisKey, initialState);\r\n      // Update the global state\r\n      updateGlobalState(\r\n        thisKey,\r\n        initialState,\r\n        newState,\r\n        effectiveSetState,\r\n        componentIdRef.current,\r\n        sessionId\r\n      );\r\n\r\n      // Save to localStorage if we used server data\r\n      if (isFromServer && localkey && sessionId) {\r\n        saveToLocalStorage(newState, thisKey, options, sessionId, Date.now());\r\n      }\r\n\r\n      // Notify components of the change\r\n      notifyComponents(thisKey);\r\n\r\n      const reactiveTypes = Array.isArray(reactiveType)\r\n        ? reactiveType\r\n        : [reactiveType || \"component\"];\r\n\r\n      if (!reactiveTypes.includes(\"none\")) {\r\n        forceUpdate({});\r\n      }\r\n    }\r\n  }, [\r\n    initialState,\r\n    serverState?.status,\r\n    serverState?.data,\r\n    ...(dependencies || []),\r\n  ]);\r\n  useLayoutEffect(() => {\r\n    if (noStateKey) {\r\n      setAndMergeOptions(thisKey as string, {\r\n        serverSync,\r\n        formElements,\r\n        initialState,\r\n        localStorage,\r\n        middleware: latestInitialOptionsRef.current?.middleware,\r\n      });\r\n    }\r\n\r\n    const componentKey = `${thisKey}////${componentIdRef.current}`;\r\n    const stateEntry = getGlobalStore\r\n      .getState()\r\n      .stateComponents.get(thisKey) || {\r\n      components: new Map(),\r\n    };\r\n\r\n    stateEntry.components.set(componentKey, {\r\n      forceUpdate: () => forceUpdate({}),\r\n      paths: new Set(),\r\n      deps: [],\r\n      depsFunction: reactiveDeps || undefined,\r\n      reactiveType: reactiveType ?? [\"component\", \"deps\"],\r\n    });\r\n\r\n    getGlobalStore.getState().stateComponents.set(thisKey, stateEntry);\r\n    //need to force update to create the stateUpdates references\r\n    forceUpdate({});\r\n    return () => {\r\n      if (stateEntry) {\r\n        stateEntry.components.delete(componentKey);\r\n        if (stateEntry.components.size === 0) {\r\n          getGlobalStore.getState().stateComponents.delete(thisKey);\r\n        }\r\n      }\r\n    };\r\n  }, []);\r\n\r\n  const effectiveSetState = (\r\n    newStateOrFunction: UpdateArg<TStateObject>,\r\n    path: string[],\r\n    updateObj: { updateType: \"insert\" | \"cut\" | \"update\" },\r\n    validationKey?: string\r\n  ) => {\r\n    if (Array.isArray(path)) {\r\n      const pathKey = `${thisKey}-${path.join(\".\")}`;\r\n      componentUpdatesRef.current.add(pathKey);\r\n    }\r\n    const store = getGlobalStore.getState();\r\n\r\n    setState(thisKey, (prevValue: TStateObject) => {\r\n      const payload = isFunction<TStateObject>(newStateOrFunction)\r\n        ? newStateOrFunction(prevValue as TStateObject)\r\n        : newStateOrFunction;\r\n\r\n      const signalId = `${thisKey}-${path.join(\".\")}`;\r\n      if (signalId) {\r\n        let isArrayOperation = false;\r\n        let elements = store.signalDomElements.get(signalId);\r\n\r\n        if (\r\n          (!elements || elements.size === 0) &&\r\n          (updateObj.updateType === \"insert\" || updateObj.updateType === \"cut\")\r\n        ) {\r\n          // Remove last segment (index) from path\r\n          const arrayPath = path.slice(0, -1);\r\n          const arrayValue = getNestedValue(payload, arrayPath);\r\n          // If it's an array, use that path for signal\r\n          if (Array.isArray(arrayValue)) {\r\n            isArrayOperation = true;\r\n            const arraySignalId = `${thisKey}-${arrayPath.join(\".\")}`;\r\n            elements = store.signalDomElements.get(arraySignalId);\r\n          }\r\n        }\r\n\r\n        if (elements) {\r\n          const newValue = isArrayOperation\r\n            ? getNestedValue(payload, path.slice(0, -1))\r\n            : getNestedValue(payload, path);\r\n          elements.forEach(({ parentId, position, effect }) => {\r\n            const parent = document.querySelector(\r\n              `[data-parent-id=\"${parentId}\"]`\r\n            );\r\n            if (parent) {\r\n              const childNodes = Array.from(parent.childNodes);\r\n              if (childNodes[position]) {\r\n                const displayValue = effect\r\n                  ? new Function(\"state\", `return (${effect})(state)`)(newValue)\r\n                  : newValue;\r\n                childNodes[position].textContent = String(displayValue);\r\n              }\r\n            }\r\n          });\r\n        }\r\n      }\r\n\r\n      if (\r\n        updateObj.updateType === \"update\" &&\r\n        (validationKey || latestInitialOptionsRef.current?.validation?.key) &&\r\n        path\r\n      ) {\r\n        removeValidationError(\r\n          (validationKey || latestInitialOptionsRef.current?.validation?.key) +\r\n            \".\" +\r\n            path.join(\".\")\r\n        );\r\n      }\r\n      const arrayWithoutIndex = path.slice(0, path.length - 1);\r\n      if (\r\n        updateObj.updateType === \"cut\" &&\r\n        latestInitialOptionsRef.current?.validation?.key\r\n      ) {\r\n        removeValidationError(\r\n          latestInitialOptionsRef.current?.validation?.key +\r\n            \".\" +\r\n            arrayWithoutIndex.join(\".\")\r\n        );\r\n      }\r\n      if (\r\n        updateObj.updateType === \"insert\" &&\r\n        latestInitialOptionsRef.current?.validation?.key\r\n      ) {\r\n        const getValidation = getValidationErrors(\r\n          latestInitialOptionsRef.current?.validation?.key +\r\n            \".\" +\r\n            arrayWithoutIndex.join(\".\")\r\n        );\r\n\r\n        getValidation.filter((k) => {\r\n          let length = k?.split(\".\").length;\r\n          const v = \"\"; // Placeholder as `v` is not used from getValidationErrors\r\n\r\n          if (\r\n            k == arrayWithoutIndex.join(\".\") &&\r\n            length == arrayWithoutIndex.length - 1\r\n          ) {\r\n            let newKey = k + \".\" + arrayWithoutIndex;\r\n            removeValidationError(k!);\r\n            addValidationError(newKey, v!);\r\n          }\r\n        });\r\n      }\r\n\r\n      const stateEntry = store.stateComponents.get(thisKey);\r\n      if (stateEntry) {\r\n        const changedPaths = getDifferences(prevValue, payload);\r\n        const changedPathsSet = new Set(changedPaths);\r\n        const primaryPathToCheck =\r\n          updateObj.updateType === \"update\"\r\n            ? path.join(\".\")\r\n            : path.slice(0, -1).join(\".\") || \"\";\r\n\r\n        for (const [\r\n          componentKey,\r\n          component,\r\n        ] of stateEntry.components.entries()) {\r\n          let shouldUpdate = false;\r\n          const reactiveTypes = Array.isArray(component.reactiveType)\r\n            ? component.reactiveType\r\n            : [component.reactiveType || \"component\"];\r\n\r\n          if (reactiveTypes.includes(\"none\")) continue;\r\n          if (reactiveTypes.includes(\"all\")) {\r\n            component.forceUpdate();\r\n            continue;\r\n          }\r\n\r\n          if (reactiveTypes.includes(\"component\")) {\r\n            if (\r\n              component.paths.has(primaryPathToCheck) ||\r\n              component.paths.has(\"\")\r\n            ) {\r\n              shouldUpdate = true;\r\n            }\r\n\r\n            if (!shouldUpdate) {\r\n              for (const changedPath of changedPathsSet) {\r\n                let currentPathToCheck = changedPath;\r\n                while (true) {\r\n                  if (component.paths.has(currentPathToCheck)) {\r\n                    shouldUpdate = true;\r\n                    break;\r\n                  }\r\n                  const lastDotIndex = currentPathToCheck.lastIndexOf(\".\");\r\n                  if (lastDotIndex !== -1) {\r\n                    const parentPath = currentPathToCheck.substring(\r\n                      0,\r\n                      lastDotIndex\r\n                    );\r\n                    if (\r\n                      !isNaN(\r\n                        Number(currentPathToCheck.substring(lastDotIndex + 1))\r\n                      )\r\n                    ) {\r\n                      if (component.paths.has(parentPath)) {\r\n                        shouldUpdate = true;\r\n                        break;\r\n                      }\r\n                    }\r\n                    currentPathToCheck = parentPath;\r\n                  } else {\r\n                    currentPathToCheck = \"\";\r\n                  }\r\n                  if (currentPathToCheck === \"\") {\r\n                    break;\r\n                  }\r\n                }\r\n                if (shouldUpdate) break;\r\n              }\r\n            }\r\n          }\r\n\r\n          if (!shouldUpdate && reactiveTypes.includes(\"deps\")) {\r\n            if (component.depsFunction) {\r\n              const depsResult = component.depsFunction(payload);\r\n              let depsChanged = false;\r\n              if (typeof depsResult === \"boolean\") {\r\n                if (depsResult) depsChanged = true;\r\n              } else if (!isDeepEqual(component.deps, depsResult)) {\r\n                component.deps = depsResult;\r\n                depsChanged = true;\r\n              }\r\n              if (depsChanged) {\r\n                shouldUpdate = true;\r\n              }\r\n            }\r\n          }\r\n          if (shouldUpdate) {\r\n            component.forceUpdate();\r\n          }\r\n        }\r\n      }\r\n      const timeStamp = Date.now();\r\n\r\n      let { oldValue, newValue } = getUpdateValues(\r\n        updateObj.updateType,\r\n        prevValue,\r\n        payload,\r\n        path\r\n      );\r\n      const newUpdate = {\r\n        timeStamp,\r\n        stateKey: thisKey,\r\n        path,\r\n        updateType: updateObj.updateType,\r\n        status: \"new\" as const,\r\n        oldValue,\r\n        newValue,\r\n      } satisfies UpdateTypeDetail;\r\n\r\n      switch (updateObj.updateType) {\r\n        case \"insert\": {\r\n          const parentPath = path.slice(0, -1);\r\n          const idSegment = path[path.length - 1]!; // e.g., 'id:xyz'\r\n          const targetId = idSegment.split(\":\")[1];\r\n          const newArray = getNestedValue(payload, parentPath);\r\n\r\n          newValue = newArray.find((item: any) => item.id == targetId);\r\n          oldValue = null;\r\n\r\n          store.insertShadowArrayElement(thisKey, parentPath, newValue);\r\n          break;\r\n        }\r\n\r\n        case \"cut\": {\r\n          oldValue = getNestedValue(prevValue, path);\r\n          newValue = null;\r\n\r\n          store.removeShadowArrayElement(thisKey, path);\r\n          break;\r\n        }\r\n\r\n        case \"update\": {\r\n          oldValue = getNestedValue(prevValue, path);\r\n          newValue = getNestedValue(payload, path);\r\n\r\n          const shadowPath = path.map((p, i) => {\r\n            const currentSubPath = path.slice(0, i + 1);\r\n            const subValue = getNestedValue(payload, currentSubPath);\r\n            return subValue?.id ? `id:${subValue.id}` : p;\r\n          });\r\n          store.updateShadowAtPath(thisKey, shadowPath, newValue);\r\n          break;\r\n        }\r\n      }\r\n\r\n      setStateLog(thisKey, (prevLogs) => {\r\n        const logs = [...(prevLogs ?? []), newUpdate];\r\n        const aggregatedLogs = new Map<string, typeof newUpdate>();\r\n\r\n        logs.forEach((log) => {\r\n          const uniqueKey = `${log.stateKey}:${JSON.stringify(log.path)}`;\r\n          const existing = aggregatedLogs.get(uniqueKey);\r\n\r\n          if (existing) {\r\n            existing.timeStamp = Math.max(existing.timeStamp, log.timeStamp);\r\n            existing.newValue = log.newValue;\r\n            existing.oldValue = existing.oldValue ?? log.oldValue;\r\n            existing.updateType = log.updateType;\r\n          } else {\r\n            aggregatedLogs.set(uniqueKey, { ...(log as any) });\r\n          }\r\n        });\r\n\r\n        return Array.from(aggregatedLogs.values());\r\n      });\r\n\r\n      saveToLocalStorage(\r\n        payload,\r\n        thisKey,\r\n        latestInitialOptionsRef.current,\r\n        sessionId\r\n      );\r\n\r\n      if (latestInitialOptionsRef.current?.middleware) {\r\n        latestInitialOptionsRef.current!.middleware({\r\n          updateLog: stateLog,\r\n          update: newUpdate,\r\n        });\r\n      }\r\n      if (latestInitialOptionsRef.current?.serverSync) {\r\n        const serverStateStore = store.serverState[thisKey];\r\n        const serverSync = latestInitialOptionsRef.current?.serverSync;\r\n        setServerSyncActions(thisKey, {\r\n          syncKey:\r\n            typeof serverSync.syncKey == \"string\"\r\n              ? serverSync.syncKey\r\n              : serverSync.syncKey({ state: payload }),\r\n          rollBackState: serverStateStore,\r\n          actionTimeStamp: Date.now() + (serverSync.debounce ?? 3000),\r\n          status: \"waiting\",\r\n        });\r\n      }\r\n\r\n      return payload;\r\n    });\r\n  };\r\n  if (!getGlobalStore.getState().updaterState[thisKey]) {\r\n    setUpdaterState(\r\n      thisKey,\r\n      createProxyHandler(\r\n        thisKey,\r\n        effectiveSetState,\r\n        componentIdRef.current,\r\n        sessionId\r\n      )\r\n    );\r\n    if (!getGlobalStore.getState().cogsStateStore[thisKey]) {\r\n      setState(thisKey, stateObject);\r\n    }\r\n    if (!getGlobalStore.getState().initialStateGlobal[thisKey]) {\r\n      updateInitialStateGlobal(thisKey, stateObject);\r\n    }\r\n  }\r\n\r\n  const updaterFinal = useMemo(() => {\r\n    return createProxyHandler<TStateObject>(\r\n      thisKey,\r\n      effectiveSetState,\r\n      componentIdRef.current,\r\n      sessionId\r\n    );\r\n  }, [thisKey, sessionId]);\r\n\r\n  return [getKeyState(thisKey), updaterFinal] as [\r\n    TStateObject,\r\n    StateObject<TStateObject>,\r\n  ];\r\n}\r\n\r\nfunction createProxyHandler<T>(\r\n  stateKey: string,\r\n  effectiveSetState: EffectiveSetState<T>,\r\n  componentId: string,\r\n  sessionId?: string\r\n): StateObject<T> {\r\n  type CacheEntry = {\r\n    proxy: any;\r\n    stateVersion: number;\r\n  };\r\n  const shapeCache = new Map<string, CacheEntry>();\r\n  let stateVersion = 0;\r\n\r\n  const invalidateCachePath = (path: string[]) => {\r\n    const pathKey = path.join(\".\");\r\n    for (const [key] of shapeCache) {\r\n      if (key === pathKey || key.startsWith(pathKey + \".\")) {\r\n        shapeCache.delete(key);\r\n      }\r\n    }\r\n    stateVersion++;\r\n  };\r\n\r\n  const baseObj = {\r\n    removeValidation: (obj?: { validationKey?: string }) => {\r\n      if (obj?.validationKey) {\r\n        removeValidationError(obj.validationKey);\r\n      }\r\n    },\r\n\r\n    revertToInitialState: (obj?: { validationKey?: string }) => {\r\n      const init = getGlobalStore\r\n        .getState()\r\n        .getInitialOptions(stateKey)?.validation;\r\n      if (init?.key) {\r\n        removeValidationError(init?.key);\r\n      }\r\n\r\n      if (obj?.validationKey) {\r\n        removeValidationError(obj.validationKey);\r\n      }\r\n\r\n      const initialState =\r\n        getGlobalStore.getState().initialStateGlobal[stateKey];\r\n      getGlobalStore.getState().initializeShadowState(stateKey, initialState);\r\n      getGlobalStore.getState().clearSelectedIndexesForState(stateKey);\r\n      shapeCache.clear();\r\n      stateVersion++;\r\n\r\n      const newProxy = rebuildStateShape(initialState, []);\r\n      const initalOptionsGet = getInitialOptions(stateKey as string);\r\n      const localKey = isFunction(initalOptionsGet?.localStorage?.key)\r\n        ? initalOptionsGet?.localStorage?.key(initialState)\r\n        : initalOptionsGet?.localStorage?.key;\r\n\r\n      const storageKey = `${sessionId}-${stateKey}-${localKey}`;\r\n\r\n      if (storageKey) {\r\n        localStorage.removeItem(storageKey);\r\n      }\r\n\r\n      setUpdaterState(stateKey, newProxy);\r\n      setState(stateKey, initialState);\r\n      const stateEntry = getGlobalStore\r\n        .getState()\r\n        .stateComponents.get(stateKey);\r\n      if (stateEntry) {\r\n        stateEntry.components.forEach((component) => {\r\n          component.forceUpdate();\r\n        });\r\n      }\r\n\r\n      return initialState;\r\n    },\r\n    updateInitialState: (newState: T) => {\r\n      shapeCache.clear();\r\n      stateVersion++;\r\n\r\n      const newUpdaterState = createProxyHandler(\r\n        stateKey,\r\n        effectiveSetState,\r\n        componentId,\r\n        sessionId\r\n      );\r\n      const initialState =\r\n        getGlobalStore.getState().initialStateGlobal[stateKey];\r\n      const initalOptionsGet = getInitialOptions(stateKey as string);\r\n      const localKey = isFunction(initalOptionsGet?.localStorage?.key)\r\n        ? initalOptionsGet?.localStorage?.key(initialState)\r\n        : initalOptionsGet?.localStorage?.key;\r\n\r\n      const storageKey = `${sessionId}-${stateKey}-${localKey}`;\r\n\r\n      if (localStorage.getItem(storageKey)) {\r\n        localStorage.removeItem(storageKey);\r\n      }\r\n      startTransition(() => {\r\n        updateInitialStateGlobal(stateKey, newState);\r\n        getGlobalStore.getState().initializeShadowState(stateKey, newState);\r\n        setUpdaterState(stateKey, newUpdaterState);\r\n        setState(stateKey, newState);\r\n        const stateEntry = getGlobalStore\r\n          .getState()\r\n          .stateComponents.get(stateKey);\r\n\r\n        if (stateEntry) {\r\n          stateEntry.components.forEach((component) => {\r\n            component.forceUpdate();\r\n          });\r\n        }\r\n      });\r\n\r\n      return {\r\n        fetchId: (field: keyof T) => newUpdaterState.get()[field],\r\n      };\r\n    },\r\n    _initialState: getGlobalStore.getState().initialStateGlobal[stateKey],\r\n    _serverState: getGlobalStore.getState().serverState[stateKey],\r\n    _isLoading: getGlobalStore.getState().isLoadingGlobal[stateKey],\r\n    _isServerSynced: () => {\r\n      const serverState = getGlobalStore.getState().serverState[stateKey];\r\n      return Boolean(\r\n        serverState && isDeepEqual(serverState, getKeyState(stateKey))\r\n      );\r\n    },\r\n  };\r\n\r\n  function getOrderedIds(arrayPath: string[]): string[] | null {\r\n    const arrayKey = [stateKey, ...arrayPath].join(\".\");\r\n    const arrayMeta = getGlobalStore.getState().shadowStateStore.get(arrayKey);\r\n    return arrayMeta?.arrayKeys || null;\r\n  }\r\n\r\n  function rebuildStateShape(\r\n    currentState: T,\r\n    path: string[] = [],\r\n    meta?: {\r\n      validIds?: string[];\r\n    }\r\n  ): any {\r\n    const cacheKey = path.map(String).join(\".\");\r\n    const cachedEntry = shapeCache.get(cacheKey);\r\n\r\n    type CallableStateObject<T> = {\r\n      (): T;\r\n    } & {\r\n      [key: string]: any;\r\n    };\r\n\r\n    const baseFunction = function () {\r\n      return getGlobalStore().getNestedState(stateKey, path);\r\n    } as unknown as CallableStateObject<T>;\r\n\r\n    Object.keys(baseObj).forEach((key) => {\r\n      (baseFunction as any)[key] = (baseObj as any)[key];\r\n    });\r\n\r\n    const handler = {\r\n      apply(target: any, thisArg: any, args: any[]) {\r\n        return getGlobalStore().getNestedState(stateKey, path);\r\n      },\r\n\r\n      get(target: any, prop: string) {\r\n        const mutationMethods = new Set([\r\n          \"insert\",\r\n          \"cut\",\r\n          \"cutByValue\",\r\n          \"toggleByValue\",\r\n          \"uniqueInsert\",\r\n          \"update\",\r\n          \"applyJsonPatch\",\r\n          \"setSelected\",\r\n          \"toggleSelected\",\r\n          \"clearSelected\",\r\n          \"sync\",\r\n          \"validateZodSchema\",\r\n          \"revertToInitialState\",\r\n          \"updateInitialState\",\r\n          \"removeValidation\",\r\n          \"setValidation\",\r\n          \"removeStorage\",\r\n          \"middleware\",\r\n          \"_componentId\",\r\n          \"_stateKey\",\r\n          \"getComponents\",\r\n        ]);\r\n\r\n        if (\r\n          prop !== \"then\" &&\r\n          !prop.startsWith(\"$\") &&\r\n          prop !== \"stateMapNoRender\" &&\r\n          !mutationMethods.has(prop)\r\n        ) {\r\n          const fullComponentId = `${stateKey}////${componentId}`;\r\n          const stateEntry = getGlobalStore\r\n            .getState()\r\n            .stateComponents.get(stateKey);\r\n\r\n          if (stateEntry) {\r\n            const component = stateEntry.components.get(fullComponentId);\r\n            if (component && !component.paths.has(\"\")) {\r\n              const currentPath = path.join(\".\");\r\n              let needsAdd = true;\r\n              for (const existingPath of component.paths) {\r\n                if (\r\n                  currentPath.startsWith(existingPath) &&\r\n                  (currentPath === existingPath ||\r\n                    currentPath[existingPath.length] === \".\")\r\n                ) {\r\n                  needsAdd = false;\r\n                  break;\r\n                }\r\n              }\r\n              if (needsAdd) {\r\n                component.paths.add(currentPath);\r\n              }\r\n            }\r\n          }\r\n        }\r\n        if (prop === \"getDifferences\") {\r\n          return () =>\r\n            getDifferences(\r\n              getGlobalStore.getState().cogsStateStore[stateKey],\r\n              getGlobalStore.getState().initialStateGlobal[stateKey]\r\n            );\r\n        }\r\n        if (prop === \"sync\" && path.length === 0) {\r\n          return async function () {\r\n            const options = getGlobalStore\r\n              .getState()\r\n              .getInitialOptions(stateKey);\r\n            const sync = options?.sync;\r\n\r\n            if (!sync) {\r\n              console.error(`No mutation defined for state key \"${stateKey}\"`);\r\n              return { success: false, error: `No mutation defined` };\r\n            }\r\n\r\n            const state = getGlobalStore\r\n              .getState()\r\n              .getNestedState(stateKey, []);\r\n            const validationKey = options?.validation?.key;\r\n\r\n            try {\r\n              const response = await sync.action(state);\r\n              if (\r\n                response &&\r\n                !response.success &&\r\n                response.errors &&\r\n                validationKey\r\n              ) {\r\n                getGlobalStore.getState().removeValidationError(validationKey);\r\n                response.errors.forEach((error) => {\r\n                  const errorPath = [validationKey, ...error.path].join(\".\");\r\n                  getGlobalStore\r\n                    .getState()\r\n                    .addValidationError(errorPath, error.message);\r\n                });\r\n                notifyComponents(stateKey);\r\n              }\r\n\r\n              if (response?.success && sync.onSuccess)\r\n                sync.onSuccess(response.data);\r\n              else if (!response?.success && sync.onError)\r\n                sync.onError(response.error);\r\n\r\n              return response;\r\n            } catch (error) {\r\n              if (sync.onError) sync.onError(error);\r\n              return { success: false, error };\r\n            }\r\n          };\r\n        }\r\n        if (prop === \"_status\") {\r\n          const thisReactiveState = getGlobalStore\r\n            .getState()\r\n            .getNestedState(stateKey, path);\r\n          const initialState =\r\n            getGlobalStore.getState().initialStateGlobal[stateKey];\r\n          const initialStateAtPath = getNestedValue(initialState, path);\r\n          return isDeepEqual(thisReactiveState, initialStateAtPath)\r\n            ? \"fresh\"\r\n            : \"stale\";\r\n        }\r\n        if (prop === \"getStatus\") {\r\n          return function () {\r\n            const thisReactiveState = getGlobalStore().getNestedState(\r\n              stateKey,\r\n              path\r\n            );\r\n            const initialState =\r\n              getGlobalStore.getState().initialStateGlobal[stateKey];\r\n            const initialStateAtPath = getNestedValue(initialState, path);\r\n            return isDeepEqual(thisReactiveState, initialStateAtPath)\r\n              ? \"fresh\"\r\n              : \"stale\";\r\n          };\r\n        }\r\n        if (prop === \"removeStorage\") {\r\n          return () => {\r\n            const initialState =\r\n              getGlobalStore.getState().initialStateGlobal[stateKey];\r\n            const initalOptionsGet = getInitialOptions(stateKey as string);\r\n            const localKey = isFunction(initalOptionsGet?.localStorage?.key)\r\n              ? initalOptionsGet.localStorage.key(initialState)\r\n              : initalOptionsGet?.localStorage?.key;\r\n            const storageKey = `${sessionId}-${stateKey}-${localKey}`;\r\n            if (storageKey) localStorage.removeItem(storageKey);\r\n          };\r\n        }\r\n        if (prop === \"showValidationErrors\") {\r\n          return () => {\r\n            const init = getGlobalStore\r\n              .getState()\r\n              .getInitialOptions(stateKey)?.validation;\r\n            if (!init?.key) throw new Error(\"Validation key not found\");\r\n            return getGlobalStore\r\n              .getState()\r\n              .getValidationErrors(init.key + \".\" + path.join(\".\"));\r\n          };\r\n        }\r\n        if (Array.isArray(currentState)) {\r\n          if (prop === \"getSelected\") {\r\n            return () => {\r\n              const selectedIndex = getGlobalStore\r\n                .getState()\r\n                .getSelectedIndex(stateKey, path.join(\".\"));\r\n              if (selectedIndex === undefined) return undefined;\r\n\r\n              const sourceArray = getGlobalStore\r\n                .getState()\r\n                .getNestedState(stateKey, path) as any[];\r\n              if (!sourceArray || selectedIndex >= sourceArray.length)\r\n                return undefined;\r\n\r\n              const selectedItem = sourceArray[selectedIndex];\r\n              const itemId = `id:${selectedItem.id}`;\r\n\r\n              return rebuildStateShape(selectedItem, [...path, itemId], meta);\r\n            };\r\n          }\r\n          if (prop === \"clearSelected\") {\r\n            return () => {\r\n              getGlobalStore.getState().clearSelectedIndex({ stateKey, path });\r\n            };\r\n          }\r\n          if (prop === \"getSelectedIndex\") {\r\n            return () => {\r\n              const globallySelectedIndex = getGlobalStore\r\n                .getState()\r\n                .getSelectedIndex(stateKey, path.join(\".\"));\r\n              if (globallySelectedIndex === undefined) return -1;\r\n\r\n              if (meta?.validIds) {\r\n                const sourceIds = getOrderedIds(path) || [];\r\n                const selectedItemId = sourceIds[globallySelectedIndex];\r\n                if (!selectedItemId) return -1;\r\n                const localIndex = meta.validIds.indexOf(selectedItemId);\r\n                return localIndex;\r\n              }\r\n\r\n              return globallySelectedIndex;\r\n            };\r\n          }\r\n          // Replace the entire 'if (prop === \"useVirtualView\")' block with this\r\n          if (prop === \"useVirtualView\") {\r\n            return (\r\n              options: VirtualViewOptions\r\n            ): VirtualStateObjectResult<any[]> => {\r\n              const {\r\n                itemHeight = 50,\r\n                overscan = 6,\r\n                stickToBottom = false,\r\n                dependencies = [],\r\n              } = options;\r\n\r\n              const containerRef = useRef<HTMLDivElement | null>(null);\r\n              const [range, setRange] = useState({\r\n                startIndex: 0,\r\n                endIndex: 10,\r\n              });\r\n              const [shadowUpdateTrigger, setShadowUpdateTrigger] = useState(0);\r\n              const wasAtBottomRef = useRef(true);\r\n              const userHasScrolledAwayRef = useRef(false);\r\n              const previousCountRef = useRef(0);\r\n              const lastRangeRef = useRef(range);\r\n              const orderedIds = getOrderedIds(path);\r\n\r\n              // Subscribe to shadow state updates for dynamic height changes\r\n              useEffect(() => {\r\n                const unsubscribe = getGlobalStore\r\n                  .getState()\r\n                  .subscribeToShadowState(stateKey, () => {\r\n                    setShadowUpdateTrigger((prev) => prev + 1);\r\n                  });\r\n                return unsubscribe;\r\n              }, [stateKey]);\r\n\r\n              const sourceArray = getGlobalStore().getNestedState(\r\n                stateKey,\r\n                path\r\n              ) as any[];\r\n              const totalCount = sourceArray.length;\r\n\r\n              // Calculate total height and individual item positions\r\n              const { totalHeight, positions } = useMemo(() => {\r\n                let height = 0;\r\n                const pos: number[] = [];\r\n                for (let i = 0; i < totalCount; i++) {\r\n                  pos[i] = height;\r\n                  const itemId = orderedIds?.[i];\r\n                  if (itemId) {\r\n                    const itemPath = [...path, itemId];\r\n                    const itemMeta = getGlobalStore\r\n                      .getState()\r\n                      .getShadowMetadata(stateKey, itemPath);\r\n                    const measuredHeight = itemMeta?.virtualizer?.itemHeight;\r\n                    height += measuredHeight || itemHeight;\r\n                  } else {\r\n                    height += itemHeight;\r\n                  }\r\n                }\r\n                return { totalHeight: height, positions: pos };\r\n              }, [\r\n                totalCount,\r\n                stateKey,\r\n                path.join(\".\"),\r\n                itemHeight,\r\n                shadowUpdateTrigger,\r\n                orderedIds,\r\n              ]);\r\n\r\n              // Create the virtual state object\r\n              const virtualState = useMemo(() => {\r\n                const start = Math.max(0, range.startIndex);\r\n                const end = Math.min(totalCount, range.endIndex);\r\n                // The sliced array is the `currentState` for the new proxy\r\n                const slicedArray = sourceArray.slice(start, end);\r\n                // The `validIds` for the new proxy are the sliced IDs\r\n                const slicedIds = orderedIds?.slice(start, end);\r\n\r\n                return rebuildStateShape(slicedArray as any, path, {\r\n                  ...meta,\r\n                  validIds: slicedIds,\r\n                });\r\n              }, [\r\n                range.startIndex,\r\n                range.endIndex,\r\n                sourceArray,\r\n                totalCount,\r\n                orderedIds,\r\n              ]);\r\n\r\n              const scrollToLastItem = useCallback(() => {\r\n                const lastIndex = totalCount - 1;\r\n                if (lastIndex >= 0 && orderedIds?.[lastIndex]) {\r\n                  const lastItemId = orderedIds[lastIndex];\r\n                  const lastItemPath = [...path, lastItemId];\r\n                  const lastItemMeta = getGlobalStore\r\n                    .getState()\r\n                    .getShadowMetadata(stateKey, lastItemPath);\r\n                  if (lastItemMeta?.virtualizer?.domRef) {\r\n                    const element = lastItemMeta.virtualizer.domRef;\r\n                    if (element?.scrollIntoView) {\r\n                      element.scrollIntoView({\r\n                        behavior: \"auto\",\r\n                        block: \"end\",\r\n                      });\r\n                      return true;\r\n                    }\r\n                  }\r\n                }\r\n                return false;\r\n              }, [stateKey, path, totalCount, orderedIds]);\r\n\r\n              useEffect(() => {\r\n                if (!stickToBottom || totalCount === 0) return;\r\n                const hasNewItems = totalCount > previousCountRef.current;\r\n                if (\r\n                  hasNewItems &&\r\n                  wasAtBottomRef.current &&\r\n                  !userHasScrolledAwayRef.current\r\n                ) {\r\n                  setTimeout(() => scrollToIndex(totalCount - 1, \"smooth\"), 50);\r\n                }\r\n                previousCountRef.current = totalCount;\r\n              }, [totalCount, stickToBottom]);\r\n\r\n              useEffect(() => {\r\n                const container = containerRef.current;\r\n                if (!container) return;\r\n\r\n                const handleScroll = () => {\r\n                  const { scrollTop, scrollHeight, clientHeight } = container;\r\n                  const distanceFromBottom =\r\n                    scrollHeight - scrollTop - clientHeight;\r\n                  wasAtBottomRef.current = distanceFromBottom < 5;\r\n                  if (distanceFromBottom > 100)\r\n                    userHasScrolledAwayRef.current = true;\r\n                  if (distanceFromBottom < 5)\r\n                    userHasScrolledAwayRef.current = false;\r\n\r\n                  let startIndex = 0;\r\n                  for (let i = 0; i < positions.length; i++) {\r\n                    if (positions[i]! > scrollTop - itemHeight * overscan) {\r\n                      startIndex = Math.max(0, i - 1);\r\n                      break;\r\n                    }\r\n                  }\r\n                  let endIndex = startIndex;\r\n                  const viewportEnd = scrollTop + clientHeight;\r\n                  for (let i = startIndex; i < positions.length; i++) {\r\n                    if (positions[i]! > viewportEnd + itemHeight * overscan) {\r\n                      break;\r\n                    }\r\n                    endIndex = i;\r\n                  }\r\n                  const newStartIndex = Math.max(0, startIndex);\r\n                  const newEndIndex = Math.min(\r\n                    totalCount,\r\n                    endIndex + 1 + overscan\r\n                  );\r\n\r\n                  if (\r\n                    newStartIndex !== lastRangeRef.current.startIndex ||\r\n                    newEndIndex !== lastRangeRef.current.endIndex\r\n                  ) {\r\n                    lastRangeRef.current = {\r\n                      startIndex: newStartIndex,\r\n                      endIndex: newEndIndex,\r\n                    };\r\n                    setRange({\r\n                      startIndex: newStartIndex,\r\n                      endIndex: newEndIndex,\r\n                    });\r\n                  }\r\n                };\r\n\r\n                container.addEventListener(\"scroll\", handleScroll, {\r\n                  passive: true,\r\n                });\r\n                handleScroll(); // Initial check\r\n                return () =>\r\n                  container.removeEventListener(\"scroll\", handleScroll);\r\n              }, [positions, totalCount, itemHeight, overscan, stickToBottom]);\r\n\r\n              const scrollToBottom = useCallback(() => {\r\n                wasAtBottomRef.current = true;\r\n                userHasScrolledAwayRef.current = false;\r\n                if (!scrollToLastItem() && containerRef.current) {\r\n                  containerRef.current.scrollTop =\r\n                    containerRef.current.scrollHeight;\r\n                }\r\n              }, [scrollToLastItem]);\r\n\r\n              const scrollToIndex = useCallback(\r\n                (index: number, behavior: ScrollBehavior = \"smooth\") => {\r\n                  const container = containerRef.current;\r\n                  if (!container) return;\r\n                  const top = positions[index];\r\n                  if (top !== undefined) {\r\n                    container.scrollTo({ top, behavior });\r\n                  }\r\n                },\r\n                [positions]\r\n              );\r\n\r\n              const virtualizerProps = {\r\n                outer: {\r\n                  ref: containerRef,\r\n                  style: { overflowY: \"auto\" as const, height: \"100%\" },\r\n                },\r\n                inner: {\r\n                  style: {\r\n                    height: `${totalHeight}px`,\r\n                    position: \"relative\" as const,\r\n                  },\r\n                },\r\n                list: {\r\n                  style: {\r\n                    transform: `translateY(${positions[range.startIndex] || 0}px)`,\r\n                  },\r\n                },\r\n              };\r\n\r\n              return {\r\n                virtualState,\r\n                virtualizerProps,\r\n                scrollToBottom,\r\n                scrollToIndex,\r\n              };\r\n            };\r\n          }\r\n          if (prop === \"stateMap\") {\r\n            return (\r\n              callbackfn: (\r\n                value: any,\r\n                setter: any,\r\n                index: number,\r\n                array: any,\r\n                arraySetter: any\r\n              ) => void\r\n            ) => {\r\n              const arrayToMap = currentState as any[];\r\n              const itemIdsForCurrentArray =\r\n                meta?.validIds || getOrderedIds(path) || [];\r\n              const arraySetter = rebuildStateShape(currentState, path, meta);\r\n\r\n              return arrayToMap.map((item, index) => {\r\n                const itemId = itemIdsForCurrentArray[index] || `id:${item.id}`;\r\n                const itemPath = [...path, itemId];\r\n                const itemSetter = rebuildStateShape(item, itemPath, meta);\r\n                return callbackfn(\r\n                  item,\r\n                  itemSetter,\r\n                  index,\r\n                  currentState,\r\n                  arraySetter\r\n                );\r\n              });\r\n            };\r\n          }\r\n          if (prop === \"stateMapNoRender\") {\r\n            return (\r\n              callbackfn: (\r\n                value: any,\r\n                setter: any,\r\n                index: number,\r\n                array: any,\r\n                arraySetter: any\r\n              ) => void\r\n            ) => {\r\n              const arrayToMap = currentState as any[];\r\n              const itemIdsForCurrentArray =\r\n                meta?.validIds || getOrderedIds(path) || [];\r\n              const arraySetter = rebuildStateShape(currentState, path, meta);\r\n\r\n              return arrayToMap.map((item, index) => {\r\n                const itemId = itemIdsForCurrentArray[index] || `id:${item.id}`;\r\n                const finalPath = [...path, itemId];\r\n                const setter = rebuildStateShape(item, finalPath, meta);\r\n                return callbackfn(\r\n                  item,\r\n                  setter,\r\n                  index,\r\n                  currentState,\r\n                  arraySetter\r\n                );\r\n              });\r\n            };\r\n          }\r\n          if (prop === \"$stateMap\") {\r\n            return (callbackfn: any) =>\r\n              createElement(SignalMapRenderer, {\r\n                proxy: { _stateKey: stateKey, _path: path, _mapFn: callbackfn },\r\n                rebuildStateShape,\r\n              });\r\n          }\r\n          if (prop === \"stateList\") {\r\n            return (\r\n              callbackfn: (\r\n                value: any,\r\n                setter: any,\r\n                index: { localIndex: number; originalIndex: number },\r\n                array: any,\r\n                arraySetter: any\r\n              ) => ReactNode\r\n            ) => {\r\n              const arrayToMap = currentState as any[];\r\n              if (!Array.isArray(arrayToMap)) return null;\r\n\r\n              const itemIdsForCurrentArray =\r\n                meta?.validIds || getOrderedIds(path) || [];\r\n              const sourceIds = getOrderedIds(path) || [];\r\n              const arraySetter = rebuildStateShape(\r\n                arrayToMap as any,\r\n                path,\r\n                meta\r\n              );\r\n\r\n              return arrayToMap.map((item, localIndex) => {\r\n                const itemId =\r\n                  itemIdsForCurrentArray[localIndex] || `id:${item.id}`;\r\n                const originalIndex = sourceIds.indexOf(itemId);\r\n                const finalPath = [...path, itemId];\r\n                const setter = rebuildStateShape(item, finalPath, meta);\r\n                const itemComponentId = `${componentId}-${path.join(\".\")}-${itemId}`;\r\n\r\n                return createElement(CogsItemWrapper, {\r\n                  key: itemId,\r\n                  stateKey,\r\n                  itemComponentId,\r\n                  itemPath: finalPath,\r\n                  children: callbackfn(\r\n                    item,\r\n                    setter,\r\n                    { localIndex, originalIndex },\r\n                    arrayToMap as any,\r\n                    arraySetter\r\n                  ),\r\n                });\r\n              });\r\n            };\r\n          }\r\n          if (prop === \"stateFlattenOn\") {\r\n            return (fieldName: string) => {\r\n              const arrayToMap = currentState as any[];\r\n              shapeCache.clear();\r\n              stateVersion++;\r\n              const flattenedResults = arrayToMap.flatMap(\r\n                (val: any) => val[fieldName] ?? []\r\n              );\r\n              return rebuildStateShape(\r\n                flattenedResults as any,\r\n                [...path, \"[*]\", fieldName],\r\n                meta\r\n              );\r\n            };\r\n          }\r\n          if (prop === \"index\") {\r\n            return (index: number) => {\r\n              const idList = meta?.validIds || getOrderedIds(path);\r\n              const itemId = idList?.[index];\r\n\r\n              if (!itemId) {\r\n                return rebuildStateShape(undefined as T, [\r\n                  ...path,\r\n                  index.toString(),\r\n                ]);\r\n              }\r\n\r\n              const sourceArray = getGlobalStore\r\n                .getState()\r\n                .getNestedState(stateKey, path) as any[];\r\n              const itemData = sourceArray.find(\r\n                (item) => `id:${item.id}` === itemId\r\n              );\r\n\r\n              const itemPath = [...path, itemId];\r\n              return rebuildStateShape(itemData, itemPath, meta);\r\n            };\r\n          }\r\n          if (prop === \"last\") {\r\n            return () => {\r\n              const currentArray = getGlobalStore\r\n                .getState()\r\n                .getNestedState(stateKey, path) as any[];\r\n              if (currentArray.length === 0) return undefined;\r\n              const lastIndex = currentArray.length - 1;\r\n              const lastValue = currentArray[lastIndex];\r\n              const newPath = [...path, lastIndex.toString()];\r\n              return rebuildStateShape(lastValue, newPath);\r\n            };\r\n          }\r\n          if (prop === \"insert\") {\r\n            return (payload: UpdateArg<T>) => {\r\n              invalidateCachePath(path);\r\n              pushFunc(effectiveSetState, payload, path, stateKey);\r\n              return rebuildStateShape(\r\n                getGlobalStore.getState().getNestedState(stateKey, path),\r\n                path\r\n              );\r\n            };\r\n          }\r\n          if (prop === \"uniqueInsert\") {\r\n            return (\r\n              payload: UpdateArg<T>,\r\n              fields?: (keyof InferArrayElement<T>)[],\r\n              onMatch?: (existingItem: any) => any\r\n            ) => {\r\n              const currentArray = getGlobalStore\r\n                .getState()\r\n                .getNestedState(stateKey, path) as any[];\r\n              const newValue = isFunction<T>(payload)\r\n                ? payload(currentArray as any)\r\n                : (payload as any);\r\n\r\n              let matchedItem: any = null;\r\n              const isUnique = !currentArray.some((item) => {\r\n                const isMatch = fields\r\n                  ? fields.every((field) =>\r\n                      isDeepEqual(item[field], newValue[field])\r\n                    )\r\n                  : isDeepEqual(item, newValue);\r\n                if (isMatch) matchedItem = item;\r\n                return isMatch;\r\n              });\r\n\r\n              if (isUnique) {\r\n                invalidateCachePath(path);\r\n                pushFunc(effectiveSetState, newValue, path, stateKey);\r\n              } else if (onMatch && matchedItem) {\r\n                const updatedItem = onMatch(matchedItem);\r\n                const updatedArray = currentArray.map((item) =>\r\n                  isDeepEqual(item, matchedItem) ? updatedItem : item\r\n                );\r\n                invalidateCachePath(path);\r\n                updateFn(effectiveSetState, updatedArray as any, path);\r\n              }\r\n            };\r\n          }\r\n          if (prop === \"cut\") {\r\n            return (index: number, options?: { waitForSync?: boolean }) => {\r\n              if (options?.waitForSync) return;\r\n              invalidateCachePath(path);\r\n              cutFunc(effectiveSetState, path, stateKey, index);\r\n              return rebuildStateShape(\r\n                getGlobalStore.getState().getNestedState(stateKey, path),\r\n                path\r\n              );\r\n            };\r\n          }\r\n          if (prop === \"cutByValue\") {\r\n            return (value: string | number | boolean) => {\r\n              const index = currentState.findIndex((item) => item === value);\r\n              if (index > -1) cutFunc(effectiveSetState, path, stateKey, index);\r\n            };\r\n          }\r\n          if (prop === \"toggleByValue\") {\r\n            return (value: string | number | boolean) => {\r\n              const index = currentState.findIndex((item) => item === value);\r\n              if (index > -1) {\r\n                cutFunc(effectiveSetState, path, stateKey, index);\r\n              } else {\r\n                pushFunc(effectiveSetState, value as any, path, stateKey);\r\n              }\r\n            };\r\n          }\r\n          if (prop === \"stateFilter\") {\r\n            return (callbackfn: (value: any, index: number) => boolean) => {\r\n              const sourceIds = meta?.validIds || getOrderedIds(path) || [];\r\n              const sourceArray = getGlobalStore\r\n                .getState()\r\n                .getNestedState(stateKey, path) as any[];\r\n              const sourceMap = new Map(\r\n                sourceArray.map((item) => [`id:${item.id}`, item])\r\n              );\r\n\r\n              const newValidIds: string[] = [];\r\n              const newFilteredArray: any[] = [];\r\n\r\n              sourceIds.forEach((id, index) => {\r\n                const item = sourceMap.get(id);\r\n                if (item && callbackfn(item, index)) {\r\n                  newValidIds.push(id);\r\n                  newFilteredArray.push(item);\r\n                }\r\n              });\r\n\r\n              return rebuildStateShape(newFilteredArray as any, path, {\r\n                validIds: newValidIds,\r\n              });\r\n            };\r\n          }\r\n          if (prop === \"stateSort\") {\r\n            return (compareFn: (a: any, b: any) => number) => {\r\n              const sourceArray = currentState as any[];\r\n              const itemsWithIds = sourceArray.map((item) => ({\r\n                item,\r\n                id: `id:${item.id}`,\r\n              }));\r\n              itemsWithIds.sort((a, b) => compareFn(a.item, b.item));\r\n              const sortedArray = itemsWithIds.map((d) => d.item);\r\n              const newValidIds = itemsWithIds.map((d) => d.id);\r\n              return rebuildStateShape(sortedArray as any, path, {\r\n                validIds: newValidIds,\r\n              });\r\n            };\r\n          }\r\n          if (prop === \"findWith\") {\r\n            return (thisKey: keyof InferArrayElement<T>, thisValue: any) => {\r\n              const foundItem = (currentState as any[]).find(\r\n                (item) => item[thisKey] === thisValue\r\n              );\r\n              if (!foundItem) return undefined;\r\n              const itemId = `id:${foundItem.id}`;\r\n              const finalPath = [...path, itemId];\r\n              return rebuildStateShape(foundItem, finalPath, meta);\r\n            };\r\n          }\r\n        }\r\n        const lastPathElement = path[path.length - 1];\r\n        if (!isNaN(Number(lastPathElement))) {\r\n          const parentPath = path.slice(0, -1);\r\n          const parentValue = getGlobalStore\r\n            .getState()\r\n            .getNestedState(stateKey, parentPath);\r\n          if (Array.isArray(parentValue) && prop === \"cut\") {\r\n            return () =>\r\n              cutFunc(\r\n                effectiveSetState,\r\n                parentPath,\r\n                stateKey,\r\n                Number(lastPathElement)\r\n              );\r\n          }\r\n        }\r\n        if (prop === \"get\") {\r\n          return () => {\r\n            // Check if this proxy represents a derived array.\r\n            // A derived array proxy has `meta.validIds` AND its `currentState` is an array.\r\n            if (meta?.validIds && Array.isArray(currentState)) {\r\n              // It IS a derived array proxy. Reconstruct it to ensure freshness.\r\n              const sourceArray = getGlobalStore\r\n                .getState()\r\n                .getNestedState(stateKey, path) as any[];\r\n              if (!Array.isArray(sourceArray)) return [];\r\n\r\n              const sourceMap = new Map(\r\n                sourceArray.map((item: any) => [`id:${item.id}`, item])\r\n              );\r\n\r\n              return meta.validIds\r\n                .map((id) => sourceMap.get(id))\r\n                .filter(Boolean);\r\n            }\r\n\r\n            // For all other cases (non-derived arrays, single items, properties),\r\n            // the standard lookup is correct.\r\n            return getGlobalStore.getState().getNestedState(stateKey, path);\r\n          };\r\n        }\r\n        if (prop === \"$derive\") {\r\n          return (fn: any) =>\r\n            $cogsSignal({\r\n              _stateKey: stateKey,\r\n              _path: path,\r\n              _effect: fn.toString(),\r\n            });\r\n        }\r\n        if (prop === \"$get\") {\r\n          return () => $cogsSignal({ _stateKey: stateKey, _path: path });\r\n        }\r\n        if (prop === \"lastSynced\") {\r\n          const syncKey = `${stateKey}:${path.join(\".\")}`;\r\n          return getGlobalStore.getState().getSyncInfo(syncKey);\r\n        }\r\n        if (prop == \"getLocalStorage\") {\r\n          return (key: string) =>\r\n            loadFromLocalStorage(sessionId + \"-\" + stateKey + \"-\" + key);\r\n        }\r\n        if (prop === \"_selected\") {\r\n          const parentPath = path.slice(0, -1);\r\n          const parentKey = parentPath.join(\".\");\r\n          if (\r\n            Array.isArray(\r\n              getGlobalStore.getState().getNestedState(stateKey, parentPath)\r\n            )\r\n          ) {\r\n            const itemId = path[path.length - 1];\r\n            const orderedIds = getOrderedIds(parentPath);\r\n            const thisIndex = orderedIds?.indexOf(itemId!);\r\n            return (\r\n              thisIndex ===\r\n              getGlobalStore.getState().getSelectedIndex(stateKey, parentKey)\r\n            );\r\n          }\r\n          return undefined;\r\n        }\r\n        if (prop === \"setSelected\") {\r\n          return (value: boolean) => {\r\n            const parentPath = path.slice(0, -1);\r\n            const itemId = path[path.length - 1];\r\n            const orderedIds = getOrderedIds(parentPath);\r\n            const thisIndex = orderedIds?.indexOf(itemId!);\r\n\r\n            if (thisIndex === undefined || thisIndex === -1) return;\r\n\r\n            const parentKey = parentPath.join(\".\");\r\n            getGlobalStore\r\n              .getState()\r\n              .setSelectedIndex(\r\n                stateKey,\r\n                parentKey,\r\n                value ? thisIndex : undefined\r\n              );\r\n            const nested = getGlobalStore\r\n              .getState()\r\n              .getNestedState(stateKey, [...parentPath]);\r\n            updateFn(effectiveSetState, nested, parentPath);\r\n            invalidateCachePath(parentPath);\r\n          };\r\n        }\r\n        if (prop === \"toggleSelected\") {\r\n          return () => {\r\n            const parentPath = path.slice(0, -1);\r\n            const itemId = path[path.length - 1];\r\n            const orderedIds = getOrderedIds(parentPath);\r\n            const thisIndex = orderedIds?.indexOf(itemId!);\r\n            if (thisIndex === undefined || thisIndex === -1) return;\r\n\r\n            const parentKey = parentPath.join(\".\");\r\n            const selectedIndex = getGlobalStore\r\n              .getState()\r\n              .getSelectedIndex(stateKey, parentKey);\r\n            getGlobalStore\r\n              .getState()\r\n              .setSelectedIndex(\r\n                stateKey,\r\n                parentKey,\r\n                selectedIndex === thisIndex ? undefined : thisIndex\r\n              );\r\n\r\n            const nested = getGlobalStore\r\n              .getState()\r\n              .getNestedState(stateKey, [...parentPath]);\r\n            updateFn(effectiveSetState, nested, parentPath);\r\n            invalidateCachePath(parentPath);\r\n          };\r\n        }\r\n        if (path.length == 0) {\r\n          if (prop === \"addValidation\") {\r\n            return (errors: ValidationError[]) => {\r\n              const init = getGlobalStore\r\n                .getState()\r\n                .getInitialOptions(stateKey)?.validation;\r\n              if (!init?.key) throw new Error(\"Validation key not found\");\r\n              removeValidationError(init.key);\r\n              errors.forEach((error) => {\r\n                const fullErrorPath = [init.key, ...error.path].join(\".\");\r\n                addValidationError(fullErrorPath, error.message);\r\n              });\r\n              notifyComponents(stateKey);\r\n            };\r\n          }\r\n          if (prop === \"applyJsonPatch\") {\r\n            return (patches: any[]) => {\r\n              const currentState =\r\n                getGlobalStore.getState().cogsStateStore[stateKey];\r\n              const newState = applyPatch(currentState, patches).newDocument;\r\n              updateGlobalState(\r\n                stateKey,\r\n                getGlobalStore.getState().initialStateGlobal[stateKey],\r\n                newState,\r\n                effectiveSetState,\r\n                componentId,\r\n                sessionId\r\n              );\r\n              notifyComponents(stateKey); // Simplified notification\r\n            };\r\n          }\r\n          if (prop === \"validateZodSchema\") {\r\n            return () => {\r\n              const init = getGlobalStore\r\n                .getState()\r\n                .getInitialOptions(stateKey)?.validation;\r\n              if (!init?.zodSchema || !init?.key)\r\n                throw new Error(\"Zod schema or validation key not found\");\r\n\r\n              removeValidationError(init.key);\r\n              const thisObject =\r\n                getGlobalStore.getState().cogsStateStore[stateKey];\r\n              const result = init.zodSchema.safeParse(thisObject);\r\n\r\n              if (!result.success) {\r\n                result.error.errors.forEach((error) => {\r\n                  const fullErrorPath = [init.key, ...error.path].join(\".\");\r\n                  addValidationError(fullErrorPath, error.message);\r\n                });\r\n                notifyComponents(stateKey);\r\n                return false;\r\n              }\r\n              return true;\r\n            };\r\n          }\r\n          if (prop === \"_componentId\") return componentId;\r\n          if (prop === \"getComponents\")\r\n            return () => getGlobalStore().stateComponents.get(stateKey);\r\n          if (prop === \"getAllFormRefs\")\r\n            return () =>\r\n              formRefStore.getState().getFormRefsByStateKey(stateKey);\r\n          if (prop === \"_initialState\")\r\n            return getGlobalStore.getState().initialStateGlobal[stateKey];\r\n          if (prop === \"_serverState\")\r\n            return getGlobalStore.getState().serverState[stateKey];\r\n          if (prop === \"_isLoading\")\r\n            return getGlobalStore.getState().isLoadingGlobal[stateKey];\r\n          if (prop === \"revertToInitialState\")\r\n            return baseObj.revertToInitialState;\r\n          if (prop === \"updateInitialState\") return baseObj.updateInitialState;\r\n          if (prop === \"removeValidation\") return baseObj.removeValidation;\r\n        }\r\n        if (prop === \"getFormRef\") {\r\n          return () =>\r\n            formRefStore.getState().getFormRef(stateKey + \".\" + path.join(\".\"));\r\n        }\r\n        if (prop === \"validationWrapper\") {\r\n          return ({\r\n            children,\r\n            hideMessage,\r\n          }: {\r\n            children: React.ReactNode;\r\n            hideMessage?: boolean;\r\n          }) => (\r\n            <ValidationWrapper\r\n              formOpts={\r\n                hideMessage ? { validation: { message: \"\" } } : undefined\r\n              }\r\n              path={path}\r\n              stateKey={stateKey}\r\n            >\r\n              {children}\r\n            </ValidationWrapper>\r\n          );\r\n        }\r\n        if (prop === \"_stateKey\") return stateKey;\r\n        if (prop === \"_path\") return path;\r\n        if (prop === \"_isServerSynced\") return baseObj._isServerSynced;\r\n        if (prop === \"update\") {\r\n          return (payload: UpdateArg<T>, opts?: UpdateOpts<T>) => {\r\n            if (opts?.debounce) {\r\n              debounce(() => {\r\n                updateFn(effectiveSetState, payload, path, \"\");\r\n                const newValue = getGlobalStore\r\n                  .getState()\r\n                  .getNestedState(stateKey, path);\r\n                if (opts?.afterUpdate) opts.afterUpdate(newValue);\r\n              }, opts.debounce);\r\n            } else {\r\n              updateFn(effectiveSetState, payload, path, \"\");\r\n              const newValue = getGlobalStore\r\n                .getState()\r\n                .getNestedState(stateKey, path);\r\n              if (opts?.afterUpdate) opts.afterUpdate(newValue);\r\n            }\r\n            invalidateCachePath(path);\r\n          };\r\n        }\r\n        if (prop === \"formElement\") {\r\n          return (child: FormControl<T>, formOpts?: FormOptsType) => (\r\n            <FormControlComponent<T>\r\n              setState={effectiveSetState}\r\n              stateKey={stateKey}\r\n              path={path}\r\n              child={child}\r\n              formOpts={formOpts}\r\n            />\r\n          );\r\n        }\r\n\r\n        const nextPath = [...path, prop];\r\n        const nextValue = getGlobalStore\r\n          .getState()\r\n          .getNestedState(stateKey, nextPath);\r\n        return rebuildStateShape(nextValue, nextPath, meta);\r\n      },\r\n    };\r\n\r\n    const proxyInstance = new Proxy(baseFunction, handler);\r\n    shapeCache.set(cacheKey, {\r\n      proxy: proxyInstance,\r\n      stateVersion: stateVersion,\r\n    });\r\n    return proxyInstance;\r\n  }\r\n\r\n  return rebuildStateShape(\r\n    getGlobalStore.getState().getNestedState(stateKey, [])\r\n  );\r\n}\r\n\r\nexport function $cogsSignal(proxy: {\r\n  _path: string[];\r\n  _stateKey: string;\r\n  _effect?: string;\r\n}) {\r\n  return createElement(SignalRenderer, { proxy });\r\n}\r\n\r\nfunction SignalMapRenderer({\r\n  proxy,\r\n  rebuildStateShape,\r\n}: {\r\n  proxy: {\r\n    _stateKey: string;\r\n    _path: string[];\r\n    _mapFn: (\r\n      value: any,\r\n      setter: any,\r\n      index: number,\r\n      array: any[],\r\n      arraySetter: any\r\n    ) => ReactNode;\r\n  };\r\n  rebuildStateShape: (\r\n    currentState: any,\r\n    path: string[],\r\n    meta?: { validIds?: string[] }\r\n  ) => any;\r\n}) {\r\n  const value = getGlobalStore().getNestedState(proxy._stateKey, proxy._path);\r\n  if (!Array.isArray(value)) return null;\r\n\r\n  const arraySetter = rebuildStateShape(\r\n    value,\r\n    proxy._path\r\n  ) as ArrayEndType<any>;\r\n  return arraySetter.stateMapNoRender(\r\n    (item, setter, index, array, arraySetter) => {\r\n      return proxy._mapFn(item, setter, index, array, arraySetter);\r\n    }\r\n  );\r\n}\r\n\r\nfunction SignalRenderer({\r\n  proxy,\r\n}: {\r\n  proxy: {\r\n    _path: string[];\r\n    _stateKey: string;\r\n    _effect?: string;\r\n  };\r\n}) {\r\n  const elementRef = useRef<HTMLSpanElement>(null);\r\n  const signalId = `${proxy._stateKey}-${proxy._path.join(\".\")}`;\r\n\r\n  useEffect(() => {\r\n    const element = elementRef.current;\r\n    if (!element || !element.parentElement) return;\r\n\r\n    const parentElement = element.parentElement;\r\n    const childNodes = Array.from(parentElement.childNodes);\r\n    const position = childNodes.indexOf(element);\r\n\r\n    let parentId = parentElement.getAttribute(\"data-parent-id\");\r\n    if (!parentId) {\r\n      parentId = `parent-${crypto.randomUUID()}`;\r\n      parentElement.setAttribute(\"data-parent-id\", parentId);\r\n    }\r\n\r\n    const instanceId = `instance-${crypto.randomUUID()}`;\r\n    const elementInfo = {\r\n      instanceId,\r\n      parentId,\r\n      position,\r\n      effect: proxy._effect,\r\n    };\r\n\r\n    getGlobalStore.getState().addSignalElement(signalId, elementInfo);\r\n\r\n    const value = getGlobalStore\r\n      .getState()\r\n      .getNestedState(proxy._stateKey, proxy._path);\r\n    let displayValue = value;\r\n    if (proxy._effect) {\r\n      try {\r\n        displayValue = new Function(\r\n          \"state\",\r\n          `return (${proxy._effect})(state)`\r\n        )(value);\r\n      } catch (err) {\r\n        console.error(\"Error evaluating effect function:\", err);\r\n      }\r\n    }\r\n\r\n    if (displayValue !== null && typeof displayValue === \"object\") {\r\n      displayValue = JSON.stringify(displayValue);\r\n    }\r\n\r\n    const textNode = document.createTextNode(String(displayValue));\r\n    element.replaceWith(textNode);\r\n  }, [proxy._stateKey, proxy._path.join(\".\"), proxy._effect]);\r\n\r\n  return createElement(\"span\", {\r\n    ref: elementRef,\r\n    style: { display: \"none\" },\r\n    \"data-signal-id\": signalId,\r\n  });\r\n}\r\n\r\nexport function $cogsSignalStore(proxy: {\r\n  _path: string[];\r\n  _stateKey: string;\r\n}) {\r\n  const value = useSyncExternalStore(\r\n    (notify) => {\r\n      const stateEntry = getGlobalStore\r\n        .getState()\r\n        .stateComponents.get(proxy._stateKey) || { components: new Map() };\r\n      stateEntry.components.set(proxy._stateKey, {\r\n        forceUpdate: notify,\r\n        paths: new Set([proxy._path.join(\".\")]),\r\n      });\r\n      getGlobalStore\r\n        .getState()\r\n        .stateComponents.set(proxy._stateKey, stateEntry);\r\n      return () => stateEntry.components.delete(proxy._stateKey);\r\n    },\r\n    () => getGlobalStore.getState().getNestedState(proxy._stateKey, proxy._path)\r\n  );\r\n  return createElement(\"text\", {}, String(value));\r\n}\r\n\r\nfunction CogsItemWrapper({\r\n  stateKey,\r\n  itemComponentId,\r\n  itemPath,\r\n  children,\r\n}: {\r\n  stateKey: string;\r\n  itemComponentId: string;\r\n  itemPath: string[];\r\n  formOpts?: FormOptsType;\r\n  children: React.ReactNode;\r\n}) {\r\n  const [, forceUpdate] = useState({});\r\n  const [measureRef, bounds] = useMeasure();\r\n  const elementRef = useRef<HTMLDivElement | null>(null);\r\n  const lastReportedHeight = useRef<number | null>(null);\r\n\r\n  const setRefs = useCallback(\r\n    (element: HTMLDivElement | null) => {\r\n      measureRef(element);\r\n      elementRef.current = element;\r\n    },\r\n    [measureRef]\r\n  );\r\n\r\n  useEffect(() => {\r\n    if (bounds.height > 0 && bounds.height !== lastReportedHeight.current) {\r\n      lastReportedHeight.current = bounds.height;\r\n      getGlobalStore.getState().setShadowMetadata(stateKey, itemPath, {\r\n        virtualizer: { itemHeight: bounds.height, domRef: elementRef.current },\r\n      });\r\n    }\r\n  }, [bounds.height, stateKey, itemPath]);\r\n\r\n  useLayoutEffect(() => {\r\n    const fullComponentId = `${stateKey}////${itemComponentId}`;\r\n    const stateEntry = getGlobalStore\r\n      .getState()\r\n      .stateComponents.get(stateKey) || { components: new Map() };\r\n    stateEntry.components.set(fullComponentId, {\r\n      forceUpdate: () => forceUpdate({}),\r\n      paths: new Set([itemPath.join(\".\")]),\r\n    });\r\n    getGlobalStore.getState().stateComponents.set(stateKey, stateEntry);\r\n    return () => {\r\n      const currentEntry = getGlobalStore\r\n        .getState()\r\n        .stateComponents.get(stateKey);\r\n      if (currentEntry) currentEntry.components.delete(fullComponentId);\r\n    };\r\n  }, [stateKey, itemComponentId, itemPath.join(\".\")]);\r\n\r\n  return <div ref={setRefs}>{children}</div>;\r\n}\r\n"],"names":["setAndMergeOptions","stateKey","newOptions","getInitialOptions","getGlobalStore","setInitialStateOptions","initialOptions","setOptions","options","initialOptionsPart","initialOptionsPartState","mergedOptions","needToAdd","key","isDeepEqual","addStateOptions","initialState","formElements","validation","createCogsState","opt","newInitialState","statePart","transformStateFunc","useCogsState","componentId","useState","uuidv4","thiState","partialState","state","updater","useCogsStateFn","setCogsOptions","loadAndApplyLocalStorage","notifyComponents","setUpdaterState","setState","getKeyState","getValidationErrors","setStateLog","updateInitialStateGlobal","addValidationError","removeValidationError","setServerSyncActions","saveToLocalStorage","thisKey","currentInitialOptions","sessionId","lastSyncedWithServer","isFunction","storageKey","existingLastSynced","loadFromLocalStorage","data","superJsonResult","superjson","localStorageKey","storedData","error","currentState","useCogsConfig","localkey","localData","updateGlobalState","newState","effectiveSetState","updates","createProxyHandler","stateEntry","component","update","notifyComponent","fullComponentId","getUpdateValues","updateType","prevValue","payload","path","getNestedValue","stateObject","serverSync","localStorage","reactiveDeps","reactiveType","syncUpdate","dependencies","serverState","reactiveForce","forceUpdate","noStateKey","stateLog","componentUpdatesRef","useRef","componentIdRef","latestInitialOptionsRef","useEffect","prevState","syncKey","hasServerData","currentGloballyStoredInitialState","isFromServer","serverTimestamp","localTimestamp","lastSyncTimestamp","useLayoutEffect","componentKey","newStateOrFunction","updateObj","validationKey","pathKey","store","signalId","isArrayOperation","elements","arrayPath","arrayValue","arraySignalId","newValue","parentId","position","effect","parent","childNodes","displayValue","arrayWithoutIndex","k","length","v","newKey","changedPaths","getDifferences","changedPathsSet","primaryPathToCheck","shouldUpdate","reactiveTypes","changedPath","currentPathToCheck","lastDotIndex","parentPath","depsResult","depsChanged","timeStamp","oldValue","newUpdate","targetId","item","shadowPath","p","i","currentSubPath","subValue","prevLogs","logs","aggregatedLogs","log","uniqueKey","existing","serverStateStore","updaterFinal","useMemo","shapeCache","stateVersion","invalidateCachePath","baseObj","obj","init","newProxy","rebuildStateShape","initalOptionsGet","localKey","newUpdaterState","startTransition","field","getOrderedIds","arrayKey","meta","cacheKey","baseFunction","handler","target","thisArg","args","prop","mutationMethods","currentPath","needsAdd","existingPath","sync","response","errorPath","thisReactiveState","initialStateAtPath","selectedIndex","sourceArray","selectedItem","itemId","globallySelectedIndex","selectedItemId","itemHeight","overscan","stickToBottom","containerRef","range","setRange","shadowUpdateTrigger","setShadowUpdateTrigger","wasAtBottomRef","userHasScrolledAwayRef","previousCountRef","lastRangeRef","orderedIds","prev","totalCount","totalHeight","positions","height","pos","itemPath","measuredHeight","virtualState","start","end","slicedArray","slicedIds","scrollToLastItem","useCallback","lastIndex","lastItemId","lastItemPath","lastItemMeta","element","scrollToIndex","container","handleScroll","scrollTop","scrollHeight","clientHeight","distanceFromBottom","startIndex","endIndex","viewportEnd","newStartIndex","newEndIndex","scrollToBottom","index","behavior","top","virtualizerProps","callbackfn","arrayToMap","itemIdsForCurrentArray","arraySetter","itemSetter","finalPath","setter","createElement","SignalMapRenderer","sourceIds","localIndex","originalIndex","itemComponentId","CogsItemWrapper","fieldName","flattenedResults","val","itemData","currentArray","lastValue","newPath","pushFunc","fields","onMatch","matchedItem","isMatch","updatedItem","updatedArray","updateFn","cutFunc","value","sourceMap","newValidIds","newFilteredArray","id","compareFn","itemsWithIds","a","b","sortedArray","d","thisValue","foundItem","lastPathElement","parentValue","fn","$cogsSignal","parentKey","thisIndex","nested","errors","fullErrorPath","patches","applyPatch","thisObject","result","formRefStore","children","hideMessage","jsx","ValidationWrapper","opts","debounce","child","formOpts","FormControlComponent","nextPath","nextValue","proxyInstance","proxy","SignalRenderer","array","elementRef","parentElement","elementInfo","err","textNode","$cogsSignalStore","useSyncExternalStore","notify","measureRef","bounds","useMeasure","lastReportedHeight","setRefs","currentEntry"],"mappings":"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"}