{"version":3,"file":"CogsState.jsx","sources":["../src/CogsState.tsx"],"sourcesContent":["\"use client\";\r\nimport {\r\n    createElement,\r\n    startTransition,\r\n    useEffect,\r\n    useMemo,\r\n    useRef,\r\n    useState,\r\n    useSyncExternalStore,\r\n} from \"react\";\r\n\r\nimport { getNestedValue, isFunction, type GenericObject } from \"./utility.js\";\r\nimport {\r\n    cutFunc,\r\n    FormControlComponent,\r\n    pushFunc,\r\n    updateFn,\r\n    ValidationWrapper,\r\n} from \"./updaterFunctions.js\";\r\nimport { isDeepEqual, transformStateFunc } from \"./utility.js\";\r\nimport type { UseMutationResult } from \"@tanstack/react-query\";\r\nimport { v4 as uuidv4 } from \"uuid\";\r\nimport { ZodObject, type ZodRawShape } from \"zod\";\r\n\r\nimport { getGlobalStore } from \"./store.js\";\r\nimport { useCogsConfig } from \"./CogsStateClient.js\";\r\n\r\ntype Prettify<T> = { [K in keyof T]: T[K] } & {};\r\n\r\nexport type ServerSyncStatus = {\r\n    isFresh: boolean;\r\n    isFreshTime: number;\r\n    isStale: boolean;\r\n    isStaleTime: number;\r\n    isSyncing: boolean;\r\n    isSyncingTime: number;\r\n};\r\n\r\nexport type SyncInfo = {\r\n    timeStamp: number;\r\n    userId: number;\r\n};\r\n\r\nexport type FormElementParmas<T> = {\r\n    get: () => T;\r\n\r\n    set: UpdateType<T>;\r\n    syncStatus: (SyncInfo & { date: Date }) | null;\r\n    path: string[];\r\n    validationErrors: () => string[];\r\n\r\n    inputProps: {\r\n        value?: T;\r\n        onChange?: (\r\n            event: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>,\r\n        ) => void;\r\n    };\r\n};\r\n\r\nexport type StateKeys = string;\r\n\r\ntype findWithFuncType<U> = (\r\n    thisKey: keyof U,\r\n    thisValue: U[keyof U],\r\n) => EndType<U> & { upsert: UpdateType<U> } & StateObject<U>;\r\nexport type PushArgs<U> = (\r\n    update:\r\n        | Prettify<U>\r\n        | ((prevState: NonNullable<Prettify<U>>[]) => NonNullable<Prettify<U>>),\r\n    opts?: UpdateOpts,\r\n) => void;\r\nexport interface GlobalState<T, K extends keyof T = keyof T> {\r\n    getKeyState: () => T;\r\n    setState: (newState: T | ((previousState: T) => T)) => void;\r\n    key: K;\r\n}\r\ntype CutFunctionType = (\r\n    index?: number,\r\n    options?: { waitForSync?: boolean },\r\n) => void;\r\n\r\nexport type InferArrayElement<T> = T extends (infer U)[] ? U : never;\r\n\r\nexport type ArrayEndType<TShape extends unknown> = {\r\n    findWith: findWithFuncType<InferArrayElement<TShape>>;\r\n    index: (index: number) => StateObject<InferArrayElement<TShape>> & {\r\n        insert: PushArgs<InferArrayElement<TShape>>;\r\n        cut: CutFunctionType;\r\n        _index: number;\r\n    } & EndType<InferArrayElement<TShape>>;\r\n    insert: PushArgs<InferArrayElement<TShape>>;\r\n    cut: CutFunctionType;\r\n    stateEach: (\r\n        callbackfn: (\r\n            value: InferArrayElement<TShape>,\r\n            setter: StateObject<InferArrayElement<TShape>>,\r\n            index: number,\r\n            array: TShape,\r\n            arraySetter: StateObject<TShape>,\r\n        ) => void,\r\n    ) => any;\r\n    stateFlattenOn: <K extends keyof InferArrayElement<TShape>>(\r\n        field: K,\r\n    ) => StateObject<InferArrayElement<InferArrayElement<TShape>[K]>[]>;\r\n    uniqueInsert: (\r\n        payload: UpdateArg<InferArrayElement<TShape>>,\r\n        fields?: (keyof InferArrayElement<TShape>)[],\r\n    ) => void;\r\n    stateFilter: (\r\n        callbackfn: (value: InferArrayElement<TShape>, index: number) => void,\r\n    ) => ArrayEndType<TShape>;\r\n    getSelected: () => StateObject<InferArrayElement<TShape>> | undefined;\r\n} & EndType<TShape>;\r\n\r\nexport type UpdateType<T> = (\r\n    payload: UpdateArg<Prettify<T>>,\r\n    opts?: UpdateOpts,\r\n) => void;\r\nexport type FormOptsType = {\r\n    key?: string;\r\n    validation?: {\r\n        message?: string;\r\n        stretch?: boolean;\r\n        props?: GenericObject;\r\n        disable?: boolean;\r\n    };\r\n    formElements?: boolean;\r\n    debounceTime?: number;\r\n    stateServerDifferences?: string[][];\r\n};\r\n\r\nexport type FormControl<T> = (obj: FormElementParmas<T>) => JSX.Element;\r\n\r\nexport type UpdateArg<S> = S | ((prevState: S) => S);\r\nexport type UpdateOpts = {\r\n    timelineLabel?: string;\r\n    timeLineMessage?: string;\r\n    validate?: boolean;\r\n};\r\nexport type ObjectEndType<T> = EndType<T> & {\r\n    [K in keyof T]-?: ObjectEndType<T[K]>;\r\n} & {\r\n    stateObject: (\r\n        callbackfn: (value: T, setter: StateObject<T>) => void,\r\n    ) => any;\r\n    delete: () => void;\r\n};\r\n\r\nexport type EndType<T> = {\r\n    update: UpdateType<T>;\r\n    _path: string[];\r\n    _stateKey: string;\r\n    formElement: (\r\n        validationKey: string,\r\n        control: FormControl<T>,\r\n        opts?: FormOptsType,\r\n    ) => JSX.Element;\r\n    get: () => T;\r\n\r\n    $get: () => T;\r\n    _status: \"fresh\" | \"stale\" | \"synced\";\r\n    showValidationErrors: (ctx: string) => string[];\r\n    setValidation: (ctx: string) => void;\r\n    removeValidation: (ctx: string) => void;\r\n    ignoreFields: (fields: string[]) => StateObject<T>;\r\n    _selected: boolean; // New field for selection state\r\n    setSelected: (value: boolean) => void; // New method to update selection\r\n    validationWrapper: ({\r\n        children,\r\n        hideMessage,\r\n    }: {\r\n        children: React.ReactNode;\r\n        hideMessage?: boolean;\r\n    }) => JSX.Element;\r\n    lastSynced?: SyncInfo;\r\n};\r\nexport type StateObject<T> = (T extends any[]\r\n    ? ArrayEndType<T>\r\n    : T extends Record<string, unknown> | object\r\n      ? { [K in keyof T]-?: StateObject<T[K]> } & ObjectEndType<T>\r\n      : T extends string | number | boolean | null\r\n        ? T\r\n        : never) &\r\n    EndType<T> & {\r\n        _componentId: string | null;\r\n        _initialState: T;\r\n        updateInitialState: (newState: T | null) => {\r\n            fetchId: (field: keyof T) => string | number;\r\n        };\r\n        _isLoading: boolean;\r\n        _serverState: T;\r\n        revertToInitialState: (obj?: { validationKey?: string }) => void;\r\n        middleware: (\r\n            middles: ({\r\n                updateLog,\r\n                update,\r\n            }: {\r\n                updateLog: UpdateTypeDetail[] | undefined;\r\n                update: UpdateTypeDetail;\r\n            }) => void,\r\n        ) => void;\r\n        _isServerSynced: () => boolean;\r\n        getLocalStorage: (key: string) => LocalStorageData<T> | null;\r\n    };\r\n\r\nexport type CogsUpdate<T extends unknown> = UpdateType<T>;\r\n\r\nexport type EffectiveSetState<TStateObject> = (\r\n    newStateOrFunction:\r\n        | TStateObject\r\n        | ((prevState: TStateObject) => TStateObject),\r\n    path: string[],\r\n    updateObj: { updateType: \"update\" | \"insert\" | \"cut\" },\r\n    validationKey?: string,\r\n    opts?: UpdateOpts,\r\n) => void;\r\n\r\nexport type UpdateTypeDetail = {\r\n    timeStamp: number;\r\n    stateKey: string;\r\n    updateType: \"update\" | \"insert\" | \"cut\";\r\n    path: string[];\r\n    status: \"new\" | \"sent\" | \"synced\";\r\n    oldValue: any;\r\n    newValue: any;\r\n    userId?: number;\r\n};\r\n\r\n//let globalStoreInstance: ReturnType<typeof getGlobalStore> | null = null;\r\n\r\n// export const getGlobalStore = <State extends GenericObject | GenericObject[]>(initialState?: State) => {\r\n//     if (!globalStoreInstance) {\r\n//         globalStoreInstance = cogStateGlobalStore(initialState ?? {});\r\n//     }\r\n//     return globalStoreInstance;\r\n// };\r\n\r\nexport type ActionsType<T> = {\r\n    type: \"onChange\";\r\n    action: ({ state, actionType }: { state: T; actionType: string }) => void;\r\n    debounce?: number;\r\n}[];\r\n\r\ntype ArrayToObject<T extends string[]> = Record<T[number], string>;\r\ntype CookieType<T> = {\r\n    timeStamp: number;\r\n    value: T;\r\n    cookieName: string;\r\n    OnUnMountCookie?: Boolean;\r\n};\r\nexport type CogsCookiesType<T extends string[] = string[]> = CookieType<\r\n    ArrayToObject<T>\r\n>;\r\n\r\nexport type OptionsType<T extends unknown = unknown> = {\r\n    serverSync?: ServerSyncType<T>;\r\n    validationKey?: string;\r\n    enableServerState?: boolean;\r\n    middleware?: ({\r\n        updateLog,\r\n        update,\r\n    }: {\r\n        updateLog: UpdateTypeDetail[] | undefined;\r\n        update: UpdateTypeDetail;\r\n    }) => void;\r\n\r\n    zodSchema?: ZodObject<ZodRawShape>;\r\n    modifyState?: (state: T) => T;\r\n    localStorage?: { key: string | ((state: T) => string) };\r\n    formElements?: FormsElementsType;\r\n    enabledSync?: (state: T) => boolean;\r\n    reactiveDeps?: (state: T) => any[] | true;\r\n    syncUpdate?: Partial<UpdateTypeDetail>;\r\n    initState?: {\r\n        localStorageKey?: string;\r\n        ctx?: Record<string, any>;\r\n        initialState: T;\r\n        dependencies?: any[]; // Just like useEffect dependencies\r\n    };\r\n};\r\nexport type ServerSyncType<T> = {\r\n    testKey?: string;\r\n    syncKey: (({ state }: { state: T }) => string) | string;\r\n    syncFunction: ({ state }: { state: T }) => void;\r\n    debounce?: number;\r\n    mutation: UseMutationResult<any, unknown, any, unknown>;\r\n    snapshot?: {\r\n        name: (({ state }: { state: T }) => string) | string;\r\n        stateKeys: StateKeys[];\r\n        currentUrl: string;\r\n        currentParams?: URLSearchParams;\r\n    };\r\n};\r\nexport type SyncActionsType<T> = {\r\n    syncKey: string;\r\n\r\n    rollBackState?: T;\r\n    actionTimeStamp: number;\r\n    retryCount?: number;\r\n    status:\r\n        | \"success\"\r\n        | \"waiting\"\r\n        | \"rolledBack\"\r\n        | \"error\"\r\n        | \"cancelled\"\r\n        | \"failed\";\r\n    snapshot?: {\r\n        name: string;\r\n        stateKeys: StateKeys[];\r\n        currentUrl: string;\r\n        currentParams?: URLSearchParams;\r\n    };\r\n};\r\n\r\nexport type ValidationWrapperOptions<T extends unknown = unknown> = {\r\n    children: React.ReactNode;\r\n    active: boolean;\r\n    stretch?: boolean;\r\n    path: string[];\r\n    message?: string;\r\n    data?: T;\r\n    key?: string;\r\n};\r\nexport type SyncRenderOptions<T extends unknown = unknown> = {\r\n    children: React.ReactNode;\r\n    time: number;\r\n    data?: T;\r\n    key?: string;\r\n};\r\n\r\ntype FormsElementsType<T extends unknown = unknown> = {\r\n    validation?: (options: ValidationWrapperOptions<T>) => React.ReactNode;\r\n    syncRender?: (options: SyncRenderOptions<T>) => React.ReactNode;\r\n};\r\n\r\nexport type InitialStateInnerType<T extends unknown = unknown> = {\r\n    initialState: T;\r\n} & OptionsType<T>;\r\n\r\nexport type InitialStateType<T> = {\r\n    [key: string]: InitialStateInnerType<T>;\r\n};\r\nexport type FunctionsToPassDownType = {\r\n    getValidationErrors: (pathArray: string) => string[];\r\n    removeValidationError: (path: string) => void;\r\n};\r\n\r\nexport type AllStateTypes<T extends unknown> = Record<string, T>;\r\n\r\nexport type CogsInitialState<T> = {\r\n    initialState: T;\r\n    formElements?: FormsElementsType<T>;\r\n};\r\n\r\nexport type TransformedStateType<T> = {\r\n    [P in keyof T]: T[P] extends CogsInitialState<infer U> ? U : T[P];\r\n};\r\n\r\nexport function addStateOptions<T extends unknown>(\r\n    initialState: T,\r\n    { formElements, zodSchema }: OptionsType<T>,\r\n) {\r\n    return { initialState: initialState, formElements, zodSchema } as T;\r\n}\r\n\r\nfunction setAndMergeOptions(stateKey: string, newOptions: OptionsType<any>) {\r\n    const getInitialOptions = getGlobalStore.getState().getInitialOptions;\r\n    const setInitialStateOptions =\r\n        getGlobalStore.getState().setInitialStateOptions;\r\n\r\n    const initialOptions = getInitialOptions(stateKey as string) || {};\r\n\r\n    setInitialStateOptions(stateKey as string, {\r\n        ...initialOptions,\r\n        ...newOptions,\r\n    });\r\n}\r\n\r\nfunction setOptions<StateKey, Opt>({\r\n    stateKey,\r\n    options,\r\n    initialOptionsPart,\r\n}: {\r\n    stateKey: StateKey;\r\n    options?: Opt;\r\n    initialOptionsPart: Record<string, any>;\r\n}) {\r\n    const initialOptions = getInitialOptions(stateKey as string) || {};\r\n    const initialOptionsPartState =\r\n        initialOptionsPart[stateKey as string] || {};\r\n    const setInitialStateOptions =\r\n        getGlobalStore.getState().setInitialStateOptions;\r\n    const mergedOptions = { ...initialOptionsPartState, ...initialOptions };\r\n\r\n    let needToAdd = false;\r\n    if (options) {\r\n        for (const key in options) {\r\n            if (!mergedOptions.hasOwnProperty(key)) {\r\n                needToAdd = true;\r\n                mergedOptions[key] = options[key as keyof typeof options];\r\n            }\r\n        }\r\n    }\r\n    if (needToAdd) {\r\n        setInitialStateOptions(stateKey as string, mergedOptions);\r\n    }\r\n}\r\n\r\nexport const createCogsState = <State extends Record<string, unknown>>(\r\n    initialState: State,\r\n) => {\r\n    let newInitialState = initialState;\r\n\r\n    const [statePart, initialOptionsPart] =\r\n        transformStateFunc<State>(newInitialState);\r\n\r\n    getGlobalStore.getState().setInitialStates(statePart);\r\n    type StateKeys = keyof typeof statePart;\r\n\r\n    const useCogsState = <StateKey extends StateKeys>(\r\n        stateKey: StateKey,\r\n        options?: OptionsType<(typeof statePart)[StateKey]>,\r\n    ) => {\r\n        const [componentId] = useState(uuidv4());\r\n        setOptions({ stateKey, options, initialOptionsPart });\r\n\r\n        const thiState =\r\n            getGlobalStore.getState().cogsStateStore[stateKey as string] ||\r\n            statePart[stateKey as string];\r\n        const partialState = options?.modifyState\r\n            ? options.modifyState(thiState)\r\n            : thiState;\r\n\r\n        const [state, updater] = useCogsStateFn<(typeof statePart)[StateKey]>(\r\n            partialState,\r\n            {\r\n                stateKey: stateKey as string,\r\n                syncUpdate: options?.syncUpdate,\r\n                componentId,\r\n                localStorage: options?.localStorage,\r\n                middleware: options?.middleware,\r\n                enabledSync: options?.enabledSync,\r\n                reactiveDeps: options?.reactiveDeps,\r\n                initState: options?.initState,\r\n            },\r\n        );\r\n\r\n        return [state, updater] as const;\r\n    };\r\n\r\n    function setCogsOptions<StateKey extends StateKeys>(\r\n        stateKey: StateKey,\r\n        options: OptionsType<(typeof statePart)[StateKey]>,\r\n    ) {\r\n        setOptions({ stateKey, options, initialOptionsPart });\r\n    }\r\n\r\n    return { useCogsState, setCogsOptions };\r\n};\r\n\r\nconst {\r\n    setUpdaterState,\r\n    setState,\r\n    getInitialOptions,\r\n    getKeyState,\r\n    getValidationErrors,\r\n    setStateLog,\r\n    updateInitialStateGlobal,\r\n    addValidationError,\r\n    removeValidationError,\r\n    setServerSyncActions,\r\n} = getGlobalStore.getState();\r\n\r\nconst loadFromLocalStorage = (localStorageKey: string) => {\r\n    if (!localStorageKey) return null;\r\n\r\n    try {\r\n        const storedData = window.localStorage.getItem(localStorageKey);\r\n        if (!storedData) return null;\r\n\r\n        const parsedData = JSON.parse(storedData);\r\n\r\n        return parsedData;\r\n    } catch (error) {\r\n        console.error(\"Error loading from localStorage:\", error);\r\n        return null;\r\n    }\r\n};\r\n\r\nconst saveToLocalStorage = <T,>(\r\n    state: T,\r\n    thisKey: string,\r\n    currentInitialOptions: any,\r\n    sessionId?: string,\r\n) => {\r\n    if (currentInitialOptions?.initState) {\r\n        const data: LocalStorageData<T> = {\r\n            state,\r\n            lastUpdated: Date.now(),\r\n            lastSyncedWithServer:\r\n                getGlobalStore.getState().serverSyncLog[thisKey]?.[0]\r\n                    ?.timeStamp,\r\n            baseServerState: getGlobalStore.getState().serverState[thisKey],\r\n        };\r\n\r\n        const storageKey = currentInitialOptions.initState\r\n            ? `${sessionId}-${thisKey}-${currentInitialOptions.initState.localStorageKey}`\r\n            : thisKey;\r\n\r\n        window.localStorage.setItem(storageKey, JSON.stringify(data));\r\n    }\r\n};\r\n\r\ntype LocalStorageData<T> = {\r\n    state: T;\r\n    lastUpdated: number;\r\n    lastSyncedWithServer?: number;\r\n    baseServerState?: T; // Add this to track what server state our changes are based on\r\n};\r\n\r\nconst updateGlobalState = (\r\n    thisKey: string,\r\n    initialState: any,\r\n    newState: any,\r\n    effectiveSetState: EffectiveSetState<any>,\r\n    componentId: string,\r\n    sessionId?: string,\r\n) => {\r\n    // Update all global state at once\r\n    const updates = {\r\n        initialState: initialState,\r\n        updaterState: createProxyHandler(\r\n            thisKey,\r\n            effectiveSetState,\r\n            componentId,\r\n            sessionId,\r\n        ),\r\n        state: newState,\r\n    };\r\n\r\n    startTransition(() => {\r\n        updateInitialStateGlobal(thisKey, updates.initialState);\r\n        setUpdaterState(thisKey, updates.updaterState);\r\n        setState(thisKey, updates.state);\r\n    });\r\n};\r\n\r\nconst notifyComponents = (thisKey: string) => {\r\n    const stateEntry = getGlobalStore.getState().stateComponents.get(thisKey);\r\n    if (!stateEntry) return;\r\n\r\n    // Batch component updates\r\n    const updates = new Set<() => void>();\r\n    stateEntry.components.forEach((component) => {\r\n        updates.add(() => component.forceUpdate());\r\n    });\r\n\r\n    // Schedule updates in the next tick to allow batching\r\n    queueMicrotask(() => {\r\n        startTransition(() => {\r\n            updates.forEach((update) => update());\r\n        });\r\n    });\r\n};\r\n\r\nexport function useCogsStateFn<TStateObject extends unknown>(\r\n    stateObject: TStateObject,\r\n    {\r\n        stateKey,\r\n        serverSync,\r\n        zodSchema,\r\n        localStorage,\r\n        formElements,\r\n        middleware,\r\n        reactiveDeps,\r\n        componentId,\r\n        initState,\r\n        syncUpdate,\r\n    }: {\r\n        stateKey?: string;\r\n        componentId?: string;\r\n    } & OptionsType<TStateObject> = {},\r\n) {\r\n    const [reactiveForce, forceUpdate] = useState({}); //this is the key to reactivity\r\n    const { sessionId } = useCogsConfig();\r\n\r\n    let noStateKey = stateKey ? false : true;\r\n    const [thisKey] = useState(stateKey ?? uuidv4());\r\n    const stateLog = getGlobalStore.getState().stateLog[thisKey];\r\n    const componentUpdatesRef = useRef(new Set<string>());\r\n    const componentIdRef = useRef(componentId ?? uuidv4());\r\n    const latestInitialOptionsRef = useRef<any>(null);\r\n    latestInitialOptionsRef.current = getInitialOptions(thisKey as string); //i have to do this for it to work\r\n    useEffect(() => {\r\n        if (\r\n            syncUpdate &&\r\n            syncUpdate.stateKey === thisKey &&\r\n            syncUpdate.path?.[0]\r\n        ) {\r\n            // Update the actual state value\r\n            setState(thisKey, (prevState: any) => ({\r\n                ...prevState,\r\n                [syncUpdate.path![0]!]: syncUpdate.newValue,\r\n            }));\r\n\r\n            // Create combined key and update sync info\r\n            const syncKey = `${syncUpdate.stateKey}:${syncUpdate.path.join(\".\")}`;\r\n            getGlobalStore.getState().setSyncInfo(syncKey, {\r\n                timeStamp: syncUpdate.timeStamp!,\r\n                userId: syncUpdate.userId!,\r\n            });\r\n        }\r\n    }, [syncUpdate]);\r\n\r\n    useEffect(() => {\r\n        if (initState) {\r\n            const { initialState, dependencies } = initState;\r\n\r\n            setAndMergeOptions(thisKey as string, {\r\n                initState,\r\n            });\r\n            const localData = loadFromLocalStorage(\r\n                sessionId + \"-\" + thisKey + \"-\" + initState?.localStorageKey,\r\n            );\r\n            let newState = initialState;\r\n            if (localData) {\r\n                if (\r\n                    localData.lastUpdated >\r\n                    (localData.lastSyncedWithServer || 0)\r\n                ) {\r\n                    newState = localData.state;\r\n                }\r\n            }\r\n            updateGlobalState(\r\n                thisKey,\r\n                initialState,\r\n                newState,\r\n                effectiveSetState,\r\n                componentIdRef.current,\r\n                sessionId,\r\n            );\r\n            notifyComponents(thisKey);\r\n        }\r\n    }, [initState?.localStorageKey, ...(initState?.dependencies || [])]);\r\n\r\n    useEffect(() => {\r\n        if (noStateKey) {\r\n            setAndMergeOptions(thisKey as string, {\r\n                serverSync,\r\n                formElements,\r\n                zodSchema,\r\n                initState,\r\n                localStorage,\r\n                middleware,\r\n            });\r\n        }\r\n\r\n        const depsKey = `${thisKey}////${componentIdRef.current}`;\r\n        const stateEntry = getGlobalStore\r\n            .getState()\r\n            .stateComponents.get(thisKey) || {\r\n            components: new Map(),\r\n        };\r\n\r\n        stateEntry.components.set(depsKey, {\r\n            forceUpdate: () => forceUpdate({}),\r\n            paths: new Set(),\r\n            deps: [],\r\n            depsFunction: reactiveDeps || undefined,\r\n        });\r\n\r\n        getGlobalStore.getState().stateComponents.set(thisKey, stateEntry);\r\n\r\n        return () => {\r\n            const depsKey = `${thisKey}////${componentIdRef.current}`;\r\n\r\n            if (stateEntry) {\r\n                stateEntry.components.delete(depsKey);\r\n                if (stateEntry.components.size === 0) {\r\n                    getGlobalStore.getState().stateComponents.delete(thisKey);\r\n                }\r\n            }\r\n        };\r\n    }, []);\r\n\r\n    const effectiveSetState = (\r\n        newStateOrFunction:\r\n            | TStateObject\r\n            | ((prevState: TStateObject) => TStateObject),\r\n        path: string[],\r\n        updateObj: { updateType: \"insert\" | \"cut\" | \"update\" },\r\n        validationKey?: string,\r\n    ) => {\r\n        if (Array.isArray(path)) {\r\n            const pathKey = `${thisKey}-${path.join(\".\")}`;\r\n            componentUpdatesRef.current.add(pathKey);\r\n        }\r\n        setState(thisKey, (prevValue: TStateObject) => {\r\n            const payload = isFunction<TStateObject>(newStateOrFunction)\r\n                ? newStateOrFunction(prevValue as TStateObject)\r\n                : newStateOrFunction;\r\n\r\n            const signalId = `${thisKey}-${path.join(\".\")}`;\r\n\r\n            if (signalId) {\r\n                const elements = getGlobalStore\r\n                    .getState()\r\n                    .signalDomElements.get(signalId);\r\n                //   console.log(\"elements\", elements);\r\n                if (elements) {\r\n                    const newValue = getNestedValue(payload, path);\r\n                    elements.forEach(({ parentId, position }) => {\r\n                        const parent = document.querySelector(\r\n                            `[data-parent-id=\"${parentId}\"]`,\r\n                        );\r\n                        if (parent) {\r\n                            const childNodes = Array.from(parent.childNodes);\r\n                            if (childNodes[position]) {\r\n                                childNodes[position].textContent =\r\n                                    String(newValue);\r\n                            }\r\n                        }\r\n                    });\r\n                }\r\n            }\r\n            if (\r\n                updateObj.updateType === \"update\" &&\r\n                (validationKey ||\r\n                    latestInitialOptionsRef.current?.validationKey) &&\r\n                path\r\n            ) {\r\n                removeValidationError(\r\n                    (validationKey ||\r\n                        latestInitialOptionsRef.current?.validationKey) +\r\n                        \".\" +\r\n                        path.join(\".\"),\r\n                );\r\n            }\r\n            const arrayWithoutIndex = path.slice(0, path.length - 1);\r\n            if (\r\n                updateObj.updateType === \"cut\" &&\r\n                latestInitialOptionsRef.current?.validationKey\r\n            ) {\r\n                removeValidationError(\r\n                    latestInitialOptionsRef.current?.validationKey +\r\n                        \".\" +\r\n                        arrayWithoutIndex.join(\".\"),\r\n                );\r\n            }\r\n            if (\r\n                updateObj.updateType === \"insert\" &&\r\n                latestInitialOptionsRef.current?.validationKey\r\n            ) {\r\n                let getValidation = getValidationErrors(\r\n                    latestInitialOptionsRef.current?.validationKey +\r\n                        \".\" +\r\n                        arrayWithoutIndex.join(\".\"),\r\n                );\r\n\r\n                //TODO this is untested its supposed to cahnge teh validation errors alreaady stored when a new entry is push\r\n\r\n                getValidation.filter(([k, v]) => {\r\n                    let length = k?.split(\".\").length;\r\n\r\n                    if (\r\n                        k == arrayWithoutIndex.join(\".\") &&\r\n                        length == arrayWithoutIndex.length - 1\r\n                    ) {\r\n                        //   console.log(length, pathWithoutIndex.length);\r\n                        let newKey = k + \".\" + arrayWithoutIndex;\r\n                        removeValidationError(k!);\r\n                        addValidationError(newKey, v!);\r\n                    }\r\n                });\r\n            }\r\n\r\n            const oldValue = getNestedValue(prevValue, path);\r\n            const newValue = getNestedValue(payload, path);\r\n            const pathToCheck =\r\n                updateObj.updateType === \"update\"\r\n                    ? path.join(\".\")\r\n                    : [...path].slice(0, -1).join(\".\");\r\n            const stateEntry = getGlobalStore\r\n                .getState()\r\n                .stateComponents.get(thisKey);\r\n\r\n            if (stateEntry) {\r\n                for (const [\r\n                    key,\r\n                    component,\r\n                ] of stateEntry.components.entries()) {\r\n                    if (\r\n                        component.depsFunction ||\r\n                        (component.paths && component.paths.has(pathToCheck))\r\n                    ) {\r\n                        if (component.depsFunction) {\r\n                            const depsResult = component.depsFunction(payload);\r\n\r\n                            if (typeof depsResult === \"boolean\") {\r\n                                if (depsResult) {\r\n                                    component.forceUpdate();\r\n                                }\r\n                            } else if (\r\n                                !isDeepEqual(component.deps, depsResult)\r\n                            ) {\r\n                                component.deps = depsResult;\r\n                                component.forceUpdate();\r\n                            }\r\n                        } else {\r\n                            component.forceUpdate();\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            const timeStamp = Date.now();\r\n\r\n            const newUpdate = {\r\n                timeStamp,\r\n                stateKey: thisKey,\r\n                path,\r\n                updateType: updateObj.updateType,\r\n                status: \"new\" as const,\r\n                oldValue,\r\n                newValue,\r\n            } satisfies UpdateTypeDetail;\r\n\r\n            setStateLog(thisKey, (prevLogs) => {\r\n                const logs = [...(prevLogs ?? []), newUpdate];\r\n\r\n                // Aggregate the updates by stateKey and path\r\n                const aggregatedLogs = logs.reduce((acc, log) => {\r\n                    const uniqueKey = `${log.stateKey}:${JSON.stringify(log.path)}`;\r\n                    const existing = acc.get(uniqueKey);\r\n\r\n                    if (existing) {\r\n                        // Update the existing entry with the most recent details\r\n                        existing.timeStamp = Math.max(\r\n                            existing.timeStamp,\r\n                            log.timeStamp,\r\n                        );\r\n                        existing.newValue = log.newValue; // Overwrite with the latest value\r\n                        existing.oldValue = existing.oldValue ?? log.oldValue; // Retain the initial oldValue\r\n                        existing.updateType = log.updateType; // Update to the most recent type\r\n                    } else {\r\n                        // Add the log if no existing match is found\r\n                        acc.set(uniqueKey, { ...(log as any) });\r\n                    }\r\n\r\n                    return acc;\r\n                }, new Map<string, typeof newUpdate>());\r\n\r\n                // Convert the aggregated map back to an array\r\n                return Array.from(aggregatedLogs.values());\r\n            });\r\n\r\n            saveToLocalStorage(\r\n                payload,\r\n                thisKey,\r\n                latestInitialOptionsRef.current,\r\n                sessionId,\r\n            );\r\n\r\n            if (middleware) {\r\n                middleware({ updateLog: stateLog, update: newUpdate });\r\n            }\r\n            if (latestInitialOptionsRef.current?.serverSync) {\r\n                const serverStateStore =\r\n                    getGlobalStore.getState().serverState[thisKey];\r\n                const serverSync = latestInitialOptionsRef.current?.serverSync;\r\n                setServerSyncActions(thisKey, {\r\n                    syncKey:\r\n                        typeof serverSync.syncKey == \"string\"\r\n                            ? serverSync.syncKey\r\n                            : serverSync.syncKey({ state: payload }),\r\n                    rollBackState: serverStateStore,\r\n                    actionTimeStamp: Date.now() + (serverSync.debounce ?? 3000),\r\n                    status: \"waiting\",\r\n                });\r\n            }\r\n\r\n            return payload;\r\n        });\r\n    };\r\n    if (!getGlobalStore.getState().updaterState[thisKey]) {\r\n        console.log(\"Initializing state for\", thisKey, stateObject); // Debug log\r\n        setUpdaterState(\r\n            thisKey,\r\n            createProxyHandler(\r\n                thisKey,\r\n                effectiveSetState,\r\n                componentIdRef.current,\r\n                sessionId,\r\n            ),\r\n        );\r\n        if (!getGlobalStore.getState().cogsStateStore[thisKey]) {\r\n            setState(thisKey, stateObject);\r\n        }\r\n        if (!getGlobalStore.getState().initialStateGlobal[thisKey]) {\r\n            updateInitialStateGlobal(thisKey, stateObject);\r\n        }\r\n    }\r\n\r\n    const updaterFinal = useMemo(() => {\r\n        // Create proxy with baseObject as target\r\n        return createProxyHandler<TStateObject>(\r\n            thisKey,\r\n            effectiveSetState,\r\n            componentIdRef.current,\r\n            sessionId,\r\n        );\r\n    }, [thisKey]);\r\n\r\n    return [getKeyState(thisKey), updaterFinal] as [\r\n        TStateObject,\r\n        StateObject<TStateObject>,\r\n    ];\r\n}\r\n\r\nfunction SignalRenderer({\r\n    proxy,\r\n}: {\r\n    proxy: { _path: string[]; _stateKey: string };\r\n}) {\r\n    const elementRef = useRef<HTMLSpanElement>(null);\r\n    const signalId = `${proxy._stateKey}-${proxy._path.join(\".\")}`;\r\n\r\n    useEffect(() => {\r\n        const element = elementRef.current;\r\n        if (!element || !element.parentElement) {\r\n            console.log(\"No element or parent\");\r\n            return;\r\n        }\r\n\r\n        const parentElement = element.parentElement;\r\n        const childNodes = Array.from(parentElement.childNodes);\r\n        const position = childNodes.indexOf(element);\r\n\r\n        // Get or create parent ID\r\n        let parentId = parentElement.getAttribute(\"data-parent-id\");\r\n        if (!parentId) {\r\n            parentId = `parent-${crypto.randomUUID()}`;\r\n            parentElement.setAttribute(\"data-parent-id\", parentId);\r\n        }\r\n\r\n        const instanceId = `instance-${crypto.randomUUID()}`;\r\n        const elementInfo = { instanceId, parentId, position };\r\n\r\n        getGlobalStore.getState().addSignalElement(signalId, elementInfo);\r\n\r\n        const textNode = document.createTextNode(\r\n            String(\r\n                getGlobalStore\r\n                    .getState()\r\n                    .getNestedState(proxy._stateKey, proxy._path),\r\n            ),\r\n        );\r\n        element.replaceWith(textNode);\r\n    }, [proxy._stateKey, proxy._path.join(\".\")]);\r\n\r\n    return createElement(\"span\", {\r\n        ref: elementRef,\r\n        style: { display: \"none\" },\r\n    });\r\n}\r\n\r\nfunction createProxyHandler<T>(\r\n    stateKey: string,\r\n    effectiveSetState: EffectiveSetState<T>,\r\n    componentId: string,\r\n    sessionId?: string,\r\n): StateObject<T> {\r\n    // ADDED: Enhanced cache with versioning\r\n    type CacheEntry = {\r\n        proxy: any;\r\n        stateVersion: number;\r\n    };\r\n    const shapeCache = new Map<string, CacheEntry>();\r\n    let stateVersion = 0;\r\n\r\n    // ADDED: Cache invalidation helper\r\n    const invalidateCachePath = (path: string[]) => {\r\n        const pathKey = path.join(\".\");\r\n        for (const [key] of shapeCache) {\r\n            if (key === pathKey || key.startsWith(pathKey + \".\")) {\r\n                shapeCache.delete(key);\r\n            }\r\n        }\r\n        stateVersion++;\r\n    };\r\n\r\n    const selectedIndexMap = new Map<string, number>();\r\n\r\n    const baseObj = {\r\n        removeValidation: (obj?: { validationKey?: string }) => {\r\n            if (obj?.validationKey) {\r\n                removeValidationError(obj.validationKey);\r\n            }\r\n        },\r\n\r\n        revertToInitialState: (obj?: { validationKey?: string }) => {\r\n            if (obj?.validationKey) {\r\n                removeValidationError(obj.validationKey);\r\n            }\r\n\r\n            const initialState =\r\n                getGlobalStore.getState().initialStateGlobal[stateKey];\r\n\r\n            // ADDED: Clear cache on revert\r\n            shapeCache.clear();\r\n            stateVersion++;\r\n\r\n            const newProxy = rebuildStateShape(initialState, []);\r\n\r\n            startTransition(() => {\r\n                setUpdaterState(stateKey, newProxy);\r\n                setState(stateKey, initialState);\r\n                const stateEntry = getGlobalStore\r\n                    .getState()\r\n                    .stateComponents.get(stateKey);\r\n                if (stateEntry) {\r\n                    stateEntry.components.forEach((component) => {\r\n                        component.forceUpdate();\r\n                    });\r\n                }\r\n                const initalOptionsGet = getInitialOptions(stateKey as string);\r\n                if (initalOptionsGet?.initState) {\r\n                    localStorage.removeItem(\r\n                        initalOptionsGet?.initState\r\n                            ? sessionId +\r\n                                  \"-\" +\r\n                                  stateKey +\r\n                                  \"-\" +\r\n                                  initalOptionsGet?.initState.localStorageKey\r\n                            : stateKey,\r\n                    );\r\n                }\r\n                localStorage.removeItem(stateKey);\r\n            });\r\n        },\r\n        updateInitialState: (newState: T) => {\r\n            // ADDED: Clear cache on initial state update\r\n            shapeCache.clear();\r\n            stateVersion++;\r\n\r\n            const newUpdaterState = createProxyHandler(\r\n                stateKey,\r\n                effectiveSetState,\r\n                componentId,\r\n                sessionId,\r\n            );\r\n            startTransition(() => {\r\n                updateInitialStateGlobal(stateKey, newState);\r\n                setUpdaterState(stateKey, newUpdaterState);\r\n                setState(stateKey, newState);\r\n                const stateEntry = getGlobalStore\r\n                    .getState()\r\n                    .stateComponents.get(stateKey);\r\n                if (stateEntry) {\r\n                    stateEntry.components.forEach((component) => {\r\n                        component.forceUpdate();\r\n                    });\r\n                }\r\n                localStorage.removeItem(stateKey);\r\n            });\r\n            return {\r\n                fetchId: (field: keyof T) => newUpdaterState.get()[field],\r\n            };\r\n        },\r\n        _initialState: getGlobalStore.getState().initialStateGlobal[stateKey],\r\n        _serverState: getGlobalStore.getState().serverState[stateKey],\r\n        _isLoading: getGlobalStore.getState().isLoadingGlobal[stateKey],\r\n        _isServerSynced: () => {\r\n            const serverState = getGlobalStore.getState().serverState[stateKey];\r\n            return Boolean(\r\n                serverState && isDeepEqual(serverState, getKeyState(stateKey)),\r\n            );\r\n        },\r\n    };\r\n\r\n    function rebuildStateShape(\r\n        currentState: T,\r\n        path: string[] = [],\r\n        meta?: { filtered?: string[][]; validIndices?: number[] },\r\n    ): any {\r\n        const cacheKey = path.map(String).join(\".\");\r\n\r\n        // MODIFIED: Cache check with version\r\n        const cachedEntry = shapeCache.get(cacheKey);\r\n        if (cachedEntry?.stateVersion === stateVersion) {\r\n            return cachedEntry.proxy;\r\n        }\r\n\r\n        const handler = {\r\n            get(target: any, prop: string) {\r\n                if (prop !== \"then\" && prop !== \"$get\") {\r\n                    const currentPath = path.join(\".\");\r\n                    const fullComponentId = `${stateKey}////${componentId}`;\r\n                    const stateEntry = getGlobalStore\r\n                        .getState()\r\n                        .stateComponents.get(stateKey);\r\n                    if (stateEntry && currentPath) {\r\n                        const component =\r\n                            stateEntry.components.get(fullComponentId);\r\n                        if (component) {\r\n                            component.paths.add(currentPath);\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if (prop === \"lastSynced\") {\r\n                    const syncKey = `${stateKey}:${path.join(\".\")}`;\r\n                    return getGlobalStore.getState().getSyncInfo(syncKey);\r\n                }\r\n\r\n                if (prop === \"_selected\") {\r\n                    const parentPath = path.slice(0, -1);\r\n                    const parentKey = parentPath.join(\".\");\r\n                    const parent = getGlobalStore\r\n                        .getState()\r\n                        .getNestedState(stateKey, parentPath);\r\n                    if (Array.isArray(parent)) {\r\n                        const currentIndex = Number(path[path.length - 1]);\r\n                        return currentIndex === selectedIndexMap.get(parentKey);\r\n                    }\r\n                    return undefined;\r\n                }\r\n                if (prop == \"getLocalStorage\") {\r\n                    return (key: string) =>\r\n                        loadFromLocalStorage(\r\n                            sessionId + \"-\" + stateKey + \"-\" + key,\r\n                        );\r\n                }\r\n                if (prop === \"setSelected\") {\r\n                    return (value: boolean) => {\r\n                        const parentPath = path.slice(0, -1);\r\n                        const thisIndex = Number(path[path.length - 1]);\r\n                        const parentKey = parentPath.join(\".\");\r\n                        if (value) {\r\n                            selectedIndexMap.set(parentKey, thisIndex);\r\n                        } else {\r\n                            // Optional: clear selection if false\r\n                            selectedIndexMap.delete(parentKey);\r\n                        }\r\n                        const nested = getGlobalStore\r\n                            .getState()\r\n                            .getNestedState(stateKey, [...parentPath]);\r\n                        updateFn(effectiveSetState, nested, parentPath);\r\n\r\n                        // ADDED: Invalidate cache for parent path\r\n                        invalidateCachePath(parentPath);\r\n                    };\r\n                }\r\n\r\n                if (path.length == 0) {\r\n                    if (prop == \"_componentId\") return componentId;\r\n                    if (prop === \"_initialState\")\r\n                        return getGlobalStore.getState().initialStateGlobal[\r\n                            stateKey\r\n                        ];\r\n                    if (prop === \"_serverState\")\r\n                        return getGlobalStore.getState().serverState[stateKey];\r\n                    if (prop === \"_isLoading\")\r\n                        return getGlobalStore.getState().isLoadingGlobal[\r\n                            stateKey\r\n                        ];\r\n                    if (prop === \"revertToInitialState\")\r\n                        return baseObj.revertToInitialState;\r\n                    if (prop === \"updateInitialState\")\r\n                        return baseObj.updateInitialState;\r\n                    if (prop === \"removeValidation\")\r\n                        return baseObj.removeValidation;\r\n                }\r\n\r\n                if (prop === \"validationWrapper\") {\r\n                    return ({\r\n                        children,\r\n                        hideMessage,\r\n                    }: {\r\n                        children: React.ReactNode;\r\n                        hideMessage?: boolean;\r\n                    }) => (\r\n                        <ValidationWrapper\r\n                            formOpts={\r\n                                hideMessage\r\n                                    ? { validation: { message: \"\" } }\r\n                                    : undefined\r\n                            }\r\n                            path={path}\r\n                            validationKey={\r\n                                getGlobalStore\r\n                                    .getState()\r\n                                    .getInitialOptions(stateKey)\r\n                                    ?.validationKey || \"\"\r\n                            }\r\n                            stateKey={stateKey}\r\n                            validIndices={meta?.validIndices}\r\n                        >\r\n                            {children}\r\n                        </ValidationWrapper>\r\n                    );\r\n                }\r\n\r\n                if (prop === \"_stateKey\") return stateKey;\r\n                if (prop === \"_path\") return path;\r\n                if (prop === \"_isServerSynced\") return baseObj._isServerSynced;\r\n\r\n                if (prop === \"update\") {\r\n                    return (payload: UpdateArg<T>, opts?: UpdateOpts) => {\r\n                        // ADDED: Invalidate cache on update\r\n                        invalidateCachePath(path);\r\n                        updateFn(effectiveSetState, payload, path, \"\");\r\n                    };\r\n                }\r\n\r\n                if (prop === \"get\") {\r\n                    return () =>\r\n                        getGlobalStore\r\n                            .getState()\r\n                            .getNestedState(stateKey, path);\r\n                }\r\n\r\n                if (prop === \"$get\") {\r\n                    return () =>\r\n                        $cogsSignal({ _stateKey: stateKey, _path: path });\r\n                }\r\n\r\n                if (prop === \"formElement\") {\r\n                    return (\r\n                        validationKey: string,\r\n                        child: FormControl<T>,\r\n                        formOpts?: FormOptsType,\r\n                    ) => {\r\n                        return (\r\n                            <FormControlComponent<T>\r\n                                setState={effectiveSetState}\r\n                                validationKey={validationKey}\r\n                                stateKey={stateKey}\r\n                                path={path}\r\n                                child={child}\r\n                                formOpts={formOpts}\r\n                            />\r\n                        );\r\n                    };\r\n                }\r\n\r\n                if (Array.isArray(currentState)) {\r\n                    if (prop === \"getSelected\") {\r\n                        return () => {\r\n                            const selectedIndex = selectedIndexMap.get(\r\n                                path.join(\".\"),\r\n                            );\r\n                            if (selectedIndex === undefined) return undefined;\r\n                            return rebuildStateShape(\r\n                                currentState[selectedIndex],\r\n                                [...path, selectedIndex.toString()],\r\n                                meta,\r\n                            );\r\n                        };\r\n                    }\r\n\r\n                    if (prop === \"$get\") {\r\n                        return () =>\r\n                            $cogsSignal({ _stateKey: stateKey, _path: path });\r\n                    }\r\n                    if (prop === \"stateEach\") {\r\n                        return (\r\n                            callbackfn: (\r\n                                value: InferArrayElement<T>,\r\n                                setter: StateObject<InferArrayElement<T>>,\r\n                                index: number,\r\n                                array: T,\r\n                                arraySetter: StateObject<T>,\r\n                            ) => void,\r\n                        ) => {\r\n                            const isFiltered = meta?.filtered?.some(\r\n                                (p) => p.join(\".\") === path.join(\".\"),\r\n                            );\r\n                            const arrayToMap = isFiltered\r\n                                ? currentState\r\n                                : getGlobalStore\r\n                                      .getState()\r\n                                      .getNestedState(stateKey, path);\r\n\r\n                            // ADDED: Clear shape cache for array operations\r\n                            shapeCache.clear();\r\n                            stateVersion++;\r\n\r\n                            return arrayToMap.map((val: any, index: number) => {\r\n                                const thisIndex =\r\n                                    isFiltered && val.__origIndex\r\n                                        ? val.__origIndex\r\n                                        : index;\r\n                                const elementProxy = rebuildStateShape(\r\n                                    val,\r\n                                    [...path, thisIndex.toString()],\r\n                                    meta,\r\n                                );\r\n                                return callbackfn(\r\n                                    val,\r\n                                    elementProxy,\r\n                                    index,\r\n                                    currentState as any,\r\n                                    rebuildStateShape(\r\n                                        currentState as any,\r\n                                        path,\r\n                                        meta,\r\n                                    ),\r\n                                );\r\n                            });\r\n                        };\r\n                    }\r\n\r\n                    if (prop === \"stateFlattenOn\") {\r\n                        return (fieldName: string) => {\r\n                            const isFiltered = meta?.filtered?.some(\r\n                                (p) => p.join(\".\") === path.join(\".\"),\r\n                            );\r\n                            const arrayToMap = isFiltered\r\n                                ? currentState\r\n                                : getGlobalStore\r\n                                      .getState()\r\n                                      .getNestedState(stateKey, path);\r\n\r\n                            // ADDED: Clear shape cache for flattening operation\r\n                            shapeCache.clear();\r\n                            stateVersion++;\r\n\r\n                            const flattenedResults = arrayToMap.flatMap(\r\n                                (val: any, index: number) => {\r\n                                    return val[fieldName] ?? [];\r\n                                },\r\n                            );\r\n\r\n                            return rebuildStateShape(\r\n                                flattenedResults,\r\n                                [...path, \"[*]\", fieldName],\r\n                                meta,\r\n                            );\r\n                        };\r\n                    }\r\n\r\n                    if (prop === \"findWith\") {\r\n                        return (\r\n                            thisKey: keyof InferArrayElement<T>,\r\n                            thisValue: InferArrayElement<T>[keyof InferArrayElement<T>],\r\n                        ) => {\r\n                            const foundIndex = currentState.findIndex(\r\n                                (obj: any) => obj[thisKey] === thisValue,\r\n                            );\r\n                            if (foundIndex === -1) return undefined;\r\n                            const foundValue = currentState[foundIndex];\r\n                            const newPath = [...path, foundIndex.toString()];\r\n\r\n                            // ADDED: Clear cache for find operation\r\n                            shapeCache.clear();\r\n                            stateVersion++;\r\n\r\n                            return rebuildStateShape(foundValue, newPath);\r\n                        };\r\n                    }\r\n\r\n                    if (prop === \"index\") {\r\n                        return (index: number) => {\r\n                            const indexValue = currentState[index];\r\n                            return rebuildStateShape(indexValue, [\r\n                                ...path,\r\n                                index.toString(),\r\n                            ]);\r\n                        };\r\n                    }\r\n\r\n                    if (prop === \"insert\") {\r\n                        return (payload: UpdateArg<T>) => {\r\n                            // ADDED: Invalidate cache on insert\r\n                            invalidateCachePath(path);\r\n                            pushFunc(\r\n                                effectiveSetState,\r\n                                payload,\r\n                                path,\r\n                                stateKey,\r\n                            );\r\n                            return rebuildStateShape(\r\n                                getGlobalStore.getState().cogsStateStore[\r\n                                    stateKey\r\n                                ],\r\n                                [],\r\n                            );\r\n                        };\r\n                    }\r\n\r\n                    if (prop === \"uniqueInsert\") {\r\n                        return (\r\n                            payload: UpdateArg<T>,\r\n                            fields?: (keyof InferArrayElement<T>)[],\r\n                        ) => {\r\n                            const currentArray = getGlobalStore\r\n                                .getState()\r\n                                .getNestedState(stateKey, path) as any[];\r\n                            const newValue = isFunction<T>(payload)\r\n                                ? payload(currentArray as any)\r\n                                : (payload as any);\r\n\r\n                            const isUnique = !currentArray.some((item) => {\r\n                                if (fields) {\r\n                                    return fields.every((field) =>\r\n                                        isDeepEqual(\r\n                                            item[field],\r\n                                            newValue[field],\r\n                                        ),\r\n                                    );\r\n                                }\r\n                                return isDeepEqual(item, newValue);\r\n                            });\r\n\r\n                            if (isUnique) {\r\n                                // ADDED: Invalidate cache on unique insert\r\n                                invalidateCachePath(path);\r\n                                pushFunc(\r\n                                    effectiveSetState,\r\n                                    newValue,\r\n                                    path,\r\n                                    stateKey,\r\n                                );\r\n                            }\r\n                        };\r\n                    }\r\n\r\n                    if (prop === \"cut\") {\r\n                        return (\r\n                            index: number,\r\n                            options?: { waitForSync?: boolean },\r\n                        ) => {\r\n                            if (options?.waitForSync) return;\r\n                            // ADDED: Invalidate cache on cut\r\n                            invalidateCachePath(path);\r\n                            cutFunc(effectiveSetState, path, stateKey, index);\r\n                        };\r\n                    }\r\n\r\n                    if (prop === \"stateFilter\") {\r\n                        return (\r\n                            callbackfn: (\r\n                                value: InferArrayElement<T>,\r\n                                index: number,\r\n                            ) => boolean,\r\n                        ) => {\r\n                            const newVal = currentState.map(\r\n                                (v: any, i: number) => ({\r\n                                    ...v,\r\n                                    __origIndex: i.toString(),\r\n                                }),\r\n                            );\r\n\r\n                            const validIndices: number[] = [];\r\n                            const filteredArray: Array<InferArrayElement<T>> =\r\n                                [];\r\n\r\n                            for (let i = 0; i < newVal.length; i++) {\r\n                                if (callbackfn(newVal[i], i)) {\r\n                                    validIndices.push(i);\r\n                                    filteredArray.push(newVal[i]);\r\n                                }\r\n                            }\r\n\r\n                            // ADDED: Clear cache for filter operation\r\n                            shapeCache.clear();\r\n                            stateVersion++;\r\n                            return rebuildStateShape(\r\n                                filteredArray as any,\r\n                                path,\r\n                                {\r\n                                    filtered: [...(meta?.filtered || []), path],\r\n                                    validIndices, // Pass through the meta\r\n                                },\r\n                            );\r\n                        };\r\n                    }\r\n                }\r\n\r\n                const nextPath = [...path, prop];\r\n                const nextValue = getGlobalStore\r\n                    .getState()\r\n                    .getNestedState(stateKey, nextPath);\r\n                return rebuildStateShape(nextValue, nextPath, meta);\r\n            },\r\n        };\r\n\r\n        const proxyInstance = new Proxy(baseObj as StateObject<T>, handler);\r\n\r\n        shapeCache.set(cacheKey, {\r\n            proxy: proxyInstance,\r\n            stateVersion: stateVersion,\r\n        });\r\n\r\n        return proxyInstance;\r\n    }\r\n\r\n    return rebuildStateShape(\r\n        getGlobalStore.getState().getNestedState(stateKey, []),\r\n    );\r\n}\r\n\r\nexport function $cogsSignal(proxy: { _path: string[]; _stateKey: string }) {\r\n    return createElement(SignalRenderer, { proxy });\r\n}\r\n\r\nexport function $cogsSignalStore(proxy: {\r\n    _path: string[];\r\n    _stateKey: string;\r\n}) {\r\n    const value = useSyncExternalStore(\r\n        (notify) => {\r\n            const stateEntry = getGlobalStore\r\n                .getState()\r\n                .stateComponents.get(proxy._stateKey) || {\r\n                components: new Map(),\r\n            };\r\n            stateEntry.components.set(proxy._stateKey, {\r\n                forceUpdate: notify,\r\n                paths: new Set([proxy._path.join(\".\")]),\r\n            });\r\n            return () => stateEntry.components.delete(proxy._stateKey);\r\n        },\r\n        () =>\r\n            getGlobalStore\r\n                .getState()\r\n                .getNestedState(proxy._stateKey, proxy._path),\r\n    );\r\n    return createElement(\"text\", {}, String(value));\r\n}\r\n"],"names":["addStateOptions","initialState","formElements","zodSchema","setAndMergeOptions","stateKey","newOptions","getInitialOptions","getGlobalStore","setInitialStateOptions","initialOptions","setOptions","options","initialOptionsPart","initialOptionsPartState","mergedOptions","needToAdd","key","createCogsState","newInitialState","statePart","transformStateFunc","useCogsState","componentId","useState","uuidv4","thiState","partialState","state","updater","useCogsStateFn","setCogsOptions","setUpdaterState","setState","getKeyState","getValidationErrors","setStateLog","updateInitialStateGlobal","addValidationError","removeValidationError","setServerSyncActions","loadFromLocalStorage","localStorageKey","storedData","error","saveToLocalStorage","thisKey","currentInitialOptions","sessionId","data","storageKey","updateGlobalState","newState","effectiveSetState","updates","createProxyHandler","startTransition","notifyComponents","stateEntry","component","update","stateObject","serverSync","localStorage","middleware","reactiveDeps","initState","syncUpdate","reactiveForce","forceUpdate","useCogsConfig","noStateKey","stateLog","componentUpdatesRef","useRef","componentIdRef","latestInitialOptionsRef","useEffect","prevState","syncKey","dependencies","localData","depsKey","newStateOrFunction","path","updateObj","validationKey","pathKey","prevValue","payload","isFunction","signalId","elements","newValue","getNestedValue","parentId","position","parent","childNodes","arrayWithoutIndex","k","v","length","newKey","oldValue","pathToCheck","depsResult","isDeepEqual","newUpdate","prevLogs","aggregatedLogs","acc","log","uniqueKey","existing","serverStateStore","updaterFinal","useMemo","SignalRenderer","proxy","elementRef","element","parentElement","elementInfo","textNode","createElement","shapeCache","stateVersion","invalidateCachePath","selectedIndexMap","baseObj","obj","newProxy","rebuildStateShape","initalOptionsGet","newUpdaterState","field","serverState","currentState","meta","cacheKey","cachedEntry","handler","target","prop","currentPath","fullComponentId","parentPath","parentKey","value","thisIndex","nested","updateFn","children","hideMessage","jsx","ValidationWrapper","opts","$cogsSignal","child","formOpts","FormControlComponent","selectedIndex","callbackfn","isFiltered","p","arrayToMap","val","index","elementProxy","fieldName","flattenedResults","thisValue","foundIndex","foundValue","newPath","indexValue","pushFunc","fields","currentArray","item","cutFunc","newVal","i","validIndices","filteredArray","nextPath","nextValue","proxyInstance","$cogsSignalStore","useSyncExternalStore","notify"],"mappings":"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"}