{"version":3,"file":"CogsState.jsx","sources":["../src/CogsState.tsx"],"sourcesContent":["'use client';\r\nimport { pluginStore } from './pluginStore';\r\nimport { FormWrapperParams, type CogsPlugin } from './plugins';\r\nimport {\r\n  createElement,\r\n  startTransition,\r\n  useCallback,\r\n  useEffect,\r\n  useLayoutEffect,\r\n  useMemo,\r\n  useRef,\r\n  useState,\r\n  type CSSProperties,\r\n  type ReactNode,\r\n  type RefObject,\r\n} from 'react';\r\n\r\nimport {\r\n  transformStateFunc,\r\n  isFunction,\r\n  type GenericObject,\r\n  isArray,\r\n  getDifferences,\r\n} from './utility.js';\r\nimport {\r\n  FormElementWrapper,\r\n  IsolatedComponentWrapper,\r\n  MemoizedCogsItemWrapper,\r\n  ValidationWrapper,\r\n} from './Components.js';\r\nimport { isDeepEqual } from './utility.js';\r\nimport superjson from 'superjson';\r\nimport { v4 as uuidv4 } from 'uuid';\r\n\r\nimport {\r\n  getGlobalStore,\r\n  shadowStateStore,\r\n  updateShadowTypeInfo,\r\n  ValidationError,\r\n  ValidationSeverity,\r\n  ValidationStatus,\r\n  type ComponentsType,\r\n} from './store.js';\r\nimport { useCogsConfig } from './CogsStateClient.js';\r\nimport { Operation } from 'fast-json-patch';\r\n\r\nimport * as z3 from 'zod/v3';\r\nimport * as z4 from 'zod/v4';\r\nimport { get } from 'http';\r\nimport { runValidation } from './validation';\r\n\r\nexport type Prettify<T> = T extends any ? { [K in keyof T]: T[K] } : never;\r\n\r\nexport type VirtualViewOptions = {\r\n  itemHeight?: number;\r\n  overscan?: number;\r\n  stickToBottom?: boolean;\r\n  dependencies?: any[];\r\n  scrollStickTolerance?: number;\r\n};\r\n\r\n// The result now returns a real StateObject\r\nexport type VirtualStateObjectResult<T extends any[]> = {\r\n  virtualState: StateObject<T>;\r\n  virtualizerProps: {\r\n    outer: { ref: RefObject<HTMLDivElement>; style: CSSProperties };\r\n    inner: { style: CSSProperties };\r\n    list: { style: CSSProperties };\r\n  };\r\n  scrollToBottom: (behavior?: ScrollBehavior) => void;\r\n  scrollToIndex: (index: number, behavior?: ScrollBehavior) => void;\r\n};\r\n\r\nexport type SyncInfo = {\r\n  timeStamp: number;\r\n  userId: number;\r\n};\r\n\r\nexport type FormElementParams<T> = StateObject<T> & {\r\n  $inputProps: {\r\n    ref?: React.RefObject<any>;\r\n    value?: T extends boolean ? never : T;\r\n    onChange?: (\r\n      event: React.ChangeEvent<\r\n        HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement\r\n      >\r\n    ) => void;\r\n    onBlur?: (\r\n      event: React.FocusEvent<\r\n        HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement\r\n      >\r\n    ) => void;\r\n  };\r\n};\r\n\r\nexport type StateKeys = string;\r\n\r\ntype findWithFuncType<U> = (\r\n  thisKey: keyof U,\r\n  thisValue: U[keyof U]\r\n) => EndType<U> & StateObject<U>;\r\n\r\ntype CutFunctionType<T> = (\r\n  index?: number,\r\n  options?: { waitForSync?: boolean }\r\n) => StateObject<T>;\r\n\r\nexport type InferArrayElement<T> = T extends (infer U)[] ? U : never;\r\n\r\nexport type StreamOptions<T, R = T> = {\r\n  bufferSize?: number;\r\n  flushInterval?: number;\r\n  bufferStrategy?: 'sliding' | 'dropping' | 'accumulate';\r\n  store?: (buffer: T[]) => R | R[];\r\n  onFlush?: (buffer: T[]) => void;\r\n};\r\n\r\nexport type StreamHandle<T> = {\r\n  write: (data: T) => void;\r\n  writeMany: (data: T[]) => void;\r\n  flush: () => void;\r\n  close: () => void;\r\n  pause: () => void;\r\n  resume: () => void;\r\n};\r\n\r\nexport type ArrayEndType<TShape extends unknown> = {\r\n  $stream: <T = Prettify<InferArrayElement<TShape>>, R = T>(\r\n    options?: StreamOptions<T, R>\r\n  ) => StreamHandle<T>;\r\n  $findWith: findWithFuncType<Prettify<InferArrayElement<TShape>>>;\r\n  $index: (index: number) => StateObject<\r\n    Prettify<InferArrayElement<TShape>>\r\n  > & {\r\n    $insert: InsertTypeObj<Prettify<InferArrayElement<TShape>>>;\r\n    $cut: CutFunctionType<TShape>;\r\n    $_index: number;\r\n  } & EndType<Prettify<InferArrayElement<TShape>>>;\r\n  $insert: InsertType<Prettify<InferArrayElement<TShape>>>;\r\n  $insertMany: (payload: InferArrayElement<TShape>[]) => void;\r\n  $cut: CutFunctionType<TShape>;\r\n  $cutSelected: () => void;\r\n  $cutByValue: (value: string | number | boolean) => void;\r\n  $toggleByValue: (value: string | number | boolean) => void;\r\n  $stateSort: (\r\n    compareFn: (\r\n      a: Prettify<InferArrayElement<TShape>>,\r\n      b: Prettify<InferArrayElement<TShape>>\r\n    ) => number\r\n  ) => ArrayEndType<TShape>;\r\n  $useVirtualView: (\r\n    options: VirtualViewOptions\r\n  ) => VirtualStateObjectResult<Prettify<InferArrayElement<TShape>>[]>;\r\n\r\n  $stateList: (\r\n    callbackfn: (\r\n      setter: StateObject<Prettify<InferArrayElement<TShape>>>,\r\n      index: number,\r\n      arraySetter: StateObject<TShape>\r\n    ) => void\r\n  ) => any;\r\n  $stateMap: <U>(\r\n    callbackfn: (\r\n      setter: StateObject<Prettify<InferArrayElement<TShape>>>,\r\n      index: number,\r\n      arraySetter: StateObject<TShape>\r\n    ) => U\r\n  ) => U[];\r\n\r\n  $stateFlattenOn: <K extends keyof Prettify<InferArrayElement<TShape>>>(\r\n    field: K\r\n  ) => StateObject<InferArrayElement<Prettify<InferArrayElement<TShape>>[K]>[]>;\r\n  $uniqueInsert: (\r\n    payload: InsertParams<Prettify<InferArrayElement<TShape>>>,\r\n    fields?: (keyof Prettify<InferArrayElement<TShape>>)[],\r\n    onMatch?: (existingItem: any) => any\r\n  ) => void;\r\n  $stateFind: (\r\n    callbackfn: (\r\n      value: Prettify<InferArrayElement<TShape>>,\r\n      index: number\r\n    ) => boolean\r\n  ) => StateObject<Prettify<InferArrayElement<TShape>>> | undefined;\r\n  $stateFilter: (\r\n    callbackfn: (\r\n      value: Prettify<InferArrayElement<TShape>>,\r\n      index: number\r\n    ) => void\r\n  ) => ArrayEndType<TShape>;\r\n  $getSelected: () =>\r\n    | StateObject<Prettify<InferArrayElement<TShape>>>\r\n    | undefined;\r\n  $clearSelected: () => void;\r\n  $getSelectedIndex: () => number;\r\n  $last: () => StateObject<Prettify<InferArrayElement<TShape>>> | undefined;\r\n} & EndType<TShape>;\r\n\r\nexport type FormOptsType = {\r\n  validation?: {\r\n    hideMessage?: boolean;\r\n    message?: string;\r\n\r\n    props?: GenericObject;\r\n    disable?: boolean;\r\n  };\r\n\r\n  debounceTime?: number;\r\n  sync?: {\r\n    allowInvalidValues?: boolean; // default: false\r\n  };\r\n};\r\n\r\nexport type FormControl<T> = (obj: FormElementParams<T>) => JSX.Element;\r\n\r\nexport type UpdateArg<S> = S | ((prevState: S) => S);\r\nexport type InsertParams<S> =\r\n  | S\r\n  | ((prevState: { state: S; uuid: string }) => S);\r\nexport type UpdateType<T> = (payload: UpdateArg<T>) => { synced: () => void };\r\n\r\nexport type InsertType<T> = (payload: InsertParams<T>, index?: number) => void;\r\nexport type InsertTypeObj<T> = (payload: InsertParams<T>) => void;\r\n\r\ntype EffectFunction<T, R> = (state: T, deps: any[]) => R;\r\nexport type EndType<T, IsArrayElement = false> = {\r\n  $getPluginMetaData: (pluginName: string) => Record<string, any>;\r\n  $addPluginMetaData: (key: string, data: Record<string, any>) => void;\r\n  $removePluginMetaData: (key: string) => void;\r\n  $setOptions: (options: OptionsType<T>) => void;\r\n  $useFocusedFormElement: () => {\r\n    path: string[];\r\n    ref: React.RefObject<any>;\r\n  } | null;\r\n  $addZodValidation: (\r\n    errors: ValidationError[],\r\n    source?: 'client' | 'sync_engine' | 'api'\r\n  ) => void;\r\n  $clearZodValidation: (paths?: string[]) => void;\r\n  $applyOperation: (\r\n    operation: UpdateTypeDetail,\r\n    metaData?: Record<string, any>\r\n  ) => void;\r\n  $applyJsonPatch: (patches: any[]) => void;\r\n  $update: UpdateType<T>;\r\n  $_path: string[];\r\n  $_stateKey: string;\r\n  $isolate: (\r\n    renderFn: (state: StateObject<T>) => React.ReactNode\r\n  ) => JSX.Element;\r\n  $formElement: (control: FormControl<T>, opts?: FormOptsType) => JSX.Element;\r\n  $get: () => T;\r\n  $$get: () => T;\r\n  $$derive: <R>(fn: EffectFunction<T, R>) => R;\r\n  $_status: 'fresh' | 'dirty' | 'synced' | 'restored' | 'unknown';\r\n  $getStatus: () => 'fresh' | 'dirty' | 'synced' | 'restored' | 'unknown';\r\n  $showValidationErrors: () => string[];\r\n  $setValidation: (ctx: string) => void;\r\n  $removeValidation: (ctx: string) => void;\r\n  $ignoreFields: (fields: string[]) => StateObject<T>;\r\n  $isSelected: boolean;\r\n  $setSelected: (value: boolean) => void;\r\n  $toggleSelected: () => void;\r\n  $formInput: {\r\n    setDisabled: (isDisabled: boolean) => void;\r\n    focus: () => void;\r\n    blur: () => void;\r\n    scrollIntoView: (options?: ScrollIntoViewOptions) => void;\r\n    click: () => void;\r\n    selectText: () => void;\r\n  };\r\n  $removeStorage: () => void;\r\n  $sync: () => void;\r\n  $validationWrapper: ({\r\n    children,\r\n    hideMessage,\r\n  }: {\r\n    children: React.ReactNode;\r\n    hideMessage?: boolean;\r\n  }) => JSX.Element;\r\n  $lastSynced?: SyncInfo;\r\n} & (IsArrayElement extends true ? { $cutThis: () => void } : {});\r\n\r\nexport type StateObject<T> = (T extends any[]\r\n  ? ArrayEndType<T>\r\n  : T extends Record<string, unknown> | object\r\n    ? { [K in keyof T]-?: StateObject<T[K]> }\r\n    : T extends string | number | boolean | null\r\n      ? EndType<T, true>\r\n      : never) &\r\n  EndType<T, true> & {\r\n    $toggle: T extends boolean ? () => void : never;\r\n\r\n    $_componentId: string | null;\r\n    $getComponents: () => ComponentsType;\r\n\r\n    $_initialState: T;\r\n    $updateInitialState: (newState: T | null) => {\r\n      fetchId: (field: keyof T) => string | number;\r\n    };\r\n    $initializeAndMergeShadowState: (newState: any | null) => void;\r\n    $_isLoading: boolean;\r\n    $_serverState: T;\r\n    $revertToInitialState: (obj?: { validationKey?: string }) => T;\r\n\r\n    $middleware: (\r\n      middles: ({\r\n        updateLog,\r\n        update,\r\n      }: {\r\n        updateLog: UpdateTypeDetail[] | undefined;\r\n        update: UpdateTypeDetail;\r\n      }) => void\r\n    ) => void;\r\n\r\n    $getLocalStorage: (key: string) => LocalStorageData<T> | null;\r\n  };\r\n\r\nexport type CogsUpdate<T extends unknown> = UpdateType<T>;\r\ntype EffectiveSetStateArg<\r\n  T,\r\n  UpdateType extends 'update' | 'insert' | 'cut',\r\n> = UpdateType extends 'insert'\r\n  ? T extends any[]\r\n    ? InsertParams<InferArrayElement<T>>\r\n    : never\r\n  : UpdateArg<T>;\r\n\r\ntype UpdateOptions = {\r\n  updateType: 'insert' | 'cut' | 'update' | 'insert_many';\r\n  validationTrigger?: 'onBlur' | 'onChange' | 'programmatic';\r\n  itemId?: string;\r\n  index?: number;\r\n  metaData?: Record<string, any>;\r\n};\r\ntype EffectiveSetState<TStateObject> = (\r\n  newStateOrFunction:\r\n    | EffectiveSetStateArg<TStateObject, 'update'>\r\n    | EffectiveSetStateArg<TStateObject, 'insert'>\r\n    | null,\r\n  path: string[],\r\n  updateObj: UpdateOptions, // Now includes itemId\r\n  validationKey?: string\r\n) => void;\r\n\r\nexport type UpdateTypeDetail = {\r\n  timeStamp: number;\r\n  stateKey: string;\r\n  updateType: 'update' | 'insert' | 'cut' | 'insert_many';\r\n  path: string[];\r\n  status: 'new' | 'sent' | 'synced';\r\n  oldValue: any;\r\n  newValue: any;\r\n  userId?: number;\r\n\r\n  itemId?: string;\r\n  insertAfterId?: string;\r\n  metaData?: Record<string, any>;\r\n};\r\nexport type ReactivityUnion = 'none' | 'component' | 'deps' | 'all';\r\nexport type ReactivityType =\r\n  | 'none'\r\n  | 'component'\r\n  | 'deps'\r\n  | 'all'\r\n  | Array<Prettify<'none' | 'component' | 'deps' | 'all'>>;\r\n\r\n// Define the return type of the sync hook locally\r\n\r\ntype ValidationOptionsType = {\r\n  key?: string;\r\n  zodSchemaV3?: z3.ZodType<any, any, any>;\r\n  zodSchemaV4?: z4.ZodType<any, any, any>;\r\n  onBlur?: 'error' | 'warning';\r\n  onChange?: 'error' | 'warning';\r\n  blockSync?: boolean;\r\n};\r\n\r\ntype SyncOptionsType<TApiParams> = {\r\n  apiParams: TApiParams;\r\n  stateKey?: string;\r\n  stateRoom:\r\n    | number\r\n    | string\r\n    | (({ clientId }: { clientId: string }) => string | null);\r\n  connect?: boolean;\r\n  inMemoryState?: boolean;\r\n};\r\n\r\nexport type CreateStateOptionsType<\r\n  T extends unknown = unknown,\r\n  TPlugins extends readonly CogsPlugin<any, any, any, any, any>[] = [],\r\n> = {\r\n  formElements?: FormsElementsType<T, TPlugins>;\r\n  validation?: ValidationOptionsType;\r\n  plugins?: TPlugins;\r\n};\r\nexport type OptionsType<\r\n  T extends unknown = unknown,\r\n  TApiParams = never,\r\n> = CreateStateOptionsType & {\r\n  log?: boolean;\r\n  componentId?: string;\r\n  syncOptions?: SyncOptionsType<TApiParams>;\r\n\r\n  serverState?: {\r\n    id?: string | number;\r\n    data?: T;\r\n    status?: 'pending' | 'error' | 'success' | 'loading';\r\n    timestamp?: number;\r\n    merge?:\r\n      | boolean\r\n      | {\r\n          strategy: 'append' | 'prepend' | 'diff';\r\n          key?: string;\r\n        };\r\n  };\r\n\r\n  sync?: {\r\n    action: (state: T) => Promise<{\r\n      success: boolean;\r\n      data?: any;\r\n      error?: any;\r\n      errors?: Array<{\r\n        path: (string | number)[];\r\n        message: string;\r\n      }>;\r\n    }>;\r\n    onSuccess?: (data: any) => void;\r\n    onError?: (error: any) => void;\r\n  };\r\n  middleware?: ({ update }: { update: UpdateTypeDetail }) => void;\r\n\r\n  localStorage?: {\r\n    key: string | ((state: T) => string);\r\n    onChange?: (state: T) => void;\r\n  };\r\n\r\n  reactiveDeps?: (state: T) => any[] | true;\r\n  reactiveType?: ReactivityType;\r\n  syncUpdate?: Partial<UpdateTypeDetail>;\r\n\r\n  defaultState?: T;\r\n\r\n  dependencies?: any[];\r\n};\r\n\r\nexport type FormsElementsType<\r\n  TState,\r\n  TPlugins extends readonly CogsPlugin<any, any, any, any, any>[] = [],\r\n> = {\r\n  // These optional, built-in wrappers are unchanged.\r\n  validation?: (options: {\r\n    children: React.ReactNode;\r\n    status: ValidationStatus;\r\n    severity: ValidationSeverity;\r\n    hasErrors: boolean;\r\n    hasWarnings: boolean;\r\n    allErrors: ValidationError[];\r\n    path: string[];\r\n    message?: string;\r\n    getData?: () => TState;\r\n  }) => React.ReactNode;\r\n  syncRender?: (options: {\r\n    children: React.ReactNode;\r\n    time: number;\r\n    data?: TState;\r\n    key?: string;\r\n  }) => React.ReactNode;\r\n} & {\r\n  // For each plugin `P` in the TPlugins array...\r\n  [P in TPlugins[number] as P['name']]?: P['formWrapper'] extends (\r\n    // ...check if its `formWrapper` property is a function...\r\n    arg: any\r\n  ) => any\r\n    ? // ...if it is, infer the type of its FIRST PARAMETER. This is the key.\r\n      Parameters<P['formWrapper']>[0]\r\n    : // Otherwise, the type is invalid.\r\n      never;\r\n};\r\nexport type CogsInitialState<T> =\r\n  | {\r\n      initialState: T;\r\n    }\r\n  | CreateStateOptionsType<T>;\r\n\r\nexport type TransformedStateType<T> = {\r\n  [P in keyof T]: T[P] extends CogsInitialState<infer U> ? U : T[P];\r\n};\r\n\r\nconst {\r\n  getInitialOptions,\r\n  updateInitialStateGlobal,\r\n  getShadowMetadata,\r\n  setShadowMetadata,\r\n  getShadowValue,\r\n  initializeShadowState,\r\n  initializeAndMergeShadowState,\r\n  updateShadowAtPath,\r\n  insertShadowArrayElement,\r\n  insertManyShadowArrayElements,\r\n  removeShadowArrayElement,\r\n  setInitialStateOptions,\r\n  setServerStateUpdate,\r\n  markAsDirty,\r\n  addPathComponent,\r\n  clearSelectedIndexesForState,\r\n  addStateLog,\r\n  setSyncInfo,\r\n  clearSelectedIndex,\r\n  getSyncInfo,\r\n  notifyPathSubscribers,\r\n  getPluginMetaDataMap,\r\n  setPluginMetaData,\r\n  removePluginMetaData,\r\n  // Note: The old functions are no longer imported under their original names\r\n} = getGlobalStore.getState();\r\n\r\nconst { notifyUpdate } = pluginStore.getState();\r\n\r\nfunction getArrayData(stateKey: string, path: string[], meta?: MetaData) {\r\n  const shadowMeta = getShadowMetadata(stateKey, path);\r\n  const isArray = !!shadowMeta?.arrayKeys;\r\n\r\n  if (!isArray) {\r\n    const value = getGlobalStore.getState().getShadowValue(stateKey, path);\r\n    return { isArray: false, value, keys: [] };\r\n  }\r\n  const arrayPathKey = path.length > 0 ? path.join('.') : 'root';\r\n  const viewIds = meta?.arrayViews?.[arrayPathKey] ?? shadowMeta.arrayKeys;\r\n\r\n  // FIX: If the derived view is empty, return an empty array and keys.\r\n  if (Array.isArray(viewIds) && viewIds.length === 0) {\r\n    return { isArray: true, value: [], keys: [] };\r\n  }\r\n\r\n  const value = getGlobalStore\r\n    .getState()\r\n    .getShadowValue(stateKey, path, viewIds);\r\n\r\n  return { isArray: true, value, keys: viewIds ?? [] };\r\n}\r\n\r\nfunction findArrayItem(\r\n  array: any[],\r\n  keys: string[],\r\n  predicate: (item: any, index: number) => boolean\r\n): { key: string; index: number; value: any } | null {\r\n  for (let i = 0; i < array.length; i++) {\r\n    if (predicate(array[i], i)) {\r\n      const key = keys[i];\r\n      if (key) {\r\n        return { key, index: i, value: array[i] };\r\n      }\r\n    }\r\n  }\r\n  return null;\r\n}\r\n\r\nfunction setAndMergeOptions(stateKey: string, newOptions: OptionsType<any>) {\r\n  const initialOptions = getInitialOptions(stateKey as string) || {};\r\n\r\n  const mergedOptions = {\r\n    ...initialOptions,\r\n    ...newOptions,\r\n  };\r\n\r\n  // FIX: Apply the same default onBlur logic here too\r\n  if (\r\n    (mergedOptions.validation?.zodSchemaV4 ||\r\n      mergedOptions.validation?.zodSchemaV3) &&\r\n    !mergedOptions.validation?.onBlur\r\n  ) {\r\n    mergedOptions.validation.onBlur = 'error';\r\n  }\r\n\r\n  setInitialStateOptions(stateKey as string, mergedOptions);\r\n}\r\n\r\nfunction setOptions<StateKey, Opt>({\r\n  stateKey,\r\n  options,\r\n  initialOptionsPart,\r\n}: {\r\n  stateKey: StateKey;\r\n  options?: OptionsType<any>;\r\n  initialOptionsPart: Record<string, any>;\r\n}) {\r\n  const initialOptions = getInitialOptions(stateKey as string) || {};\r\n  const initialOptionsPartState = initialOptionsPart[stateKey as string] || {};\r\n\r\n  let mergedOptions = { ...initialOptionsPartState, ...initialOptions };\r\n  let needToAdd = false;\r\n\r\n  if (options) {\r\n    const deepMerge = (target: any, source: any) => {\r\n      for (const key in source) {\r\n        if (source.hasOwnProperty(key)) {\r\n          if (\r\n            source[key] instanceof Object &&\r\n            !Array.isArray(source[key]) &&\r\n            target[key] instanceof Object\r\n          ) {\r\n            if (!isDeepEqual(target[key], source[key])) {\r\n              deepMerge(target[key], source[key]);\r\n              needToAdd = true;\r\n            }\r\n          } else {\r\n            if (target[key] !== source[key]) {\r\n              target[key] = source[key];\r\n              needToAdd = true;\r\n            }\r\n          }\r\n        }\r\n      }\r\n      return target;\r\n    };\r\n\r\n    mergedOptions = deepMerge(mergedOptions, options);\r\n  }\r\n\r\n  // Set default onBlur\r\n  if (mergedOptions.validation) {\r\n    const onBlurProvided =\r\n      options?.validation?.hasOwnProperty('onBlur') ||\r\n      initialOptions?.validation?.hasOwnProperty('onBlur') ||\r\n      initialOptionsPartState?.validation?.hasOwnProperty('onBlur');\r\n\r\n    if (!onBlurProvided) {\r\n      mergedOptions.validation.onBlur = 'error';\r\n      needToAdd = true;\r\n    }\r\n  }\r\n\r\n  if (needToAdd) {\r\n    setInitialStateOptions(stateKey as string, mergedOptions);\r\n\r\n    // NEW: Update type info if validation schema was added\r\n    const hadSchema =\r\n      initialOptions?.validation?.zodSchemaV4 ||\r\n      initialOptions?.validation?.zodSchemaV3;\r\n    const hasNewSchemaV4 =\r\n      mergedOptions.validation?.zodSchemaV4 &&\r\n      !initialOptions?.validation?.zodSchemaV4;\r\n    const hasNewSchemaV3 =\r\n      mergedOptions.validation?.zodSchemaV3 &&\r\n      !initialOptions?.validation?.zodSchemaV3;\r\n\r\n    if (!hadSchema && (hasNewSchemaV4 || hasNewSchemaV3)) {\r\n      if (hasNewSchemaV4) {\r\n        updateShadowTypeInfo(\r\n          stateKey as string,\r\n          mergedOptions.validation.zodSchemaV4,\r\n          'zod4'\r\n        );\r\n      } else if (hasNewSchemaV3) {\r\n        updateShadowTypeInfo(\r\n          stateKey as string,\r\n          mergedOptions.validation.zodSchemaV3,\r\n          'zod3'\r\n        );\r\n      }\r\n\r\n      // Notify components to re-render with updated validation\r\n      notifyComponents(stateKey as string);\r\n    }\r\n  }\r\n\r\n  return mergedOptions;\r\n}\r\nexport function addStateOptions<T>(\r\n  initialState: T,\r\n  options: CreateStateOptionsType<T>\r\n) {\r\n  return {\r\n    ...options,\r\n    initialState,\r\n    _addStateOptions: true,\r\n  };\r\n}\r\nexport type PluginData = {\r\n  plugin: CogsPlugin<any, any, any, any, any>;\r\n  options: any;\r\n  hookData?: any;\r\n};\r\n\r\n////////////////////////////////\r\n\r\nexport const createCogsState = <\r\n  State extends Record<string, unknown>,\r\n  const TPlugins extends readonly CogsPlugin<string, any, any, any, any>[] = [],\r\n>(\r\n  initialState: State,\r\n  opt?: {\r\n    plugins?: TPlugins;\r\n    formElements?: FormsElementsType<State, TPlugins>;\r\n    validation?: ValidationOptionsType;\r\n  }\r\n) => {\r\n  type PluginOptions = {\r\n    [K in TPlugins[number] as K['name']]?: K extends CogsPlugin<\r\n      string,\r\n      infer O,\r\n      any,\r\n      any,\r\n      any\r\n    >\r\n      ? O\r\n      : never;\r\n  };\r\n\r\n  if (opt?.plugins) {\r\n    pluginStore.getState().setRegisteredPlugins(opt.plugins as any);\r\n  }\r\n\r\n  const [statePart, initialOptionsPart] =\r\n    transformStateFunc<State>(initialState);\r\n\r\n  // FIX: Store options INCLUDING validation for each state key\r\n  Object.keys(statePart).forEach((key) => {\r\n    let existingOptions = initialOptionsPart[key] || {};\r\n\r\n    const mergedOptions: any = {\r\n      ...existingOptions,\r\n    };\r\n\r\n    if (opt?.formElements) {\r\n      mergedOptions.formElements = {\r\n        ...opt.formElements,\r\n        ...(existingOptions.formElements || {}),\r\n      };\r\n    }\r\n\r\n    mergedOptions.validation = {\r\n      onBlur: 'error',\r\n      ...opt?.validation,\r\n      ...(existingOptions.validation || {}),\r\n    };\r\n\r\n    if (opt?.validation?.key && !existingOptions.validation?.key) {\r\n      mergedOptions.validation.key = `${opt.validation.key}.${key}`;\r\n    }\r\n\r\n    const existingGlobalOptions = getInitialOptions(key);\r\n\r\n    const finalOptions = existingGlobalOptions\r\n      ? {\r\n          ...existingGlobalOptions,\r\n          ...mergedOptions,\r\n          formElements: {\r\n            ...existingGlobalOptions.formElements,\r\n            ...mergedOptions.formElements,\r\n          },\r\n          validation: {\r\n            ...existingGlobalOptions.validation,\r\n            ...mergedOptions.validation,\r\n          },\r\n        }\r\n      : mergedOptions;\r\n\r\n    setInitialStateOptions(key, finalOptions);\r\n  });\r\n\r\n  Object.keys(statePart).forEach((key) => {\r\n    initializeShadowState(key, statePart[key]);\r\n  });\r\n  type Prettify<T> = {\r\n    [K in keyof T]: T[K];\r\n  } & {};\r\n  type StateKeys = keyof typeof statePart;\r\n\r\n  const useCogsState = <StateKey extends StateKeys>(\r\n    stateKey: StateKey,\r\n    options?: Prettify<\r\n      OptionsType<(typeof statePart)[StateKey], never> & {\r\n        [PName in keyof PluginOptions]?: PluginOptions[PName] extends infer P\r\n          ? P extends Record<string, any>\r\n            ? {\r\n                [K in keyof P]: P[K] extends { __key: 'keyed'; map: infer TMap }\r\n                  ? StateKey extends keyof TMap\r\n                    ? TMap[StateKey]\r\n                    : never\r\n                  : P[K];\r\n              }\r\n            : P\r\n          : never;\r\n      }\r\n    >\r\n  ) => {\r\n    const [componentId] = useState(options?.componentId ?? uuidv4());\r\n\r\n    const currentOptions = setOptions({\r\n      stateKey,\r\n      options,\r\n      initialOptionsPart,\r\n    });\r\n\r\n    const optionsRef = useRef(currentOptions);\r\n    optionsRef.current = currentOptions;\r\n\r\n    const thiState =\r\n      getShadowValue(stateKey as string, []) || statePart[stateKey as string];\r\n\r\n    const updater = useCogsStateFn<(typeof statePart)[StateKey]>(thiState, {\r\n      stateKey: stateKey as string,\r\n      syncUpdate: options?.syncUpdate,\r\n      componentId,\r\n      localStorage: options?.localStorage,\r\n      middleware: options?.middleware,\r\n      reactiveType: options?.reactiveType,\r\n      reactiveDeps: options?.reactiveDeps,\r\n      defaultState: options?.defaultState as any,\r\n      dependencies: options?.dependencies,\r\n      serverState: options?.serverState,\r\n    });\r\n\r\n    useEffect(() => {\r\n      if (options) {\r\n        pluginStore\r\n          .getState()\r\n          .setPluginOptionsForState(stateKey as string, options);\r\n      }\r\n    }, [stateKey, options]);\r\n    useEffect(() => {\r\n      console.log('adding handler 1', stateKey, updater);\r\n      pluginStore\r\n        .getState()\r\n        .stateHandlers.set(stateKey as string, updater as any);\r\n\r\n      return () => {\r\n        pluginStore.getState().stateHandlers.delete(stateKey as string);\r\n      };\r\n    }, [stateKey, updater]);\r\n\r\n    return updater;\r\n  };\r\n\r\n  function setCogsOptionsByKey<StateKey extends StateKeys>(\r\n    stateKey: StateKey,\r\n    options: OptionsType<(typeof statePart)[StateKey]>\r\n  ) {\r\n    setOptions({ stateKey, options, initialOptionsPart });\r\n\r\n    if (options.localStorage) {\r\n      loadAndApplyLocalStorage(stateKey as string, options);\r\n    }\r\n\r\n    notifyComponents(stateKey as string);\r\n  }\r\n\r\n  function setCogsFormElements(\r\n    formElements: FormsElementsType<State, TPlugins>\r\n  ) {\r\n    // Get the current list of registered plugins from the store.\r\n    const currentPlugins = pluginStore.getState().registeredPlugins;\r\n\r\n    // Create a new array by mapping over the current plugins.\r\n    // This is crucial for immutability and ensuring Zustand detects the change.\r\n    const updatedPlugins = currentPlugins.map((plugin) => {\r\n      // Check if the formElements object has a wrapper for this specific plugin by name.\r\n      if (formElements.hasOwnProperty(plugin.name)) {\r\n        // If it does, return a *new* plugin object.\r\n        // Spread the existing plugin properties and add/overwrite the formWrapper.\r\n        return {\r\n          ...plugin,\r\n          formWrapper: formElements[plugin.name as keyof typeof formElements],\r\n        };\r\n      }\r\n      // If there's no new wrapper for this plugin, return the original object.\r\n      return plugin;\r\n    });\r\n\r\n    // Use the store's dedicated setter function to update the registered plugins list.\r\n    // This will trigger a state update that components listening to the store will react to.\r\n    pluginStore.getState().setRegisteredPlugins(updatedPlugins as any);\r\n\r\n    // For good measure and consistency, we should still update the formElements\r\n    // in the initial options, in case any other part of the system relies on it.\r\n    const allStateKeys = Object.keys(statePart);\r\n    allStateKeys.forEach((key) => {\r\n      const existingOptions = getInitialOptions(key) || {};\r\n      const finalOptions = {\r\n        ...existingOptions,\r\n        formElements: {\r\n          ...(existingOptions.formElements || {}),\r\n          ...formElements,\r\n        },\r\n      };\r\n      setInitialStateOptions(key, finalOptions);\r\n    });\r\n  }\r\n  return {\r\n    useCogsState,\r\n    setCogsOptionsByKey,\r\n    setCogsFormElements,\r\n  };\r\n};\r\n\r\nconst saveToLocalStorage = <T,>(\r\n  state: T,\r\n  thisKey: string,\r\n  currentInitialOptions: any,\r\n  sessionId?: string,\r\n  lastSyncedWithServer?: number\r\n) => {\r\n  if (currentInitialOptions?.log) {\r\n    console.log(\r\n      'saving to localstorage',\r\n      thisKey,\r\n      currentInitialOptions.localStorage?.key,\r\n      sessionId\r\n    );\r\n  }\r\n\r\n  const key = isFunction(currentInitialOptions?.localStorage?.key)\r\n    ? currentInitialOptions.localStorage?.key(state)\r\n    : currentInitialOptions?.localStorage?.key;\r\n\r\n  if (key && sessionId) {\r\n    const storageKey = `${sessionId}-${thisKey}-${key}`;\r\n\r\n    // Get existing data to preserve lastSyncedWithServer if not explicitly updating it\r\n    let existingLastSynced: number | undefined;\r\n    try {\r\n      const existing = loadFromLocalStorage(storageKey);\r\n      existingLastSynced = existing?.lastSyncedWithServer;\r\n    } catch {\r\n      // Ignore errors, will use undefined\r\n    }\r\n    const shadowMeta = getShadowMetadata(thisKey, []);\r\n\r\n    const data: LocalStorageData<T> = {\r\n      state,\r\n      lastUpdated: Date.now(),\r\n      lastSyncedWithServer: lastSyncedWithServer ?? existingLastSynced,\r\n      stateSource: shadowMeta?.stateSource,\r\n      baseServerState: shadowMeta?.baseServerState,\r\n    };\r\n\r\n    // Use SuperJSON serialize to get the json part only\r\n    const superJsonResult = superjson.serialize(data);\r\n    window.localStorage.setItem(\r\n      storageKey,\r\n      JSON.stringify(superJsonResult.json)\r\n    );\r\n  }\r\n};\r\n\r\nconst loadFromLocalStorage = (localStorageKey: string) => {\r\n  if (!localStorageKey) return null;\r\n\r\n  try {\r\n    const storedData = window.localStorage.getItem(localStorageKey);\r\n    if (!storedData) return null;\r\n\r\n    // Parse the json part back normally\r\n    const parsedData = JSON.parse(storedData);\r\n\r\n    return parsedData;\r\n  } catch (error) {\r\n    console.error('Error loading from localStorage:', error);\r\n    return null;\r\n  }\r\n};\r\nconst loadAndApplyLocalStorage = (stateKey: string, options: any) => {\r\n  const currentState = getShadowValue(stateKey, []);\r\n  const { sessionId } = useCogsConfig();\r\n  const localkey = isFunction(options?.localStorage?.key)\r\n    ? options.localStorage.key(currentState)\r\n    : options?.localStorage?.key;\r\n\r\n  if (localkey && sessionId) {\r\n    const localData = loadFromLocalStorage(\r\n      `${sessionId}-${stateKey}-${localkey}`\r\n    );\r\n\r\n    if (\r\n      localData &&\r\n      localData.lastUpdated > (localData.lastSyncedWithServer || 0)\r\n    ) {\r\n      notifyComponents(stateKey);\r\n      return true;\r\n    }\r\n  }\r\n  return false;\r\n};\r\n\r\ntype LocalStorageData<T> = {\r\n  state: T;\r\n  lastUpdated: number;\r\n  lastSyncedWithServer?: number;\r\n  baseServerState?: T; // Keep reference to what server state this is based on\r\n  stateSource?: 'default' | 'server' | 'localStorage'; // Track origin\r\n};\r\n\r\nconst notifyComponents = (thisKey: string) => {\r\n  const stateEntry = getShadowMetadata(thisKey, []);\r\n  if (!stateEntry) return;\r\n\r\n  // Batch component updates\r\n  const updates = new Set<() => void>();\r\n  stateEntry?.components?.forEach((component) => {\r\n    const reactiveTypes = component\r\n      ? Array.isArray(component.reactiveType)\r\n        ? component.reactiveType\r\n        : [component.reactiveType || 'component']\r\n      : null;\r\n    if (!reactiveTypes?.includes('none')) {\r\n      updates.add(() => component.forceUpdate());\r\n    }\r\n  });\r\n\r\n  // Schedule updates in the next tick to allow batching\r\n  queueMicrotask(() => {\r\n    updates.forEach((update) => update());\r\n  });\r\n};\r\n\r\nfunction markEntireStateAsServerSynced(\r\n  stateKey: string,\r\n  path: string[],\r\n  data: any,\r\n  timestamp: number\r\n) {\r\n  // Mark current path as synced\r\n  const currentMeta = getShadowMetadata(stateKey, path);\r\n  setShadowMetadata(stateKey, path, {\r\n    ...currentMeta,\r\n    isDirty: false,\r\n    stateSource: 'server',\r\n    lastServerSync: timestamp || Date.now(),\r\n  });\r\n\r\n  // If it's an array, mark each item as synced\r\n  if (Array.isArray(data)) {\r\n    const arrayMeta = getShadowMetadata(stateKey, path);\r\n    if (arrayMeta?.arrayKeys) {\r\n      arrayMeta.arrayKeys.forEach((itemKey, index) => {\r\n        // Fix: Don't split the itemKey, just use it directly\r\n        const itemPath = [...path, itemKey];\r\n        const itemData = data[index];\r\n        if (itemData !== undefined) {\r\n          markEntireStateAsServerSynced(\r\n            stateKey,\r\n            itemPath,\r\n            itemData,\r\n            timestamp\r\n          );\r\n        }\r\n      });\r\n    }\r\n  }\r\n  // If it's an object, mark each field as synced\r\n  else if (data && typeof data === 'object' && data.constructor === Object) {\r\n    Object.keys(data).forEach((key) => {\r\n      const fieldPath = [...path, key];\r\n      const fieldData = data[key];\r\n      markEntireStateAsServerSynced(stateKey, fieldPath, fieldData, timestamp);\r\n    });\r\n  }\r\n}\r\n// 5. Batch queue\r\nlet updateBatchQueue: any[] = [];\r\nlet isFlushScheduled = false;\r\n\r\nfunction scheduleFlush() {\r\n  if (!isFlushScheduled) {\r\n    isFlushScheduled = true;\r\n    console.log('Scheduling flush');\r\n    queueMicrotask(() => {\r\n      console.log('Actually flushing');\r\n      flushQueue();\r\n    });\r\n  }\r\n}\r\n\r\n// 2. Update signals\r\nfunction updateSignals(shadowMeta: any, displayValue: any) {\r\n  if (!shadowMeta?.signals?.length) return;\r\n\r\n  shadowMeta.signals.forEach(({ parentId, position, effect }: any) => {\r\n    const parent = document.querySelector(`[data-parent-id=\"${parentId}\"]`);\r\n    if (!parent) return;\r\n\r\n    const childNodes = Array.from(parent.childNodes);\r\n    if (!childNodes[position]) return;\r\n\r\n    let finalDisplayValue = displayValue;\r\n    if (effect && displayValue !== null) {\r\n      try {\r\n        finalDisplayValue = new Function('state', `return (${effect})(state)`)(\r\n          displayValue\r\n        );\r\n      } catch (err) {\r\n        console.error('Error evaluating effect function:', err);\r\n      }\r\n    }\r\n\r\n    if (finalDisplayValue !== null && typeof finalDisplayValue === 'object') {\r\n      finalDisplayValue = JSON.stringify(finalDisplayValue);\r\n    }\r\n\r\n    childNodes[position].textContent = String(finalDisplayValue ?? '');\r\n  });\r\n}\r\n\r\nfunction getComponentNotifications(\r\n  stateKey: string,\r\n  path: string[],\r\n  result: any\r\n): Set<any> {\r\n  const rootMeta = getShadowMetadata(stateKey, []);\r\n\r\n  if (!rootMeta?.components) {\r\n    return new Set();\r\n  }\r\n\r\n  const componentsToNotify = new Set<any>();\r\n\r\n  // --- PASS 1: Notify specific subscribers based on update type ---\r\n\r\n  if (result.type === 'update') {\r\n    // --- Bubble-up Notification ---\r\n    // An update to `user.address.street` notifies listeners of `street`, `address`, and `user`.\r\n    let currentPath = [...path];\r\n    while (true) {\r\n      const pathMeta = getShadowMetadata(stateKey, currentPath);\r\n\r\n      if (pathMeta?.pathComponents) {\r\n        pathMeta.pathComponents.forEach((componentId: string) => {\r\n          const component = rootMeta.components?.get(componentId);\r\n          // NEW: Add component to the set instead of calling forceUpdate()\r\n          if (component) {\r\n            const reactiveTypes = Array.isArray(component.reactiveType)\r\n              ? component.reactiveType\r\n              : [component.reactiveType || 'component'];\r\n            if (!reactiveTypes.includes('none')) {\r\n              componentsToNotify.add(component);\r\n            }\r\n          }\r\n        });\r\n      }\r\n\r\n      if (currentPath.length === 0) break;\r\n      currentPath.pop(); // Go up one level\r\n    }\r\n\r\n    // --- Deep Object Change Notification ---\r\n    // If the new value is an object, notify components subscribed to sub-paths that changed.\r\n    if (\r\n      result.newValue &&\r\n      typeof result.newValue === 'object' &&\r\n      !isArray(result.newValue)\r\n    ) {\r\n      const changedSubPaths = getDifferences(result.newValue, result.oldValue);\r\n\r\n      changedSubPaths.forEach((subPathString: string) => {\r\n        const subPath = subPathString.split('.');\r\n        const fullSubPath = [...path, ...subPath];\r\n        const subPathMeta = getShadowMetadata(stateKey, fullSubPath);\r\n\r\n        if (subPathMeta?.pathComponents) {\r\n          subPathMeta.pathComponents.forEach((componentId: string) => {\r\n            const component = rootMeta.components?.get(componentId);\r\n            // NEW: Add component to the set\r\n            if (component) {\r\n              const reactiveTypes = Array.isArray(component.reactiveType)\r\n                ? component.reactiveType\r\n                : [component.reactiveType || 'component'];\r\n              if (!reactiveTypes.includes('none')) {\r\n                componentsToNotify.add(component);\r\n              }\r\n            }\r\n          });\r\n        }\r\n      });\r\n    }\r\n  } else if (\r\n    result.type === 'insert' ||\r\n    result.type === 'cut' ||\r\n    result.type === 'insert_many'\r\n  ) {\r\n    // For array structural changes (add/remove), notify components listening to the parent array.\r\n    const parentArrayPath = result.type === 'insert' ? path : path.slice(0, -1);\r\n    const parentMeta = getShadowMetadata(stateKey, parentArrayPath);\r\n\r\n    if (parentMeta?.pathComponents) {\r\n      parentMeta.pathComponents.forEach((componentId: string) => {\r\n        const component = rootMeta.components?.get(componentId);\r\n        // NEW: Add component to the set\r\n        if (component) {\r\n          componentsToNotify.add(component);\r\n        }\r\n      });\r\n    }\r\n  }\r\n\r\n  // --- PASS 2: Handle 'all' and 'deps' reactivity types ---\r\n  // Iterate over all components for this stateKey that haven't been notified yet.\r\n  // rootMeta.components.forEach((component, componentId) => {\r\n  //   // If we've already added this component, skip it.\r\n  //   if (componentsToNotify.has(component)) {\r\n  //     return;\r\n  //   }\r\n\r\n  //   const reactiveTypes = Array.isArray(component.reactiveType)\r\n  //     ? component.reactiveType\r\n  //     : [component.reactiveType || 'component'];\r\n\r\n  //   if (reactiveTypes.includes('all')) {\r\n  //     componentsToNotify.add(component);\r\n  //   } else if (reactiveTypes.includes('deps') && component.depsFunction) {\r\n  //     const currentState = getShadowValue(stateKey, []);\r\n  //     const newDeps = component.depsFunction(currentState);\r\n\r\n  //     if (\r\n  //       newDeps === true ||\r\n  //       (Array.isArray(newDeps) && !isDeepEqual(component.prevDeps, newDeps))\r\n  //     ) {\r\n  //       component.prevDeps = newDeps as any; // Update the dependencies for the next check\r\n  //       componentsToNotify.add(component);\r\n  //     }\r\n  //   }\r\n  // });\r\n\r\n  return componentsToNotify;\r\n}\r\n\r\nfunction handleUpdate(\r\n  stateKey: string,\r\n  path: string[],\r\n  payload: any\r\n): { type: 'update'; oldValue: any; newValue: any; shadowMeta: any } {\r\n  // ✅ FIX: Get the old value before the update.\r\n  const oldValue = getGlobalStore.getState().getShadowValue(stateKey, path);\r\n\r\n  const newValue = isFunction(payload) ? payload(oldValue) : payload;\r\n\r\n  // ✅ FIX: The new `updateShadowAtPath` handles metadata preservation automatically.\r\n  // The manual loop has been removed.\r\n  updateShadowAtPath(stateKey, path, newValue);\r\n\r\n  markAsDirty(stateKey, path, { bubble: true });\r\n\r\n  // Return the metadata of the node *after* the update.\r\n  const newShadowMeta = getShadowMetadata(stateKey, path);\r\n\r\n  return {\r\n    type: 'update',\r\n    oldValue: oldValue,\r\n    newValue,\r\n    shadowMeta: newShadowMeta,\r\n  };\r\n}\r\nfunction handleInsertMany(\r\n  stateKey: string,\r\n  path: string[],\r\n  payload: any[]\r\n): {\r\n  type: 'insert_many';\r\n  count: number;\r\n  shadowMeta: any;\r\n  path: string[];\r\n} {\r\n  // Use the existing, optimized global store function to perform the state update\r\n  insertManyShadowArrayElements(stateKey, path, payload);\r\n\r\n  markAsDirty(stateKey, path, { bubble: true });\r\n  const updatedMeta = getShadowMetadata(stateKey, path);\r\n\r\n  return {\r\n    type: 'insert_many',\r\n    count: payload.length,\r\n    shadowMeta: updatedMeta,\r\n    path: path,\r\n  };\r\n}\r\nfunction handleInsert(\r\n  stateKey: string,\r\n  path: string[],\r\n  payload: any,\r\n  index?: number,\r\n  itemId?: string\r\n): {\r\n  type: 'insert';\r\n  newValue: any;\r\n  shadowMeta: any;\r\n  path: string[];\r\n  itemId: string;\r\n  insertAfterId?: string;\r\n} {\r\n  let newValue;\r\n\r\n  if (isFunction(payload)) {\r\n    const { value: currentValue } = getScopedData(stateKey, path);\r\n    newValue = payload({ state: currentValue });\r\n  } else {\r\n    newValue = payload;\r\n  }\r\n  //console.time('insertShadowArrayElement');\r\n  // Pass itemId to insertShadowArrayElement\r\n  const actualItemId = insertShadowArrayElement(\r\n    stateKey,\r\n    path,\r\n    newValue,\r\n    index,\r\n    itemId\r\n  );\r\n  //console.timeEnd('insertShadowArrayElement');\r\n\r\n  markAsDirty(stateKey, path, { bubble: true });\r\n\r\n  const updatedMeta = getShadowMetadata(stateKey, path);\r\n\r\n  let insertAfterId: string | undefined;\r\n  if (updatedMeta?.arrayKeys && index !== undefined && index > 0) {\r\n    insertAfterId = updatedMeta.arrayKeys[index - 1];\r\n  }\r\n\r\n  return {\r\n    type: 'insert',\r\n    newValue,\r\n    shadowMeta: updatedMeta,\r\n    path: path,\r\n    itemId: actualItemId,\r\n    insertAfterId: insertAfterId,\r\n  };\r\n}\r\n\r\nfunction handleCut(\r\n  stateKey: string,\r\n  path: string[]\r\n): { type: 'cut'; oldValue: any; parentPath: string[] } {\r\n  const parentArrayPath = path.slice(0, -1);\r\n  const oldValue = getShadowValue(stateKey, path);\r\n  removeShadowArrayElement(stateKey, path);\r\n  markAsDirty(stateKey, parentArrayPath, { bubble: true });\r\n  return { type: 'cut', oldValue: oldValue, parentPath: parentArrayPath };\r\n}\r\n\r\nfunction flushQueue() {\r\n  const allComponentsToNotify = new Set<any>();\r\n  const signalUpdates: { shadowMeta: any; displayValue: any }[] = [];\r\n\r\n  const logsToAdd: UpdateTypeDetail[] = [];\r\n\r\n  for (const item of updateBatchQueue) {\r\n    if (item.status && item.updateType) {\r\n      logsToAdd.push(item as UpdateTypeDetail);\r\n      continue;\r\n    }\r\n\r\n    const result = item;\r\n\r\n    const displayValue = result.type === 'cut' ? null : result.newValue;\r\n    if (result.shadowMeta?.signals?.length > 0) {\r\n      signalUpdates.push({ shadowMeta: result.shadowMeta, displayValue });\r\n    }\r\n    // console.time('getComponentNotifications');\r\n    const componentNotifications = getComponentNotifications(\r\n      result.stateKey,\r\n      result.path,\r\n      result\r\n    );\r\n\r\n    componentNotifications.forEach((component) => {\r\n      allComponentsToNotify.add(component);\r\n    });\r\n    //  console.timeEnd('getComponentNotifications');\r\n  }\r\n  //console.time('logs');\r\n  if (logsToAdd.length > 0) {\r\n    addStateLog(logsToAdd);\r\n  }\r\n  //console.timeEnd('logs');\r\n  signalUpdates.forEach(({ shadowMeta, displayValue }) => {\r\n    updateSignals(shadowMeta, displayValue);\r\n  });\r\n\r\n  // console.time('updateComponents');\r\n  allComponentsToNotify.forEach((component) => {\r\n    component.forceUpdate();\r\n  });\r\n  //console.timeEnd('updateComponents');\r\n\r\n  // --- Step 3: CLEANUP ---\r\n  // Clear the queue for the next batch of updates.\r\n  updateBatchQueue = [];\r\n  isFlushScheduled = false;\r\n}\r\nfunction createEffectiveSetState<T>(\r\n  thisKey: string,\r\n  sessionId: string | undefined,\r\n  latestInitialOptionsRef: React.MutableRefObject<OptionsType<T> | null>\r\n): EffectiveSetState<T> {\r\n  return (newStateOrFunction, path, updateObj) => {\r\n    executeUpdate(thisKey, path, newStateOrFunction, updateObj);\r\n  };\r\n\r\n  function executeUpdate(\r\n    stateKey: string,\r\n    path: string[],\r\n    payload: any,\r\n    options: UpdateOptions // Now includes itemId\r\n  ) {\r\n    let result: any;\r\n    switch (options.updateType) {\r\n      case 'update':\r\n        result = handleUpdate(stateKey, path, payload);\r\n        break;\r\n      case 'insert':\r\n        result = handleInsert(\r\n          stateKey,\r\n          path,\r\n          payload,\r\n          options.index,\r\n          options.itemId\r\n        );\r\n        break;\r\n      case 'insert_many':\r\n        result = handleInsertMany(stateKey, path, payload);\r\n        break;\r\n      case 'cut':\r\n        result = handleCut(stateKey, path);\r\n        break;\r\n    }\r\n    result.stateKey = stateKey;\r\n    result.path = path;\r\n    updateBatchQueue.push(result);\r\n    scheduleFlush();\r\n\r\n    const newUpdate: UpdateTypeDetail = {\r\n      timeStamp: Date.now(),\r\n      stateKey,\r\n      path,\r\n      updateType: options.updateType,\r\n      status: 'new',\r\n      oldValue: result.oldValue,\r\n      newValue: result.newValue ?? null,\r\n      itemId: result.itemId,\r\n      insertAfterId: result.insertAfterId,\r\n      metaData: options.metaData,\r\n    };\r\n\r\n    updateBatchQueue.push(newUpdate);\r\n\r\n    if (result.newValue !== undefined) {\r\n      saveToLocalStorage(\r\n        result.newValue,\r\n        stateKey,\r\n        latestInitialOptionsRef.current,\r\n        sessionId\r\n      );\r\n    }\r\n\r\n    if (latestInitialOptionsRef.current?.middleware) {\r\n      latestInitialOptionsRef.current.middleware({ update: newUpdate });\r\n    }\r\n    runValidation(newUpdate, options.validationTrigger || 'programmatic');\r\n    notifyUpdate(newUpdate);\r\n  }\r\n}\r\n\r\nexport function useCogsStateFn<TStateObject extends unknown>(\r\n  stateObject: TStateObject,\r\n  {\r\n    stateKey,\r\n    localStorage,\r\n    formElements,\r\n    reactiveDeps,\r\n    reactiveType,\r\n    componentId,\r\n    defaultState,\r\n    dependencies,\r\n    serverState,\r\n  }: {\r\n    stateKey?: string;\r\n    componentId?: string;\r\n    defaultState?: TStateObject;\r\n    syncOptions?: SyncOptionsType<any>;\r\n  } & OptionsType<TStateObject> = {}\r\n) {\r\n  const [reactiveForce, forceUpdate] = useState({}); //this is the key to reactivity\r\n  const { sessionId } = useCogsConfig();\r\n  let noStateKey = stateKey ? false : true;\r\n  const [thisKey] = useState(stateKey ?? uuidv4());\r\n  const componentIdRef = useRef(componentId ?? uuidv4());\r\n  const latestInitialOptionsRef = useRef<OptionsType<TStateObject> | null>(\r\n    null\r\n  );\r\n  latestInitialOptionsRef.current = (getInitialOptions(thisKey as string) ??\r\n    null) as OptionsType<TStateObject> | null;\r\n\r\n  const resolveInitialState = useCallback(\r\n    (\r\n      overrideOptions?: OptionsType<TStateObject>\r\n    ): {\r\n      value: TStateObject;\r\n      source: 'default' | 'server' | 'localStorage';\r\n      timestamp: number;\r\n    } => {\r\n      // If we pass in options, use them. Otherwise, get from the global store.\r\n      const optionsToUse = overrideOptions\r\n        ? { ...getInitialOptions(thisKey as string), ...overrideOptions }\r\n        : getInitialOptions(thisKey as string);\r\n\r\n      const currentOptions = optionsToUse;\r\n      const finalDefaultState =\r\n        currentOptions?.defaultState || defaultState || stateObject;\r\n\r\n      // 1. Check server state\r\n      const hasValidServerData =\r\n        currentOptions?.serverState?.status === 'success' &&\r\n        currentOptions?.serverState?.data !== undefined;\r\n\r\n      if (hasValidServerData) {\r\n        return {\r\n          value: currentOptions.serverState!.data! as any,\r\n          source: 'server',\r\n          timestamp: currentOptions.serverState!.timestamp || Date.now(),\r\n        };\r\n      }\r\n      // 2. Check localStorage\r\n      if (currentOptions?.localStorage?.key && sessionId) {\r\n        const localKey = isFunction(currentOptions.localStorage.key)\r\n          ? currentOptions.localStorage.key(finalDefaultState)\r\n          : currentOptions.localStorage.key;\r\n\r\n        const localData = loadFromLocalStorage(\r\n          `${sessionId}-${thisKey}-${localKey}`\r\n        );\r\n\r\n        if (\r\n          localData &&\r\n          localData.lastUpdated > (currentOptions?.serverState?.timestamp || 0)\r\n        ) {\r\n          return {\r\n            value: localData.state,\r\n            source: 'localStorage',\r\n            timestamp: localData.lastUpdated,\r\n          };\r\n        }\r\n      }\r\n\r\n      // 3. Use default state\r\n      return {\r\n        value: finalDefaultState || (stateObject as any),\r\n        source: 'default',\r\n        timestamp: Date.now(),\r\n      };\r\n    },\r\n    [thisKey, defaultState, stateObject, sessionId]\r\n  );\r\n\r\n  // Effect 1: When this component's serverState prop changes, broadcast it\r\n  useEffect(() => {\r\n    if (!serverState) return;\r\n\r\n    // Only broadcast if we have valid server data\r\n    if (serverState.status === 'success' && serverState.data !== undefined) {\r\n      setServerStateUpdate(thisKey, serverState);\r\n    }\r\n  }, [serverState, thisKey]);\r\n  // Effect 2: Listen for server state updates from ANY component\r\n  useEffect(() => {\r\n    const unsubscribe = getGlobalStore\r\n      .getState()\r\n      .subscribeToPath(thisKey, (event) => {\r\n        if (event?.type === 'SERVER_STATE_UPDATE') {\r\n          const serverStateData = event.serverState;\r\n\r\n          if (\r\n            serverStateData?.status !== 'success' ||\r\n            serverStateData.data === undefined\r\n          ) {\r\n            return; // Ignore if no valid data\r\n          }\r\n\r\n          // Store the server state in options for future reference\r\n          setAndMergeOptions(thisKey, { serverState: serverStateData });\r\n\r\n          const mergeConfig =\r\n            typeof serverStateData.merge === 'object'\r\n              ? serverStateData.merge\r\n              : serverStateData.merge === true\r\n                ? { strategy: 'append' as const, key: 'id' }\r\n                : null;\r\n\r\n          const currentState = getShadowValue(thisKey, []);\r\n          const incomingData = serverStateData.data;\r\n\r\n          if (\r\n            mergeConfig &&\r\n            mergeConfig.strategy === 'append' &&\r\n            'key' in mergeConfig &&\r\n            Array.isArray(currentState) &&\r\n            Array.isArray(incomingData)\r\n          ) {\r\n            const keyField = mergeConfig.key;\r\n            if (!keyField) {\r\n              console.error(\r\n                \"CogsState: Merge strategy 'append' requires a 'key' field.\"\r\n              );\r\n              return;\r\n            }\r\n\r\n            // Get existing IDs to check for duplicates\r\n            const existingIds = new Set(\r\n              currentState.map((item: any) => item[keyField])\r\n            );\r\n\r\n            // Filter out duplicates from incoming data\r\n            const newUniqueItems = incomingData.filter(\r\n              (item: any) => !existingIds.has(item[keyField])\r\n            );\r\n\r\n            if (newUniqueItems.length > 0) {\r\n              // Insert only the new unique items\r\n              insertManyShadowArrayElements(thisKey, [], newUniqueItems);\r\n            }\r\n\r\n            // Mark the entire merged state as synced\r\n            const finalState = getShadowValue(thisKey, []);\r\n            markEntireStateAsServerSynced(\r\n              thisKey,\r\n              [],\r\n              finalState,\r\n              serverStateData.timestamp || Date.now()\r\n            );\r\n          } else {\r\n            // Replace strategy (default) - completely replace the state\r\n            initializeShadowState(thisKey, incomingData);\r\n\r\n            // Mark as synced from server\r\n            markEntireStateAsServerSynced(\r\n              thisKey,\r\n              [],\r\n              incomingData,\r\n              serverStateData.timestamp || Date.now()\r\n            );\r\n          }\r\n\r\n          // Notify all components subscribed to this state\r\n          notifyComponents(thisKey);\r\n        }\r\n      });\r\n\r\n    return unsubscribe;\r\n  }, [thisKey]);\r\n  useEffect(() => {\r\n    const existingMeta = getGlobalStore\r\n      .getState()\r\n      .getShadowMetadata(thisKey, []);\r\n\r\n    // Skip if already initialized\r\n    if (existingMeta && existingMeta.stateSource) {\r\n      return;\r\n    }\r\n\r\n    const options = getInitialOptions(thisKey as string);\r\n\r\n    const features = {\r\n      localStorageEnabled: !!options?.localStorage?.key,\r\n    };\r\n\r\n    setShadowMetadata(thisKey, [], {\r\n      ...existingMeta,\r\n      features,\r\n    });\r\n\r\n    if (options?.defaultState !== undefined || defaultState !== undefined) {\r\n      const finalDefaultState = options?.defaultState || defaultState;\r\n      if (!options?.defaultState) {\r\n        setAndMergeOptions(thisKey as string, {\r\n          defaultState: finalDefaultState,\r\n        });\r\n      }\r\n    }\r\n\r\n    const { value: resolvedState, source, timestamp } = resolveInitialState();\r\n    initializeShadowState(thisKey, resolvedState);\r\n    setShadowMetadata(thisKey, [], {\r\n      stateSource: source,\r\n      lastServerSync: source === 'server' ? timestamp : undefined,\r\n      isDirty: source === 'server' ? false : undefined,\r\n      baseServerState: source === 'server' ? resolvedState : undefined,\r\n    });\r\n\r\n    if (source === 'server' && serverState) {\r\n      setServerStateUpdate(thisKey, serverState);\r\n    }\r\n\r\n    notifyComponents(thisKey);\r\n  }, [thisKey, ...(dependencies || [])]);\r\n\r\n  useLayoutEffect(() => {\r\n    if (noStateKey) {\r\n      setAndMergeOptions(thisKey as string, {\r\n        formElements,\r\n        defaultState,\r\n        localStorage,\r\n        middleware: latestInitialOptionsRef.current?.middleware,\r\n      });\r\n    }\r\n\r\n    const componentKey = `${thisKey}////${componentIdRef.current}`;\r\n\r\n    // Register component in shadow metadata at root level\r\n    const rootMeta = getShadowMetadata(thisKey, []);\r\n    const components = rootMeta?.components || new Map();\r\n\r\n    components.set(componentKey, {\r\n      forceUpdate: () => forceUpdate({}),\r\n      reactiveType: reactiveType ?? ['component'],\r\n      paths: new Set(),\r\n      depsFunction: reactiveDeps || undefined,\r\n      deps: reactiveDeps ? reactiveDeps(getShadowValue(thisKey, [])) : [],\r\n      prevDeps: reactiveDeps // Initialize prevDeps with the same initial value\r\n        ? reactiveDeps(getShadowValue(thisKey, []))\r\n        : [],\r\n    });\r\n\r\n    setShadowMetadata(thisKey, [], {\r\n      ...rootMeta,\r\n      components,\r\n    });\r\n    forceUpdate({});\r\n    return () => {\r\n      const meta = getShadowMetadata(thisKey, []);\r\n      const component = meta?.components?.get(componentKey);\r\n\r\n      // Remove from each path we registered to\r\n      if (component?.paths) {\r\n        component.paths.forEach((fullPath) => {\r\n          // fullPath is like \"todos.0.name\", need to split and remove stateKey\r\n          const pathParts = fullPath.split('.');\r\n          const path = pathParts.slice(1); // Remove stateKey part\r\n\r\n          const pathMeta = getGlobalStore\r\n            .getState()\r\n            .getShadowMetadata(thisKey, path);\r\n          if (pathMeta?.pathComponents) {\r\n            // Optionally clean up empty Sets\r\n\r\n            if (pathMeta.pathComponents.size === 0) {\r\n              delete pathMeta.pathComponents;\r\n              getGlobalStore\r\n                .getState()\r\n                .setShadowMetadata(thisKey, path, pathMeta);\r\n            }\r\n          }\r\n        });\r\n      }\r\n\r\n      // Remove from root components\r\n      if (meta?.components) {\r\n        setShadowMetadata(thisKey, [], meta);\r\n      }\r\n    };\r\n  }, []);\r\n\r\n  const effectiveSetState = createEffectiveSetState(\r\n    thisKey,\r\n\r\n    sessionId,\r\n    latestInitialOptionsRef\r\n  );\r\n\r\n  if (!getGlobalStore.getState().initialStateGlobal[thisKey]) {\r\n    updateInitialStateGlobal(thisKey, stateObject);\r\n  }\r\n\r\n  const updaterFinal = useMemo(() => {\r\n    const handler = createProxyHandler<TStateObject>(\r\n      thisKey,\r\n      effectiveSetState,\r\n      componentIdRef.current,\r\n      sessionId\r\n    );\r\n\r\n    return handler;\r\n  }, [thisKey, sessionId]);\r\n\r\n  return updaterFinal;\r\n}\r\n\r\ntype MetaData = {\r\n  // Map array paths to their filtered/sorted ID order\r\n  arrayViews?: {\r\n    [arrayPath: string]: string[]; // e.g. { \"todos\": [\"id:xxx\", \"id:yyy\"], \"todos.id:xxx.subtasks\": [\"id:aaa\"] }\r\n  };\r\n  transforms?: Array<{\r\n    type: 'filter' | 'sort';\r\n    fn: Function;\r\n    path: string[]; // Which array this transform applies to\r\n  }>;\r\n  serverStateIsUpStream?: boolean;\r\n};\r\n\r\nconst applyTransforms = (\r\n  stateKey: string,\r\n  path: string[],\r\n  meta?: MetaData\r\n): string[] => {\r\n  let ids = getShadowMetadata(stateKey, path)?.arrayKeys || [];\r\n  const transforms = meta?.transforms;\r\n  if (!transforms || transforms.length === 0) {\r\n    return ids;\r\n  }\r\n\r\n  // Apply each transform using just IDs\r\n  for (const transform of transforms) {\r\n    if (transform.type === 'filter') {\r\n      const filtered: any[] = [];\r\n      ids.forEach((id, index) => {\r\n        const value = getShadowValue(stateKey, [...path, id]);\r\n\r\n        if (transform.fn(value, index)) {\r\n          filtered.push(id);\r\n        }\r\n      });\r\n      ids = filtered;\r\n    } else if (transform.type === 'sort') {\r\n      ids.sort((a, b) => {\r\n        const aValue = getShadowValue(stateKey, [...path, a]);\r\n        const bValue = getShadowValue(stateKey, [...path, b]);\r\n        return transform.fn(aValue, bValue);\r\n      });\r\n    }\r\n  }\r\n\r\n  return ids;\r\n};\r\nconst registerComponentDependency = (\r\n  stateKey: string,\r\n  componentId: string,\r\n  dependencyPath: string[]\r\n) => {\r\n  const fullComponentId = `${stateKey}////${componentId}`;\r\n\r\n  const rootMeta = getShadowMetadata(stateKey, []);\r\n  const component = rootMeta?.components?.get(fullComponentId);\r\n\r\n  if (\r\n    !component ||\r\n    component.reactiveType === 'none' ||\r\n    !(\r\n      Array.isArray(component.reactiveType)\r\n        ? component.reactiveType\r\n        : [component.reactiveType]\r\n    ).includes('component')\r\n  ) {\r\n    return;\r\n  }\r\n\r\n  addPathComponent(stateKey, dependencyPath, fullComponentId);\r\n};\r\nconst notifySelectionComponents = (\r\n  stateKey: string,\r\n  parentPath: string[],\r\n  currentSelected?: string | undefined\r\n) => {\r\n  const rootMeta = getShadowMetadata(stateKey, []);\r\n  const notifiedComponents = new Set<string>();\r\n\r\n  // Handle \"all\" reactive components first\r\n  if (rootMeta?.components) {\r\n    rootMeta.components.forEach((component, componentId) => {\r\n      const reactiveTypes = Array.isArray(component.reactiveType)\r\n        ? component.reactiveType\r\n        : [component.reactiveType || 'component'];\r\n\r\n      if (reactiveTypes.includes('all')) {\r\n        component.forceUpdate();\r\n        notifiedComponents.add(componentId);\r\n      }\r\n    });\r\n  }\r\n\r\n  getShadowMetadata(stateKey, [\r\n    ...parentPath,\r\n    'getSelected',\r\n  ])?.pathComponents?.forEach((componentId) => {\r\n    const thisComp = rootMeta?.components?.get(componentId);\r\n    thisComp?.forceUpdate();\r\n  });\r\n\r\n  const parentMeta = getShadowMetadata(stateKey, parentPath);\r\n  for (let arrayKey of parentMeta?.arrayKeys || []) {\r\n    const key = arrayKey + '.selected';\r\n    const selectedItem = getShadowMetadata(stateKey, key.split('.').slice(1));\r\n    if (arrayKey == currentSelected) {\r\n      selectedItem?.pathComponents?.forEach((componentId) => {\r\n        const thisComp = rootMeta?.components?.get(componentId);\r\n        thisComp?.forceUpdate();\r\n      });\r\n    }\r\n  }\r\n};\r\nfunction getScopedData(stateKey: string, path: string[], meta?: MetaData) {\r\n  const shadowMeta = getShadowMetadata(stateKey, path);\r\n  const arrayPathKey = path.length > 0 ? path.join('.') : 'root';\r\n  const arrayKeys = meta?.arrayViews?.[arrayPathKey];\r\n\r\n  // FIX: If the derived view is empty, return an empty array directly.\r\n  if (Array.isArray(arrayKeys) && arrayKeys.length === 0) {\r\n    return {\r\n      shadowMeta,\r\n      value: [],\r\n      arrayKeys: shadowMeta?.arrayKeys,\r\n    };\r\n  }\r\n\r\n  const value = getShadowValue(stateKey, path, arrayKeys);\r\n\r\n  return {\r\n    shadowMeta,\r\n    value,\r\n    arrayKeys: shadowMeta?.arrayKeys,\r\n  };\r\n}\r\n\r\nfunction createProxyHandler<T>(\r\n  stateKey: string,\r\n  effectiveSetState: EffectiveSetState<T>,\r\n  outerComponentId: string,\r\n  sessionId?: string\r\n): StateObject<T> {\r\n  const proxyCache = new Map<string, any>();\r\n\r\n  function rebuildStateShape({\r\n    path = [],\r\n    meta,\r\n    componentId,\r\n  }: {\r\n    path: string[];\r\n    componentId: string;\r\n    meta?: MetaData;\r\n  }): any {\r\n    const derivationSignature = meta\r\n      ? JSON.stringify(meta.arrayViews || meta.transforms)\r\n      : '';\r\n    const cacheKey =\r\n      path.join('.') + ':' + componentId + ':' + derivationSignature;\r\n    if (proxyCache.has(cacheKey)) {\r\n      return proxyCache.get(cacheKey);\r\n    }\r\n    const stateKeyPathKey = [stateKey, ...path].join('.');\r\n\r\n    // We attach baseObj properties *inside* the get trap now to avoid recursion\r\n    // This is a placeholder for the proxy.\r\n\r\n    const handler = {\r\n      get(target: any, prop: string) {\r\n        if (path.length === 0 && prop in rootLevelMethods) {\r\n          return rootLevelMethods[prop as keyof typeof rootLevelMethods];\r\n        }\r\n        if (!prop.startsWith('$')) {\r\n          const nextPath = [...path, prop];\r\n          return rebuildStateShape({\r\n            path: nextPath,\r\n            componentId: componentId!,\r\n            meta,\r\n          });\r\n        }\r\n        if (prop === '$_rebuildStateShape') {\r\n          return rebuildStateShape;\r\n        }\r\n\r\n        if (prop === '$sync' && path.length === 0) {\r\n          return async function () {\r\n            const options = getGlobalStore\r\n              .getState()\r\n              .getInitialOptions(stateKey);\r\n            const sync = options?.sync;\r\n\r\n            if (!sync) {\r\n              console.error(`No mutation defined for state key \"${stateKey}\"`);\r\n              return { success: false, error: `No mutation defined` };\r\n            }\r\n\r\n            const state = getGlobalStore\r\n              .getState()\r\n              .getShadowValue(stateKey, []);\r\n            const validationKey = options?.validation?.key;\r\n\r\n            try {\r\n              const response = await sync.action(state);\r\n              if (\r\n                response &&\r\n                !response.success &&\r\n                response.errors &&\r\n                validationKey\r\n              ) {\r\n                //  getGlobalStore.getState().removeValidationError(validationKey);\r\n                // response.errors.forEach((error) => {\r\n                //   const errorPath = [validationKey, ...error.path].join('.');\r\n                //   getGlobalStore\r\n                //     .getState()\r\n                //     .addValidationError(errorPath, error.message);\r\n                // });\r\n                //   notifyComponents(stateKey);\r\n              }\r\n\r\n              if (response?.success) {\r\n                // Mark as synced and not dirty\r\n                const shadowMeta = getGlobalStore\r\n                  .getState()\r\n                  .getShadowMetadata(stateKey, []);\r\n                setShadowMetadata(stateKey, [], {\r\n                  ...shadowMeta,\r\n                  isDirty: false,\r\n                  lastServerSync: Date.now(),\r\n                  stateSource: 'server',\r\n                  baseServerState: state, // Update base server state\r\n                });\r\n\r\n                if (sync.onSuccess) {\r\n                  sync.onSuccess(response.data);\r\n                }\r\n              } else if (!response?.success && sync.onError)\r\n                sync.onError(response.error);\r\n\r\n              return response;\r\n            } catch (error) {\r\n              if (sync.onError) sync.onError(error);\r\n              return { success: false, error };\r\n            }\r\n          };\r\n        }\r\n        // Fixed getStatus function in createProxyHandler\r\n        if (prop === '$_status' || prop === '$getStatus') {\r\n          const getStatusFunc = () => {\r\n            // ✅ Use the optimized helper to get all data in one efficient call\r\n            const { shadowMeta, value } = getScopedData(stateKey, path, meta);\r\n            console.log('getStatusFunc', path, shadowMeta, value);\r\n            if (shadowMeta?.isDirty === true) {\r\n              return 'dirty';\r\n            }\r\n\r\n            if (\r\n              shadowMeta?.stateSource === 'server' ||\r\n              shadowMeta?.isDirty === false\r\n            ) {\r\n              return 'synced';\r\n            }\r\n\r\n            if (shadowMeta?.stateSource === 'localStorage') {\r\n              return 'restored';\r\n            }\r\n\r\n            if (shadowMeta?.stateSource === 'default') {\r\n              return 'fresh';\r\n            }\r\n\r\n            if (value !== undefined) {\r\n              return 'fresh';\r\n            }\r\n\r\n            // Fallback if no other condition is met.\r\n            return 'unknown';\r\n          };\r\n\r\n          // This part remains the same\r\n          return prop === '$_status' ? getStatusFunc() : getStatusFunc;\r\n        }\r\n        if (prop === '$removeStorage') {\r\n          return () => {\r\n            const initialState =\r\n              getGlobalStore.getState().initialStateGlobal[stateKey];\r\n            const initalOptionsGet = getInitialOptions(stateKey as string);\r\n            const localKey = isFunction(initalOptionsGet?.localStorage?.key)\r\n              ? initalOptionsGet.localStorage.key(initialState)\r\n              : initalOptionsGet?.localStorage?.key;\r\n            const storageKey = `${sessionId}-${stateKey}-${localKey}`;\r\n            if (storageKey) localStorage.removeItem(storageKey);\r\n          };\r\n        }\r\n        if (prop === '$showValidationErrors') {\r\n          return () => {\r\n            const { shadowMeta } = getScopedData(stateKey, path, meta);\r\n            if (\r\n              shadowMeta?.validation?.status === 'INVALID' &&\r\n              shadowMeta.validation.errors.length > 0\r\n            ) {\r\n              // Return only error-severity messages (not warnings)\r\n              return shadowMeta.validation.errors\r\n                .filter((err) => err.severity === 'error')\r\n                .map((err) => err.message);\r\n            }\r\n            return [];\r\n          };\r\n        }\r\n\r\n        if (prop === '$getSelected') {\r\n          return () => {\r\n            const arrayKey = [stateKey, ...path].join('.');\r\n            registerComponentDependency(stateKey, componentId, [\r\n              ...path,\r\n              'getSelected',\r\n            ]);\r\n\r\n            const selectedItemKey = getGlobalStore\r\n              .getState()\r\n              .selectedIndicesMap.get(arrayKey);\r\n            if (!selectedItemKey) {\r\n              return undefined;\r\n            }\r\n\r\n            const viewKey = path.join('.');\r\n            const currentViewIds = meta?.arrayViews?.[viewKey];\r\n            const selectedItemId = selectedItemKey.split('.').pop();\r\n\r\n            // FIX: Only return the selected item if it exists in the current filtered/sorted view.\r\n            if (currentViewIds && !currentViewIds.includes(selectedItemId!)) {\r\n              return undefined;\r\n            }\r\n\r\n            const value = getShadowValue(\r\n              stateKey,\r\n              selectedItemKey.split('.').slice(1)\r\n            );\r\n            if (value === undefined) {\r\n              return undefined;\r\n            }\r\n\r\n            return rebuildStateShape({\r\n              path: selectedItemKey.split('.').slice(1) as string[],\r\n              componentId: componentId!,\r\n              meta,\r\n            });\r\n          };\r\n        }\r\n        if (prop === '$getSelectedIndex') {\r\n          return () => {\r\n            // Key for the array in the global selection map (e.g., \"myState.products\")\r\n            const arrayKey = stateKey + '.' + path.join('.');\r\n            // Key for this specific view in the meta object (e.g., \"products\")\r\n            const viewKey = path.join('.');\r\n\r\n            // Get the full path of the selected item (e.g., \"myState.products.id:abc\")\r\n            const selectedItemKey = getGlobalStore\r\n              .getState()\r\n              .selectedIndicesMap.get(arrayKey);\r\n\r\n            if (!selectedItemKey) {\r\n              return -1; // Nothing is selected for this array.\r\n            }\r\n\r\n            // Get the list of item IDs for the current filtered/sorted view.\r\n            const { keys: viewIds } = getArrayData(stateKey, path, meta);\r\n\r\n            if (!viewIds) {\r\n              return -1; // Should not happen if it's an array, but a safe guard.\r\n            }\r\n\r\n            // FIX: Extract just the ID from the full selected item path.\r\n            const selectedId = selectedItemKey.split('.').pop();\r\n\r\n            // Return the index of that ID within the current view's list of IDs.\r\n            return (viewIds as string[]).indexOf(selectedId as string);\r\n          };\r\n        }\r\n        if (prop === '$clearSelected') {\r\n          notifySelectionComponents(stateKey, path);\r\n          return () => {\r\n            clearSelectedIndex({\r\n              arrayKey: stateKey + '.' + path.join('.'),\r\n            });\r\n          };\r\n        }\r\n\r\n        if (prop === '$useVirtualView') {\r\n          return (\r\n            options: VirtualViewOptions\r\n          ): VirtualStateObjectResult<any[]> => {\r\n            const {\r\n              itemHeight = 50,\r\n              overscan = 6,\r\n              stickToBottom = false,\r\n              scrollStickTolerance = 75,\r\n            } = options;\r\n\r\n            const containerRef = useRef<HTMLDivElement | null>(null);\r\n            const [range, setRange] = useState({\r\n              startIndex: 0,\r\n              endIndex: 10,\r\n            });\r\n            const [rerender, forceUpdate] = useState({});\r\n            const initialScrollRef = useRef(true);\r\n\r\n            useEffect(() => {\r\n              const interval = setInterval(() => {\r\n                forceUpdate({});\r\n              }, 1000);\r\n              return () => clearInterval(interval);\r\n            }, []);\r\n\r\n            // Scroll state management\r\n            const scrollStateRef = useRef({\r\n              isUserScrolling: false,\r\n              lastScrollTop: 0,\r\n              scrollUpCount: 0,\r\n              isNearBottom: true,\r\n            });\r\n\r\n            // Measurement cache\r\n            const measurementCache = useRef(\r\n              new Map<string, { height: number; offset: number }>()\r\n            );\r\n            const { keys: arrayKeys } = getArrayData(stateKey, path, meta);\r\n\r\n            // Subscribe to state changes like stateList does\r\n            useEffect(() => {\r\n              const stateKeyPathKey = [stateKey, ...path].join('.');\r\n              const unsubscribe = getGlobalStore\r\n                .getState()\r\n                .subscribeToPath(stateKeyPathKey, (e) => {\r\n                  if (e.type === 'GET_SELECTED') {\r\n                    return;\r\n                  }\r\n                  if (e.type === 'SERVER_STATE_UPDATE') {\r\n                    //  forceUpdate({});\r\n                  }\r\n                });\r\n\r\n              return () => {\r\n                unsubscribe();\r\n              };\r\n            }, [componentId, stateKey, path.join('.')]);\r\n\r\n            // YOUR ORIGINAL INITIAL POSITIONING - KEEPING EXACTLY AS IS\r\n            useLayoutEffect(() => {\r\n              if (\r\n                stickToBottom &&\r\n                arrayKeys.length > 0 &&\r\n                containerRef.current &&\r\n                !scrollStateRef.current.isUserScrolling &&\r\n                initialScrollRef.current\r\n              ) {\r\n                const container = containerRef.current;\r\n\r\n                const waitForContainer = () => {\r\n                  if (container.clientHeight > 0) {\r\n                    const visibleCount = Math.ceil(\r\n                      container.clientHeight / itemHeight\r\n                    );\r\n                    const endIndex = arrayKeys.length - 1;\r\n                    const startIndex = Math.max(\r\n                      0,\r\n                      endIndex - visibleCount - overscan\r\n                    );\r\n\r\n                    setRange({ startIndex, endIndex });\r\n\r\n                    requestAnimationFrame(() => {\r\n                      scrollToBottom('instant');\r\n                      initialScrollRef.current = false;\r\n                    });\r\n                  } else {\r\n                    requestAnimationFrame(waitForContainer);\r\n                  }\r\n                };\r\n\r\n                waitForContainer();\r\n              }\r\n            }, [arrayKeys.length, stickToBottom, itemHeight, overscan]);\r\n\r\n            const rangeRef = useRef(range);\r\n            useLayoutEffect(() => {\r\n              rangeRef.current = range;\r\n            }, [range]);\r\n\r\n            const arrayKeysRef = useRef(arrayKeys);\r\n            useLayoutEffect(() => {\r\n              arrayKeysRef.current = arrayKeys;\r\n            }, [arrayKeys]);\r\n\r\n            const handleScroll = useCallback(() => {\r\n              const container = containerRef.current;\r\n              if (!container) return;\r\n\r\n              const currentScrollTop = container.scrollTop;\r\n              const { scrollHeight, clientHeight } = container;\r\n              const scrollState = scrollStateRef.current;\r\n\r\n              // Check if user is near bottom\r\n              const distanceFromBottom =\r\n                scrollHeight - (currentScrollTop + clientHeight);\r\n              const wasNearBottom = scrollState.isNearBottom;\r\n              scrollState.isNearBottom =\r\n                distanceFromBottom <= scrollStickTolerance;\r\n\r\n              // Detect scroll direction\r\n              if (currentScrollTop < scrollState.lastScrollTop) {\r\n                // User scrolled up\r\n                scrollState.scrollUpCount++;\r\n\r\n                if (scrollState.scrollUpCount > 3 && wasNearBottom) {\r\n                  // User has deliberately scrolled away from bottom\r\n                  scrollState.isUserScrolling = true;\r\n                  console.log('User scrolled away from bottom');\r\n                }\r\n              } else if (scrollState.isNearBottom) {\r\n                // Reset if we're back near the bottom\r\n                scrollState.isUserScrolling = false;\r\n                scrollState.scrollUpCount = 0;\r\n              }\r\n\r\n              scrollState.lastScrollTop = currentScrollTop;\r\n\r\n              // Update visible range\r\n              let newStartIndex = 0;\r\n              for (let i = 0; i < arrayKeys.length; i++) {\r\n                const itemKey = arrayKeys[i];\r\n                const item = measurementCache.current.get(itemKey!);\r\n                if (item && item.offset + item.height > currentScrollTop) {\r\n                  newStartIndex = i;\r\n                  break;\r\n                }\r\n              }\r\n              console.log(\r\n                'hadnlescroll ',\r\n                measurementCache.current,\r\n                newStartIndex,\r\n                range\r\n              );\r\n              // Only update if range actually changed\r\n              if (newStartIndex !== range.startIndex && range.startIndex != 0) {\r\n                const visibleCount = Math.ceil(clientHeight / itemHeight);\r\n                setRange({\r\n                  startIndex: Math.max(0, newStartIndex - overscan),\r\n                  endIndex: Math.min(\r\n                    arrayKeys.length - 1,\r\n                    newStartIndex + visibleCount + overscan\r\n                  ),\r\n                });\r\n              }\r\n            }, [\r\n              arrayKeys.length,\r\n              range.startIndex,\r\n              itemHeight,\r\n              overscan,\r\n              scrollStickTolerance,\r\n            ]);\r\n\r\n            // Set up scroll listener\r\n            useEffect(() => {\r\n              const container = containerRef.current;\r\n              if (!container) return;\r\n\r\n              container.addEventListener('scroll', handleScroll, {\r\n                passive: true,\r\n              });\r\n              return () => {\r\n                container.removeEventListener('scroll', handleScroll);\r\n              };\r\n            }, [handleScroll, stickToBottom]);\r\n\r\n            // YOUR ORIGINAL SCROLL TO BOTTOM FUNCTION - KEEPING EXACTLY AS IS\r\n            const scrollToBottom = useCallback(\r\n              (behavior: ScrollBehavior = 'smooth') => {\r\n                const container = containerRef.current;\r\n                if (!container) return;\r\n\r\n                scrollStateRef.current.isUserScrolling = false;\r\n                scrollStateRef.current.isNearBottom = true;\r\n                scrollStateRef.current.scrollUpCount = 0;\r\n\r\n                const performScroll = () => {\r\n                  const attemptScroll = (attempts = 0) => {\r\n                    if (attempts > 5) return;\r\n\r\n                    const currentHeight = container.scrollHeight;\r\n                    const currentScroll = container.scrollTop;\r\n                    const clientHeight = container.clientHeight;\r\n\r\n                    if (currentScroll + clientHeight >= currentHeight - 1) {\r\n                      return;\r\n                    }\r\n\r\n                    container.scrollTo({\r\n                      top: currentHeight,\r\n                      behavior: behavior,\r\n                    });\r\n\r\n                    setTimeout(() => {\r\n                      const newHeight = container.scrollHeight;\r\n                      const newScroll = container.scrollTop;\r\n\r\n                      if (\r\n                        newHeight !== currentHeight ||\r\n                        newScroll + clientHeight < newHeight - 1\r\n                      ) {\r\n                        attemptScroll(attempts + 1);\r\n                      }\r\n                    }, 50);\r\n                  };\r\n\r\n                  attemptScroll();\r\n                };\r\n\r\n                if ('requestIdleCallback' in window) {\r\n                  requestIdleCallback(performScroll, { timeout: 100 });\r\n                } else {\r\n                  requestAnimationFrame(() => {\r\n                    requestAnimationFrame(performScroll);\r\n                  });\r\n                }\r\n              },\r\n              []\r\n            );\r\n\r\n            // YOUR ORIGINAL AUTO-SCROLL EFFECTS - KEEPING ALL OF THEM\r\n            useEffect(() => {\r\n              if (!stickToBottom || !containerRef.current) return;\r\n\r\n              const container = containerRef.current;\r\n              const scrollState = scrollStateRef.current;\r\n\r\n              let scrollTimeout: NodeJS.Timeout;\r\n              const debouncedScrollToBottom = () => {\r\n                clearTimeout(scrollTimeout);\r\n                scrollTimeout = setTimeout(() => {\r\n                  if (\r\n                    !scrollState.isUserScrolling &&\r\n                    scrollState.isNearBottom\r\n                  ) {\r\n                    scrollToBottom(\r\n                      initialScrollRef.current ? 'instant' : 'smooth'\r\n                    );\r\n                  }\r\n                }, 100);\r\n              };\r\n\r\n              const observer = new MutationObserver(() => {\r\n                if (!scrollState.isUserScrolling) {\r\n                  debouncedScrollToBottom();\r\n                }\r\n              });\r\n\r\n              observer.observe(container, {\r\n                childList: true,\r\n                subtree: true,\r\n                attributes: true,\r\n                attributeFilter: ['style', 'class'],\r\n              });\r\n\r\n              if (initialScrollRef.current) {\r\n                setTimeout(() => {\r\n                  scrollToBottom('instant');\r\n                }, 0);\r\n              } else {\r\n                debouncedScrollToBottom();\r\n              }\r\n\r\n              return () => {\r\n                clearTimeout(scrollTimeout);\r\n                observer.disconnect();\r\n              };\r\n            }, [stickToBottom, arrayKeys.length, scrollToBottom]);\r\n\r\n            // Create virtual state - NO NEED to get values, only IDs!\r\n            const virtualState = useMemo(() => {\r\n              // 2. Physically slice the corresponding keys.\r\n              const slicedKeys = Array.isArray(arrayKeys)\r\n                ? arrayKeys.slice(range.startIndex, range.endIndex + 1)\r\n                : [];\r\n\r\n              // Use the same keying as getArrayData (empty string for root)\r\n              const arrayPath = path.length > 0 ? path.join('.') : 'root';\r\n              return rebuildStateShape({\r\n                path,\r\n                componentId: componentId!,\r\n                meta: {\r\n                  ...meta,\r\n                  arrayViews: { [arrayPath]: slicedKeys },\r\n                  serverStateIsUpStream: true,\r\n                },\r\n              });\r\n            }, [range.startIndex, range.endIndex, arrayKeys, meta]);\r\n\r\n            return {\r\n              virtualState,\r\n              virtualizerProps: {\r\n                outer: {\r\n                  ref: containerRef,\r\n                  style: {\r\n                    overflowY: 'auto' as const,\r\n                    height: '100%',\r\n                    position: 'relative' as const,\r\n                  },\r\n                },\r\n                inner: {\r\n                  style: {\r\n                    position: 'relative' as const,\r\n                  },\r\n                },\r\n                list: {\r\n                  style: {\r\n                    transform: `translateY(${\r\n                      measurementCache.current.get(arrayKeys[range.startIndex]!)\r\n                        ?.offset || 0\r\n                    }px)`,\r\n                  },\r\n                },\r\n              },\r\n              scrollToBottom,\r\n              scrollToIndex: (\r\n                index: number,\r\n                behavior: ScrollBehavior = 'smooth'\r\n              ) => {\r\n                if (containerRef.current && arrayKeys[index]) {\r\n                  const offset =\r\n                    measurementCache.current.get(arrayKeys[index]!)?.offset ||\r\n                    0;\r\n                  containerRef.current.scrollTo({ top: offset, behavior });\r\n                }\r\n              },\r\n            };\r\n          };\r\n        }\r\n        if (prop === '$stateMap') {\r\n          return (\r\n            callbackfn: (setter: any, index: number, arraySetter: any) => void\r\n          ) => {\r\n            // FIX: Use getArrayData to reliably get both the value and the keys of the current view.\r\n            const { value: shadowValue, keys: arrayKeys } = getArrayData(\r\n              stateKey,\r\n              path,\r\n              meta\r\n            );\r\n            registerComponentDependency(stateKey, componentId, path);\r\n            if (!arrayKeys || !Array.isArray(shadowValue)) {\r\n              return []; // It's valid to map over an empty array.\r\n            }\r\n\r\n            const arraySetter = rebuildStateShape({\r\n              path,\r\n              componentId: componentId!,\r\n              meta,\r\n            });\r\n\r\n            return shadowValue.map((_item, index) => {\r\n              const itemKey = arrayKeys[index];\r\n              if (!itemKey) return undefined;\r\n\r\n              // FIX: Construct the correct path to the item in the original store.\r\n              // The path is the array's path plus the specific item's unique key.\r\n              const itemPath = [...path, itemKey];\r\n\r\n              const itemSetter = rebuildStateShape({\r\n                path: itemPath, // This now correctly points to the item in the shadow store.\r\n                componentId: componentId!,\r\n                meta,\r\n              });\r\n\r\n              return callbackfn(itemSetter, index, arraySetter);\r\n            });\r\n          };\r\n        }\r\n\r\n        if (prop === '$stateFilter') {\r\n          return (callbackfn: (value: any, index: number) => boolean) => {\r\n            const arrayPathKey = path.length > 0 ? path.join('.') : 'root';\r\n\r\n            // ✅ FIX: Get keys from `getArrayData` which correctly resolves them from meta or the full list.\r\n            const { keys: currentViewIds, value: array } = getArrayData(\r\n              stateKey,\r\n              path,\r\n              meta\r\n            );\r\n\r\n            if (!Array.isArray(array)) {\r\n              throw new Error('stateFilter can only be used on arrays');\r\n            }\r\n\r\n            // Filter the array and collect the IDs of the items that pass\r\n            const filteredIds: string[] = [];\r\n            array.forEach((item, index) => {\r\n              if (callbackfn(item, index)) {\r\n                // currentViewIds[index] is the original ID before filtering\r\n                const id = currentViewIds[index];\r\n                if (id) {\r\n                  filteredIds.push(id);\r\n                }\r\n              }\r\n            });\r\n\r\n            // The rest is the same...\r\n            return rebuildStateShape({\r\n              path,\r\n              componentId: componentId!,\r\n              meta: {\r\n                ...meta,\r\n                arrayViews: {\r\n                  ...(meta?.arrayViews || {}),\r\n                  [arrayPathKey]: filteredIds,\r\n                },\r\n                transforms: [\r\n                  ...(meta?.transforms || []),\r\n                  { type: 'filter', fn: callbackfn, path },\r\n                ],\r\n              },\r\n            });\r\n          };\r\n        }\r\n        if (prop === '$stateSort') {\r\n          return (compareFn: (a: any, b: any) => number) => {\r\n            const arrayPathKey = path.length > 0 ? path.join('.') : 'root';\r\n\r\n            // FIX: Use the more robust `getArrayData` which always correctly resolves the keys for a view.\r\n            const { value: currentArray, keys: currentViewIds } = getArrayData(\r\n              stateKey,\r\n              path,\r\n              meta\r\n            );\r\n\r\n            if (!Array.isArray(currentArray) || !currentViewIds) {\r\n              throw new Error('No array keys found for sorting');\r\n            }\r\n\r\n            // ... (rest of the function is the same and now works)\r\n            const itemsWithIds = currentArray.map((item, index) => ({\r\n              item,\r\n              key: currentViewIds[index],\r\n            }));\r\n            itemsWithIds.sort((a, b) => compareFn(a.item, b.item));\r\n            const sortedIds = itemsWithIds.map((i) => i.key as string);\r\n\r\n            return rebuildStateShape({\r\n              path,\r\n              componentId: componentId!,\r\n              meta: {\r\n                ...meta,\r\n                arrayViews: {\r\n                  ...(meta?.arrayViews || {}),\r\n                  [arrayPathKey]: sortedIds,\r\n                },\r\n                transforms: [\r\n                  ...(meta?.transforms || []),\r\n                  { type: 'sort', fn: compareFn, path },\r\n                ],\r\n              },\r\n            });\r\n          };\r\n        }\r\n        // In createProxyHandler, inside the get trap where you have other array methods:\r\n        if (prop === '$stream') {\r\n          return function <U = InferArrayElement<T>, R = U>(\r\n            options: StreamOptions<U, R> = {}\r\n          ): StreamHandle<U> {\r\n            const {\r\n              bufferSize = 100,\r\n              flushInterval = 100,\r\n              bufferStrategy = 'accumulate',\r\n              store,\r\n              onFlush,\r\n            } = options;\r\n\r\n            let buffer: U[] = [];\r\n            let isPaused = false;\r\n            let flushTimer: NodeJS.Timeout | null = null;\r\n\r\n            const addToBuffer = (item: U) => {\r\n              if (isPaused) return;\r\n\r\n              if (bufferStrategy === 'sliding' && buffer.length >= bufferSize) {\r\n                buffer.shift();\r\n              } else if (\r\n                bufferStrategy === 'dropping' &&\r\n                buffer.length >= bufferSize\r\n              ) {\r\n                return;\r\n              }\r\n\r\n              buffer.push(item);\r\n\r\n              if (buffer.length >= bufferSize) {\r\n                flushBuffer();\r\n              }\r\n            };\r\n\r\n            const flushBuffer = () => {\r\n              if (buffer.length === 0) return;\r\n\r\n              const toFlush = [...buffer];\r\n              buffer = [];\r\n\r\n              if (store) {\r\n                const result = store(toFlush);\r\n                if (result !== undefined) {\r\n                  const items = Array.isArray(result) ? result : [result];\r\n                  items.forEach((item) => {\r\n                    effectiveSetState(item as any, path, {\r\n                      updateType: 'insert',\r\n                    });\r\n                  });\r\n                }\r\n              } else {\r\n                toFlush.forEach((item) => {\r\n                  effectiveSetState(item as any, path, {\r\n                    updateType: 'insert',\r\n                  });\r\n                });\r\n              }\r\n\r\n              onFlush?.(toFlush);\r\n            };\r\n\r\n            if (flushInterval > 0) {\r\n              flushTimer = setInterval(flushBuffer, flushInterval);\r\n            }\r\n\r\n            const streamId = uuidv4();\r\n            const currentMeta = getShadowMetadata(stateKey, path) || {};\r\n            const streams = currentMeta.streams || new Map();\r\n            streams.set(streamId, { buffer, flushTimer });\r\n\r\n            setShadowMetadata(stateKey, path, {\r\n              ...currentMeta,\r\n              streams,\r\n            });\r\n\r\n            return {\r\n              write: (data: U) => addToBuffer(data),\r\n              writeMany: (data: U[]) => data.forEach(addToBuffer),\r\n              flush: () => flushBuffer(),\r\n              pause: () => {\r\n                isPaused = true;\r\n              },\r\n              resume: () => {\r\n                isPaused = false;\r\n                if (buffer.length > 0) flushBuffer();\r\n              },\r\n              close: () => {\r\n                flushBuffer();\r\n                if (flushTimer) clearInterval(flushTimer);\r\n\r\n                const meta = getGlobalStore\r\n                  .getState()\r\n                  .getShadowMetadata(stateKey, path);\r\n                if (meta?.streams) {\r\n                  meta.streams.delete(streamId);\r\n                }\r\n              },\r\n            };\r\n          };\r\n        }\r\n\r\n        if (prop === '$stateList') {\r\n          return (\r\n            callbackfn: (\r\n              setter: any,\r\n              index: number,\r\n              arraySetter: any\r\n            ) => ReactNode\r\n          ) => {\r\n            const StateListWrapper = () => {\r\n              const componentIdsRef = useRef<Map<string, string>>(new Map());\r\n\r\n              const [updateTrigger, forceUpdate] = useState({});\r\n\r\n              const arrayPathKey = path.length > 0 ? path.join('.') : 'root';\r\n\r\n              const validIds = applyTransforms(stateKey, path, meta);\r\n\r\n              // Memoize the updated meta to prevent creating new objects on every render\r\n              const updatedMeta = useMemo(() => {\r\n                return {\r\n                  ...meta,\r\n                  arrayViews: {\r\n                    ...(meta?.arrayViews || {}),\r\n                    [arrayPathKey]: validIds,\r\n                  },\r\n                };\r\n              }, [meta, arrayPathKey, validIds]);\r\n\r\n              // Now use the updated meta when getting array data\r\n              const { value: arrayValues } = getArrayData(\r\n                stateKey,\r\n                path,\r\n                updatedMeta\r\n              );\r\n\r\n              useEffect(() => {\r\n                const unsubscribe = getGlobalStore\r\n                  .getState()\r\n                  .subscribeToPath(stateKeyPathKey, (e) => {\r\n                    if (e.type === 'GET_SELECTED') {\r\n                      return;\r\n                    }\r\n                    const shadowMeta = getGlobalStore\r\n                      .getState()\r\n                      .getShadowMetadata(stateKey, path);\r\n\r\n                    const caches = shadowMeta?.transformCaches;\r\n                    if (caches) {\r\n                      // Iterate over ALL keys in the cache map.\r\n                      for (const key of caches.keys()) {\r\n                        // If the key belongs to this component instance, delete it.\r\n                        // This purges caches for 'sort by name', 'sort by score', etc.\r\n                        if (key.startsWith(componentId)) {\r\n                          caches.delete(key);\r\n                        }\r\n                      }\r\n                    }\r\n\r\n                    if (\r\n                      e.type === 'INSERT' ||\r\n                      e.type === 'INSERT_MANY' ||\r\n                      e.type === 'REMOVE' ||\r\n                      e.type === 'CLEAR_SELECTION' ||\r\n                      (e.type === 'SERVER_STATE_UPDATE' &&\r\n                        !meta?.serverStateIsUpStream)\r\n                    ) {\r\n                      forceUpdate({});\r\n                    }\r\n                  });\r\n\r\n                return () => {\r\n                  unsubscribe();\r\n                };\r\n\r\n                // This effect's logic now depends on the componentId to perform the purge.\r\n              }, [componentId, stateKeyPathKey]);\r\n\r\n              if (!Array.isArray(arrayValues)) {\r\n                return null;\r\n              }\r\n\r\n              // Continue using updatedMeta for the rest of your logic instead of meta\r\n              const arraySetter = rebuildStateShape({\r\n                path,\r\n                componentId: componentId!,\r\n                meta: updatedMeta, // Use updated meta here\r\n              });\r\n\r\n              const returnValue = arrayValues.map((item, localIndex) => {\r\n                const itemKey = validIds[localIndex];\r\n\r\n                if (!itemKey) {\r\n                  return null;\r\n                }\r\n\r\n                let itemComponentId = componentIdsRef.current.get(itemKey);\r\n                if (!itemComponentId) {\r\n                  itemComponentId = uuidv4();\r\n                  componentIdsRef.current.set(itemKey, itemComponentId);\r\n                }\r\n\r\n                const itemPath = [...path, itemKey];\r\n\r\n                return createElement(MemoizedCogsItemWrapper, {\r\n                  key: itemKey,\r\n                  stateKey,\r\n                  itemComponentId,\r\n                  itemPath,\r\n                  localIndex,\r\n                  arraySetter,\r\n                  rebuildStateShape,\r\n                  renderFn: callbackfn,\r\n                });\r\n              });\r\n\r\n              return <>{returnValue}</>;\r\n            };\r\n\r\n            return <StateListWrapper />;\r\n          };\r\n        }\r\n        if (prop === '$stateFlattenOn') {\r\n          return (fieldName: string) => {\r\n            // FIX: Get the definitive list of IDs for the current view from meta.arrayViews.\r\n            const arrayPathKey = path.length > 0 ? path.join('.') : 'root';\r\n            const viewIds = meta?.arrayViews?.[arrayPathKey];\r\n\r\n            const currentState = getGlobalStore\r\n              .getState()\r\n              .getShadowValue(stateKey, path, viewIds);\r\n\r\n            if (!Array.isArray(currentState)) return [];\r\n\r\n            return rebuildStateShape({\r\n              path: [...path, '[*]', fieldName],\r\n              componentId: componentId!,\r\n              meta,\r\n            });\r\n          };\r\n        }\r\n        if (prop === '$index') {\r\n          return (index: number) => {\r\n            const arrayPathKey = path.length > 0 ? path.join('.') : 'root';\r\n            const viewIds = meta?.arrayViews?.[arrayPathKey];\r\n\r\n            if (viewIds) {\r\n              const itemId = viewIds[index];\r\n              if (!itemId) return undefined;\r\n              return rebuildStateShape({\r\n                path: [...path, itemId],\r\n                componentId: componentId!,\r\n                meta,\r\n              });\r\n            }\r\n\r\n            // ✅ FIX: Get the metadata and use the `arrayKeys` property.\r\n            const shadowMeta = getShadowMetadata(stateKey, path);\r\n            if (!shadowMeta?.arrayKeys) return undefined;\r\n\r\n            const itemId = shadowMeta.arrayKeys[index];\r\n            if (!itemId) return undefined;\r\n\r\n            return rebuildStateShape({\r\n              path: [...path, itemId],\r\n              componentId: componentId!,\r\n              meta,\r\n            });\r\n          };\r\n        }\r\n        if (prop === '$last') {\r\n          return () => {\r\n            const { keys: currentViewIds } = getArrayData(stateKey, path, meta);\r\n            if (!currentViewIds || currentViewIds.length === 0) {\r\n              return undefined;\r\n            }\r\n            const lastItemKey = currentViewIds[currentViewIds.length - 1];\r\n\r\n            if (!lastItemKey) {\r\n              return undefined;\r\n            }\r\n            const newPath = [...path, lastItemKey];\r\n\r\n            return rebuildStateShape({\r\n              path: newPath,\r\n              componentId: componentId!,\r\n              meta,\r\n            });\r\n          };\r\n        }\r\n        if (prop === '$insert') {\r\n          return (\r\n            payload: InsertParams<InferArrayElement<T>>,\r\n            index?: number\r\n          ) => {\r\n            effectiveSetState(payload as any, path, {\r\n              updateType: 'insert',\r\n              index,\r\n            });\r\n          };\r\n        }\r\n        if (prop === '$insertMany') {\r\n          return (payload: InferArrayElement<T>[]) => {\r\n            // Call the one true path for all state changes.\r\n            effectiveSetState(payload as any, path, {\r\n              updateType: 'insert_many',\r\n            });\r\n          };\r\n        }\r\n        if (prop === '$uniqueInsert') {\r\n          return (\r\n            payload: UpdateArg<T>,\r\n            fields?: (keyof InferArrayElement<T>)[],\r\n            onMatch?: (existingItem: any) => any\r\n          ) => {\r\n            const { value: currentArray } = getScopedData(\r\n              stateKey,\r\n              path,\r\n              meta\r\n            ) as {\r\n              value: any[];\r\n            };\r\n            const newValue = isFunction<T>(payload)\r\n              ? payload(currentArray as any)\r\n              : (payload as any);\r\n\r\n            let matchedItem: any = null;\r\n            const isUnique = !currentArray.some((item) => {\r\n              const isMatch = fields\r\n                ? fields.every((field) =>\r\n                    isDeepEqual(item[field], newValue[field])\r\n                  )\r\n                : isDeepEqual(item, newValue);\r\n              if (isMatch) matchedItem = item;\r\n              return isMatch;\r\n            });\r\n\r\n            if (isUnique) {\r\n              effectiveSetState(newValue, path, { updateType: 'insert' });\r\n            } else if (onMatch && matchedItem) {\r\n              const updatedItem = onMatch(matchedItem);\r\n              const updatedArray = currentArray.map((item) =>\r\n                isDeepEqual(item, matchedItem) ? updatedItem : item\r\n              );\r\n\r\n              effectiveSetState(updatedArray as any, path, {\r\n                updateType: 'update',\r\n              });\r\n            }\r\n          };\r\n        }\r\n        if (prop === '$cut') {\r\n          return (index?: number, options?: { waitForSync?: boolean }) => {\r\n            const shadowMeta = getShadowMetadata(stateKey, path);\r\n            if (!shadowMeta?.arrayKeys || shadowMeta.arrayKeys.length === 0)\r\n              return;\r\n\r\n            const indexToCut =\r\n              index === -1\r\n                ? shadowMeta.arrayKeys.length - 1\r\n                : index !== undefined\r\n                  ? index\r\n                  : shadowMeta.arrayKeys.length - 1;\r\n\r\n            const idToCut = shadowMeta.arrayKeys[indexToCut];\r\n            if (!idToCut) return;\r\n\r\n            effectiveSetState(null, [...path, idToCut], {\r\n              updateType: 'cut',\r\n            });\r\n          };\r\n        }\r\n        if (prop === '$cutSelected') {\r\n          return () => {\r\n            const arrayKey = [stateKey, ...path].join('.');\r\n\r\n            const { keys: currentViewIds } = getArrayData(stateKey, path, meta);\r\n            if (!currentViewIds || currentViewIds.length === 0) {\r\n              return;\r\n            }\r\n            const selectedItemKey = getGlobalStore\r\n              .getState()\r\n              .selectedIndicesMap.get(arrayKey);\r\n\r\n            if (!selectedItemKey) {\r\n              return;\r\n            }\r\n            const selectedId = selectedItemKey.split('.').pop() as string;\r\n\r\n            if (!(currentViewIds as any[]).includes(selectedId!)) {\r\n              return;\r\n            }\r\n            const pathForCut = selectedItemKey.split('.').slice(1);\r\n            getGlobalStore.getState().clearSelectedIndex({ arrayKey });\r\n\r\n            const parentPath = pathForCut.slice(0, -1);\r\n            notifySelectionComponents(stateKey, parentPath);\r\n\r\n            effectiveSetState(null, pathForCut, {\r\n              updateType: 'cut',\r\n            });\r\n          };\r\n        }\r\n        if (prop === '$cutByValue') {\r\n          return (value: string | number | boolean) => {\r\n            const {\r\n              isArray,\r\n              value: array,\r\n              keys,\r\n            } = getArrayData(stateKey, path, meta);\r\n\r\n            if (!isArray) return;\r\n\r\n            const found = findArrayItem(array, keys, (item) => item === value);\r\n            if (found) {\r\n              effectiveSetState(null, [...path, found.key], {\r\n                updateType: 'cut',\r\n              });\r\n            }\r\n          };\r\n        }\r\n\r\n        if (prop === '$toggleByValue') {\r\n          return (value: string | number | boolean) => {\r\n            const {\r\n              isArray,\r\n              value: array,\r\n              keys,\r\n            } = getArrayData(stateKey, path, meta);\r\n\r\n            if (!isArray) return;\r\n\r\n            const found = findArrayItem(array, keys, (item) => item === value);\r\n\r\n            if (found) {\r\n              const pathForItem = [...path, found.key];\r\n\r\n              effectiveSetState(null, pathForItem, {\r\n                updateType: 'cut',\r\n              });\r\n            } else {\r\n              effectiveSetState(value as any, path, { updateType: 'insert' });\r\n            }\r\n          };\r\n        }\r\n        if (prop === '$findWith') {\r\n          return (searchKey: string, searchValue: any) => {\r\n            const { isArray, value, keys } = getArrayData(stateKey, path, meta);\r\n\r\n            if (!isArray) {\r\n              throw new Error('findWith can only be used on arrays');\r\n            }\r\n\r\n            const found = findArrayItem(\r\n              value,\r\n              keys,\r\n              (item) => item?.[searchKey] === searchValue\r\n            );\r\n\r\n            if (found) {\r\n              return rebuildStateShape({\r\n                path: [...path, found.key],\r\n                componentId: componentId!,\r\n                meta,\r\n              });\r\n            }\r\n\r\n            return null;\r\n          };\r\n        }\r\n        if (prop === '$cutThis') {\r\n          const { value: shadowValue } = getScopedData(stateKey, path, meta);\r\n          const parentPath = path.slice(0, -1);\r\n          notifySelectionComponents(stateKey, parentPath);\r\n          return () => {\r\n            effectiveSetState(shadowValue, path, { updateType: 'cut' });\r\n          };\r\n        }\r\n\r\n        if (prop === '$get') {\r\n          return () => {\r\n            registerComponentDependency(stateKey, componentId, path);\r\n            const { value } = getScopedData(stateKey, path, meta);\r\n            return value;\r\n          };\r\n        }\r\n\r\n        if (prop === '$$derive') {\r\n          return (fn: any) =>\r\n            $cogsSignal({\r\n              _stateKey: stateKey,\r\n              _path: path,\r\n              _effect: fn.toString(),\r\n              _meta: meta,\r\n            });\r\n        }\r\n\r\n        if (prop === '$formInput') {\r\n          const _getFormElement = (path: string[]): HTMLElement | null => {\r\n            const metadata = getShadowMetadata(stateKey, path);\r\n            if (metadata?.formRef?.current) {\r\n              return metadata.formRef.current;\r\n            }\r\n            // This warning is helpful for debugging if a ref is missing.\r\n            console.warn(\r\n              `Form element ref not found for stateKey \"${stateKey}\" at path \"${path.join('.')}\"`\r\n            );\r\n            return null;\r\n          };\r\n          return {\r\n            setDisabled: (isDisabled: boolean) => {\r\n              const element = _getFormElement(path) as HTMLInputElement | null;\r\n              if (element) {\r\n                element.disabled = isDisabled;\r\n              }\r\n            },\r\n            focus: () => {\r\n              const element = _getFormElement(path);\r\n              element?.focus();\r\n            },\r\n            blur: () => {\r\n              const element = _getFormElement(path);\r\n              element?.blur();\r\n            },\r\n            scrollIntoView: (options?: ScrollIntoViewOptions) => {\r\n              const element = _getFormElement(path);\r\n              element?.scrollIntoView(\r\n                options ?? { behavior: 'smooth', block: 'center' }\r\n              );\r\n            },\r\n            click: () => {\r\n              const element = _getFormElement(path);\r\n              element?.click();\r\n            },\r\n            selectText: () => {\r\n              const element = _getFormElement(path) as\r\n                | HTMLInputElement\r\n                | HTMLTextAreaElement\r\n                | null;\r\n              if (element && typeof element.select === 'function') {\r\n                element.select();\r\n              }\r\n            },\r\n          };\r\n        }\r\n        if (prop === '$$get') {\r\n          return () =>\r\n            $cogsSignal({ _stateKey: stateKey, _path: path, _meta: meta });\r\n        }\r\n\r\n        if (prop === '$lastSynced') {\r\n          const syncKey = `${stateKey}:${path.join('.')}`;\r\n          return getSyncInfo(syncKey);\r\n        }\r\n        if (prop == 'getLocalStorage') {\r\n          return (key: string) =>\r\n            loadFromLocalStorage(sessionId + '-' + stateKey + '-' + key);\r\n        }\r\n        if (prop === '$isSelected') {\r\n          const parentPathArray = path.slice(0, -1);\r\n          const parentMeta = getShadowMetadata(stateKey, parentPathArray);\r\n\r\n          if (parentMeta?.arrayKeys) {\r\n            const fullParentKey = stateKey + '.' + parentPathArray.join('.');\r\n            const selectedItemKey = getGlobalStore\r\n              .getState()\r\n              .selectedIndicesMap.get(fullParentKey);\r\n\r\n            const fullItemKey = stateKey + '.' + path.join('.');\r\n\r\n            return selectedItemKey === fullItemKey;\r\n          }\r\n          return undefined;\r\n        }\r\n\r\n        if (prop === '$setSelected') {\r\n          return (value: boolean) => {\r\n            const parentPath = path.slice(0, -1);\r\n            const fullParentKey = stateKey + '.' + parentPath.join('.');\r\n            const fullItemKey = stateKey + '.' + path.join('.');\r\n\r\n            notifySelectionComponents(stateKey, parentPath, undefined);\r\n\r\n            const selectedIndex = getGlobalStore\r\n              .getState()\r\n              .selectedIndicesMap.get(fullParentKey);\r\n\r\n            if (value) {\r\n              getGlobalStore\r\n                .getState()\r\n                .setSelectedIndex(fullParentKey, fullItemKey);\r\n            }\r\n          };\r\n        }\r\n\r\n        if (prop === '$toggleSelected') {\r\n          return () => {\r\n            const parentPath = path.slice(0, -1);\r\n            const fullParentKey = stateKey + '.' + parentPath.join('.');\r\n            const fullItemKey = stateKey + '.' + path.join('.');\r\n\r\n            const currentSelected = getGlobalStore\r\n              .getState()\r\n              .selectedIndicesMap.get(fullParentKey);\r\n\r\n            if (currentSelected === fullItemKey) {\r\n              getGlobalStore\r\n                .getState()\r\n                .clearSelectedIndex({ arrayKey: fullParentKey });\r\n            } else {\r\n              getGlobalStore\r\n                .getState()\r\n                .setSelectedIndex(fullParentKey, fullItemKey);\r\n            }\r\n            notifySelectionComponents(stateKey, parentPath);\r\n          };\r\n        }\r\n        if (prop === '$_componentId') {\r\n          return componentId;\r\n        }\r\n        if (path.length == 0) {\r\n          if (prop === '$setOptions') {\r\n            return (options: OptionsType<T>) => {\r\n              setOptions({ stateKey, options, initialOptionsPart: {} });\r\n            };\r\n          }\r\n\r\n          if (prop === '$useFocusedFormElement') {\r\n            // The returned function is the hook.\r\n            return () => {\r\n              const { subscribeToPath } = getGlobalStore.getState();\r\n\r\n              // Define the virtual path consistently.\r\n              const virtualFocusPath = `${stateKey}.__focusedElement`;\r\n\r\n              const [focusedElement, setFocusedElement] = useState(\r\n                // Lazily get the initial value from the root metadata.\r\n                () => getShadowMetadata(stateKey, [])?.focusedElement || null\r\n              );\r\n\r\n              useEffect(() => {\r\n                // Subscribe specifically to the virtual path. The callback is the state setter.\r\n                const unsubscribe = subscribeToPath(\r\n                  virtualFocusPath,\r\n                  setFocusedElement\r\n                );\r\n\r\n                // The cleanup function is returned by the existing subscription system.\r\n                return unsubscribe;\r\n              }, [stateKey]); // Only subscribe once for the lifetime of the component.\r\n\r\n              return focusedElement;\r\n            };\r\n          }\r\n          if (prop === '$_applyUpdate') {\r\n            return (\r\n              value: any,\r\n              path: string[],\r\n              updateType: 'update' | 'insert' | 'cut' = 'update'\r\n            ) => {\r\n              effectiveSetState(value, path, { updateType });\r\n            };\r\n          }\r\n\r\n          if (prop === '$_getEffectiveSetState') {\r\n            return effectiveSetState;\r\n          }\r\n          if (prop === '$getPluginMetaData') {\r\n            return (pluginName: string) =>\r\n              getPluginMetaDataMap(stateKey, path)?.get(pluginName);\r\n          }\r\n          if (prop === '$addPluginMetaData') {\r\n            console.log('$addPluginMetaDat');\r\n            return (pluginName: string, data: Record<string, any>) =>\r\n              setPluginMetaData(stateKey, path, pluginName, data);\r\n          }\r\n          if (prop === '$removePluginMetaData') {\r\n            return (pluginName: string) =>\r\n              removePluginMetaData(stateKey, path, pluginName);\r\n          }\r\n          if (prop === '$addZodValidation') {\r\n            return (\r\n              zodErrors: any[],\r\n              source: 'client' | 'sync_engine' | 'api'\r\n            ) => {\r\n              zodErrors.forEach((error) => {\r\n                const currentMeta =\r\n                  getGlobalStore\r\n                    .getState()\r\n                    .getShadowMetadata(stateKey, error.path) || {};\r\n\r\n                getGlobalStore\r\n                  .getState()\r\n                  .setShadowMetadata(stateKey, error.path, {\r\n                    ...currentMeta,\r\n                    validation: {\r\n                      status: 'INVALID',\r\n                      errors: [\r\n                        {\r\n                          source: source || 'client',\r\n                          message: error.message,\r\n                          severity: 'error',\r\n                          code: error.code,\r\n                        },\r\n                      ],\r\n                      lastValidated: Date.now(),\r\n                      validatedValue: undefined,\r\n                    },\r\n                  });\r\n              });\r\n            };\r\n          }\r\n          if (prop === '$clearZodValidation') {\r\n            return (path?: string[]) => {\r\n              if (!path) {\r\n                throw new Error('clearZodValidation requires a path');\r\n              }\r\n\r\n              const currentMeta = getShadowMetadata(stateKey, path) || {};\r\n\r\n              setShadowMetadata(stateKey, path, {\r\n                ...currentMeta,\r\n                validation: {\r\n                  status: 'NOT_VALIDATED',\r\n                  errors: [],\r\n                  lastValidated: Date.now(),\r\n                },\r\n              });\r\n            };\r\n          }\r\n\r\n          if (prop === '$applyOperation') {\r\n            return (\r\n              operation: UpdateTypeDetail & {\r\n                validation?: any[];\r\n                version?: string;\r\n              },\r\n              metaData?: Record<string, any>\r\n            ) => {\r\n              // const validationErrorsFromServer = operation.validation || [];\r\n\r\n              // if (!operation || !operation.path) {\r\n              //   console.error(\r\n              //     'Invalid operation received by $applyOperation:',\r\n              //     operation\r\n              //   );\r\n              //   return;\r\n              // }\r\n\r\n              // const newErrors: ValidationError[] =\r\n              //   validationErrorsFromServer.map((err) => ({\r\n              //     source: 'sync_engine',\r\n              //     message: err.message,\r\n              //     severity: 'warning',\r\n              //     code: err.code,\r\n              //   }));\r\n              // console.log('newErrors', newErrors);\r\n              // getGlobalStore\r\n              //   .getState()\r\n              //   .setShadowMetadata(stateKey, operation.path, {\r\n              //     validation: {\r\n              //       status: newErrors.length > 0 ? 'INVALID' : 'VALID',\r\n              //       errors: newErrors,\r\n              //       lastValidated: Date.now(),\r\n              //     },\r\n              //   });\r\n              console.log(\r\n                'getGlobalStore',\r\n                getGlobalStore\r\n                  .getState()\r\n                  .getShadowMetadata(stateKey, operation.path)\r\n              );\r\n              let index: number | undefined;\r\n              if (\r\n                operation.insertAfterId &&\r\n                operation.updateType === 'insert'\r\n              ) {\r\n                const shadowMeta = getShadowMetadata(stateKey, operation.path);\r\n                if (shadowMeta?.arrayKeys) {\r\n                  const afterIndex = shadowMeta.arrayKeys.indexOf(\r\n                    operation.insertAfterId\r\n                  );\r\n                  if (afterIndex !== -1) {\r\n                    index = afterIndex + 1; // Insert after the found item\r\n                  }\r\n                }\r\n              }\r\n\r\n              effectiveSetState(operation.newValue, operation.path, {\r\n                updateType: operation.updateType,\r\n                itemId: operation.itemId,\r\n                index, // Pass the calculated index\r\n                metaData,\r\n              });\r\n            };\r\n          }\r\n          if (prop === '$applyJsonPatch') {\r\n            return (patches: Operation[]) => {\r\n              const store = getGlobalStore.getState();\r\n              const rootMeta = store.getShadowMetadata(stateKey, []);\r\n              if (!rootMeta?.components) return;\r\n\r\n              const convertPath = (jsonPath: string): string[] => {\r\n                if (!jsonPath || jsonPath === '/') return [];\r\n                return jsonPath\r\n                  .split('/')\r\n                  .slice(1)\r\n                  .map((p) => p.replace(/~1/g, '/').replace(/~0/g, '~'));\r\n              };\r\n\r\n              const notifiedComponents = new Set<string>();\r\n\r\n              for (const patch of patches) {\r\n                const relativePath = convertPath(patch.path);\r\n\r\n                switch (patch.op) {\r\n                  case 'add':\r\n                  case 'replace': {\r\n                    const { value } = patch as {\r\n                      op: 'add' | 'replace';\r\n                      path: string;\r\n                      value: any;\r\n                    };\r\n                    store.updateShadowAtPath(stateKey, relativePath, value);\r\n\r\n                    store.markAsDirty(stateKey, relativePath, { bubble: true });\r\n\r\n                    // Bubble up - notify components at this path and all parent paths\r\n                    let currentPath = [...relativePath];\r\n                    while (true) {\r\n                      const pathMeta = store.getShadowMetadata(\r\n                        stateKey,\r\n                        currentPath\r\n                      );\r\n\r\n                      if (pathMeta?.pathComponents) {\r\n                        pathMeta.pathComponents.forEach((componentId) => {\r\n                          if (!notifiedComponents.has(componentId)) {\r\n                            const component =\r\n                              rootMeta.components?.get(componentId);\r\n                            if (component) {\r\n                              component.forceUpdate();\r\n                              notifiedComponents.add(componentId);\r\n                            }\r\n                          }\r\n                        });\r\n                      }\r\n\r\n                      if (currentPath.length === 0) break;\r\n                      currentPath.pop(); // Go up one level\r\n                    }\r\n                    break;\r\n                  }\r\n                  case 'remove': {\r\n                    const parentPath = relativePath.slice(0, -1);\r\n                    store.removeShadowArrayElement(stateKey, relativePath);\r\n                    store.markAsDirty(stateKey, parentPath, { bubble: true });\r\n\r\n                    // Bubble up from parent path\r\n                    let currentPath = [...parentPath];\r\n                    while (true) {\r\n                      const pathMeta = store.getShadowMetadata(\r\n                        stateKey,\r\n                        currentPath\r\n                      );\r\n                      if (pathMeta?.pathComponents) {\r\n                        pathMeta.pathComponents.forEach((componentId) => {\r\n                          if (!notifiedComponents.has(componentId)) {\r\n                            const component =\r\n                              rootMeta.components?.get(componentId);\r\n                            if (component) {\r\n                              component.forceUpdate();\r\n                              notifiedComponents.add(componentId);\r\n                            }\r\n                          }\r\n                        });\r\n                      }\r\n\r\n                      if (currentPath.length === 0) break;\r\n                      currentPath.pop();\r\n                    }\r\n                    break;\r\n                  }\r\n                }\r\n              }\r\n            };\r\n          }\r\n\r\n          if (prop === '$getComponents')\r\n            return () => getShadowMetadata(stateKey, [])?.components;\r\n        }\r\n\r\n        if (prop === '$validationWrapper') {\r\n          return ({\r\n            children,\r\n            hideMessage,\r\n          }: {\r\n            children: React.ReactNode;\r\n            hideMessage?: boolean;\r\n          }) => (\r\n            <ValidationWrapper\r\n              formOpts={\r\n                hideMessage ? { validation: { message: '' } } : undefined\r\n              }\r\n              path={path}\r\n              stateKey={stateKey}\r\n            >\r\n              {children}\r\n            </ValidationWrapper>\r\n          );\r\n        }\r\n\r\n        if (prop === '$_stateKey') return stateKey;\r\n        if (prop === '$_path') return path;\r\n        if (prop === '$update') {\r\n          return (payload: UpdateArg<T>) => {\r\n            effectiveSetState(payload as any, path, { updateType: 'update' });\r\n\r\n            return {\r\n              synced: () => {\r\n                const shadowMeta = getGlobalStore\r\n                  .getState()\r\n                  .getShadowMetadata(stateKey, path);\r\n\r\n                setShadowMetadata(stateKey, path, {\r\n                  ...shadowMeta,\r\n                  isDirty: false,\r\n                  stateSource: 'server',\r\n                  lastServerSync: Date.now(),\r\n                });\r\n\r\n                const fullPath = [stateKey, ...path].join('.');\r\n                notifyPathSubscribers(fullPath, {\r\n                  type: 'SYNC_STATUS_CHANGE',\r\n                  isDirty: false,\r\n                });\r\n              },\r\n            };\r\n          };\r\n        }\r\n        if (prop === '$toggle') {\r\n          const { value: currentValueAtPath } = getScopedData(\r\n            stateKey,\r\n            path,\r\n            meta\r\n          );\r\n\r\n          if (typeof currentValueAtPath != 'boolean') {\r\n            throw new Error('toggle() can only be used on boolean values');\r\n          }\r\n          return () => {\r\n            effectiveSetState(!currentValueAtPath as any, path, {\r\n              updateType: 'update',\r\n            });\r\n          };\r\n        }\r\n        if (prop === '$isolate') {\r\n          return (renderFn: (state: any) => React.ReactNode) => {\r\n            return (\r\n              <IsolatedComponentWrapper\r\n                stateKey={stateKey}\r\n                path={path}\r\n                rebuildStateShape={rebuildStateShape}\r\n                renderFn={renderFn}\r\n              />\r\n            );\r\n          };\r\n        }\r\n        if (prop === '$formElement') {\r\n          return (child: FormControl<T>, formOpts?: FormOptsType) => {\r\n            return (\r\n              <FormElementWrapper\r\n                stateKey={stateKey}\r\n                path={path}\r\n                rebuildStateShape={rebuildStateShape}\r\n                setState={effectiveSetState}\r\n                formOpts={formOpts}\r\n                renderFn={child as any}\r\n              />\r\n            );\r\n          };\r\n        }\r\n        const nextPath = [...path, prop];\r\n        return rebuildStateShape({\r\n          path: nextPath,\r\n          componentId: componentId!,\r\n          meta,\r\n        });\r\n      },\r\n    };\r\n\r\n    const proxyInstance = new Proxy({}, handler);\r\n    proxyCache.set(cacheKey, proxyInstance);\r\n\r\n    return proxyInstance;\r\n  }\r\n\r\n  const rootLevelMethods = {\r\n    $revertToInitialState: (obj?: { validationKey?: string }) => {\r\n      const shadowMeta = getGlobalStore\r\n        .getState()\r\n        .getShadowMetadata(stateKey, []);\r\n      let revertState;\r\n\r\n      if (shadowMeta?.stateSource === 'server' && shadowMeta.baseServerState) {\r\n        revertState = shadowMeta.baseServerState;\r\n      } else {\r\n        revertState = getGlobalStore.getState().initialStateGlobal[stateKey];\r\n      }\r\n\r\n      clearSelectedIndexesForState(stateKey);\r\n      initializeShadowState(stateKey, revertState);\r\n\r\n      rebuildStateShape({\r\n        path: [],\r\n        componentId: outerComponentId!,\r\n      });\r\n\r\n      // Handle localStorage side-effects\r\n      const initalOptionsGet = getInitialOptions(stateKey as string);\r\n      const localKey = isFunction(initalOptionsGet?.localStorage?.key)\r\n        ? initalOptionsGet?.localStorage?.key(revertState)\r\n        : initalOptionsGet?.localStorage?.key;\r\n      const storageKey = `${sessionId}-${stateKey}-${localKey}`;\r\n      if (storageKey) {\r\n        localStorage.removeItem(storageKey);\r\n      }\r\n\r\n      notifyComponents(stateKey);\r\n\r\n      return revertState;\r\n    },\r\n    $initializeAndMergeShadowState: (newState: T) => {\r\n      initializeAndMergeShadowState(stateKey, newState);\r\n      notifyComponents(stateKey);\r\n    },\r\n    $updateInitialState: (newState: T) => {\r\n      const newUpdaterState = createProxyHandler(\r\n        stateKey,\r\n        effectiveSetState,\r\n        outerComponentId,\r\n        sessionId\r\n      );\r\n      const initialState =\r\n        getGlobalStore.getState().initialStateGlobal[stateKey];\r\n      const initalOptionsGet = getInitialOptions(stateKey as string);\r\n      const localKey = isFunction(initalOptionsGet?.localStorage?.key)\r\n        ? initalOptionsGet?.localStorage?.key(initialState)\r\n        : initalOptionsGet?.localStorage?.key;\r\n\r\n      const storageKey = `${sessionId}-${stateKey}-${localKey}`;\r\n\r\n      if (localStorage.getItem(storageKey)) {\r\n        localStorage.removeItem(storageKey);\r\n      }\r\n      startTransition(() => {\r\n        updateInitialStateGlobal(stateKey, newState);\r\n        initializeShadowState(stateKey, newState);\r\n        // initializeShadowStateNEW(stateKey, newState);\r\n\r\n        const stateEntry = getGlobalStore\r\n          .getState()\r\n          .getShadowMetadata(stateKey, []);\r\n\r\n        if (stateEntry) {\r\n          stateEntry?.components?.forEach((component) => {\r\n            component.forceUpdate();\r\n          });\r\n        }\r\n      });\r\n\r\n      return {\r\n        fetchId: (field: keyof T) => (newUpdaterState.$get() as any)[field],\r\n      };\r\n    },\r\n  };\r\n\r\n  const returnShape = rebuildStateShape({\r\n    componentId: outerComponentId,\r\n    path: [],\r\n  });\r\n\r\n  return returnShape;\r\n}\r\n\r\nexport function $cogsSignal(proxy: {\r\n  _path: string[];\r\n  _stateKey: string;\r\n  _effect?: string;\r\n\r\n  _meta?: MetaData;\r\n}) {\r\n  return createElement(SignalRenderer, { proxy });\r\n}\r\n\r\nfunction SignalRenderer({\r\n  proxy,\r\n}: {\r\n  proxy: {\r\n    _path: string[];\r\n    _stateKey: string;\r\n    _effect?: string;\r\n    _meta?: MetaData;\r\n  };\r\n}) {\r\n  const elementRef = useRef<HTMLSpanElement>(null);\r\n  const instanceIdRef = useRef<string | null>(null);\r\n  const isSetupRef = useRef(false);\r\n  const signalId = `${proxy._stateKey}-${proxy._path.join('.')}`;\r\n\r\n  const arrayPathKey = proxy._path.length > 0 ? proxy._path.join('.') : 'root';\r\n  const viewIds = proxy._meta?.arrayViews?.[arrayPathKey];\r\n\r\n  const value = getShadowValue(proxy._stateKey, proxy._path, viewIds);\r\n\r\n  useEffect(() => {\r\n    const element = elementRef.current;\r\n    if (!element || isSetupRef.current) return;\r\n\r\n    const timeoutId = setTimeout(() => {\r\n      if (!element.parentElement) {\r\n        console.warn('Parent element not found for signal', signalId);\r\n        return;\r\n      }\r\n\r\n      const parentElement = element.parentElement;\r\n      const childNodes = Array.from(parentElement.childNodes);\r\n      const position = childNodes.indexOf(element);\r\n\r\n      let parentId = parentElement.getAttribute('data-parent-id');\r\n      if (!parentId) {\r\n        parentId = `parent-${crypto.randomUUID()}`;\r\n        parentElement.setAttribute('data-parent-id', parentId);\r\n      }\r\n\r\n      instanceIdRef.current = `instance-${crypto.randomUUID()}`;\r\n\r\n      const currentMeta =\r\n        getGlobalStore\r\n          .getState()\r\n          .getShadowMetadata(proxy._stateKey, proxy._path) || {};\r\n      const signals = currentMeta.signals || [];\r\n      signals.push({\r\n        instanceId: instanceIdRef.current,\r\n        parentId,\r\n        position,\r\n        effect: proxy._effect,\r\n      });\r\n\r\n      getGlobalStore\r\n        .getState()\r\n        .setShadowMetadata(proxy._stateKey, proxy._path, {\r\n          ...currentMeta,\r\n          signals,\r\n        });\r\n\r\n      let displayValue = value;\r\n      if (proxy._effect) {\r\n        try {\r\n          displayValue = new Function(\r\n            'state',\r\n            `return (${proxy._effect})(state)`\r\n          )(value);\r\n        } catch (err) {\r\n          console.error('Error evaluating effect function:', err);\r\n        }\r\n      }\r\n\r\n      if (displayValue !== null && typeof displayValue === 'object') {\r\n        displayValue = JSON.stringify(displayValue);\r\n      }\r\n      const textNode = document.createTextNode(String(displayValue ?? ''));\r\n      element.replaceWith(textNode);\r\n      isSetupRef.current = true;\r\n    }, 0);\r\n\r\n    return () => {\r\n      clearTimeout(timeoutId);\r\n      if (instanceIdRef.current) {\r\n        const currentMeta =\r\n          getGlobalStore\r\n            .getState()\r\n            .getShadowMetadata(proxy._stateKey, proxy._path) || {};\r\n        if (currentMeta.signals) {\r\n          currentMeta.signals = currentMeta.signals.filter(\r\n            (s) => s.instanceId !== instanceIdRef.current\r\n          );\r\n          getGlobalStore\r\n            .getState()\r\n            .setShadowMetadata(proxy._stateKey, proxy._path, currentMeta);\r\n        }\r\n      }\r\n    };\r\n  }, []);\r\n\r\n  return createElement('span', {\r\n    ref: elementRef,\r\n    style: { display: 'contents' },\r\n    'data-signal-id': signalId,\r\n  });\r\n}\r\n"],"names":["getInitialOptions","updateInitialStateGlobal","getShadowMetadata","setShadowMetadata","getShadowValue","initializeShadowState","initializeAndMergeShadowState","updateShadowAtPath","insertShadowArrayElement","insertManyShadowArrayElements","removeShadowArrayElement","setInitialStateOptions","setServerStateUpdate","markAsDirty","addPathComponent","clearSelectedIndexesForState","addStateLog","setSyncInfo","clearSelectedIndex","getSyncInfo","notifyPathSubscribers","getPluginMetaDataMap","setPluginMetaData","removePluginMetaData","getGlobalStore","notifyUpdate","pluginStore","getArrayData","stateKey","path","meta","shadowMeta","arrayPathKey","viewIds","findArrayItem","array","keys","predicate","i","key","setAndMergeOptions","newOptions","mergedOptions","setOptions","options","initialOptionsPart","initialOptions","initialOptionsPartState","needToAdd","deepMerge","target","source","isDeepEqual","hadSchema","hasNewSchemaV4","hasNewSchemaV3","updateShadowTypeInfo","notifyComponents","addStateOptions","initialState","createCogsState","opt","statePart","transformStateFunc","existingOptions","existingGlobalOptions","finalOptions","useCogsState","componentId","useState","uuidv4","currentOptions","optionsRef","useRef","thiState","updater","useCogsStateFn","useEffect","setCogsOptionsByKey","loadAndApplyLocalStorage","setCogsFormElements","formElements","updatedPlugins","plugin","saveToLocalStorage","state","thisKey","currentInitialOptions","sessionId","lastSyncedWithServer","isFunction","storageKey","existingLastSynced","loadFromLocalStorage","data","superJsonResult","superjson","localStorageKey","storedData","error","currentState","useCogsConfig","localkey","localData","stateEntry","updates","component","update","markEntireStateAsServerSynced","timestamp","currentMeta","arrayMeta","itemKey","index","itemPath","itemData","fieldPath","fieldData","updateBatchQueue","isFlushScheduled","scheduleFlush","flushQueue","updateSignals","displayValue","parentId","position","effect","parent","childNodes","finalDisplayValue","err","getComponentNotifications","result","rootMeta","componentsToNotify","currentPath","pathMeta","isArray","getDifferences","subPathString","subPath","fullSubPath","subPathMeta","parentArrayPath","parentMeta","handleUpdate","payload","oldValue","newValue","newShadowMeta","handleInsertMany","updatedMeta","handleInsert","itemId","currentValue","getScopedData","actualItemId","insertAfterId","handleCut","allComponentsToNotify","signalUpdates","logsToAdd","item","createEffectiveSetState","latestInitialOptionsRef","newStateOrFunction","updateObj","executeUpdate","newUpdate","runValidation","stateObject","localStorage","reactiveDeps","reactiveType","defaultState","dependencies","serverState","reactiveForce","forceUpdate","noStateKey","componentIdRef","resolveInitialState","useCallback","overrideOptions","finalDefaultState","localKey","event","serverStateData","mergeConfig","incomingData","keyField","existingIds","newUniqueItems","finalState","existingMeta","features","resolvedState","useLayoutEffect","componentKey","components","fullPath","effectiveSetState","useMemo","createProxyHandler","applyTransforms","ids","transforms","transform","filtered","id","value","a","b","aValue","bValue","registerComponentDependency","dependencyPath","fullComponentId","notifySelectionComponents","parentPath","currentSelected","notifiedComponents","arrayKey","selectedItem","arrayKeys","outerComponentId","proxyCache","rebuildStateShape","derivationSignature","cacheKey","stateKeyPathKey","handler","prop","rootLevelMethods","nextPath","sync","validationKey","response","getStatusFunc","initalOptionsGet","selectedItemKey","viewKey","currentViewIds","selectedItemId","selectedId","itemHeight","overscan","stickToBottom","scrollStickTolerance","containerRef","range","setRange","rerender","initialScrollRef","interval","scrollStateRef","measurementCache","unsubscribe","e","container","waitForContainer","visibleCount","endIndex","startIndex","scrollToBottom","rangeRef","arrayKeysRef","handleScroll","currentScrollTop","scrollHeight","clientHeight","scrollState","distanceFromBottom","wasNearBottom","newStartIndex","behavior","performScroll","attemptScroll","attempts","currentHeight","currentScroll","newHeight","newScroll","scrollTimeout","debouncedScrollToBottom","observer","slicedKeys","arrayPath","offset","callbackfn","shadowValue","arraySetter","_item","itemSetter","filteredIds","compareFn","currentArray","itemsWithIds","sortedIds","bufferSize","flushInterval","bufferStrategy","store","onFlush","buffer","isPaused","flushTimer","addToBuffer","flushBuffer","toFlush","streamId","streams","componentIdsRef","updateTrigger","validIds","arrayValues","caches","returnValue","localIndex","itemComponentId","createElement","MemoizedCogsItemWrapper","fieldName","lastItemKey","newPath","fields","onMatch","matchedItem","isMatch","field","updatedItem","updatedArray","indexToCut","idToCut","pathForCut","found","pathForItem","searchKey","searchValue","fn","$cogsSignal","_getFormElement","metadata","isDisabled","element","syncKey","parentPathArray","fullParentKey","fullItemKey","subscribeToPath","virtualFocusPath","focusedElement","setFocusedElement","updateType","pluginName","zodErrors","operation","metaData","afterIndex","patches","convertPath","jsonPath","p","patch","relativePath","children","hideMessage","jsx","ValidationWrapper","currentValueAtPath","renderFn","IsolatedComponentWrapper","child","formOpts","FormElementWrapper","proxyInstance","obj","revertState","newState","newUpdaterState","startTransition","proxy","SignalRenderer","elementRef","instanceIdRef","isSetupRef","signalId","timeoutId","parentElement","signals","textNode","s"],"mappings":"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"}