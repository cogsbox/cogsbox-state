{"version":3,"file":"CogsState.jsx","sources":["../src/CogsState.tsx"],"sourcesContent":["\"use client\";\r\nimport {\r\n    createElement,\r\n    startTransition,\r\n    useEffect,\r\n    useMemo,\r\n    useRef,\r\n    useState,\r\n    useSyncExternalStore,\r\n    type ReactNode,\r\n} from \"react\";\r\n\r\nimport { getNestedValue, isFunction, type GenericObject } from \"./utility.js\";\r\nimport {\r\n    cutFunc,\r\n    FormControlComponent,\r\n    pushFunc,\r\n    updateFn,\r\n    ValidationWrapper,\r\n} from \"./Functions.js\";\r\nimport { isDeepEqual, transformStateFunc } from \"./utility.js\";\r\nimport type { UseMutationResult } from \"@tanstack/react-query\";\r\nimport { v4 as uuidv4 } from \"uuid\";\r\nimport { ZodObject, type ZodRawShape } from \"zod\";\r\n\r\nimport { getGlobalStore } from \"./store.js\";\r\nimport { useCogsConfig } from \"./CogsStateClient.js\";\r\n\r\ntype Prettify<T> = { [K in keyof T]: T[K] } & {};\r\n\r\nexport type ServerSyncStatus = {\r\n    isFresh: boolean;\r\n    isFreshTime: number;\r\n    isStale: boolean;\r\n    isStaleTime: number;\r\n    isSyncing: boolean;\r\n    isSyncingTime: number;\r\n};\r\n\r\nexport type SyncInfo = {\r\n    timeStamp: number;\r\n    userId: number;\r\n};\r\n\r\nexport type FormElementParmas<T> = {\r\n    get: () => T;\r\n\r\n    set: UpdateType<T>;\r\n    syncStatus: (SyncInfo & { date: Date }) | null;\r\n    path: string[];\r\n    validationErrors: () => string[];\r\n\r\n    inputProps: {\r\n        value?: T;\r\n        onChange?: (\r\n            event: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>,\r\n        ) => void;\r\n    };\r\n};\r\n\r\nexport type StateKeys = string;\r\n\r\ntype findWithFuncType<U> = (\r\n    thisKey: keyof U,\r\n    thisValue: U[keyof U],\r\n) => EndType<U> & StateObject<U>;\r\nexport type PushArgs<U> = (\r\n    update:\r\n        | Prettify<U>\r\n        | ((prevState: NonNullable<Prettify<U>>[]) => NonNullable<Prettify<U>>),\r\n    opts?: UpdateOpts,\r\n) => void;\r\n\r\ntype CutFunctionType = (\r\n    index?: number,\r\n    options?: { waitForSync?: boolean },\r\n) => void;\r\n\r\nexport type InferArrayElement<T> = T extends (infer U)[] ? U : never;\r\n\r\nexport type ArrayEndType<TShape extends unknown> = {\r\n    findWith: findWithFuncType<InferArrayElement<TShape>>;\r\n    index: (index: number) => StateObject<InferArrayElement<TShape>> & {\r\n        insert: PushArgs<InferArrayElement<TShape>>;\r\n        cut: CutFunctionType;\r\n        _index: number;\r\n    } & EndType<InferArrayElement<TShape>>;\r\n    insert: PushArgs<InferArrayElement<TShape>>;\r\n    cut: CutFunctionType;\r\n    stateEach: (\r\n        callbackfn: (\r\n            value: InferArrayElement<TShape>,\r\n            setter: StateObject<InferArrayElement<TShape>>,\r\n            index: number,\r\n            array: TShape,\r\n            arraySetter: StateObject<TShape>,\r\n        ) => void,\r\n    ) => any;\r\n    stateFlattenOn: <K extends keyof InferArrayElement<TShape>>(\r\n        field: K,\r\n    ) => StateObject<InferArrayElement<InferArrayElement<TShape>[K]>[]>;\r\n    uniqueInsert: (\r\n        payload: UpdateArg<InferArrayElement<TShape>>,\r\n        fields?: (keyof InferArrayElement<TShape>)[],\r\n    ) => void;\r\n    stateFilter: (\r\n        callbackfn: (value: InferArrayElement<TShape>, index: number) => void,\r\n    ) => ArrayEndType<TShape>;\r\n    getSelected: () => StateObject<InferArrayElement<TShape>> | undefined;\r\n} & EndType<TShape> & {\r\n        [K in keyof (any[] extends infer T ? T : never)]: never;\r\n    };\r\n\r\nexport type UpdateType<T> = (\r\n    payload: UpdateArg<Prettify<T>>,\r\n    opts?: UpdateOpts,\r\n) => void;\r\nexport type FormOptsType = {\r\n    key?: string;\r\n    validation?: {\r\n        message?: string;\r\n        stretch?: boolean;\r\n        props?: GenericObject;\r\n        disable?: boolean;\r\n    };\r\n    formElements?: boolean;\r\n    debounceTime?: number;\r\n    stateServerDifferences?: string[][];\r\n};\r\n\r\nexport type FormControl<T> = (obj: FormElementParmas<T>) => JSX.Element;\r\n\r\nexport type UpdateArg<S> = S | ((prevState: S) => S);\r\nexport type UpdateOpts = {\r\n    timelineLabel?: string;\r\n    timeLineMessage?: string;\r\n    validate?: boolean;\r\n};\r\nexport type ObjectEndType<T> = EndType<T> & {\r\n    [K in keyof T]-?: ObjectEndType<T[K]>;\r\n} & {\r\n    stateObject: (\r\n        callbackfn: (value: T, setter: StateObject<T>) => void,\r\n    ) => any;\r\n    delete: () => void;\r\n};\r\ntype EffectFunction<T, R> = (state: T) => R;\r\nexport type EndType<T, IsArrayElement = false> = {\r\n    update: UpdateType<T>;\r\n    _path: string[];\r\n    _stateKey: string;\r\n    formElement: (\r\n        validationKey: string,\r\n        control: FormControl<T>,\r\n        opts?: FormOptsType,\r\n    ) => JSX.Element;\r\n    get: () => T;\r\n    $get: () => T;\r\n    $effect: <R>(fn: EffectFunction<T, R>) => R;\r\n    _status: \"fresh\" | \"stale\" | \"synced\";\r\n    showValidationErrors: (ctx: string) => string[];\r\n    setValidation: (ctx: string) => void;\r\n    removeValidation: (ctx: string) => void;\r\n    ignoreFields: (fields: string[]) => StateObject<T>;\r\n    _selected: boolean;\r\n    setSelected: (value: boolean) => void;\r\n    validationWrapper: ({\r\n        children,\r\n        hideMessage,\r\n    }: {\r\n        children: React.ReactNode;\r\n        hideMessage?: boolean;\r\n    }) => JSX.Element;\r\n    lastSynced?: SyncInfo;\r\n} & (IsArrayElement extends true ? { cut: () => void } : {}) & {\r\n        [K in keyof (any extends infer T ? T : never)]: never;\r\n    };\r\n\r\nexport type StateObject<T> = (T extends any[]\r\n    ? ArrayEndType<T>\r\n    : T extends Record<string, unknown> | object\r\n      ? { [K in keyof T]-?: StateObject<T[K]> } & ObjectEndType<T>\r\n      : T extends string | number | boolean | null\r\n        ? T\r\n        : never) &\r\n    EndType<T, true> & {\r\n        _componentId: string | null;\r\n        _initialState: T;\r\n        updateInitialState: (newState: T | null) => {\r\n            fetchId: (field: keyof T) => string | number;\r\n        };\r\n        _isLoading: boolean;\r\n        _serverState: T;\r\n        revertToInitialState: (obj?: { validationKey?: string }) => void;\r\n        middleware: (\r\n            middles: ({\r\n                updateLog,\r\n                update,\r\n            }: {\r\n                updateLog: UpdateTypeDetail[] | undefined;\r\n                update: UpdateTypeDetail;\r\n            }) => void,\r\n        ) => void;\r\n        _isServerSynced: () => boolean;\r\n        getLocalStorage: (key: string) => LocalStorageData<T> | null;\r\n    };\r\n\r\nexport type CogsUpdate<T extends unknown> = UpdateType<T>;\r\n\r\nexport type EffectiveSetState<TStateObject> = (\r\n    newStateOrFunction:\r\n        | TStateObject\r\n        | ((prevState: TStateObject) => TStateObject),\r\n    path: string[],\r\n    updateObj: { updateType: \"update\" | \"insert\" | \"cut\" },\r\n    validationKey?: string,\r\n    opts?: UpdateOpts,\r\n) => void;\r\n\r\nexport type UpdateTypeDetail = {\r\n    timeStamp: number;\r\n    stateKey: string;\r\n    updateType: \"update\" | \"insert\" | \"cut\";\r\n    path: string[];\r\n    status: \"new\" | \"sent\" | \"synced\";\r\n    oldValue: any;\r\n    newValue: any;\r\n    userId?: number;\r\n};\r\n\r\n//let globalStoreInstance: ReturnType<typeof getGlobalStore> | null = null;\r\n\r\n// export const getGlobalStore = <State extends GenericObject | GenericObject[]>(initialState?: State) => {\r\n//     if (!globalStoreInstance) {\r\n//         globalStoreInstance = cogStateGlobalStore(initialState ?? {});\r\n//     }\r\n//     return globalStoreInstance;\r\n// };\r\n\r\nexport type ActionsType<T> = {\r\n    type: \"onChange\";\r\n    action: ({ state, actionType }: { state: T; actionType: string }) => void;\r\n    debounce?: number;\r\n}[];\r\n\r\ntype ArrayToObject<T extends string[]> = Record<T[number], string>;\r\ntype CookieType<T> = {\r\n    timeStamp: number;\r\n    value: T;\r\n    cookieName: string;\r\n    OnUnMountCookie?: Boolean;\r\n};\r\nexport type CogsCookiesType<T extends string[] = string[]> = CookieType<\r\n    ArrayToObject<T>\r\n>;\r\n\r\nexport type OptionsType<T extends unknown = unknown> = {\r\n    serverSync?: ServerSyncType<T>;\r\n    validationKey?: string;\r\n    enableServerState?: boolean;\r\n    middleware?: ({\r\n        updateLog,\r\n        update,\r\n    }: {\r\n        updateLog: UpdateTypeDetail[] | undefined;\r\n        update: UpdateTypeDetail;\r\n    }) => void;\r\n\r\n    zodSchema?: ZodObject<ZodRawShape>;\r\n    modifyState?: (state: T) => T;\r\n    localStorage?: { key: string | ((state: T) => string) };\r\n    formElements?: FormsElementsType;\r\n    enabledSync?: (state: T) => boolean;\r\n    reactiveDeps?: (state: T) => any[] | true;\r\n    syncUpdate?: Partial<UpdateTypeDetail>;\r\n    initState?: {\r\n        localStorageKey?: string;\r\n        ctx?: Record<string, any>;\r\n        initialState: T;\r\n        dependencies?: any[]; // Just like useEffect dependencies\r\n    };\r\n};\r\nexport type ServerSyncType<T> = {\r\n    testKey?: string;\r\n    syncKey: (({ state }: { state: T }) => string) | string;\r\n    syncFunction: ({ state }: { state: T }) => void;\r\n    debounce?: number;\r\n    mutation: UseMutationResult<any, unknown, any, unknown>;\r\n    snapshot?: {\r\n        name: (({ state }: { state: T }) => string) | string;\r\n        stateKeys: StateKeys[];\r\n        currentUrl: string;\r\n        currentParams?: URLSearchParams;\r\n    };\r\n};\r\nexport type SyncActionsType<T> = {\r\n    syncKey: string;\r\n\r\n    rollBackState?: T;\r\n    actionTimeStamp: number;\r\n    retryCount?: number;\r\n    status:\r\n        | \"success\"\r\n        | \"waiting\"\r\n        | \"rolledBack\"\r\n        | \"error\"\r\n        | \"cancelled\"\r\n        | \"failed\";\r\n    snapshot?: {\r\n        name: string;\r\n        stateKeys: StateKeys[];\r\n        currentUrl: string;\r\n        currentParams?: URLSearchParams;\r\n    };\r\n};\r\n\r\nexport type ValidationWrapperOptions<T extends unknown = unknown> = {\r\n    children: React.ReactNode;\r\n    active: boolean;\r\n    stretch?: boolean;\r\n    path: string[];\r\n    message?: string;\r\n    data?: T;\r\n    key?: string;\r\n};\r\nexport type SyncRenderOptions<T extends unknown = unknown> = {\r\n    children: React.ReactNode;\r\n    time: number;\r\n    data?: T;\r\n    key?: string;\r\n};\r\n\r\ntype FormsElementsType<T extends unknown = unknown> = {\r\n    validation?: (options: ValidationWrapperOptions<T>) => React.ReactNode;\r\n    syncRender?: (options: SyncRenderOptions<T>) => React.ReactNode;\r\n};\r\n\r\nexport type InitialStateInnerType<T extends unknown = unknown> = {\r\n    initialState: T;\r\n} & OptionsType<T>;\r\n\r\nexport type InitialStateType<T> = {\r\n    [key: string]: InitialStateInnerType<T>;\r\n};\r\nexport type FunctionsToPassDownType = {\r\n    getValidationErrors: (pathArray: string) => string[];\r\n    removeValidationError: (path: string) => void;\r\n};\r\n\r\nexport type AllStateTypes<T extends unknown> = Record<string, T>;\r\n\r\nexport type CogsInitialState<T> = {\r\n    initialState: T;\r\n    formElements?: FormsElementsType<T>;\r\n};\r\n\r\nexport type TransformedStateType<T> = {\r\n    [P in keyof T]: T[P] extends CogsInitialState<infer U> ? U : T[P];\r\n};\r\n\r\nexport function addStateOptions<T extends unknown>(\r\n    initialState: T,\r\n    { formElements, zodSchema }: OptionsType<T>,\r\n) {\r\n    return { initialState: initialState, formElements, zodSchema } as T;\r\n}\r\n\r\nfunction setAndMergeOptions(stateKey: string, newOptions: OptionsType<any>) {\r\n    const getInitialOptions = getGlobalStore.getState().getInitialOptions;\r\n    const setInitialStateOptions =\r\n        getGlobalStore.getState().setInitialStateOptions;\r\n\r\n    const initialOptions = getInitialOptions(stateKey as string) || {};\r\n\r\n    setInitialStateOptions(stateKey as string, {\r\n        ...initialOptions,\r\n        ...newOptions,\r\n    });\r\n}\r\n\r\nfunction setOptions<StateKey, Opt>({\r\n    stateKey,\r\n    options,\r\n    initialOptionsPart,\r\n}: {\r\n    stateKey: StateKey;\r\n    options?: Opt;\r\n    initialOptionsPart: Record<string, any>;\r\n}) {\r\n    const initialOptions = getInitialOptions(stateKey as string) || {};\r\n    const initialOptionsPartState =\r\n        initialOptionsPart[stateKey as string] || {};\r\n    const setInitialStateOptions =\r\n        getGlobalStore.getState().setInitialStateOptions;\r\n    const mergedOptions = { ...initialOptionsPartState, ...initialOptions };\r\n\r\n    let needToAdd = false;\r\n    if (options) {\r\n        for (const key in options) {\r\n            if (!mergedOptions.hasOwnProperty(key)) {\r\n                needToAdd = true;\r\n                mergedOptions[key] = options[key as keyof typeof options];\r\n            }\r\n        }\r\n    }\r\n    if (needToAdd) {\r\n        setInitialStateOptions(stateKey as string, mergedOptions);\r\n    }\r\n}\r\n\r\nexport const createCogsState = <State extends Record<string, unknown>>(\r\n    initialState: State,\r\n    opts?: { reRenderType?: \"get\" | \"state\" | \"none\" },\r\n) => {\r\n    let newInitialState = initialState;\r\n\r\n    const [statePart, initialOptionsPart] =\r\n        transformStateFunc<State>(newInitialState);\r\n\r\n    getGlobalStore.getState().setInitialStates(statePart);\r\n    type StateKeys = keyof typeof statePart;\r\n\r\n    const useCogsState = <StateKey extends StateKeys>(\r\n        stateKey: StateKey,\r\n        options?: OptionsType<(typeof statePart)[StateKey]>,\r\n    ) => {\r\n        const [componentId] = useState(uuidv4());\r\n        setOptions({ stateKey, options, initialOptionsPart });\r\n\r\n        const thiState =\r\n            getGlobalStore.getState().cogsStateStore[stateKey as string] ||\r\n            statePart[stateKey as string];\r\n        const partialState = options?.modifyState\r\n            ? options.modifyState(thiState)\r\n            : thiState;\r\n\r\n        const [state, updater] = useCogsStateFn<(typeof statePart)[StateKey]>(\r\n            partialState,\r\n            {\r\n                stateKey: stateKey as string,\r\n                syncUpdate: options?.syncUpdate,\r\n                componentId,\r\n                localStorage: options?.localStorage,\r\n                middleware: options?.middleware,\r\n                enabledSync: options?.enabledSync,\r\n                reactiveDeps: options?.reactiveDeps,\r\n                initState: options?.initState,\r\n            },\r\n        );\r\n\r\n        return updater;\r\n    };\r\n\r\n    function setCogsOptions<StateKey extends StateKeys>(\r\n        stateKey: StateKey,\r\n        options: OptionsType<(typeof statePart)[StateKey]>,\r\n    ) {\r\n        setOptions({ stateKey, options, initialOptionsPart });\r\n    }\r\n\r\n    return { useCogsState, setCogsOptions };\r\n};\r\n\r\nconst {\r\n    setUpdaterState,\r\n    setState,\r\n    getInitialOptions,\r\n    getKeyState,\r\n    getValidationErrors,\r\n    setStateLog,\r\n    updateInitialStateGlobal,\r\n    addValidationError,\r\n    removeValidationError,\r\n    setServerSyncActions,\r\n} = getGlobalStore.getState();\r\n\r\nconst loadFromLocalStorage = (localStorageKey: string) => {\r\n    if (!localStorageKey) return null;\r\n\r\n    try {\r\n        const storedData = window.localStorage.getItem(localStorageKey);\r\n        if (!storedData) return null;\r\n\r\n        const parsedData = JSON.parse(storedData);\r\n\r\n        return parsedData;\r\n    } catch (error) {\r\n        console.error(\"Error loading from localStorage:\", error);\r\n        return null;\r\n    }\r\n};\r\n\r\nconst saveToLocalStorage = <T,>(\r\n    state: T,\r\n    thisKey: string,\r\n    currentInitialOptions: any,\r\n    sessionId?: string,\r\n) => {\r\n    if (currentInitialOptions?.initState) {\r\n        const data: LocalStorageData<T> = {\r\n            state,\r\n            lastUpdated: Date.now(),\r\n            lastSyncedWithServer:\r\n                getGlobalStore.getState().serverSyncLog[thisKey]?.[0]\r\n                    ?.timeStamp,\r\n            baseServerState: getGlobalStore.getState().serverState[thisKey],\r\n        };\r\n\r\n        const storageKey = currentInitialOptions.initState\r\n            ? `${sessionId}-${thisKey}-${currentInitialOptions.initState.localStorageKey}`\r\n            : thisKey;\r\n\r\n        window.localStorage.setItem(storageKey, JSON.stringify(data));\r\n    }\r\n};\r\n\r\ntype LocalStorageData<T> = {\r\n    state: T;\r\n    lastUpdated: number;\r\n    lastSyncedWithServer?: number;\r\n    baseServerState?: T; // Add this to track what server state our changes are based on\r\n};\r\n\r\nconst updateGlobalState = (\r\n    thisKey: string,\r\n    initialState: any,\r\n    newState: any,\r\n    effectiveSetState: EffectiveSetState<any>,\r\n    componentId: string,\r\n    sessionId?: string,\r\n) => {\r\n    // Update all global state at once\r\n    const updates = {\r\n        initialState: initialState,\r\n        updaterState: createProxyHandler(\r\n            thisKey,\r\n            effectiveSetState,\r\n            componentId,\r\n            sessionId,\r\n        ),\r\n        state: newState,\r\n    };\r\n\r\n    startTransition(() => {\r\n        updateInitialStateGlobal(thisKey, updates.initialState);\r\n        setUpdaterState(thisKey, updates.updaterState);\r\n        setState(thisKey, updates.state);\r\n    });\r\n};\r\n\r\nconst notifyComponents = (thisKey: string) => {\r\n    const stateEntry = getGlobalStore.getState().stateComponents.get(thisKey);\r\n    if (!stateEntry) return;\r\n\r\n    // Batch component updates\r\n    const updates = new Set<() => void>();\r\n    stateEntry.components.forEach((component) => {\r\n        updates.add(() => component.forceUpdate());\r\n    });\r\n\r\n    // Schedule updates in the next tick to allow batching\r\n    queueMicrotask(() => {\r\n        startTransition(() => {\r\n            updates.forEach((update) => update());\r\n        });\r\n    });\r\n};\r\n\r\nexport function useCogsStateFn<TStateObject extends unknown>(\r\n    stateObject: TStateObject,\r\n    {\r\n        stateKey,\r\n        serverSync,\r\n        zodSchema,\r\n        localStorage,\r\n        formElements,\r\n        middleware,\r\n        reactiveDeps,\r\n        componentId,\r\n        initState,\r\n        syncUpdate,\r\n    }: {\r\n        stateKey?: string;\r\n        componentId?: string;\r\n    } & OptionsType<TStateObject> = {},\r\n) {\r\n    const [reactiveForce, forceUpdate] = useState({}); //this is the key to reactivity\r\n    const { sessionId } = useCogsConfig();\r\n\r\n    let noStateKey = stateKey ? false : true;\r\n    const [thisKey] = useState(stateKey ?? uuidv4());\r\n    const stateLog = getGlobalStore.getState().stateLog[thisKey];\r\n    const componentUpdatesRef = useRef(new Set<string>());\r\n    const componentIdRef = useRef(componentId ?? uuidv4());\r\n    const latestInitialOptionsRef = useRef<any>(null);\r\n    latestInitialOptionsRef.current = getInitialOptions(thisKey as string); //i have to do this for it to work\r\n    useEffect(() => {\r\n        if (\r\n            syncUpdate &&\r\n            syncUpdate.stateKey === thisKey &&\r\n            syncUpdate.path?.[0]\r\n        ) {\r\n            // Update the actual state value\r\n            setState(thisKey, (prevState: any) => ({\r\n                ...prevState,\r\n                [syncUpdate.path![0]!]: syncUpdate.newValue,\r\n            }));\r\n\r\n            // Create combined key and update sync info\r\n            const syncKey = `${syncUpdate.stateKey}:${syncUpdate.path.join(\".\")}`;\r\n            getGlobalStore.getState().setSyncInfo(syncKey, {\r\n                timeStamp: syncUpdate.timeStamp!,\r\n                userId: syncUpdate.userId!,\r\n            });\r\n        }\r\n    }, [syncUpdate]);\r\n\r\n    useEffect(() => {\r\n        setAndMergeOptions(thisKey as string, {\r\n            initState,\r\n        });\r\n        const localData = loadFromLocalStorage(\r\n            sessionId + \"-\" + thisKey + \"-\" + initState?.localStorageKey,\r\n        );\r\n        let newState = null;\r\n        if (initState?.initialState) {\r\n            newState = initState?.initialState;\r\n\r\n            if (localData) {\r\n                if (\r\n                    localData.lastUpdated >\r\n                    (localData.lastSyncedWithServer || 0)\r\n                ) {\r\n                    newState = localData.state;\r\n                }\r\n            }\r\n            updateGlobalState(\r\n                thisKey,\r\n                initState?.initialState,\r\n                newState,\r\n                effectiveSetState,\r\n                componentIdRef.current,\r\n                sessionId,\r\n            );\r\n        }\r\n        notifyComponents(thisKey);\r\n    }, [initState?.localStorageKey, ...(initState?.dependencies || [])]);\r\n\r\n    useEffect(() => {\r\n        if (noStateKey) {\r\n            setAndMergeOptions(thisKey as string, {\r\n                serverSync,\r\n                formElements,\r\n                zodSchema,\r\n                initState,\r\n                localStorage,\r\n                middleware,\r\n            });\r\n        }\r\n\r\n        const depsKey = `${thisKey}////${componentIdRef.current}`;\r\n        const stateEntry = getGlobalStore\r\n            .getState()\r\n            .stateComponents.get(thisKey) || {\r\n            components: new Map(),\r\n        };\r\n        console.log(\"stateEntry\", stateEntry);\r\n        stateEntry.components.set(depsKey, {\r\n            forceUpdate: () => forceUpdate({}),\r\n            paths: new Set(),\r\n            deps: [],\r\n            depsFunction: reactiveDeps || undefined,\r\n        });\r\n\r\n        getGlobalStore.getState().stateComponents.set(thisKey, stateEntry);\r\n        console.log(\r\n            \"   getGlobalStore.getState().stateComponent\",\r\n            getGlobalStore.getState().stateComponents,\r\n        );\r\n        return () => {\r\n            const depsKey = `${thisKey}////${componentIdRef.current}`;\r\n\r\n            if (stateEntry) {\r\n                stateEntry.components.delete(depsKey);\r\n                if (stateEntry.components.size === 0) {\r\n                    getGlobalStore.getState().stateComponents.delete(thisKey);\r\n                }\r\n            }\r\n        };\r\n    }, []);\r\n\r\n    const effectiveSetState = (\r\n        newStateOrFunction:\r\n            | TStateObject\r\n            | ((prevState: TStateObject) => TStateObject),\r\n        path: string[],\r\n        updateObj: { updateType: \"insert\" | \"cut\" | \"update\" },\r\n        validationKey?: string,\r\n    ) => {\r\n        if (Array.isArray(path)) {\r\n            const pathKey = `${thisKey}-${path.join(\".\")}`;\r\n            componentUpdatesRef.current.add(pathKey);\r\n        }\r\n        setState(thisKey, (prevValue: TStateObject) => {\r\n            const payload = isFunction<TStateObject>(newStateOrFunction)\r\n                ? newStateOrFunction(prevValue as TStateObject)\r\n                : newStateOrFunction;\r\n\r\n            const signalId = `${thisKey}-${path.join(\".\")}`;\r\n            if (signalId) {\r\n                let isArrayOperation = false;\r\n                let elements = getGlobalStore\r\n                    .getState()\r\n                    .signalDomElements.get(signalId);\r\n\r\n                if (\r\n                    (!elements || elements.size === 0) &&\r\n                    (updateObj.updateType === \"insert\" ||\r\n                        updateObj.updateType === \"cut\")\r\n                ) {\r\n                    // Remove last segment (index) from path\r\n                    const arrayPath = path.slice(0, -1);\r\n                    const arrayValue = getNestedValue(payload, arrayPath);\r\n                    // If it's an array, use that path for signal\r\n                    if (Array.isArray(arrayValue)) {\r\n                        isArrayOperation = true;\r\n                        const arraySignalId = `${thisKey}-${arrayPath.join(\".\")}`;\r\n                        elements = getGlobalStore\r\n                            .getState()\r\n                            .signalDomElements.get(arraySignalId);\r\n                    }\r\n                }\r\n\r\n                if (elements) {\r\n                    const newValue = isArrayOperation\r\n                        ? getNestedValue(payload, path.slice(0, -1)) // Get array for array operations\r\n                        : getNestedValue(payload, path); // Get normal value otherwise\r\n                    elements.forEach(({ parentId, position, effect }) => {\r\n                        const parent = document.querySelector(\r\n                            `[data-parent-id=\"${parentId}\"]`,\r\n                        );\r\n                        if (parent) {\r\n                            const childNodes = Array.from(parent.childNodes);\r\n                            if (childNodes[position]) {\r\n                                const displayValue = effect\r\n                                    ? new Function(\r\n                                          \"state\",\r\n                                          `return (${effect})(state)`,\r\n                                      )(newValue)\r\n                                    : newValue;\r\n                                childNodes[position].textContent =\r\n                                    String(displayValue);\r\n                            }\r\n                        }\r\n                    });\r\n                }\r\n            }\r\n            if (\r\n                updateObj.updateType === \"update\" &&\r\n                (validationKey ||\r\n                    latestInitialOptionsRef.current?.validationKey) &&\r\n                path\r\n            ) {\r\n                removeValidationError(\r\n                    (validationKey ||\r\n                        latestInitialOptionsRef.current?.validationKey) +\r\n                        \".\" +\r\n                        path.join(\".\"),\r\n                );\r\n            }\r\n            const arrayWithoutIndex = path.slice(0, path.length - 1);\r\n            if (\r\n                updateObj.updateType === \"cut\" &&\r\n                latestInitialOptionsRef.current?.validationKey\r\n            ) {\r\n                removeValidationError(\r\n                    latestInitialOptionsRef.current?.validationKey +\r\n                        \".\" +\r\n                        arrayWithoutIndex.join(\".\"),\r\n                );\r\n            }\r\n            if (\r\n                updateObj.updateType === \"insert\" &&\r\n                latestInitialOptionsRef.current?.validationKey\r\n            ) {\r\n                let getValidation = getValidationErrors(\r\n                    latestInitialOptionsRef.current?.validationKey +\r\n                        \".\" +\r\n                        arrayWithoutIndex.join(\".\"),\r\n                );\r\n\r\n                //TODO this is untested its supposed to cahnge teh validation errors alreaady stored when a new entry is push\r\n\r\n                getValidation.filter(([k, v]) => {\r\n                    let length = k?.split(\".\").length;\r\n\r\n                    if (\r\n                        k == arrayWithoutIndex.join(\".\") &&\r\n                        length == arrayWithoutIndex.length - 1\r\n                    ) {\r\n                        //   console.log(length, pathWithoutIndex.length);\r\n                        let newKey = k + \".\" + arrayWithoutIndex;\r\n                        removeValidationError(k!);\r\n                        addValidationError(newKey, v!);\r\n                    }\r\n                });\r\n            }\r\n\r\n            const oldValue = getNestedValue(prevValue, path);\r\n            const newValue = getNestedValue(payload, path);\r\n            const pathToCheck =\r\n                updateObj.updateType === \"update\"\r\n                    ? path.join(\".\")\r\n                    : [...path].slice(0, -1).join(\".\");\r\n            const stateEntry = getGlobalStore\r\n                .getState()\r\n                .stateComponents.get(thisKey);\r\n            console.log(\"stateEntry\", stateEntry);\r\n            if (stateEntry) {\r\n                for (const [\r\n                    key,\r\n                    component,\r\n                ] of stateEntry.components.entries()) {\r\n                    if (\r\n                        component.depsFunction ||\r\n                        (component.paths && component.paths.has(pathToCheck))\r\n                    ) {\r\n                        if (component.depsFunction) {\r\n                            const depsResult = component.depsFunction(payload);\r\n\r\n                            if (typeof depsResult === \"boolean\") {\r\n                                if (depsResult) {\r\n                                    component.forceUpdate();\r\n                                }\r\n                            } else if (\r\n                                !isDeepEqual(component.deps, depsResult)\r\n                            ) {\r\n                                component.deps = depsResult;\r\n                                component.forceUpdate();\r\n                            }\r\n                        } else {\r\n                            component.forceUpdate();\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            const timeStamp = Date.now();\r\n\r\n            const newUpdate = {\r\n                timeStamp,\r\n                stateKey: thisKey,\r\n                path,\r\n                updateType: updateObj.updateType,\r\n                status: \"new\" as const,\r\n                oldValue,\r\n                newValue,\r\n            } satisfies UpdateTypeDetail;\r\n\r\n            setStateLog(thisKey, (prevLogs) => {\r\n                const logs = [...(prevLogs ?? []), newUpdate];\r\n\r\n                // Aggregate the updates by stateKey and path\r\n                const aggregatedLogs = logs.reduce((acc, log) => {\r\n                    const uniqueKey = `${log.stateKey}:${JSON.stringify(log.path)}`;\r\n                    const existing = acc.get(uniqueKey);\r\n\r\n                    if (existing) {\r\n                        // Update the existing entry with the most recent details\r\n                        existing.timeStamp = Math.max(\r\n                            existing.timeStamp,\r\n                            log.timeStamp,\r\n                        );\r\n                        existing.newValue = log.newValue; // Overwrite with the latest value\r\n                        existing.oldValue = existing.oldValue ?? log.oldValue; // Retain the initial oldValue\r\n                        existing.updateType = log.updateType; // Update to the most recent type\r\n                    } else {\r\n                        // Add the log if no existing match is found\r\n                        acc.set(uniqueKey, { ...(log as any) });\r\n                    }\r\n\r\n                    return acc;\r\n                }, new Map<string, typeof newUpdate>());\r\n\r\n                // Convert the aggregated map back to an array\r\n                return Array.from(aggregatedLogs.values());\r\n            });\r\n\r\n            saveToLocalStorage(\r\n                payload,\r\n                thisKey,\r\n                latestInitialOptionsRef.current,\r\n                sessionId,\r\n            );\r\n\r\n            if (middleware) {\r\n                middleware({ updateLog: stateLog, update: newUpdate });\r\n            }\r\n            if (latestInitialOptionsRef.current?.serverSync) {\r\n                const serverStateStore =\r\n                    getGlobalStore.getState().serverState[thisKey];\r\n                const serverSync = latestInitialOptionsRef.current?.serverSync;\r\n                setServerSyncActions(thisKey, {\r\n                    syncKey:\r\n                        typeof serverSync.syncKey == \"string\"\r\n                            ? serverSync.syncKey\r\n                            : serverSync.syncKey({ state: payload }),\r\n                    rollBackState: serverStateStore,\r\n                    actionTimeStamp: Date.now() + (serverSync.debounce ?? 3000),\r\n                    status: \"waiting\",\r\n                });\r\n            }\r\n\r\n            return payload;\r\n        });\r\n    };\r\n    if (!getGlobalStore.getState().updaterState[thisKey]) {\r\n        console.log(\"Initializing state for\", thisKey, stateObject); // Debug log\r\n        setUpdaterState(\r\n            thisKey,\r\n            createProxyHandler(\r\n                thisKey,\r\n                effectiveSetState,\r\n                componentIdRef.current,\r\n                sessionId,\r\n            ),\r\n        );\r\n        if (!getGlobalStore.getState().cogsStateStore[thisKey]) {\r\n            setState(thisKey, stateObject);\r\n        }\r\n        if (!getGlobalStore.getState().initialStateGlobal[thisKey]) {\r\n            updateInitialStateGlobal(thisKey, stateObject);\r\n        }\r\n    }\r\n\r\n    const updaterFinal = useMemo(() => {\r\n        // Create proxy with baseObject as target\r\n        return createProxyHandler<TStateObject>(\r\n            thisKey,\r\n            effectiveSetState,\r\n            componentIdRef.current,\r\n            sessionId,\r\n        );\r\n    }, [thisKey]);\r\n\r\n    return [getKeyState(thisKey), updaterFinal] as [\r\n        TStateObject,\r\n        StateObject<TStateObject>,\r\n    ];\r\n}\r\n\r\nfunction createProxyHandler<T>(\r\n    stateKey: string,\r\n    effectiveSetState: EffectiveSetState<T>,\r\n    componentId: string,\r\n    sessionId?: string,\r\n): StateObject<T> {\r\n    // ADDED: Enhanced cache with versioning\r\n    type CacheEntry = {\r\n        proxy: any;\r\n        stateVersion: number;\r\n    };\r\n    const shapeCache = new Map<string, CacheEntry>();\r\n    let stateVersion = 0;\r\n\r\n    // ADDED: Cache invalidation helper\r\n    const invalidateCachePath = (path: string[]) => {\r\n        const pathKey = path.join(\".\");\r\n        for (const [key] of shapeCache) {\r\n            if (key === pathKey || key.startsWith(pathKey + \".\")) {\r\n                shapeCache.delete(key);\r\n            }\r\n        }\r\n        stateVersion++;\r\n    };\r\n\r\n    const selectedIndexMap = new Map<string, number>();\r\n\r\n    const baseObj = {\r\n        removeValidation: (obj?: { validationKey?: string }) => {\r\n            if (obj?.validationKey) {\r\n                removeValidationError(obj.validationKey);\r\n            }\r\n        },\r\n\r\n        revertToInitialState: (obj?: { validationKey?: string }) => {\r\n            if (obj?.validationKey) {\r\n                removeValidationError(obj.validationKey);\r\n            }\r\n\r\n            const initialState =\r\n                getGlobalStore.getState().initialStateGlobal[stateKey];\r\n\r\n            // ADDED: Clear cache on revert\r\n            shapeCache.clear();\r\n            stateVersion++;\r\n\r\n            const newProxy = rebuildStateShape(initialState, []);\r\n\r\n            startTransition(() => {\r\n                setUpdaterState(stateKey, newProxy);\r\n                setState(stateKey, initialState);\r\n                const stateEntry = getGlobalStore\r\n                    .getState()\r\n                    .stateComponents.get(stateKey);\r\n                if (stateEntry) {\r\n                    stateEntry.components.forEach((component) => {\r\n                        component.forceUpdate();\r\n                    });\r\n                }\r\n                const initalOptionsGet = getInitialOptions(stateKey as string);\r\n                if (initalOptionsGet?.initState) {\r\n                    localStorage.removeItem(\r\n                        initalOptionsGet?.initState\r\n                            ? sessionId +\r\n                                  \"-\" +\r\n                                  stateKey +\r\n                                  \"-\" +\r\n                                  initalOptionsGet?.initState.localStorageKey\r\n                            : stateKey,\r\n                    );\r\n                }\r\n                localStorage.removeItem(stateKey);\r\n            });\r\n        },\r\n        updateInitialState: (newState: T) => {\r\n            // ADDED: Clear cache on initial state update\r\n            shapeCache.clear();\r\n            stateVersion++;\r\n\r\n            const newUpdaterState = createProxyHandler(\r\n                stateKey,\r\n                effectiveSetState,\r\n                componentId,\r\n                sessionId,\r\n            );\r\n            startTransition(() => {\r\n                updateInitialStateGlobal(stateKey, newState);\r\n                setUpdaterState(stateKey, newUpdaterState);\r\n                setState(stateKey, newState);\r\n                const stateEntry = getGlobalStore\r\n                    .getState()\r\n                    .stateComponents.get(stateKey);\r\n                if (stateEntry) {\r\n                    stateEntry.components.forEach((component) => {\r\n                        component.forceUpdate();\r\n                    });\r\n                }\r\n                localStorage.removeItem(stateKey);\r\n            });\r\n            return {\r\n                fetchId: (field: keyof T) => newUpdaterState.get()[field],\r\n            };\r\n        },\r\n        _initialState: getGlobalStore.getState().initialStateGlobal[stateKey],\r\n        _serverState: getGlobalStore.getState().serverState[stateKey],\r\n        _isLoading: getGlobalStore.getState().isLoadingGlobal[stateKey],\r\n        _isServerSynced: () => {\r\n            const serverState = getGlobalStore.getState().serverState[stateKey];\r\n            return Boolean(\r\n                serverState && isDeepEqual(serverState, getKeyState(stateKey)),\r\n            );\r\n        },\r\n    };\r\n\r\n    function rebuildStateShape(\r\n        currentState: T,\r\n        path: string[] = [],\r\n        meta?: { filtered?: string[][]; validIndices?: number[] },\r\n    ): any {\r\n        const cacheKey = path.map(String).join(\".\");\r\n\r\n        // MODIFIED: Cache check with version\r\n        const cachedEntry = shapeCache.get(cacheKey);\r\n        if (cachedEntry?.stateVersion === stateVersion) {\r\n            return cachedEntry.proxy;\r\n        }\r\n\r\n        const handler = {\r\n            get(target: any, prop: string) {\r\n                if (prop !== \"then\" && prop !== \"$get\") {\r\n                    console.log(\"prop\", prop);\r\n                    const currentPath = path.join(\".\");\r\n                    const fullComponentId = `${stateKey}////${componentId}`;\r\n                    const stateEntry = getGlobalStore\r\n                        .getState()\r\n                        .stateComponents.get(stateKey);\r\n                    if (stateEntry && currentPath) {\r\n                        const component =\r\n                            stateEntry.components.get(fullComponentId);\r\n                        if (component) {\r\n                            component.paths.add(currentPath);\r\n                        }\r\n                    }\r\n                }\r\n                if (Array.isArray(currentState)) {\r\n                    if (prop === \"getSelected\") {\r\n                        return () => {\r\n                            const selectedIndex = selectedIndexMap.get(\r\n                                path.join(\".\"),\r\n                            );\r\n                            if (selectedIndex === undefined) return undefined;\r\n                            return rebuildStateShape(\r\n                                currentState[selectedIndex],\r\n                                [...path, selectedIndex.toString()],\r\n                                meta,\r\n                            );\r\n                        };\r\n                    }\r\n\r\n                    if (prop === \"stateEach\") {\r\n                        return (\r\n                            callbackfn: (\r\n                                value: InferArrayElement<T>,\r\n                                setter: StateObject<InferArrayElement<T>>,\r\n                                index: number,\r\n                                array: T,\r\n                                arraySetter: StateObject<T>,\r\n                            ) => void,\r\n                        ) => {\r\n                            const isFiltered = meta?.filtered?.some(\r\n                                (p) => p.join(\".\") === path.join(\".\"),\r\n                            );\r\n                            const arrayToMap = isFiltered\r\n                                ? currentState\r\n                                : getGlobalStore\r\n                                      .getState()\r\n                                      .getNestedState(stateKey, path);\r\n\r\n                            // ADDED: Clear shape cache for array operations\r\n                            shapeCache.clear();\r\n                            stateVersion++;\r\n\r\n                            return arrayToMap.map((val: any, index: number) => {\r\n                                const thisIndex =\r\n                                    isFiltered && val.__origIndex\r\n                                        ? val.__origIndex\r\n                                        : index;\r\n                                const elementProxy = rebuildStateShape(\r\n                                    val,\r\n                                    [...path, thisIndex.toString()],\r\n                                    meta,\r\n                                );\r\n                                return callbackfn(\r\n                                    val,\r\n                                    elementProxy,\r\n                                    index,\r\n                                    currentState as any,\r\n                                    rebuildStateShape(\r\n                                        currentState as any,\r\n                                        path,\r\n                                        meta,\r\n                                    ),\r\n                                );\r\n                            });\r\n                        };\r\n                    }\r\n\r\n                    if (prop === \"stateFlattenOn\") {\r\n                        return (fieldName: string) => {\r\n                            const isFiltered = meta?.filtered?.some(\r\n                                (p) => p.join(\".\") === path.join(\".\"),\r\n                            );\r\n                            const arrayToMap = isFiltered\r\n                                ? currentState\r\n                                : getGlobalStore\r\n                                      .getState()\r\n                                      .getNestedState(stateKey, path);\r\n\r\n                            // ADDED: Clear shape cache for flattening operation\r\n                            shapeCache.clear();\r\n                            stateVersion++;\r\n\r\n                            const flattenedResults = arrayToMap.flatMap(\r\n                                (val: any, index: number) => {\r\n                                    return val[fieldName] ?? [];\r\n                                },\r\n                            );\r\n\r\n                            return rebuildStateShape(\r\n                                flattenedResults,\r\n                                [...path, \"[*]\", fieldName],\r\n                                meta,\r\n                            );\r\n                        };\r\n                    }\r\n\r\n                    if (prop === \"findWith\") {\r\n                        return (\r\n                            thisKey: keyof InferArrayElement<T>,\r\n                            thisValue: InferArrayElement<T>[keyof InferArrayElement<T>],\r\n                        ) => {\r\n                            const foundIndex = currentState.findIndex(\r\n                                (obj: any) => obj[thisKey] === thisValue,\r\n                            );\r\n                            if (foundIndex === -1) return undefined;\r\n                            const foundValue = currentState[foundIndex];\r\n                            const newPath = [...path, foundIndex.toString()];\r\n                            // console.log(\r\n                            //     \"findWithfindWithfindWithfindWith\",\r\n                            //     stateKey,\r\n                            //     foundValue,\r\n                            //     newPath,\r\n                            // );\r\n                            shapeCache.clear();\r\n                            stateVersion++;\r\n\r\n                            // ADDED: Clear cache for find operation\r\n                            shapeCache.clear();\r\n                            stateVersion++;\r\n                            // Try returning without spread\r\n                            return rebuildStateShape(foundValue, newPath);\r\n                        };\r\n                    }\r\n\r\n                    if (prop === \"index\") {\r\n                        return (index: number) => {\r\n                            const indexValue = currentState[index];\r\n                            return rebuildStateShape(indexValue, [\r\n                                ...path,\r\n                                index.toString(),\r\n                            ]);\r\n                        };\r\n                    }\r\n\r\n                    if (prop === \"insert\") {\r\n                        return (payload: UpdateArg<T>) => {\r\n                            // ADDED: Invalidate cache on insert\r\n                            invalidateCachePath(path);\r\n                            pushFunc(\r\n                                effectiveSetState,\r\n                                payload,\r\n                                path,\r\n                                stateKey,\r\n                            );\r\n                            return rebuildStateShape(\r\n                                getGlobalStore.getState().cogsStateStore[\r\n                                    stateKey\r\n                                ],\r\n                                [],\r\n                            );\r\n                        };\r\n                    }\r\n\r\n                    if (prop === \"uniqueInsert\") {\r\n                        return (\r\n                            payload: UpdateArg<T>,\r\n                            fields?: (keyof InferArrayElement<T>)[],\r\n                        ) => {\r\n                            const currentArray = getGlobalStore\r\n                                .getState()\r\n                                .getNestedState(stateKey, path) as any[];\r\n                            const newValue = isFunction<T>(payload)\r\n                                ? payload(currentArray as any)\r\n                                : (payload as any);\r\n\r\n                            const isUnique = !currentArray.some((item) => {\r\n                                if (fields) {\r\n                                    return fields.every((field) =>\r\n                                        isDeepEqual(\r\n                                            item[field],\r\n                                            newValue[field],\r\n                                        ),\r\n                                    );\r\n                                }\r\n                                return isDeepEqual(item, newValue);\r\n                            });\r\n\r\n                            if (isUnique) {\r\n                                // ADDED: Invalidate cache on unique insert\r\n                                invalidateCachePath(path);\r\n                                pushFunc(\r\n                                    effectiveSetState,\r\n                                    newValue,\r\n                                    path,\r\n                                    stateKey,\r\n                                );\r\n                            }\r\n                        };\r\n                    }\r\n\r\n                    if (prop === \"cut\") {\r\n                        return (\r\n                            index: number,\r\n                            options?: { waitForSync?: boolean },\r\n                        ) => {\r\n                            if (options?.waitForSync) return;\r\n                            // ADDED: Invalidate cache on cut\r\n                            invalidateCachePath(path);\r\n                            cutFunc(effectiveSetState, path, stateKey, index);\r\n                        };\r\n                    }\r\n\r\n                    if (prop === \"stateFilter\") {\r\n                        return (\r\n                            callbackfn: (\r\n                                value: InferArrayElement<T>,\r\n                                index: number,\r\n                            ) => boolean,\r\n                        ) => {\r\n                            const newVal = currentState.map(\r\n                                (v: any, i: number) => ({\r\n                                    ...v,\r\n                                    __origIndex: i.toString(),\r\n                                }),\r\n                            );\r\n\r\n                            const validIndices: number[] = [];\r\n                            const filteredArray: Array<InferArrayElement<T>> =\r\n                                [];\r\n\r\n                            for (let i = 0; i < newVal.length; i++) {\r\n                                if (callbackfn(newVal[i], i)) {\r\n                                    validIndices.push(i);\r\n                                    filteredArray.push(newVal[i]);\r\n                                }\r\n                            }\r\n\r\n                            // ADDED: Clear cache for filter operation\r\n                            shapeCache.clear();\r\n                            stateVersion++;\r\n                            return rebuildStateShape(\r\n                                filteredArray as any,\r\n                                path,\r\n                                {\r\n                                    filtered: [...(meta?.filtered || []), path],\r\n                                    validIndices, // Pass through the meta\r\n                                },\r\n                            );\r\n                        };\r\n                    }\r\n                }\r\n                const lastPathElement = path[path.length - 1];\r\n                if (!isNaN(Number(lastPathElement))) {\r\n                    const parentPath = path.slice(0, -1);\r\n                    const parentValue = getGlobalStore\r\n                        .getState()\r\n                        .getNestedState(stateKey, parentPath);\r\n\r\n                    if (Array.isArray(parentValue) && prop === \"cut\") {\r\n                        return () =>\r\n                            cutFunc(\r\n                                effectiveSetState,\r\n                                parentPath,\r\n                                stateKey,\r\n                                Number(lastPathElement),\r\n                            );\r\n                    }\r\n                }\r\n\r\n                if (prop === \"get\") {\r\n                    return () =>\r\n                        getGlobalStore\r\n                            .getState()\r\n                            .getNestedState(stateKey, path);\r\n                }\r\n\r\n                if (prop === \"$effect\") {\r\n                    return (fn: any) =>\r\n                        $cogsSignal({\r\n                            _stateKey: stateKey,\r\n                            _path: path,\r\n                            _effect: fn.toString(),\r\n                        });\r\n                }\r\n\r\n                if (prop === \"$get\") {\r\n                    return () =>\r\n                        $cogsSignal({\r\n                            _stateKey: stateKey,\r\n                            _path: path,\r\n                        });\r\n                }\r\n                if (prop === \"lastSynced\") {\r\n                    const syncKey = `${stateKey}:${path.join(\".\")}`;\r\n                    return getGlobalStore.getState().getSyncInfo(syncKey);\r\n                }\r\n\r\n                if (prop === \"_selected\") {\r\n                    const parentPath = path.slice(0, -1);\r\n                    const parentKey = parentPath.join(\".\");\r\n                    const parent = getGlobalStore\r\n                        .getState()\r\n                        .getNestedState(stateKey, parentPath);\r\n                    if (Array.isArray(parent)) {\r\n                        const currentIndex = Number(path[path.length - 1]);\r\n                        return currentIndex === selectedIndexMap.get(parentKey);\r\n                    }\r\n                    return undefined;\r\n                }\r\n                if (prop == \"getLocalStorage\") {\r\n                    return (key: string) =>\r\n                        loadFromLocalStorage(\r\n                            sessionId + \"-\" + stateKey + \"-\" + key,\r\n                        );\r\n                }\r\n                if (prop === \"setSelected\") {\r\n                    return (value: boolean) => {\r\n                        const parentPath = path.slice(0, -1);\r\n                        const thisIndex = Number(path[path.length - 1]);\r\n                        const parentKey = parentPath.join(\".\");\r\n                        if (value) {\r\n                            selectedIndexMap.set(parentKey, thisIndex);\r\n                        } else {\r\n                            // Optional: clear selection if false\r\n                            selectedIndexMap.delete(parentKey);\r\n                        }\r\n                        const nested = getGlobalStore\r\n                            .getState()\r\n                            .getNestedState(stateKey, [...parentPath]);\r\n                        updateFn(effectiveSetState, nested, parentPath);\r\n\r\n                        // ADDED: Invalidate cache for parent path\r\n                        invalidateCachePath(parentPath);\r\n                    };\r\n                }\r\n\r\n                if (path.length == 0) {\r\n                    if (prop == \"_componentId\") return componentId;\r\n                    if (prop === \"_initialState\")\r\n                        return getGlobalStore.getState().initialStateGlobal[\r\n                            stateKey\r\n                        ];\r\n                    if (prop === \"_serverState\")\r\n                        return getGlobalStore.getState().serverState[stateKey];\r\n                    if (prop === \"_isLoading\")\r\n                        return getGlobalStore.getState().isLoadingGlobal[\r\n                            stateKey\r\n                        ];\r\n                    if (prop === \"revertToInitialState\")\r\n                        return baseObj.revertToInitialState;\r\n                    if (prop === \"updateInitialState\")\r\n                        return baseObj.updateInitialState;\r\n                    if (prop === \"removeValidation\")\r\n                        return baseObj.removeValidation;\r\n                }\r\n\r\n                if (prop === \"validationWrapper\") {\r\n                    return ({\r\n                        children,\r\n                        hideMessage,\r\n                    }: {\r\n                        children: React.ReactNode;\r\n                        hideMessage?: boolean;\r\n                    }) => (\r\n                        <ValidationWrapper\r\n                            formOpts={\r\n                                hideMessage\r\n                                    ? { validation: { message: \"\" } }\r\n                                    : undefined\r\n                            }\r\n                            path={path}\r\n                            validationKey={\r\n                                getGlobalStore\r\n                                    .getState()\r\n                                    .getInitialOptions(stateKey)\r\n                                    ?.validationKey || \"\"\r\n                            }\r\n                            stateKey={stateKey}\r\n                            validIndices={meta?.validIndices}\r\n                        >\r\n                            {children}\r\n                        </ValidationWrapper>\r\n                    );\r\n                }\r\n\r\n                if (prop === \"_stateKey\") return stateKey;\r\n                if (prop === \"_path\") return path;\r\n                if (prop === \"_isServerSynced\") return baseObj._isServerSynced;\r\n\r\n                if (prop === \"update\") {\r\n                    return (payload: UpdateArg<T>, opts?: UpdateOpts) => {\r\n                        // ADDED: Invalidate cache on update\r\n                        invalidateCachePath(path);\r\n                        updateFn(effectiveSetState, payload, path, \"\");\r\n                    };\r\n                }\r\n\r\n                if (prop === \"formElement\") {\r\n                    return (\r\n                        validationKey: string,\r\n                        child: FormControl<T>,\r\n                        formOpts?: FormOptsType,\r\n                    ) => {\r\n                        return (\r\n                            <FormControlComponent<T>\r\n                                setState={effectiveSetState}\r\n                                validationKey={validationKey}\r\n                                stateKey={stateKey}\r\n                                path={path}\r\n                                child={child}\r\n                                formOpts={formOpts}\r\n                            />\r\n                        );\r\n                    };\r\n                }\r\n\r\n                const nextPath = [...path, prop];\r\n                const nextValue = getGlobalStore\r\n                    .getState()\r\n                    .getNestedState(stateKey, nextPath);\r\n                return rebuildStateShape(nextValue, nextPath, meta);\r\n            },\r\n        };\r\n\r\n        const proxyInstance = new Proxy(baseObj as StateObject<T>, handler);\r\n\r\n        shapeCache.set(cacheKey, {\r\n            proxy: proxyInstance,\r\n            stateVersion: stateVersion,\r\n        });\r\n\r\n        return proxyInstance;\r\n    }\r\n\r\n    return rebuildStateShape(\r\n        getGlobalStore.getState().getNestedState(stateKey, []),\r\n    );\r\n}\r\n\r\nexport function $cogsSignal(proxy: {\r\n    _path: string[];\r\n    _stateKey: string;\r\n    _effect?: string;\r\n}) {\r\n    return createElement(SignalRenderer, { proxy });\r\n}\r\nfunction SignalRenderer({\r\n    proxy,\r\n}: {\r\n    proxy: {\r\n        _path: string[];\r\n        _stateKey: string;\r\n        _effect?: string;\r\n    };\r\n}) {\r\n    const elementRef = useRef<HTMLSpanElement>(null);\r\n    const signalId = `${proxy._stateKey}-${proxy._path.join(\".\")}`;\r\n    console.log(\"SignalRenderer\", signalId);\r\n    useEffect(() => {\r\n        const element = elementRef.current;\r\n        if (!element || !element.parentElement) return;\r\n\r\n        const parentElement = element.parentElement;\r\n        const childNodes = Array.from(parentElement.childNodes);\r\n        const position = childNodes.indexOf(element);\r\n\r\n        let parentId = parentElement.getAttribute(\"data-parent-id\");\r\n        if (!parentId) {\r\n            parentId = `parent-${crypto.randomUUID()}`;\r\n            parentElement.setAttribute(\"data-parent-id\", parentId);\r\n        }\r\n\r\n        const instanceId = `instance-${crypto.randomUUID()}`;\r\n        const elementInfo = {\r\n            instanceId,\r\n            parentId,\r\n            position,\r\n            effect: proxy._effect,\r\n        };\r\n\r\n        getGlobalStore.getState().addSignalElement(signalId, elementInfo);\r\n\r\n        const value = getGlobalStore\r\n            .getState()\r\n            .getNestedState(proxy._stateKey, proxy._path);\r\n\r\n        const textNode = document.createTextNode(String(value));\r\n        element.replaceWith(textNode);\r\n    }, [proxy._stateKey, proxy._path.join(\".\"), proxy._effect]);\r\n\r\n    return createElement(\"span\", {\r\n        ref: elementRef,\r\n        style: { display: \"none\" },\r\n        \"data-signal-id\": signalId,\r\n    });\r\n}\r\nexport function $cogsSignalStore(proxy: {\r\n    _path: string[];\r\n    _stateKey: string;\r\n}) {\r\n    const value = useSyncExternalStore(\r\n        (notify) => {\r\n            const stateEntry = getGlobalStore\r\n                .getState()\r\n                .stateComponents.get(proxy._stateKey) || {\r\n                components: new Map(),\r\n            };\r\n            stateEntry.components.set(proxy._stateKey, {\r\n                forceUpdate: notify,\r\n                paths: new Set([proxy._path.join(\".\")]),\r\n            });\r\n            return () => stateEntry.components.delete(proxy._stateKey);\r\n        },\r\n        () =>\r\n            getGlobalStore\r\n                .getState()\r\n                .getNestedState(proxy._stateKey, proxy._path),\r\n    );\r\n    return createElement(\"text\", {}, String(value));\r\n}\r\n"],"names":["addStateOptions","initialState","formElements","zodSchema","setAndMergeOptions","stateKey","newOptions","getInitialOptions","getGlobalStore","setInitialStateOptions","initialOptions","setOptions","options","initialOptionsPart","initialOptionsPartState","mergedOptions","needToAdd","key","createCogsState","opts","newInitialState","statePart","transformStateFunc","useCogsState","componentId","useState","uuidv4","thiState","partialState","state","updater","useCogsStateFn","setCogsOptions","setUpdaterState","setState","getKeyState","getValidationErrors","setStateLog","updateInitialStateGlobal","addValidationError","removeValidationError","setServerSyncActions","loadFromLocalStorage","localStorageKey","storedData","error","saveToLocalStorage","thisKey","currentInitialOptions","sessionId","data","storageKey","updateGlobalState","newState","effectiveSetState","updates","createProxyHandler","startTransition","notifyComponents","stateEntry","component","update","stateObject","serverSync","localStorage","middleware","reactiveDeps","initState","syncUpdate","reactiveForce","forceUpdate","useCogsConfig","noStateKey","stateLog","componentUpdatesRef","useRef","componentIdRef","latestInitialOptionsRef","useEffect","prevState","syncKey","localData","depsKey","newStateOrFunction","path","updateObj","validationKey","pathKey","prevValue","payload","isFunction","signalId","isArrayOperation","elements","arrayPath","arrayValue","getNestedValue","arraySignalId","newValue","parentId","position","effect","parent","childNodes","displayValue","arrayWithoutIndex","k","v","length","newKey","oldValue","pathToCheck","depsResult","isDeepEqual","newUpdate","prevLogs","aggregatedLogs","acc","log","uniqueKey","existing","serverStateStore","updaterFinal","useMemo","shapeCache","stateVersion","invalidateCachePath","selectedIndexMap","baseObj","obj","newProxy","rebuildStateShape","initalOptionsGet","newUpdaterState","field","serverState","currentState","meta","cacheKey","cachedEntry","handler","target","prop","currentPath","fullComponentId","selectedIndex","callbackfn","isFiltered","p","arrayToMap","val","index","thisIndex","elementProxy","fieldName","flattenedResults","thisValue","foundIndex","foundValue","newPath","indexValue","pushFunc","fields","currentArray","item","cutFunc","newVal","i","validIndices","filteredArray","lastPathElement","parentPath","parentValue","fn","$cogsSignal","parentKey","value","nested","updateFn","children","hideMessage","jsx","ValidationWrapper","child","formOpts","FormControlComponent","nextPath","nextValue","proxyInstance","proxy","createElement","SignalRenderer","elementRef","element","parentElement","elementInfo","textNode","$cogsSignalStore","useSyncExternalStore","notify"],"mappings":"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"}