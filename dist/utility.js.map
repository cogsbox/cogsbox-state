{"version":3,"file":"utility.js","sources":["../src/utility.ts"],"sourcesContent":["import type { InitialStateType, TransformedStateType } from \"./CogsState\";\r\nexport const isObject = (item: any): item is Record<string, any> => {\r\n  return (\r\n    item && typeof item === \"object\" && !Array.isArray(item) && item !== null\r\n  );\r\n};\r\nexport type GenericObject = Record<string, any>;\r\n\r\nexport const isFunction = <TStateObject extends unknown>(\r\n  arg: any\r\n): arg is (prev: TStateObject) => TStateObject => typeof arg === \"function\";\r\n\r\nexport const isArray = (item: any): item is Array<any> => {\r\n  return Array.isArray(item);\r\n};\r\nexport const isDeepEqual = (\r\n  object1?: Record<string, any>,\r\n  object2?: Record<string, any>,\r\n  opts: { get?: () => void } = {},\r\n  currentPath: string[] = []\r\n): boolean => {\r\n  if (isObject(object1) && isObject(object2)) {\r\n    const objKeys1 = Object.keys(object1);\r\n    const objKeys2 = Object.keys(object2);\r\n\r\n    if (objKeys1.length !== objKeys2.length) {\r\n      //     console.log(\"not equal\", objKeys1, objKeys2);\r\n      return false;\r\n    }\r\n\r\n    for (let key of objKeys1) {\r\n      const value1 = object1[key];\r\n      const value2 = object2[key];\r\n\r\n      // Check if the key exists in both objects\r\n      if (!(key in object1) || !(key in object2)) {\r\n        //     console.log(\"not equal\", key);\r\n        return false;\r\n      }\r\n\r\n      const newPath = [...currentPath, key];\r\n\r\n      // If current path is in ignoreArray, continue to the next key\r\n\r\n      if (!isDeepEqual(value1, value2, opts, newPath)) {\r\n        //   console.log(\"not equal\", value1, value2);\r\n        return false;\r\n      }\r\n    }\r\n    return true;\r\n  } else if (isArray(object1) && isArray(object2)) {\r\n    if (object1.length !== object2.length) {\r\n      //  console.log(\"not equal\", object1);\r\n      return false;\r\n    }\r\n\r\n    for (let i = 0; i < object1.length; i++) {\r\n      if (\r\n        !isDeepEqual(object1[i], object2[i], opts, [\r\n          ...currentPath,\r\n          i.toString(),\r\n        ])\r\n      ) {\r\n        //    console.log(\"not equal\", object1[i]);\r\n        return false;\r\n      }\r\n    }\r\n    return true;\r\n  } else {\r\n    return (\r\n      object1 === object2 || (Number.isNaN(object1) && Number.isNaN(object2))\r\n    );\r\n  }\r\n};\r\n\r\nexport function updateNestedProperty(\r\n  path: string[],\r\n  state: any,\r\n  update: any\r\n): any {\r\n  if (!path || path.length === 0) return update;\r\n  const head = path[0];\r\n  const tail = path.slice(1);\r\n\r\n  if (Array.isArray(state)) {\r\n    const index = Number(head);\r\n\r\n    if (!isNaN(index) && index >= 0 && index < state.length) {\r\n      return [\r\n        ...state.slice(0, index),\r\n        updateNestedProperty(tail, state[index], update),\r\n        ...state.slice(index + 1),\r\n      ];\r\n    } else {\r\n      console.log(\"errorstate\", state, path);\r\n      throw new Error(\r\n        `Invalid array index \"${index}\" in path \"${path.join(\".\")}\".`\r\n      );\r\n    }\r\n  } else if (typeof state === \"object\" && state !== null) {\r\n    if (head && head in state) {\r\n      return {\r\n        ...state,\r\n        [head!]: updateNestedProperty(tail, state[head!], update),\r\n      };\r\n    } else {\r\n      console.log(`Invalid property`, head, tail, path);\r\n      throw new Error(\r\n        `Invalid property \"${head}\" in path \"${path.join(\".\")}\".`\r\n      );\r\n    }\r\n  } else {\r\n    throw new Error(\r\n      `Cannot update nested property at path \"${path.join(\".\")}\". The path does not exist.`\r\n    );\r\n  }\r\n}\r\n\r\nexport function deleteNestedProperty(path: string[], state: any): any {\r\n  if (!path || path.length === 0) return state;\r\n  const head = path[0] as string;\r\n  const tail = path.slice(1);\r\n\r\n  if (Array.isArray(state)) {\r\n    const index = Number(head);\r\n\r\n    if (!isNaN(index) && index >= 0 && index < state.length) {\r\n      if (tail.length === 0) {\r\n        // Remove the item at the index\r\n        return [...state.slice(0, index), ...state.slice(index + 1)];\r\n      } else {\r\n        return [\r\n          ...state.slice(0, index),\r\n          deleteNestedProperty(tail, state[index]),\r\n          ...state.slice(index + 1),\r\n        ];\r\n      }\r\n    } else {\r\n      throw new Error(\r\n        `Invalid array index \"${index}\" in path \"${path.join(\".\")}\".`\r\n      );\r\n    }\r\n  } else if (typeof state === \"object\" && state !== null) {\r\n    if (tail.length === 0) {\r\n      // Delete the property and return the new object\r\n      const { [head]: _, ...rest } = state;\r\n      return rest;\r\n    } else if (head in state) {\r\n      return {\r\n        ...state,\r\n        [head]: deleteNestedProperty(tail, state[head]),\r\n      };\r\n    } else {\r\n      throw new Error(\r\n        `Invalid property \"${head}\" in path \"${path.join(\".\")}\".`\r\n      );\r\n    }\r\n  } else {\r\n    throw new Error(\r\n      `Cannot delete nested property at path \"${path.join(\".\")}\". The path does not exist.`\r\n    );\r\n  }\r\n}\r\n\r\nexport function getNestedValue<TStateObject extends unknown>(\r\n  obj: TStateObject,\r\n  pathArray: string[]\r\n) {\r\n  let value: any = obj;\r\n\r\n  for (let i = 0; i < pathArray.length; i++) {\r\n    const key = pathArray[i]!;\r\n    if (value === undefined || value === null) {\r\n      // Cannot traverse further\r\n      return undefined;\r\n    }\r\n\r\n    if (typeof key === \"string\" && key.startsWith(\"id:\")) {\r\n      if (!Array.isArray(value)) {\r\n        console.error(\"Path segment with 'id:' requires an array.\", {\r\n          path: pathArray,\r\n          currentValue: value,\r\n        });\r\n        return undefined;\r\n      }\r\n      const targetId = key.split(\":\")[1];\r\n      value = value.find((item: any) => String(item.id) === targetId);\r\n    } else if (Array.isArray(value)) {\r\n      value = value[parseInt(key)];\r\n    } else {\r\n      value = value[key];\r\n    }\r\n  }\r\n  return value;\r\n}\r\n\r\nexport function updateNestedPropertyIds(\r\n  path: string[],\r\n  state: any,\r\n  newValue: any\r\n) {\r\n  if (path.length === 0) {\r\n    return newValue;\r\n  }\r\n\r\n  const newState = Array.isArray(state) ? [...state] : { ...state };\r\n  let current: any = newState;\r\n\r\n  for (let i = 0; i < path.length - 1; i++) {\r\n    const key = path[i]!;\r\n\r\n    if (typeof key === \"string\" && key.startsWith(\"id:\")) {\r\n      if (!Array.isArray(current)) {\r\n        throw new Error(\r\n          `Path segment \"${key}\" requires an array, but got a non-array.`\r\n        );\r\n      }\r\n      const targetId = key.split(\":\")[1];\r\n      const index = current.findIndex(\r\n        (item: any) => String(item.id) === targetId\r\n      );\r\n\r\n      if (index === -1) {\r\n        throw new Error(`Item with id \"${targetId}\" not found in array.`);\r\n      }\r\n      // Create a copy of the object at the found index to avoid direct mutation\r\n      current[index] = { ...current[index] };\r\n      current = current[index];\r\n    } else {\r\n      // Create a copy of the object/array to avoid direct mutation\r\n      current[key] = Array.isArray(current[key])\r\n        ? [...current[key]]\r\n        : { ...current[key] };\r\n      current = current[key];\r\n    }\r\n  }\r\n\r\n  // --- FIX IS HERE ---\r\n  // The original code only did `current[lastKey] = newValue;`\r\n  // This new logic handles the `id:` syntax for the *last* segment of the path.\r\n  const lastKey = path[path.length - 1]!;\r\n  if (typeof lastKey === \"string\" && lastKey.startsWith(\"id:\")) {\r\n    if (!Array.isArray(current)) {\r\n      throw new Error(\r\n        `Final path segment \"${lastKey}\" requires an array, but got a non-array.`\r\n      );\r\n    }\r\n    const targetId = lastKey.split(\":\")[1];\r\n    const index = current.findIndex(\r\n      (item: any) => String(item.id) === targetId\r\n    );\r\n    if (index === -1) {\r\n      throw new Error(\r\n        `Item with id \"${targetId}\" not found in array to update.`\r\n      );\r\n    }\r\n    // Replace the item at its correct index\r\n    current[index] = newValue;\r\n  } else {\r\n    // This is the old logic, which works for normal properties.\r\n    current[lastKey] = newValue;\r\n  }\r\n  // --- END OF FIX ---\r\n\r\n  return newState;\r\n}\r\ntype DifferencePaths = string[];\r\n\r\nexport function getDifferences(\r\n  obj1: any,\r\n  obj2: any,\r\n  currentPath: string = \"\"\r\n): DifferencePaths {\r\n  let differences: DifferencePaths = [];\r\n  // Handling null and undefined cases\r\n  if (typeof obj1 === \"function\" && typeof obj2 === \"function\") {\r\n    return differences;\r\n  }\r\n  if (\r\n    obj1 === null ||\r\n    obj1 === undefined ||\r\n    obj2 === null ||\r\n    obj2 === undefined\r\n  ) {\r\n    if (obj1 !== obj2) {\r\n      //     console.log(obj1, obj2);\r\n      return [currentPath];\r\n    }\r\n    return differences;\r\n  }\r\n\r\n  // Handling primitive types\r\n  if (typeof obj1 !== \"object\" || typeof obj2 !== \"object\") {\r\n    if (obj1 !== obj2) {\r\n      return [currentPath];\r\n    }\r\n    return differences;\r\n  }\r\n\r\n  // Handling arrays\r\n  if (Array.isArray(obj1) && Array.isArray(obj2)) {\r\n    // Handle changes in length directly\r\n    if (obj1.length !== obj2.length) {\r\n      differences.push(`${currentPath}`);\r\n    }\r\n\r\n    // Use the shorter length for comparison to detect shifts or changes\r\n    const commonLength = Math.min(obj1.length, obj2.length);\r\n    for (let i = 0; i < commonLength; i++) {\r\n      if (obj1[i] !== obj2[i]) {\r\n        differences = differences.concat(\r\n          getDifferences(\r\n            obj1[i],\r\n            obj2[i],\r\n            currentPath ? `${currentPath}.${i}` : `${i}`\r\n          )\r\n        );\r\n      }\r\n    }\r\n\r\n    // If an array is shorter post-cut, the remaining items in the longer array are implicitly shifted/deleted\r\n    if (obj1.length !== obj2.length) {\r\n      const longerArrayPath = obj1.length > obj2.length ? obj1 : obj2;\r\n      for (let i = commonLength; i < longerArrayPath.length; i++) {\r\n        differences.push(currentPath ? `${currentPath}.${i}` : `${i}`);\r\n      }\r\n    }\r\n    return differences;\r\n  }\r\n  // Handling objects\r\n  const keys1 = Object.keys(obj1);\r\n  const keys2 = Object.keys(obj2);\r\n  const allKeys = Array.from(new Set([...keys1, ...keys2]));\r\n\r\n  allKeys.forEach((key) => {\r\n    const newPath = currentPath ? `${currentPath}.${key}` : key;\r\n    differences = differences.concat(\r\n      getDifferences(obj1[key], obj2[key], newPath)\r\n    );\r\n  });\r\n  return differences;\r\n}\r\n\r\nexport function getDifferencesArray(obj1: any, obj2: any) {\r\n  const convertedDiff = getDifferences(obj1, obj2).map((string) =>\r\n    string\r\n      .replace(/\\[(\\w+)\\]/g, \".$1\")\r\n      .split(\".\")\r\n      .filter(Boolean)\r\n  );\r\n\r\n  return convertedDiff;\r\n}\r\nexport function getArrayLengthDifferences(\r\n  obj1: any,\r\n  obj2: any,\r\n  currentPath: string = \"\"\r\n): string[] {\r\n  let differences: string[] = [];\r\n\r\n  // Check for null or undefined in entire objects\r\n  if (\r\n    obj1 === null ||\r\n    obj1 === undefined ||\r\n    obj2 === null ||\r\n    obj2 === undefined\r\n  ) {\r\n    return differences;\r\n  }\r\n\r\n  // Check and compare only array lengths\r\n  if (Array.isArray(obj1) && Array.isArray(obj2)) {\r\n    if (obj1.length !== obj2.length) {\r\n      differences.push(currentPath);\r\n    }\r\n  } else if (typeof obj1 === \"object\" && typeof obj2 === \"object\") {\r\n    // Recursively check for nested arrays\r\n    const keys = new Set([...Object.keys(obj1), ...Object.keys(obj2)]);\r\n    for (const key of keys) {\r\n      const newPath = currentPath ? `${currentPath}.${key}` : key;\r\n\r\n      // Perform recursive checks only for array fields\r\n      if (Array.isArray(obj1[key]) || Array.isArray(obj2[key])) {\r\n        differences = differences.concat(\r\n          getArrayLengthDifferences(obj1[key], obj2[key], newPath)\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  return differences;\r\n}\r\n\r\nexport function getArrayLengthDifferencesArray(obj1: any, obj2: any) {\r\n  const convertedDiff = getArrayLengthDifferences(obj1, obj2).map((string) =>\r\n    string\r\n      .replace(/\\[(\\w+)\\]/g, \".$1\")\r\n      .split(\".\")\r\n      .filter(Boolean)\r\n  );\r\n\r\n  return convertedDiff;\r\n}\r\n\r\nexport function transformStateFunc<State extends unknown>(initialState: State) {\r\n  const isInitialStateType = (state: any): state is InitialStateType<State> => {\r\n    return Object.values(state).some((value) =>\r\n      value?.hasOwnProperty(\"initialState\")\r\n    );\r\n  };\r\n  let initalOptions: GenericObject = {};\r\n  const transformInitialState = (\r\n    state: InitialStateType<State>\r\n  ): GenericObject | GenericObject[] => {\r\n    const transformedState: GenericObject | GenericObject[] = {};\r\n    Object.entries(state).forEach(([key, value]) => {\r\n      if (value?.initialState) {\r\n        initalOptions = { ...(initalOptions ?? {}), [key]: value };\r\n\r\n        transformedState[key] = value.initialState;\r\n      } else {\r\n        transformedState[key] = value;\r\n      }\r\n    });\r\n\r\n    return transformedState;\r\n  };\r\n\r\n  const transformedInitialState = isInitialStateType(initialState)\r\n    ? (transformInitialState(initialState) as State)\r\n    : (initialState as State);\r\n\r\n  return [transformedInitialState, initalOptions] as [\r\n    TransformedStateType<State>,\r\n    GenericObject,\r\n  ];\r\n}\r\n\r\nexport function debounce<F extends (...args: any[]) => any>(\r\n  func: (...args: any[]) => any,\r\n  wait: number\r\n): F & { cancel: () => void } {\r\n  let timeoutID: NodeJS.Timeout | null = null;\r\n\r\n  const debounced: any = (...args: Parameters<F>) => {\r\n    if (timeoutID) {\r\n      clearTimeout(timeoutID);\r\n    }\r\n\r\n    timeoutID = setTimeout(() => func(...args), wait);\r\n  };\r\n\r\n  debounced.cancel = () => {\r\n    if (timeoutID) {\r\n      clearTimeout(timeoutID);\r\n      timeoutID = null;\r\n    }\r\n  };\r\n\r\n  return debounced as DebouncedFunction<F>;\r\n}\r\nexport type DebouncedFunction<F extends (...args: any[]) => any> = F & {\r\n  cancel: () => void;\r\n};\r\n"],"names":["isObject","item","isFunction","arg","isArray","isDeepEqual","object1","object2","opts","currentPath","objKeys1","objKeys2","key","value1","value2","newPath","i","updateNestedProperty","path","state","update","head","tail","index","deleteNestedProperty","_","rest","getNestedValue","obj","pathArray","value","targetId","updateNestedPropertyIds","newValue","newState","current","lastKey","getDifferences","obj1","obj2","differences","commonLength","longerArrayPath","keys1","keys2","getDifferencesArray","string","getArrayLengthDifferences","keys","getArrayLengthDifferencesArray","transformStateFunc","initialState","isInitialStateType","initalOptions","transformInitialState","transformedState","debounce","func","wait","timeoutID","debounced","args"],"mappings":"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"}