{"version":3,"file":"utility.js","sources":["../src/utility.ts"],"sourcesContent":["import type { InitialStateType, TransformedStateType } from './CogsState';\r\nimport { getGlobalStore } from './store';\r\nexport const isObject = (item: any): item is Record<string, any> => {\r\n  return (\r\n    item && typeof item === 'object' && !Array.isArray(item) && item !== null\r\n  );\r\n};\r\nexport type GenericObject = Record<string, any>;\r\n\r\nexport const isFunction = <TStateObject extends unknown>(\r\n  arg: any\r\n): arg is (prev: TStateObject) => TStateObject => typeof arg === 'function';\r\n\r\nexport const isArray = (item: any): item is Array<any> => {\r\n  return Array.isArray(item);\r\n};\r\nexport const isDeepEqual = (\r\n  object1?: Record<string, any>,\r\n  object2?: Record<string, any>,\r\n  opts: { get?: () => void } = {},\r\n  currentPath: string[] = []\r\n): boolean => {\r\n  if (isObject(object1) && isObject(object2)) {\r\n    const objKeys1 = Object.keys(object1);\r\n    const objKeys2 = Object.keys(object2);\r\n\r\n    if (objKeys1.length !== objKeys2.length) {\r\n      //     console.log(\"not equal\", objKeys1, objKeys2);\r\n      return false;\r\n    }\r\n\r\n    for (let key of objKeys1) {\r\n      const value1 = object1[key];\r\n      const value2 = object2[key];\r\n\r\n      // Check if the key exists in both objects\r\n      if (!(key in object1) || !(key in object2)) {\r\n        //     console.log(\"not equal\", key);\r\n        return false;\r\n      }\r\n\r\n      const newPath = [...currentPath, key];\r\n\r\n      // If current path is in ignoreArray, continue to the next key\r\n\r\n      if (!isDeepEqual(value1, value2, opts, newPath)) {\r\n        //   console.log(\"not equal\", value1, value2);\r\n        return false;\r\n      }\r\n    }\r\n    return true;\r\n  } else if (isArray(object1) && isArray(object2)) {\r\n    if (object1.length !== object2.length) {\r\n      //  console.log(\"not equal\", object1);\r\n      return false;\r\n    }\r\n\r\n    for (let i = 0; i < object1.length; i++) {\r\n      if (\r\n        !isDeepEqual(object1[i], object2[i], opts, [\r\n          ...currentPath,\r\n          i.toString(),\r\n        ])\r\n      ) {\r\n        //    console.log(\"not equal\", object1[i]);\r\n        return false;\r\n      }\r\n    }\r\n    return true;\r\n  } else {\r\n    return (\r\n      object1 === object2 || (Number.isNaN(object1) && Number.isNaN(object2))\r\n    );\r\n  }\r\n};\r\n\r\nexport function updateNestedProperty(\r\n  path: string[],\r\n  state: any,\r\n  update: any\r\n): any {\r\n  if (!path || path.length === 0) return update;\r\n  const head = path[0];\r\n  const tail = path.slice(1);\r\n\r\n  if (Array.isArray(state)) {\r\n    const index = Number(head);\r\n\r\n    if (!isNaN(index) && index >= 0 && index < state.length) {\r\n      return [\r\n        ...state.slice(0, index),\r\n        updateNestedProperty(tail, state[index], update),\r\n        ...state.slice(index + 1),\r\n      ];\r\n    } else {\r\n      console.log('errorstate', state, path);\r\n      throw new Error(\r\n        `Invalid array index \"${index}\" in path \"${path.join('.')}\".`\r\n      );\r\n    }\r\n  } else if (typeof state === 'object' && state !== null) {\r\n    if (head && head in state) {\r\n      return {\r\n        ...state,\r\n        [head!]: updateNestedProperty(tail, state[head!], update),\r\n      };\r\n    } else {\r\n      console.log(`Invalid property`, head, tail, path);\r\n      throw new Error(\r\n        `Invalid property \"${head}\" in path \"${path.join('.')}\".`\r\n      );\r\n    }\r\n  } else {\r\n    throw new Error(\r\n      `Cannot update nested property at path \"${path.join('.')}\". The path does not exist.`\r\n    );\r\n  }\r\n}\r\n\r\nexport function deleteNestedProperty(path: string[], state: any): any {\r\n  if (!path || path.length === 0) return state;\r\n  const head = path[0] as string;\r\n  const tail = path.slice(1);\r\n\r\n  if (Array.isArray(state)) {\r\n    const index = Number(head);\r\n\r\n    if (!isNaN(index) && index >= 0 && index < state.length) {\r\n      if (tail.length === 0) {\r\n        // Remove the item at the index\r\n        return [...state.slice(0, index), ...state.slice(index + 1)];\r\n      } else {\r\n        return [\r\n          ...state.slice(0, index),\r\n          deleteNestedProperty(tail, state[index]),\r\n          ...state.slice(index + 1),\r\n        ];\r\n      }\r\n    } else {\r\n      throw new Error(\r\n        `Invalid array index \"${index}\" in path \"${path.join('.')}\".`\r\n      );\r\n    }\r\n  } else if (typeof state === 'object' && state !== null) {\r\n    if (tail.length === 0) {\r\n      // Delete the property and return the new object\r\n      const { [head]: _, ...rest } = state;\r\n      return rest;\r\n    } else if (head in state) {\r\n      return {\r\n        ...state,\r\n        [head]: deleteNestedProperty(tail, state[head]),\r\n      };\r\n    } else {\r\n      throw new Error(\r\n        `Invalid property \"${head}\" in path \"${path.join('.')}\".`\r\n      );\r\n    }\r\n  } else {\r\n    throw new Error(\r\n      `Cannot delete nested property at path \"${path.join('.')}\". The path does not exist.`\r\n    );\r\n  }\r\n}\r\nexport function getNestedValue<TStateObject extends unknown>(\r\n  obj: TStateObject,\r\n  pathArray: string[],\r\n  stateKey: string // <-- ADD THIS ARGUMENT\r\n) {\r\n  let value: any = obj;\r\n\r\n  for (let i = 0; i < pathArray.length; i++) {\r\n    const key = pathArray[i]!;\r\n    if (value === undefined || value === null) {\r\n      return undefined;\r\n    }\r\n\r\n    if (typeof key === 'string' && key.startsWith('id:')) {\r\n      if (!Array.isArray(value)) {\r\n        console.error(\"Path segment with 'id:' requires an array.\", {\r\n          path: pathArray,\r\n          currentValue: value,\r\n        });\r\n        return undefined;\r\n      }\r\n\r\n      // --- START OF THE SURGICAL FIX ---\r\n\r\n      // 1. Construct the FULL path of the item we are looking for.\r\n      const parentPath = pathArray.slice(0, i);\r\n      const fullItemPathToFind = [stateKey, ...parentPath, key].join('.');\r\n\r\n      // 2. Get the metadata for the PARENT array.\r\n      const parentShadowKey = [stateKey, ...parentPath].join('.');\r\n      const parentShadowMeta = getGlobalStore\r\n        .getState()\r\n        .shadowStateStore.get(parentShadowKey);\r\n\r\n      if (!parentShadowMeta?.arrayKeys) {\r\n        console.error(\r\n          'No arrayKeys found in shadow state for parent path:',\r\n          parentShadowKey\r\n        );\r\n        return undefined;\r\n      }\r\n\r\n      // 3. Find the INDEX of the full item path in the parent's arrayKeys.\r\n      const itemIndex = parentShadowMeta.arrayKeys.indexOf(fullItemPathToFind);\r\n\r\n      if (itemIndex === -1) {\r\n        console.error(\r\n          `Item key ${fullItemPathToFind} not found in parent's arrayKeys:`,\r\n          parentShadowMeta.arrayKeys\r\n        );\r\n        return undefined;\r\n      }\r\n\r\n      // 4. Use that index to get the item from the plain JS array.\r\n      value = value[itemIndex];\r\n\r\n      // --- END OF THE SURGICAL FIX ---\r\n    } else if (Array.isArray(value)) {\r\n      value = value[parseInt(key)];\r\n    } else {\r\n      value = value[key];\r\n    }\r\n  }\r\n  return value;\r\n}\r\n\r\ntype DifferencePaths = string[];\r\n\r\nexport function getDifferences(\r\n  obj1: any,\r\n  obj2: any,\r\n  currentPath: string = ''\r\n): DifferencePaths {\r\n  let differences: DifferencePaths = [];\r\n  // Handling null and undefined cases\r\n  if (typeof obj1 === 'function' && typeof obj2 === 'function') {\r\n    return differences;\r\n  }\r\n  if (\r\n    obj1 === null ||\r\n    obj1 === undefined ||\r\n    obj2 === null ||\r\n    obj2 === undefined\r\n  ) {\r\n    if (obj1 !== obj2) {\r\n      //     console.log(obj1, obj2);\r\n      return [currentPath];\r\n    }\r\n    return differences;\r\n  }\r\n\r\n  // Handling primitive types\r\n  if (typeof obj1 !== 'object' || typeof obj2 !== 'object') {\r\n    if (obj1 !== obj2) {\r\n      return [currentPath];\r\n    }\r\n    return differences;\r\n  }\r\n\r\n  // Handling arrays\r\n  if (Array.isArray(obj1) && Array.isArray(obj2)) {\r\n    // Handle changes in length directly\r\n    if (obj1.length !== obj2.length) {\r\n      differences.push(`${currentPath}`);\r\n    }\r\n\r\n    // Use the shorter length for comparison to detect shifts or changes\r\n    const commonLength = Math.min(obj1.length, obj2.length);\r\n    for (let i = 0; i < commonLength; i++) {\r\n      if (obj1[i] !== obj2[i]) {\r\n        differences = differences.concat(\r\n          getDifferences(\r\n            obj1[i],\r\n            obj2[i],\r\n            currentPath ? `${currentPath}.${i}` : `${i}`\r\n          )\r\n        );\r\n      }\r\n    }\r\n\r\n    // If an array is shorter post-cut, the remaining items in the longer array are implicitly shifted/deleted\r\n    if (obj1.length !== obj2.length) {\r\n      const longerArrayPath = obj1.length > obj2.length ? obj1 : obj2;\r\n      for (let i = commonLength; i < longerArrayPath.length; i++) {\r\n        differences.push(currentPath ? `${currentPath}.${i}` : `${i}`);\r\n      }\r\n    }\r\n    return differences;\r\n  }\r\n  // Handling objects\r\n  const keys1 = Object.keys(obj1);\r\n  const keys2 = Object.keys(obj2);\r\n  const allKeys = Array.from(new Set([...keys1, ...keys2]));\r\n\r\n  allKeys.forEach((key) => {\r\n    const newPath = currentPath ? `${currentPath}.${key}` : key;\r\n    differences = differences.concat(\r\n      getDifferences(obj1[key], obj2[key], newPath)\r\n    );\r\n  });\r\n  return differences;\r\n}\r\nexport function deepMerge(target: any, source: any): any {\r\n  const output = { ...target };\r\n  if (isObject(target) && isObject(source)) {\r\n    Object.keys(source).forEach((key) => {\r\n      if (isObject(source[key])) {\r\n        if (!(key in target)) {\r\n          Object.assign(output, { [key]: source[key] });\r\n        } else {\r\n          output[key] = deepMerge(target[key], source[key]);\r\n        }\r\n      } else {\r\n        Object.assign(output, { [key]: source[key] });\r\n      }\r\n    });\r\n  }\r\n  return output;\r\n}\r\n\r\nexport function getDifferencesArray(obj1: any, obj2: any) {\r\n  const convertedDiff = getDifferences(obj1, obj2).map((string) =>\r\n    string\r\n      .replace(/\\[(\\w+)\\]/g, '.$1')\r\n      .split('.')\r\n      .filter(Boolean)\r\n  );\r\n\r\n  return convertedDiff;\r\n}\r\nexport function getArrayLengthDifferences(\r\n  obj1: any,\r\n  obj2: any,\r\n  currentPath: string = ''\r\n): string[] {\r\n  let differences: string[] = [];\r\n\r\n  // Check for null or undefined in entire objects\r\n  if (\r\n    obj1 === null ||\r\n    obj1 === undefined ||\r\n    obj2 === null ||\r\n    obj2 === undefined\r\n  ) {\r\n    return differences;\r\n  }\r\n\r\n  // Check and compare only array lengths\r\n  if (Array.isArray(obj1) && Array.isArray(obj2)) {\r\n    if (obj1.length !== obj2.length) {\r\n      differences.push(currentPath);\r\n    }\r\n  } else if (typeof obj1 === 'object' && typeof obj2 === 'object') {\r\n    // Recursively check for nested arrays\r\n    const keys = new Set([...Object.keys(obj1), ...Object.keys(obj2)]);\r\n    for (const key of keys) {\r\n      const newPath = currentPath ? `${currentPath}.${key}` : key;\r\n\r\n      // Perform recursive checks only for array fields\r\n      if (Array.isArray(obj1[key]) || Array.isArray(obj2[key])) {\r\n        differences = differences.concat(\r\n          getArrayLengthDifferences(obj1[key], obj2[key], newPath)\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  return differences;\r\n}\r\n\r\nexport function getArrayLengthDifferencesArray(obj1: any, obj2: any) {\r\n  const convertedDiff = getArrayLengthDifferences(obj1, obj2).map((string) =>\r\n    string\r\n      .replace(/\\[(\\w+)\\]/g, '.$1')\r\n      .split('.')\r\n      .filter(Boolean)\r\n  );\r\n\r\n  return convertedDiff;\r\n}\r\n\r\nexport function transformStateFunc<State extends unknown>(initialState: State) {\r\n  const isInitialStateType = (state: any): state is InitialStateType<State> => {\r\n    return Object.values(state).some((value) =>\r\n      value?.hasOwnProperty('initialState')\r\n    );\r\n  };\r\n  let initalOptions: GenericObject = {};\r\n  const transformInitialState = (\r\n    state: InitialStateType<State>\r\n  ): GenericObject | GenericObject[] => {\r\n    const transformedState: GenericObject | GenericObject[] = {};\r\n    Object.entries(state).forEach(([key, value]) => {\r\n      if (value?.initialState) {\r\n        initalOptions = { ...(initalOptions ?? {}), [key]: value };\r\n\r\n        transformedState[key] = value.initialState;\r\n      } else {\r\n        transformedState[key] = value;\r\n      }\r\n    });\r\n\r\n    return transformedState;\r\n  };\r\n\r\n  const transformedInitialState = isInitialStateType(initialState)\r\n    ? (transformInitialState(initialState) as State)\r\n    : (initialState as State);\r\n\r\n  return [transformedInitialState, initalOptions] as [\r\n    TransformedStateType<State>,\r\n    GenericObject,\r\n  ];\r\n}\r\n\r\nexport function debounce<F extends (...args: any[]) => any>(\r\n  func: (...args: any[]) => any,\r\n  wait: number\r\n): F & { cancel: () => void } {\r\n  let timeoutID: NodeJS.Timeout | null = null;\r\n\r\n  const debounced: any = (...args: Parameters<F>) => {\r\n    if (timeoutID) {\r\n      clearTimeout(timeoutID);\r\n    }\r\n\r\n    timeoutID = setTimeout(() => func(...args), wait);\r\n  };\r\n\r\n  debounced.cancel = () => {\r\n    if (timeoutID) {\r\n      clearTimeout(timeoutID);\r\n      timeoutID = null;\r\n    }\r\n  };\r\n\r\n  return debounced as DebouncedFunction<F>;\r\n}\r\nexport type DebouncedFunction<F extends (...args: any[]) => any> = F & {\r\n  cancel: () => void;\r\n};\r\n"],"names":["isObject","item","isFunction","arg","isArray","isDeepEqual","object1","object2","opts","currentPath","objKeys1","objKeys2","key","value1","value2","newPath","updateNestedProperty","path","state","update","head","tail","index","deleteNestedProperty","_","rest","getNestedValue","obj","pathArray","stateKey","value","parentPath","fullItemPathToFind","parentShadowKey","parentShadowMeta","getGlobalStore","itemIndex","getDifferences","obj1","obj2","differences","commonLength","i","longerArrayPath","keys1","keys2","deepMerge","target","source","output","getDifferencesArray","string","getArrayLengthDifferences","keys","getArrayLengthDifferencesArray","transformStateFunc","initialState","isInitialStateType","initalOptions","transformInitialState","transformedState","debounce","func","wait","timeoutID","debounced","args"],"mappings":"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"}