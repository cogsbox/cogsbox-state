{"version":3,"file":"utility.js","sources":["../src/utility.ts"],"sourcesContent":["import type { InitialStateType, TransformedStateType } from \"./CogsState\";\r\nexport const isObject = (item: any): item is Record<string, any> => {\r\n    return (\r\n        item &&\r\n        typeof item === \"object\" &&\r\n        !Array.isArray(item) &&\r\n        item !== null\r\n    );\r\n};\r\nexport type GenericObject = Record<string, any>;\r\nexport const isFunction = <TStateObject extends unknown>(\r\n    arg: any,\r\n): arg is (prev: TStateObject) => TStateObject => typeof arg === \"function\";\r\nexport const isArray = (item: any): item is Array<any> => {\r\n    return Array.isArray(item);\r\n};\r\nexport const isDeepEqual = (\r\n    object1?: Record<string, any>,\r\n    object2?: Record<string, any>,\r\n    opts: { get?: () => void } = {},\r\n    currentPath: string[] = [],\r\n): boolean => {\r\n    if (isObject(object1) && isObject(object2)) {\r\n        const objKeys1 = Object.keys(object1);\r\n        const objKeys2 = Object.keys(object2);\r\n\r\n        if (objKeys1.length !== objKeys2.length) {\r\n            //     console.log(\"not equal\", objKeys1, objKeys2);\r\n            return false;\r\n        }\r\n\r\n        for (let key of objKeys1) {\r\n            const value1 = object1[key];\r\n            const value2 = object2[key];\r\n\r\n            // Check if the key exists in both objects\r\n            if (!(key in object1) || !(key in object2)) {\r\n                //     console.log(\"not equal\", key);\r\n                return false;\r\n            }\r\n\r\n            const newPath = [...currentPath, key];\r\n\r\n            // If current path is in ignoreArray, continue to the next key\r\n\r\n            if (!isDeepEqual(value1, value2, opts, newPath)) {\r\n                //   console.log(\"not equal\", value1, value2);\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    } else if (isArray(object1) && isArray(object2)) {\r\n        if (object1.length !== object2.length) {\r\n            //  console.log(\"not equal\", object1);\r\n            return false;\r\n        }\r\n\r\n        for (let i = 0; i < object1.length; i++) {\r\n            if (\r\n                !isDeepEqual(object1[i], object2[i], opts, [\r\n                    ...currentPath,\r\n                    i.toString(),\r\n                ])\r\n            ) {\r\n                //    console.log(\"not equal\", object1[i]);\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    } else {\r\n        return (\r\n            object1 === object2 ||\r\n            (Number.isNaN(object1) && Number.isNaN(object2))\r\n        );\r\n    }\r\n};\r\nexport function updateNestedProperty(\r\n    path: string[],\r\n    state: any,\r\n    update: any,\r\n): any {\r\n    if (!path || path.length === 0) return update;\r\n    const head = path[0];\r\n    const tail = path.slice(1);\r\n\r\n    if (Array.isArray(state)) {\r\n        const index = Number(head);\r\n\r\n        if (!isNaN(index) && index >= 0 && index < state.length) {\r\n            return [\r\n                ...state.slice(0, index),\r\n                updateNestedProperty(tail, state[index], update),\r\n                ...state.slice(index + 1),\r\n            ];\r\n        } else {\r\n            console.log(\"errorstate\", state, path);\r\n            throw new Error(\r\n                `Invalid array index \"${index}\" in path \"${path.join(\".\")}\".`,\r\n            );\r\n        }\r\n    } else if (typeof state === \"object\" && state !== null) {\r\n        if (head && head in state) {\r\n            return {\r\n                ...state,\r\n                [head!]: updateNestedProperty(tail, state[head!], update),\r\n            };\r\n        } else {\r\n            console.log(`Invalid property`, head, tail, path);\r\n            throw new Error(\r\n                `Invalid property \"${head}\" in path \"${path.join(\".\")}\".`,\r\n            );\r\n        }\r\n    } else {\r\n        throw new Error(\r\n            `Cannot update nested property at path \"${path.join(\".\")}\". The path does not exist.`,\r\n        );\r\n    }\r\n}\r\n\r\nexport function deleteNestedProperty(path: string[], state: any): any {\r\n    if (!path || path.length === 0) return state;\r\n    const head = path[0] as string;\r\n    const tail = path.slice(1);\r\n\r\n    if (Array.isArray(state)) {\r\n        const index = Number(head);\r\n\r\n        if (!isNaN(index) && index >= 0 && index < state.length) {\r\n            if (tail.length === 0) {\r\n                // Remove the item at the index\r\n                return [...state.slice(0, index), ...state.slice(index + 1)];\r\n            } else {\r\n                return [\r\n                    ...state.slice(0, index),\r\n                    deleteNestedProperty(tail, state[index]),\r\n                    ...state.slice(index + 1),\r\n                ];\r\n            }\r\n        } else {\r\n            throw new Error(\r\n                `Invalid array index \"${index}\" in path \"${path.join(\".\")}\".`,\r\n            );\r\n        }\r\n    } else if (typeof state === \"object\" && state !== null) {\r\n        if (tail.length === 0) {\r\n            // Delete the property and return the new object\r\n            const { [head]: _, ...rest } = state;\r\n            return rest;\r\n        } else if (head in state) {\r\n            return {\r\n                ...state,\r\n                [head]: deleteNestedProperty(tail, state[head]),\r\n            };\r\n        } else {\r\n            throw new Error(\r\n                `Invalid property \"${head}\" in path \"${path.join(\".\")}\".`,\r\n            );\r\n        }\r\n    } else {\r\n        throw new Error(\r\n            `Cannot delete nested property at path \"${path.join(\".\")}\". The path does not exist.`,\r\n        );\r\n    }\r\n}\r\n\r\nexport function getNestedValue<TStateObject extends unknown>(\r\n    obj: TStateObject,\r\n    pathArray: string[],\r\n) {\r\n    let value: any = obj;\r\n\r\n    for (let i = 0; i < pathArray.length; i++) {\r\n        const key = pathArray[i];\r\n        //  console.log(key, \"loooo\");\r\n        if (!key) {\r\n            throw new Error(\"Invalid path\");\r\n        }\r\n        if (Array.isArray(value)) {\r\n            value = value[parseInt(key)];\r\n        } else {\r\n            if (!value) {\r\n                //  console.log(key, value, pathArray);\r\n                return;\r\n            }\r\n\r\n            value = value[key];\r\n        }\r\n    }\r\n    return value;\r\n}\r\ntype DifferencePaths = string[];\r\n\r\nexport function getDifferences(\r\n    obj1: any,\r\n    obj2: any,\r\n    currentPath: string = \"\",\r\n): DifferencePaths {\r\n    let differences: DifferencePaths = [];\r\n    // Handling null and undefined cases\r\n    if (typeof obj1 === \"function\" && typeof obj2 === \"function\") {\r\n        return differences;\r\n    }\r\n    if (\r\n        obj1 === null ||\r\n        obj1 === undefined ||\r\n        obj2 === null ||\r\n        obj2 === undefined\r\n    ) {\r\n        if (obj1 !== obj2) {\r\n            //     console.log(obj1, obj2);\r\n            return [currentPath];\r\n        }\r\n        return differences;\r\n    }\r\n\r\n    // Handling primitive types\r\n    if (typeof obj1 !== \"object\" || typeof obj2 !== \"object\") {\r\n        if (obj1 !== obj2) {\r\n            return [currentPath];\r\n        }\r\n        return differences;\r\n    }\r\n\r\n    // Handling arrays\r\n    if (Array.isArray(obj1) && Array.isArray(obj2)) {\r\n        // Handle changes in length directly\r\n        if (obj1.length !== obj2.length) {\r\n            differences.push(`${currentPath}.length`);\r\n        }\r\n\r\n        // Use the shorter length for comparison to detect shifts or changes\r\n        const commonLength = Math.min(obj1.length, obj2.length);\r\n        for (let i = 0; i < commonLength; i++) {\r\n            if (obj1[i] !== obj2[i]) {\r\n                differences = differences.concat(\r\n                    getDifferences(obj1[i], obj2[i], `${currentPath}[${i}]`),\r\n                );\r\n            }\r\n        }\r\n\r\n        // If an array is shorter post-cut, the remaining items in the longer array are implicitly shifted/deleted\r\n        if (obj1.length !== obj2.length) {\r\n            const longerArrayPath = obj1.length > obj2.length ? obj1 : obj2;\r\n            for (let i = commonLength; i < longerArrayPath.length; i++) {\r\n                differences.push(`${currentPath}[${i}]`);\r\n            }\r\n        }\r\n        return differences;\r\n    }\r\n    // Handling objects\r\n    const keys1 = Object.keys(obj1);\r\n    const keys2 = Object.keys(obj2);\r\n    const allKeys = Array.from(new Set([...keys1, ...keys2]));\r\n\r\n    allKeys.forEach((key) => {\r\n        const newPath = currentPath ? `${currentPath}.${key}` : key;\r\n        differences = differences.concat(\r\n            getDifferences(obj1[key], obj2[key], newPath),\r\n        );\r\n    });\r\n    return differences;\r\n}\r\n\r\nexport function getDifferencesArray(obj1: any, obj2: any) {\r\n    const convertedDiff = getDifferences(obj1, obj2).map((string) =>\r\n        string\r\n            .replace(/\\[(\\w+)\\]/g, \".$1\")\r\n            .split(\".\")\r\n            .filter(Boolean),\r\n    );\r\n\r\n    return convertedDiff;\r\n}\r\nexport function getArrayLengthDifferences(\r\n    obj1: any,\r\n    obj2: any,\r\n    currentPath: string = \"\",\r\n): string[] {\r\n    let differences: string[] = [];\r\n\r\n    // Check for null or undefined in entire objects\r\n    if (\r\n        obj1 === null ||\r\n        obj1 === undefined ||\r\n        obj2 === null ||\r\n        obj2 === undefined\r\n    ) {\r\n        return differences;\r\n    }\r\n\r\n    // Check and compare only array lengths\r\n    if (Array.isArray(obj1) && Array.isArray(obj2)) {\r\n        if (obj1.length !== obj2.length) {\r\n            differences.push(currentPath);\r\n        }\r\n    } else if (typeof obj1 === \"object\" && typeof obj2 === \"object\") {\r\n        // Recursively check for nested arrays\r\n        const keys = new Set([...Object.keys(obj1), ...Object.keys(obj2)]);\r\n        for (const key of keys) {\r\n            const newPath = currentPath ? `${currentPath}.${key}` : key;\r\n\r\n            // Perform recursive checks only for array fields\r\n            if (Array.isArray(obj1[key]) || Array.isArray(obj2[key])) {\r\n                differences = differences.concat(\r\n                    getArrayLengthDifferences(obj1[key], obj2[key], newPath),\r\n                );\r\n            }\r\n        }\r\n    }\r\n\r\n    return differences;\r\n}\r\n\r\nexport function getArrayLengthDifferencesArray(obj1: any, obj2: any) {\r\n    const convertedDiff = getArrayLengthDifferences(obj1, obj2).map((string) =>\r\n        string\r\n            .replace(/\\[(\\w+)\\]/g, \".$1\")\r\n            .split(\".\")\r\n            .filter(Boolean),\r\n    );\r\n\r\n    return convertedDiff;\r\n}\r\n// export function determineUpdateType(prevState: any, newState: any): UpdateTypeDetail[] {\r\n//     console.time(\"determineUpdateType\");\r\n//     const updateDetails: UpdateTypeDetail[] = [];\r\n\r\n//     function checkForUpdates(prev: any, next: any, path: string[] = []) {\r\n//         if (Array.isArray(prev) && Array.isArray(next)) {\r\n//             if (prev.length !== next.length) {\r\n//                 updateDetails.push({\r\n//                     updateType: prev.length < next.length ? \"push\" : \"cut\",\r\n//                     path,\r\n//                     oldValue: prev,\r\n//                     newValue: next,\r\n//                 });\r\n//                 // If an array has changed size, no need to check deeper for this path\r\n//                 return;\r\n//             } else {\r\n//                 // Check for updates within the array\r\n//                 for (let i = 0; i < prev.length; i++) {\r\n//                     checkForUpdates(prev[i], next[i], path.concat(i.toString()));\r\n//                 }\r\n//             }\r\n//         } else if (typeof prev === \"object\" && typeof next === \"object\" && prev !== null && next !== null) {\r\n//             const keys = new Set([...Object.keys(prev), ...Object.keys(next)]);\r\n//             for (let key of keys) {\r\n//                 checkForUpdates(prev[key], next[key], path.concat(key));\r\n//             }\r\n//         } else if (prev !== next) {\r\n//             updateDetails.push({\r\n//                 updateType: \"updated\",\r\n//                 path,\r\n//                 oldValue: prev,\r\n//                 newValue: next,\r\n//             });\r\n//         }\r\n//     }\r\n\r\n//     checkForUpdates(prevState, newState);\r\n//     console.timeEnd(\"determineUpdateType\");\r\n//     console.log(\"updateDetails\", updateDetails);\r\n//     return updateDetails;\r\n// }\r\n\r\nexport function transformStateFunc<State extends unknown>(initialState: State) {\r\n    const isInitialStateType = (\r\n        state: any,\r\n    ): state is InitialStateType<State> => {\r\n        return Object.values(state).some((value) =>\r\n            value?.hasOwnProperty(\"initialState\"),\r\n        );\r\n    };\r\n    let initalOptions: GenericObject = {};\r\n    const transformInitialState = (\r\n        state: InitialStateType<State>,\r\n    ): GenericObject | GenericObject[] => {\r\n        const transformedState: GenericObject | GenericObject[] = {};\r\n        Object.entries(state).forEach(([key, value]) => {\r\n            if (value?.initialState) {\r\n                initalOptions = { ...(initalOptions ?? {}), [key]: value };\r\n\r\n                transformedState[key] = { ...value.initialState };\r\n            } else {\r\n                transformedState[key] = value;\r\n            }\r\n        });\r\n\r\n        return transformedState;\r\n    };\r\n\r\n    const transformedInitialState = isInitialStateType(initialState)\r\n        ? (transformInitialState(initialState) as State)\r\n        : (initialState as State);\r\n\r\n    return [transformedInitialState, initalOptions] as [\r\n        TransformedStateType<State>,\r\n        GenericObject,\r\n    ];\r\n}\r\n"],"names":["isObject","item","isFunction","arg","isArray","isDeepEqual","object1","object2","opts","currentPath","objKeys1","objKeys2","key","value1","value2","newPath","i","updateNestedProperty","path","state","update","head","tail","index","deleteNestedProperty","_","rest","getNestedValue","obj","pathArray","value","getDifferences","obj1","obj2","differences","commonLength","longerArrayPath","keys1","keys2","getDifferencesArray","string","getArrayLengthDifferences","keys","getArrayLengthDifferencesArray","transformStateFunc","initialState","isInitialStateType","initalOptions","transformInitialState","transformedState"],"mappings":"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"}