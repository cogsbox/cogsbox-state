{"version":3,"file":"plugins.js","sources":["../src/plugins.ts"],"sourcesContent":["import { UpdateTypeDetail, StateObject, PluginData } from './CogsState';\r\nimport { useState, useEffect } from 'react';\r\nimport { getGlobalStore } from './store';\r\ntype Prettify<T> = { [K in keyof T]: T[K] } & {};\r\n\r\n// Your refined, more explicit version.\r\nexport type KeyedTypes<TMap extends Record<string, any>> = {\r\n  __key: 'keyed';\r\n  map: { [K in keyof TMap]: TMap[K] };\r\n};\r\n\r\n/**\r\n * Base context available to all plugin methods.\r\n * Provides access to state and metadata storage at both root and path levels.\r\n */\r\ntype BaseContext<\r\n  TState,\r\n  TKey extends keyof TState,\r\n  TPluginMetaData,\r\n  TFieldMetaData,\r\n> = {\r\n  /** The key identifying which state this plugin is operating on */\r\n  stateKey: TKey;\r\n\r\n  /** The root-level state object with all Cogs state methods ($update, $get, etc.) */\r\n  cogsState: StateObject<TState[TKey]>;\r\n\r\n  /**\r\n   * Get plugin metadata stored at the root level (path: []).\r\n   * Use for plugin-wide state like sessionIds, feature flags, etc.\r\n   * @returns The plugin's root metadata or undefined if not set\r\n   */\r\n  getPluginMetaData: () => TPluginMetaData | undefined;\r\n\r\n  /**\r\n   * Set plugin metadata at the root level (path: []).\r\n   * Merges with existing metadata.\r\n   * @param data - Partial metadata to merge with existing root metadata\r\n   */\r\n  setPluginMetaData: (data: Partial<TPluginMetaData>) => void;\r\n\r\n  /**\r\n   * Remove all plugin metadata at the root level.\r\n   * Clears all root-level plugin state.\r\n   */\r\n  removePluginMetaData: () => void;\r\n\r\n  /**\r\n   * Get plugin metadata stored at a specific path.\r\n   * Use for field-specific state like validation errors, sync versions per path.\r\n   * @param path - The state path to get metadata from (e.g., ['users', '0', 'email'])\r\n   * @returns The metadata at that path or undefined if not set\r\n   */\r\n  getFieldMetaData: (path: string[]) => TFieldMetaData | undefined;\r\n\r\n  /**\r\n   * Set plugin metadata at a specific path.\r\n   * Merges with existing metadata at that path.\r\n   * @param path - The state path to store metadata at (e.g., ['users', '0', 'email'])\r\n   * @param data - Partial metadata to merge with existing metadata at path\r\n   */\r\n  setFieldMetaData: (path: string[], data: Partial<TFieldMetaData>) => void;\r\n\r\n  /**\r\n   * Remove plugin metadata at a specific path.\r\n   * Clears all metadata for this plugin at the specified path.\r\n   * @param path - The state path to remove metadata from\r\n   */\r\n  removeFieldMetaData: (path: string[]) => void;\r\n};\r\n\r\n/**\r\n * Parameters passed to the useHook method.\r\n * Called once when plugin is initialized to set up React hooks.\r\n */\r\nexport type UseHookParams<TState, TOptions, TPluginMetaData, TFieldMetaData> = {\r\n  [K in keyof TState]: BaseContext<\r\n    TState,\r\n    K,\r\n    TPluginMetaData,\r\n    TFieldMetaData\r\n  > & {\r\n    /**\r\n     * Plugin-specific options passed when registering the plugin.\r\n     * @example { syncEnabled: true, debounceMs: 500 }\r\n     */\r\n    options: TOptions;\r\n\r\n    /**\r\n     * The name identifier of this plugin.\r\n     * Useful for debugging or conditional logic.\r\n     */\r\n    pluginName: string;\r\n\r\n    /**\r\n     * True on the very first mount, false on all subsequent renders.\r\n     * Use to run initialization logic only once.\r\n     */\r\n    isInitialMount: boolean;\r\n  };\r\n}[keyof TState];\r\n\r\n/**\r\n * Parameters passed to the transformState method.\r\n * Called to transform/modify state based on plugin logic.\r\n */\r\nexport type TransformStateParams<\r\n  TState,\r\n  TOptions,\r\n  THookReturn,\r\n  TPluginMetaData,\r\n  TFieldMetaData,\r\n> = {\r\n  [K in keyof TState]: BaseContext<\r\n    TState,\r\n    K,\r\n    TPluginMetaData,\r\n    TFieldMetaData\r\n  > & {\r\n    /** Plugin-specific options */\r\n    options: TOptions;\r\n\r\n    /**\r\n     * Data returned from useHook if defined.\r\n     * Will be undefined if plugin has no useHook.\r\n     */\r\n    hookData?: THookReturn;\r\n\r\n    /**\r\n     * The state value before this transformation.\r\n     * Useful for computing deltas or conditional transforms.\r\n     */\r\n    previousState?: TState[K];\r\n\r\n    /**\r\n     * True on the first transform call, false on subsequent calls.\r\n     * Use to differentiate initial setup from updates.\r\n     */\r\n    isInitialTransform: boolean;\r\n  };\r\n}[keyof TState];\r\n\r\n/**\r\n * Parameters passed to the onUpdate method.\r\n * Called whenever state is updated through any mechanism.\r\n */\r\nexport type OnUpdateParams<\r\n  TState,\r\n  TOptions,\r\n  THookReturn,\r\n  TPluginMetaData,\r\n  TFieldMetaData,\r\n> = {\r\n  [K in keyof TState]: BaseContext<\r\n    TState,\r\n    K,\r\n    TPluginMetaData,\r\n    TFieldMetaData\r\n  > & {\r\n    /**\r\n     * The update operation details including type, path, and value.\r\n     * Contains all information about what changed.\r\n     */\r\n    update: UpdateTypeDetail;\r\n\r\n    /**\r\n     * The path that was updated (extracted from update.path for convenience).\r\n     * @example ['users', '0', 'name'] for updating a user's name\r\n     */\r\n    path?: string[];\r\n\r\n    /** Plugin-specific options */\r\n    options: TOptions;\r\n\r\n    /**\r\n     * Data returned from useHook if defined.\r\n     * Will be undefined if plugin has no useHook.\r\n     */\r\n    hookData?: THookReturn;\r\n\r\n    /**\r\n     * The value at this path before the update.\r\n     * Undefined if path didn't exist before.\r\n     */\r\n    previousValue?: any;\r\n\r\n    /**\r\n     * The value at this path after the update.\r\n     * The current value at the updated path.\r\n     */\r\n    nextValue?: any;\r\n\r\n    /**\r\n     * Where this update originated from.\r\n     * 'user' = user interaction, 'plugin' = plugin code, 'system' = framework\r\n     */\r\n    updateSource?: 'user' | 'plugin' | 'system';\r\n  };\r\n}[keyof TState];\r\n\r\n/**\r\n * Parameters passed to the onFormUpdate method.\r\n * Called for form-specific events (focus, blur, input).\r\n */\r\nexport type OnFormUpdateParams<\r\n  TState,\r\n  TOptions,\r\n  THookReturn,\r\n  TPluginMetaData,\r\n  TFieldMetaData,\r\n> = {\r\n  [K in keyof TState]: BaseContext<\r\n    TState,\r\n    K,\r\n    TPluginMetaData,\r\n    TFieldMetaData\r\n  > & {\r\n    /**\r\n     * Path to the form field that triggered this event.\r\n     * @example ['user', 'email'] for an email input field\r\n     */\r\n    path: string[];\r\n\r\n    /**\r\n     * The form event details.\r\n     * type: 'focus' | 'blur' | 'input' - the type of form event\r\n     * value: The current value of the form field (for input events)\r\n     */\r\n    event: {\r\n      /** Type of form interaction */\r\n      type: 'focus' | 'blur' | 'input';\r\n      /** Current field value (primarily for input events) */\r\n      value?: any;\r\n      /** Current field path (primarily for input events) */\r\n      path: string[];\r\n    };\r\n\r\n    /** Plugin-specific options */\r\n    options: TOptions;\r\n\r\n    /**\r\n     * Data returned from useHook if defined.\r\n     * Will be undefined if plugin has no useHook.\r\n     */\r\n    hookData?: THookReturn;\r\n\r\n    /**\r\n     * Additional field metadata like validation rules, field type, etc.\r\n     * Can be used to customize behavior per field.\r\n     */\r\n    fieldMetadata?: any;\r\n\r\n    /**\r\n     * Current state of the form.\r\n     * Useful for conditional logic based on form lifecycle.\r\n     */\r\n    formState?: 'pristine' | 'dirty' | 'submitting' | 'submitted';\r\n  };\r\n}[keyof TState];\r\n\r\n/**\r\n * Parameters passed to the formWrapper method.\r\n * Used to wrap form elements with additional UI/behavior.\r\n */\r\nexport type FormWrapperParams<\r\n  TState,\r\n  TOptions,\r\n  THookReturn,\r\n  TPluginMetaData,\r\n  TFieldMetaData,\r\n> = {\r\n  [K in keyof TState]: {\r\n    /**\r\n     * The form element to wrap (input, select, textarea, etc.).\r\n     * This is the actual React element that will be enhanced.\r\n     */\r\n    element: React.ReactNode;\r\n\r\n    /**\r\n     * Path to this specific form field.\r\n     * @example ['address', 'street'] for a street address input\r\n     */\r\n    path: string[];\r\n\r\n    /** The state key this form field belongs to */\r\n    stateKey: K;\r\n\r\n    /** Root-level state object with all Cogs methods */\r\n    cogsState: StateObject<TState[K]>;\r\n\r\n    /**\r\n     * Get plugin metadata stored at the root level (path: []).\r\n     * Use for plugin-wide state.\r\n     * @returns The plugin's root metadata or undefined\r\n     */\r\n    getPluginMetaData: () => TPluginMetaData | undefined;\r\n\r\n    /**\r\n     * Set plugin metadata at the root level (path: []).\r\n     * @param data - Partial metadata to merge with existing\r\n     */\r\n    setPluginMetaData: (data: Partial<TPluginMetaData>) => void;\r\n\r\n    /** Remove all plugin metadata at the root level */\r\n    removePluginMetaData: () => void;\r\n\r\n    /**\r\n     * Get plugin metadata for this specific field.\r\n     * @param path - The field path (must be explicitly provided)\r\n     * @returns The field metadata or undefined\r\n     */\r\n    getFieldMetaData: (path: string[]) => TFieldMetaData | undefined;\r\n\r\n    /**\r\n     * Set plugin metadata for this specific field.\r\n     * @param path - The field path (must be explicitly provided)\r\n     * @param data - Partial metadata to merge\r\n     */\r\n    setFieldMetaData: (path: string[], data: Partial<TFieldMetaData>) => void;\r\n\r\n    /**\r\n     * Remove plugin metadata for this specific field.\r\n     * @param path - The field path to clear\r\n     */\r\n    removeFieldMetaData: (path: string[]) => void;\r\n\r\n    /** Plugin-specific options */\r\n    options: TOptions;\r\n\r\n    /**\r\n     * Data returned from useHook if defined.\r\n     * Will be undefined if plugin has no useHook.\r\n     */\r\n    hookData?: THookReturn;\r\n\r\n    /**\r\n     * Type of form field (text, number, email, etc.).\r\n     * Can be used to apply type-specific wrapping logic.\r\n     */\r\n    fieldType?: string;\r\n\r\n    /**\r\n     * Depth of wrapper nesting for this field.\r\n     * Useful when multiple plugins wrap the same field.\r\n     */\r\n    wrapperDepth?: number;\r\n  };\r\n}[keyof TState];\r\n\r\n/**\r\n * Plugin type definition.\r\n * Represents a complete plugin with all its lifecycle methods.\r\n */\r\nexport type CogsPlugin<\r\n  TName extends string,\r\n  TState = any,\r\n  TOptions = any,\r\n  THookReturn = any,\r\n  TPluginMetaData = any,\r\n  TFieldMetaData = any,\r\n> = {\r\n  /** Unique identifier for this plugin */\r\n  name: TName;\r\n\r\n  /**\r\n   * Hook method for React integration.\r\n   * Called once on mount to set up hooks, subscriptions, etc.\r\n   */\r\n  useHook?: (\r\n    params: UseHookParams<TState, TOptions, TPluginMetaData, TFieldMetaData>\r\n  ) => THookReturn;\r\n\r\n  /**\r\n   * Transform state on initialization or when options change.\r\n   * Use for setting default values, initial sync, etc.\r\n   */\r\n  transformState?: (\r\n    params: TransformStateParams<\r\n      TState,\r\n      TOptions,\r\n      THookReturn,\r\n      TPluginMetaData,\r\n      TFieldMetaData\r\n    >\r\n  ) => void;\r\n\r\n  /**\r\n   * React to any state updates.\r\n   * Called after state changes for side effects, sync, logging, etc.\r\n   */\r\n  onUpdate?: (\r\n    params: OnUpdateParams<\r\n      TState,\r\n      TOptions,\r\n      THookReturn,\r\n      TPluginMetaData,\r\n      TFieldMetaData\r\n    >\r\n  ) => void;\r\n\r\n  /**\r\n   * Handle form-specific events.\r\n   * Called for focus, blur, and input events on form fields.\r\n   */\r\n  onFormUpdate?: (\r\n    params: OnFormUpdateParams<\r\n      TState,\r\n      TOptions,\r\n      THookReturn,\r\n      TPluginMetaData,\r\n      TFieldMetaData\r\n    >\r\n  ) => void;\r\n\r\n  /**\r\n   * Wrap form elements with additional UI.\r\n   * Returns enhanced element with validation messages, loading states, etc.\r\n   */\r\n  formWrapper?: (\r\n    params: FormWrapperParams<\r\n      TState,\r\n      TOptions,\r\n      THookReturn,\r\n      TPluginMetaData,\r\n      TFieldMetaData\r\n    >\r\n  ) => React.ReactNode;\r\n};\r\n\r\n/**\r\n * Extract plugin options type from a tuple of plugins.\r\n * Creates a mapped type of plugin names to their options.\r\n */\r\nexport type ExtractPluginOptions<\r\n  TPlugins extends readonly CogsPlugin<any, any, any>[],\r\n> = {\r\n  [P in TPlugins[number] as P['name']]?: P extends CogsPlugin<\r\n    any,\r\n    any,\r\n    infer O,\r\n    any\r\n  >\r\n    ? O\r\n    : never;\r\n};\r\n\r\nexport function createMetadataContext<TPluginMetaData, TFieldMetaData>(\r\n  stateKey: string,\r\n  pluginName: string\r\n) {\r\n  return {\r\n    // Root metadata functions\r\n    getPluginMetaData: (): TPluginMetaData | undefined =>\r\n      getGlobalStore\r\n        .getState()\r\n        .getPluginMetaDataMap(stateKey, [])\r\n        ?.get(pluginName) as TPluginMetaData | undefined,\r\n\r\n    setPluginMetaData: (data: Partial<TPluginMetaData>) =>\r\n      getGlobalStore\r\n        .getState()\r\n        .setPluginMetaData(stateKey, [], pluginName, data),\r\n\r\n    removePluginMetaData: () =>\r\n      getGlobalStore.getState().removePluginMetaData(stateKey, [], pluginName),\r\n\r\n    // Field metadata functions\r\n    getFieldMetaData: (path: string[]): TFieldMetaData | undefined =>\r\n      getGlobalStore\r\n        .getState()\r\n        .getPluginMetaDataMap(stateKey, path)\r\n        ?.get(pluginName) as TFieldMetaData | undefined,\r\n\r\n    setFieldMetaData: (path: string[], data: Partial<TFieldMetaData>) =>\r\n      getGlobalStore\r\n        .getState()\r\n        .setPluginMetaData(stateKey, path, pluginName, data),\r\n\r\n    removeFieldMetaData: (path: string[]) =>\r\n      getGlobalStore\r\n        .getState()\r\n        .removePluginMetaData(stateKey, path, pluginName),\r\n  };\r\n}\r\n\r\n/**\r\n * Create a plugin context factory for a specific state shape.\r\n * @param TState - The shape of your application state\r\n * @param TOptions - Common options type for all plugins\r\n * @param TPluginMetaData - Type for root-level plugin metadata\r\n * @param TFieldMetaData - Type for field-level plugin metadata\r\n */\r\nexport function createPluginContext<\r\n  TState extends Record<string, any>,\r\n  TOptions = unknown,\r\n  TPluginMetaData extends Record<string, any> = {},\r\n  TFieldMetaData extends Record<string, any> = {},\r\n>() {\r\n  /**\r\n   * Create a new plugin with the given name.\r\n   * Returns a fluent API for defining plugin behavior.\r\n   * @param name - Unique identifier for this plugin\r\n   */\r\n  function createPlugin<TName extends string>(name: TName) {\r\n    // Helper types for optional hook data\r\n    type HookArgs<THookReturn> = THookReturn extends never\r\n      ? []\r\n      : [hookData: THookReturn];\r\n\r\n    // Method type signatures\r\n    type TransformFn<THookReturn> = (\r\n      params: TransformStateParams<\r\n        TState,\r\n        TOptions,\r\n        THookReturn,\r\n        TPluginMetaData,\r\n        TFieldMetaData\r\n      >\r\n    ) => void;\r\n\r\n    type UpdateFn<THookReturn> = (\r\n      params: OnUpdateParams<\r\n        TState,\r\n        TOptions,\r\n        THookReturn,\r\n        TPluginMetaData,\r\n        TFieldMetaData\r\n      >\r\n    ) => void;\r\n\r\n    type FormUpdateFn<THookReturn> = (\r\n      params: OnFormUpdateParams<\r\n        TState,\r\n        TOptions,\r\n        THookReturn,\r\n        TPluginMetaData,\r\n        TFieldMetaData\r\n      >\r\n    ) => void;\r\n\r\n    type FormWrapperFn<THookReturn> = (\r\n      params: FormWrapperParams<\r\n        TState,\r\n        TOptions,\r\n        THookReturn,\r\n        TPluginMetaData,\r\n        TFieldMetaData\r\n      >\r\n    ) => React.ReactNode;\r\n\r\n    type Plugin<THookReturn> = Prettify<\r\n      CogsPlugin<\r\n        TName,\r\n        TState,\r\n        TOptions,\r\n        THookReturn,\r\n        TPluginMetaData,\r\n        TFieldMetaData\r\n      >\r\n    >;\r\n\r\n    // Runtime object factory\r\n    const createPluginObject = <THookReturn = never>(\r\n      hookFn?: (\r\n        params: UseHookParams<TState, TOptions, TPluginMetaData, TFieldMetaData>\r\n      ) => THookReturn,\r\n      transformFn?: TransformFn<THookReturn>,\r\n      updateHandler?: UpdateFn<THookReturn>,\r\n      formUpdateHandler?: FormUpdateFn<THookReturn>,\r\n      formWrapper?: FormWrapperFn<THookReturn>\r\n    ): Plugin<THookReturn> => {\r\n      return {\r\n        name,\r\n        useHook: hookFn as any,\r\n        transformState: transformFn as any,\r\n        onUpdate: updateHandler as any,\r\n        onFormUpdate: formUpdateHandler as any,\r\n        formWrapper: formWrapper as any,\r\n      };\r\n    };\r\n\r\n    // Fluent API return type with conditional methods\r\n    type BuildRet<\r\n      THookReturn,\r\n      HasTransform extends boolean,\r\n      HasUpdate extends boolean,\r\n      HasFormUpdate extends boolean,\r\n      HasWrapper extends boolean,\r\n    > = Plugin<THookReturn> &\r\n      (HasTransform extends true\r\n        ? {}\r\n        : {\r\n            /** Define state transformation logic */\r\n            transformState(\r\n              fn: TransformFn<THookReturn>\r\n            ): BuildRet<\r\n              THookReturn,\r\n              true,\r\n              HasUpdate,\r\n              HasFormUpdate,\r\n              HasWrapper\r\n            >;\r\n          }) &\r\n      (HasUpdate extends true\r\n        ? {}\r\n        : {\r\n            /** React to state updates */\r\n            onUpdate(\r\n              fn: UpdateFn<THookReturn>\r\n            ): BuildRet<\r\n              THookReturn,\r\n              HasTransform,\r\n              true,\r\n              HasFormUpdate,\r\n              HasWrapper\r\n            >;\r\n          }) &\r\n      (HasFormUpdate extends true\r\n        ? {}\r\n        : {\r\n            /** Handle form events */\r\n            onFormUpdate(\r\n              fn: FormUpdateFn<THookReturn>\r\n            ): BuildRet<THookReturn, HasTransform, HasUpdate, true, HasWrapper>;\r\n          }) &\r\n      (HasWrapper extends true\r\n        ? {}\r\n        : {\r\n            /** Wrap form elements */\r\n            formWrapper(\r\n              fn: FormWrapperFn<THookReturn>\r\n            ): BuildRet<\r\n              THookReturn,\r\n              HasTransform,\r\n              HasUpdate,\r\n              HasFormUpdate,\r\n              true\r\n            >;\r\n          });\r\n\r\n    // Builder function with type tracking\r\n    function createBuilder<\r\n      THookReturn = never,\r\n      HasTransform extends boolean = false,\r\n      HasUpdate extends boolean = false,\r\n      HasFormUpdate extends boolean = false,\r\n      HasWrapper extends boolean = false,\r\n    >(\r\n      hookFn?: (\r\n        params: UseHookParams<TState, TOptions, TPluginMetaData, TFieldMetaData>\r\n      ) => THookReturn,\r\n      transformFn?: TransformFn<THookReturn>,\r\n      updateHandler?: UpdateFn<THookReturn>,\r\n      formUpdateHandler?: FormUpdateFn<THookReturn>,\r\n      formWrapper?: FormWrapperFn<THookReturn>\r\n    ): BuildRet<\r\n      THookReturn,\r\n      HasTransform,\r\n      HasUpdate,\r\n      HasFormUpdate,\r\n      HasWrapper\r\n    > {\r\n      const plugin = createPluginObject<THookReturn>(\r\n        hookFn,\r\n        transformFn,\r\n        updateHandler,\r\n        formUpdateHandler,\r\n        formWrapper\r\n      );\r\n\r\n      // Attach only the remaining chain methods\r\n      const methods = {} as Partial<\r\n        BuildRet<\r\n          THookReturn,\r\n          HasTransform,\r\n          HasUpdate,\r\n          HasFormUpdate,\r\n          HasWrapper\r\n        >\r\n      >;\r\n\r\n      if (!transformFn) {\r\n        (methods as any).transformState = (fn: TransformFn<THookReturn>) =>\r\n          createBuilder<\r\n            THookReturn,\r\n            true,\r\n            HasUpdate,\r\n            HasFormUpdate,\r\n            HasWrapper\r\n          >(hookFn, fn, updateHandler, formUpdateHandler, formWrapper);\r\n      }\r\n\r\n      if (!updateHandler) {\r\n        (methods as any).onUpdate = (fn: UpdateFn<THookReturn>) =>\r\n          createBuilder<\r\n            THookReturn,\r\n            HasTransform,\r\n            true,\r\n            HasFormUpdate,\r\n            HasWrapper\r\n          >(hookFn, transformFn, fn, formUpdateHandler, formWrapper);\r\n      }\r\n\r\n      if (!formUpdateHandler) {\r\n        (methods as any).onFormUpdate = (fn: FormUpdateFn<THookReturn>) =>\r\n          createBuilder<THookReturn, HasTransform, HasUpdate, true, HasWrapper>(\r\n            hookFn,\r\n            transformFn,\r\n            updateHandler,\r\n            fn,\r\n            formWrapper\r\n          );\r\n      }\r\n\r\n      if (!formWrapper) {\r\n        (methods as any).formWrapper = (fn: FormWrapperFn<THookReturn>) =>\r\n          createBuilder<\r\n            THookReturn,\r\n            HasTransform,\r\n            HasUpdate,\r\n            HasFormUpdate,\r\n            true\r\n          >(hookFn, transformFn, updateHandler, formUpdateHandler, fn);\r\n      }\r\n\r\n      return Object.assign(plugin, methods) as BuildRet<\r\n        THookReturn,\r\n        HasTransform,\r\n        HasUpdate,\r\n        HasFormUpdate,\r\n        HasWrapper\r\n      >;\r\n    }\r\n\r\n    // Starting point with all methods available\r\n    const start = Object.assign(\r\n      createBuilder<never, false, false, false, false>(),\r\n      {\r\n        /**\r\n         * Define a React hook for this plugin.\r\n         * Sets up subscriptions, state, and returns data for other methods.\r\n         */\r\n        useHook<THookReturn>(\r\n          hookFn: (\r\n            params: UseHookParams<\r\n              TState,\r\n              TOptions,\r\n              TPluginMetaData,\r\n              TFieldMetaData\r\n            >\r\n          ) => THookReturn\r\n        ) {\r\n          return createBuilder<THookReturn, false, false, false, false>(hookFn);\r\n        },\r\n      }\r\n    ) as BuildRet<never, false, false, false, false> & {\r\n      useHook<THookReturn>(\r\n        hookFn: (\r\n          params: UseHookParams<\r\n            TState,\r\n            TOptions,\r\n            TPluginMetaData,\r\n            TFieldMetaData\r\n          >\r\n        ) => THookReturn\r\n      ): BuildRet<THookReturn, false, false, false, false>;\r\n    };\r\n\r\n    return start;\r\n  }\r\n\r\n  return { createPlugin };\r\n}\r\n\r\n// --- DEMO USAGE ---\r\n\r\ntype MyGlobalState = {\r\n  user: { test: string; email: string };\r\n  address: { city: string; country: string };\r\n};\r\n\r\ntype MyPluginMetaData = {\r\n  lastUpdated?: Date;\r\n  updateCount?: number;\r\n  sessionId?: string;\r\n  stateVersion?: string;\r\n};\r\n\r\ntype MyFieldMetaData = {\r\n  status?: 'VALID' | 'INVALID' | 'NOT_VALIDATED';\r\n  errors?: Array<{ message: string; severity: 'error' | 'warning' }>;\r\n  touched?: boolean;\r\n  syncVersion?: string;\r\n};\r\n\r\nconst { createPlugin } = createPluginContext<\r\n  MyGlobalState,\r\n  { id: string; syncEnabled?: boolean },\r\n  MyPluginMetaData,\r\n  MyFieldMetaData\r\n>();\r\n\r\n// Example: Analytics plugin with root metadata\r\nconst analyticsPlugin = createPlugin('analyticsPlugin').transformState(\r\n  ({ stateKey, cogsState, setPluginMetaData }) => {\r\n    if (stateKey === 'user') {\r\n      cogsState.$update({ test: 'This works!', email: 'test@example.com' });\r\n      setPluginMetaData({ lastUpdated: new Date() });\r\n    }\r\n  }\r\n);\r\n\r\n// // Example: Validation plugin with field metadata\r\n// const validationPlugin = createPlugin('validation')\r\n//   .onFormUpdate(({ path, event, setFieldMetaData, cogsState }) => {\r\n//     if (event.type === 'blur') {\r\n//       const value = cogsState.$get(path);\r\n\r\n//       if (path[path.length - 1] === 'email') {\r\n//         const isValid = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(value);\r\n//         // Store validation state at the specific field path\r\n//         setFieldMetaData(path, {\r\n//           status: isValid ? 'VALID' : 'INVALID',\r\n//           errors: isValid ? [] : [{ message: 'Invalid email format', severity: 'error' }],\r\n//           touched: true\r\n//         });\r\n//       }\r\n//     }\r\n//   })\r\n//   .formWrapper(({ element, path, getFieldMetaData }) => {\r\n//     // Get metadata for this specific field\r\n//     const fieldMeta = getFieldMetaData(path);\r\n\r\n//     return (\r\n//       <div className=\"field-wrapper\">\r\n//         {element}\r\n//         {fieldMeta?.status === 'INVALID' && fieldMeta?.touched && (\r\n//           <div className=\"error-message\">\r\n//             {fieldMeta.errors?.[0]?.message}\r\n//           </div>\r\n//         )}\r\n//       </div>\r\n//     );\r\n//   });\r\n\r\n// Example: Sync plugin with both root and field metadata\r\nconst syncPlugin = createPlugin('sync')\r\n  .useHook(({ setPluginMetaData, setFieldMetaData, cogsState }) => {\r\n    // Store session at root\r\n    const sessionId = 'session-123';\r\n    setPluginMetaData({ sessionId });\r\n\r\n    // Store sync versions at specific paths\r\n    setFieldMetaData(['user'], { syncVersion: 'v1.0' });\r\n    setFieldMetaData(['address'], { syncVersion: 'v1.1' });\r\n\r\n    return { sessionId };\r\n  })\r\n  .onUpdate(({ path, update, getFieldMetaData, setFieldMetaData }) => {\r\n    if (path) {\r\n      // Update sync version for the changed path\r\n      const currentVersion = getFieldMetaData(path)?.syncVersion || 'v0';\r\n      const newVersion = `v${parseInt(currentVersion.slice(1)) + 1}`;\r\n      setFieldMetaData(path, { syncVersion: newVersion });\r\n    }\r\n  });\r\n"],"names":["createMetadataContext","stateKey","pluginName","getGlobalStore","data","path","createPluginContext","createPlugin","name","createPluginObject","hookFn","transformFn","updateHandler","formUpdateHandler","formWrapper","createBuilder","plugin","methods","fn","cogsState","setPluginMetaData","setFieldMetaData","sessionId","update","getFieldMetaData","currentVersion","newVersion"],"mappings":"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"}