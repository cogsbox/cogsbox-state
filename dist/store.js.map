{"version":3,"file":"store.js","sources":["../src/store.ts"],"sourcesContent":["import { create } from 'zustand';\r\nimport { ulid } from 'ulid';\r\nimport type {\r\n  OptionsType,\r\n  ReactivityType,\r\n  StateKeys,\r\n  SyncInfo,\r\n  UpdateTypeDetail,\r\n} from './CogsState.js';\r\n\r\nimport type { ReactNode } from 'react';\r\n\r\ntype StateUpdater<StateValue> =\r\n  | StateValue\r\n  | ((prevValue: StateValue) => StateValue);\r\n\r\nexport type FreshValuesObject = {\r\n  pathsToValues?: string[];\r\n  prevValue?: any;\r\n  newValue?: any;\r\n  timeStamp: number;\r\n};\r\n\r\ntype SyncLogType = {\r\n  timeStamp: number;\r\n};\r\ntype StateValue = any;\r\n\r\nexport type TrieNode = {\r\n  subscribers: Set<string>;\r\n  children: Map<string, TrieNode>;\r\n};\r\n\r\nexport type FormRefStoreState = {\r\n  formRefs: Map<string, React.RefObject<any>>;\r\n  registerFormRef: (id: string, ref: React.RefObject<any>) => void;\r\n  getFormRef: (id: string) => React.RefObject<any> | undefined;\r\n  removeFormRef: (id: string) => void;\r\n  // New method to get all refs for a stateKey\r\n  getFormRefsByStateKey: (\r\n    stateKey: string\r\n  ) => Map<string, React.RefObject<any>>;\r\n};\r\n\r\nexport const formRefStore = create<FormRefStoreState>((set, get) => ({\r\n  formRefs: new Map(),\r\n\r\n  registerFormRef: (id, ref) =>\r\n    set((state) => {\r\n      const newRefs = new Map(state.formRefs);\r\n      newRefs.set(id, ref);\r\n      return { formRefs: newRefs };\r\n    }),\r\n\r\n  getFormRef: (id) => get().formRefs.get(id),\r\n\r\n  removeFormRef: (id) =>\r\n    set((state) => {\r\n      const newRefs = new Map(state.formRefs);\r\n      newRefs.delete(id);\r\n      return { formRefs: newRefs };\r\n    }),\r\n\r\n  // Get all refs that start with the stateKey prefix\r\n  getFormRefsByStateKey: (stateKey) => {\r\n    const allRefs = get().formRefs;\r\n    const stateKeyPrefix = stateKey + '.';\r\n    const filteredRefs = new Map();\r\n\r\n    allRefs.forEach((ref, id) => {\r\n      if (id.startsWith(stateKeyPrefix) || id === stateKey) {\r\n        filteredRefs.set(id, ref);\r\n      }\r\n    });\r\n\r\n    return filteredRefs;\r\n  },\r\n}));\r\nexport type ComponentsType = {\r\n  components?: Map<\r\n    string,\r\n    {\r\n      forceUpdate: () => void;\r\n      paths: Set<string>;\r\n      deps?: any[];\r\n      prevDeps?: any[];\r\n      depsFunction?: (state: any) => any[] | true;\r\n      reactiveType: ReactivityType[] | ReactivityType;\r\n    }\r\n  >;\r\n};\r\nexport type ShadowMetadata = {\r\n  id?: string;\r\n\r\n  stateSource?: 'default' | 'server' | 'localStorage';\r\n  lastServerSync?: number;\r\n  isDirty?: boolean;\r\n  baseServerState?: any;\r\n\r\n  arrayKeys?: string[];\r\n\r\n  fields?: Record<string, any>;\r\n  virtualizer?: {\r\n    itemHeight?: number;\r\n    domRef?: HTMLElement | null;\r\n  };\r\n  syncInfo?: { status: string };\r\n  lastUpdated?: number;\r\n  value?: any;\r\n  classSignals?: Array<{\r\n    // <-- ADD THIS BLOCK\r\n    id: string;\r\n    effect: string;\r\n    lastClasses: string;\r\n    deps: any[];\r\n  }>;\r\n  signals?: Array<{\r\n    instanceId: string;\r\n    parentId: string;\r\n    position: number;\r\n    effect?: string;\r\n  }>;\r\n  mapWrappers?: Array<{\r\n    instanceId: string;\r\n    path: string[];\r\n    componentId: string;\r\n    meta?: any;\r\n    mapFn: (\r\n      setter: any,\r\n      index: number,\r\n\r\n      arraySetter: any\r\n    ) => ReactNode;\r\n    containerRef: HTMLDivElement | null;\r\n    rebuildStateShape: any;\r\n  }>;\r\n  transformCaches?: Map<\r\n    string,\r\n    {\r\n      validIds: string[];\r\n      computedAt: number;\r\n      transforms: Array<{ type: 'filter' | 'sort'; fn: Function }>;\r\n    }\r\n  >;\r\n  pathComponents?: Set<string>;\r\n  streams?: Map<\r\n    string,\r\n    {\r\n      buffer: any[];\r\n      flushTimer: NodeJS.Timeout | null;\r\n    }\r\n  >;\r\n} & ComponentsType;\r\nexport type CogsEvent =\r\n  | { type: 'INSERT'; path: string; itemKey: string; index: number }\r\n  | { type: 'REMOVE'; path: string; itemKey: string }\r\n  | { type: 'UPDATE'; path: string; newValue: any }\r\n  | { type: 'ITEMHEIGHT'; itemKey: string; height: number } // For full re-initializations (e.g., when a component is removed)\r\n  | { type: 'RELOAD'; path: string }; // For full re-initializations\r\nexport type CogsGlobalState = {\r\n  // --- Shadow State and Subscription System ---\r\n  shadowStateStore: Map<string, ShadowMetadata>;\r\n  markAsDirty: (\r\n    key: string,\r\n    path: string[],\r\n    options: { bubble: boolean }\r\n  ) => void;\r\n  // These method signatures stay the same\r\n  initializeShadowState: (key: string, initialState: any) => void;\r\n  updateShadowAtPath: (key: string, path: string[], newValue: any) => void;\r\n  insertShadowArrayElement: (\r\n    key: string,\r\n    arrayPath: string[],\r\n    newItem: any\r\n  ) => void;\r\n  removeShadowArrayElement: (key: string, arrayPath: string[]) => void;\r\n  getShadowValue: (\r\n    key: string,\r\n\r\n    validArrayIds?: string[]\r\n  ) => any;\r\n\r\n  getShadowMetadata: (\r\n    key: string,\r\n    path: string[]\r\n  ) => ShadowMetadata | undefined;\r\n  setShadowMetadata: (\r\n    key: string,\r\n    path: string[],\r\n    metadata: Omit<ShadowMetadata, 'id'>\r\n  ) => void;\r\n  setTransformCache: (\r\n    key: string,\r\n    path: string[],\r\n    cacheKey: string,\r\n    cacheData: any\r\n  ) => void;\r\n\r\n  pathSubscribers: Map<string, Set<(newValue: any) => void>>;\r\n  subscribeToPath: (\r\n    path: string,\r\n    callback: (newValue: any) => void\r\n  ) => () => void;\r\n  notifyPathSubscribers: (updatedPath: string, newValue: any) => void;\r\n\r\n  selectedIndicesMap: Map<string, string>; // stateKey -> (parentPath -> selectedIndex)\r\n  getSelectedIndex: (stateKey: string, validArrayIds?: string[]) => number;\r\n  setSelectedIndex: (key: string, itemKey: string) => void;\r\n  clearSelectedIndex: ({ arrayKey }: { arrayKey: string }) => void;\r\n  clearSelectedIndexesForState: (stateKey: string) => void;\r\n\r\n  // --- Core State and Updaters ---\r\n\r\n  initialStateOptions: { [key: string]: OptionsType };\r\n\r\n  initialStateGlobal: { [key: string]: StateValue };\r\n\r\n  updateInitialStateGlobal: (key: string, newState: StateValue) => void;\r\n\r\n  getInitialOptions: (key: string) => OptionsType | undefined;\r\n  setInitialStateOptions: (key: string, value: OptionsType) => void;\r\n\r\n  // --- Validation ---\r\n  validationErrors: Map<string, string[]>;\r\n  addValidationError: (path: string, message: string) => void;\r\n  getValidationErrors: (path: string) => string[];\r\n  removeValidationError: (path: string) => void;\r\n\r\n  // --- Server Sync and Logging ---\r\n\r\n  serverStateUpdates: Map<\r\n    string,\r\n    {\r\n      data: any;\r\n      status: 'loading' | 'success' | 'error';\r\n      timestamp: number;\r\n    }\r\n  >;\r\n\r\n  setServerStateUpdate: (key: string, serverState: any) => void;\r\n\r\n  stateLog: { [key: string]: UpdateTypeDetail[] };\r\n  syncInfoStore: Map<string, SyncInfo>;\r\n\r\n  setStateLog: (\r\n    key: string,\r\n    updater: (prevUpdates: UpdateTypeDetail[]) => UpdateTypeDetail[]\r\n  ) => void;\r\n  setSyncInfo: (key: string, syncInfo: SyncInfo) => void;\r\n  getSyncInfo: (key: string) => SyncInfo | null;\r\n};\r\nconst isSimpleObject = (value: any): boolean => {\r\n  if (value === null || typeof value !== 'object') return false;\r\n\r\n  // Handle special cases that should be treated as primitives\r\n  if (\r\n    value instanceof Uint8Array ||\r\n    value instanceof Int8Array ||\r\n    value instanceof Uint16Array ||\r\n    value instanceof Int16Array ||\r\n    value instanceof Uint32Array ||\r\n    value instanceof Int32Array ||\r\n    value instanceof Float32Array ||\r\n    value instanceof Float64Array ||\r\n    value instanceof ArrayBuffer ||\r\n    value instanceof Date ||\r\n    value instanceof RegExp ||\r\n    value instanceof Map ||\r\n    value instanceof Set\r\n  ) {\r\n    return false; // Treat as primitive\r\n  }\r\n\r\n  // Arrays and plain objects are complex\r\n  return Array.isArray(value) || value.constructor === Object;\r\n};\r\nexport const getGlobalStore = create<CogsGlobalState>((set, get) => ({\r\n  markAsDirty: (key: string, path: string[], options = { bubble: true }) => {\r\n    const newShadowStore = new Map(get().shadowStateStore);\r\n    let changed = false;\r\n\r\n    const setDirty = (currentPath: string[]) => {\r\n      const fullKey = [key, ...currentPath].join('.');\r\n      const meta = newShadowStore.get(fullKey);\r\n\r\n      // We mark something as dirty if it isn't already.\r\n      // The original data source doesn't matter.\r\n      if (meta && meta.isDirty !== true) {\r\n        newShadowStore.set(fullKey, { ...meta, isDirty: true });\r\n        changed = true;\r\n      } else if (!meta) {\r\n        // If there's no metadata, create it and mark it as dirty.\r\n        // This handles newly created fields within an object.\r\n        newShadowStore.set(fullKey, { isDirty: true });\r\n        changed = true;\r\n      }\r\n    };\r\n\r\n    // 1. Mark the target path itself as dirty.\r\n    setDirty(path);\r\n\r\n    // 2. If `bubble` is true, walk up the path and mark all parents as dirty.\r\n    if (options.bubble) {\r\n      let parentPath = [...path];\r\n      while (parentPath.length > 0) {\r\n        parentPath.pop();\r\n        setDirty(parentPath);\r\n      }\r\n    }\r\n\r\n    if (changed) {\r\n      set({ shadowStateStore: newShadowStore });\r\n    }\r\n  },\r\n  serverStateUpdates: new Map(),\r\n  setServerStateUpdate: (key, serverState) => {\r\n    set((state) => {\r\n      const newMap = new Map(state.serverStateUpdates);\r\n      newMap.set(key, serverState);\r\n      return { serverStateUpdates: newMap };\r\n    });\r\n\r\n    // Notify all subscribers for this key\r\n    get().notifyPathSubscribers(key, {\r\n      type: 'SERVER_STATE_UPDATE',\r\n      serverState,\r\n    });\r\n  },\r\n  shadowStateStore: new Map(),\r\n  pathSubscribers: new Map<string, Set<(newValue: any) => void>>(),\r\n\r\n  subscribeToPath: (path, callback) => {\r\n    const subscribers = get().pathSubscribers;\r\n    const subsForPath = subscribers.get(path) || new Set();\r\n    subsForPath.add(callback);\r\n    subscribers.set(path, subsForPath);\r\n\r\n    return () => {\r\n      const currentSubs = get().pathSubscribers.get(path);\r\n      if (currentSubs) {\r\n        currentSubs.delete(callback);\r\n        if (currentSubs.size === 0) {\r\n          get().pathSubscribers.delete(path);\r\n        }\r\n      }\r\n    };\r\n  },\r\n\r\n  notifyPathSubscribers: (updatedPath, newValue) => {\r\n    // <-- Now accepts newValue\r\n    const subscribers = get().pathSubscribers;\r\n    const subs = subscribers.get(updatedPath);\r\n\r\n    if (subs) {\r\n      // Pass the newValue to every callback\r\n      subs.forEach((callback) => callback(newValue));\r\n    }\r\n  },\r\n  initializeShadowState: (key: string, initialState: any) => {\r\n    const existingShadowStore = new Map(get().shadowStateStore);\r\n\r\n    const processValue = (value: any, path: string[]) => {\r\n      const nodeKey = [key, ...path].join('.');\r\n\r\n      if (Array.isArray(value)) {\r\n        // Handle arrays as before\r\n        const childIds: string[] = [];\r\n\r\n        value.forEach((item) => {\r\n          const itemId = `id:${ulid()}`;\r\n          childIds.push(nodeKey + '.' + itemId);\r\n        });\r\n\r\n        existingShadowStore.set(nodeKey, { arrayKeys: childIds });\r\n\r\n        value.forEach((item, index) => {\r\n          const itemId = childIds[index]!.split('.').pop();\r\n          processValue(item, [...path!, itemId!]);\r\n        });\r\n      } else if (isSimpleObject(value)) {\r\n        // Only create field mappings for simple objects\r\n        const fields = Object.fromEntries(\r\n          Object.keys(value).map((k) => [k, nodeKey + '.' + k])\r\n        );\r\n        existingShadowStore.set(nodeKey, { fields });\r\n\r\n        Object.keys(value).forEach((k) => {\r\n          processValue(value[k], [...path, k]);\r\n        });\r\n      } else {\r\n        // Treat everything else (including Uint8Array) as primitive values\r\n        existingShadowStore.set(nodeKey, { value });\r\n      }\r\n    };\r\n\r\n    processValue(initialState, []);\r\n    set({ shadowStateStore: existingShadowStore });\r\n  },\r\n\r\n  getShadowValue: (fullKey: string, validArrayIds?: string[]) => {\r\n    const shadowMeta = get().shadowStateStore.get(fullKey);\r\n\r\n    // If no metadata found, return undefined\r\n    if (!shadowMeta) {\r\n      return undefined;\r\n    }\r\n\r\n    // For primitive values, return the value\r\n    if (shadowMeta.value !== undefined) {\r\n      return shadowMeta.value;\r\n    }\r\n\r\n    // For arrays, reconstruct with possible validArrayIds\r\n    if (shadowMeta.arrayKeys) {\r\n      const arrayKeys = validArrayIds ?? shadowMeta.arrayKeys;\r\n      const items = arrayKeys.map((itemKey) => {\r\n        // RECURSIVELY call getShadowValue for each item\r\n        return get().getShadowValue(itemKey);\r\n      });\r\n      return items;\r\n    }\r\n\r\n    // For objects with fields, reconstruct object\r\n    if (shadowMeta.fields) {\r\n      const reconstructedObject: any = {};\r\n      Object.entries(shadowMeta.fields).forEach(([key, fieldPath]) => {\r\n        // RECURSIVELY call getShadowValue for each field\r\n        reconstructedObject[key] = get().getShadowValue(fieldPath as string);\r\n      });\r\n      return reconstructedObject;\r\n    }\r\n\r\n    return undefined;\r\n  },\r\n  getShadowMetadata: (\r\n    key: string,\r\n    path: string[],\r\n    validArrayIds?: string[]\r\n  ) => {\r\n    const fullKey = [key, ...path].join('.');\r\n    let data = get().shadowStateStore.get(fullKey);\r\n\r\n    return get().shadowStateStore.get(fullKey);\r\n  },\r\n\r\n  setShadowMetadata: (key: string, path: string[], metadata: any) => {\r\n    const fullKey = [key, ...path].join('.');\r\n    const newShadowStore = new Map(get().shadowStateStore);\r\n    const existing = newShadowStore.get(fullKey) || { id: ulid() };\r\n    newShadowStore.set(fullKey, { ...existing, ...metadata });\r\n    set({ shadowStateStore: newShadowStore });\r\n  },\r\n  setTransformCache: (\r\n    key: string,\r\n    path: string[],\r\n    cacheKey: string,\r\n    cacheData: any\r\n  ) => {\r\n    const fullKey = [key, ...path].join('.');\r\n    const newShadowStore = new Map(get().shadowStateStore);\r\n    const existing = newShadowStore.get(fullKey) || {};\r\n\r\n    // Initialize transformCaches if it doesn't exist\r\n    if (!existing.transformCaches) {\r\n      existing.transformCaches = new Map();\r\n    }\r\n\r\n    // Update just the specific cache entry\r\n    existing.transformCaches.set(cacheKey, cacheData);\r\n\r\n    // Update shadow store WITHOUT notifying path subscribers\r\n    newShadowStore.set(fullKey, existing);\r\n    set({ shadowStateStore: newShadowStore });\r\n\r\n    // Don't call notifyPathSubscribers here - cache updates shouldn't trigger renders\r\n  },\r\n  insertShadowArrayElement: (\r\n    key: string,\r\n    arrayPath: string[],\r\n    newItem: any\r\n  ) => {\r\n    const newShadowStore = new Map(get().shadowStateStore);\r\n    const arrayKey = [key, ...arrayPath].join('.');\r\n    const parentMeta = newShadowStore.get(arrayKey);\r\n\r\n    if (!parentMeta || !parentMeta.arrayKeys) return;\r\n\r\n    const newItemId = `id:${ulid()}`;\r\n    const fullItemKey = arrayKey + '.' + newItemId;\r\n\r\n    // Just add to the end (or at a specific index if provided)\r\n    const newArrayKeys = [...parentMeta.arrayKeys];\r\n    newArrayKeys.push(fullItemKey); // Or use splice if you have an index\r\n    newShadowStore.set(arrayKey, { ...parentMeta, arrayKeys: newArrayKeys });\r\n\r\n    // Process the new item - but use the correct logic\r\n    const processNewItem = (value: any, path: string[]) => {\r\n      const nodeKey = [key, ...path].join('.');\r\n\r\n      if (Array.isArray(value)) {\r\n        // Handle arrays...\r\n      } else if (typeof value === 'object' && value !== null) {\r\n        // Create fields mapping\r\n        const fields = Object.fromEntries(\r\n          Object.keys(value).map((k) => [k, nodeKey + '.' + k])\r\n        );\r\n        newShadowStore.set(nodeKey, { fields });\r\n\r\n        // Process each field\r\n        Object.entries(value).forEach(([k, v]) => {\r\n          processNewItem(v, [...path, k]);\r\n        });\r\n      } else {\r\n        // Primitive value\r\n        newShadowStore.set(nodeKey, { value });\r\n      }\r\n    };\r\n\r\n    processNewItem(newItem, [...arrayPath, newItemId]);\r\n    set({ shadowStateStore: newShadowStore });\r\n\r\n    get().notifyPathSubscribers(arrayKey, {\r\n      type: 'INSERT',\r\n      path: arrayKey,\r\n      itemKey: fullItemKey,\r\n    });\r\n  },\r\n  removeShadowArrayElement: (key: string, itemPath: string[]) => {\r\n    const newShadowStore = new Map(get().shadowStateStore);\r\n\r\n    // Get the full item key (e.g., \"stateKey.products.id:xxx\")\r\n    const itemKey = [key, ...itemPath].join('.');\r\n\r\n    // Extract parent path and item ID\r\n    const parentPath = itemPath.slice(0, -1);\r\n    const parentKey = [key, ...parentPath].join('.');\r\n\r\n    // Get parent metadata\r\n    const parentMeta = newShadowStore.get(parentKey);\r\n\r\n    if (parentMeta && parentMeta.arrayKeys) {\r\n      // Find the index of the item to remove\r\n      const indexToRemove = parentMeta.arrayKeys.findIndex(\r\n        (arrayItemKey) => arrayItemKey === itemKey\r\n      );\r\n\r\n      if (indexToRemove !== -1) {\r\n        // Create new array keys with the item removed\r\n        const newArrayKeys = parentMeta.arrayKeys.filter(\r\n          (arrayItemKey) => arrayItemKey !== itemKey\r\n        );\r\n\r\n        // Update parent with new array keys\r\n        newShadowStore.set(parentKey, {\r\n          ...parentMeta,\r\n          arrayKeys: newArrayKeys,\r\n        });\r\n\r\n        // Delete all data associated with the removed item\r\n        const prefixToDelete = itemKey + '.';\r\n        for (const k of Array.from(newShadowStore.keys())) {\r\n          if (k === itemKey || k.startsWith(prefixToDelete)) {\r\n            newShadowStore.delete(k);\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    set({ shadowStateStore: newShadowStore });\r\n\r\n    get().notifyPathSubscribers(parentKey, {\r\n      type: 'REMOVE',\r\n      path: parentKey,\r\n      itemKey: itemKey, // The exact ID of the removed item\r\n    });\r\n  },\r\n  updateShadowAtPath: (key, path, newValue) => {\r\n    const newShadowStore = new Map(get().shadowStateStore);\r\n    const fullKey = [key, ...path].join('.');\r\n\r\n    const updateValue = (currentKey: string, valueToSet: any) => {\r\n      const meta = newShadowStore.get(currentKey);\r\n\r\n      // If it's a simple object with fields, update recursively\r\n      if (isSimpleObject(valueToSet) && meta && meta.fields) {\r\n        for (const fieldKey in valueToSet) {\r\n          if (Object.prototype.hasOwnProperty.call(valueToSet, fieldKey)) {\r\n            const childPath = meta.fields[fieldKey];\r\n            const childValue = valueToSet[fieldKey];\r\n\r\n            if (childPath) {\r\n              updateValue(childPath as string, childValue);\r\n            }\r\n          }\r\n        }\r\n      } else {\r\n        // For primitives (including Uint8Array), just replace the value\r\n        // This gives you useState-like behavior\r\n        const existing = newShadowStore.get(currentKey) || {};\r\n        newShadowStore.set(currentKey, { ...existing, value: valueToSet });\r\n      }\r\n    };\r\n\r\n    updateValue(fullKey, newValue);\r\n    get().notifyPathSubscribers(fullKey, { type: 'UPDATE', newValue });\r\n    set({ shadowStateStore: newShadowStore });\r\n  },\r\n  selectedIndicesMap: new Map<string, string>(),\r\n  getSelectedIndex: (arrayKey: string, validIds?: string[]): number => {\r\n    const itemKey = get().selectedIndicesMap.get(arrayKey);\r\n\r\n    if (!itemKey) return -1;\r\n\r\n    // Use validIds if provided (for filtered views), otherwise use all arrayKeys\r\n    const arrayKeys =\r\n      validIds ||\r\n      getGlobalStore.getState().getShadowMetadata(arrayKey, [])?.arrayKeys;\r\n\r\n    if (!arrayKeys) return -1;\r\n\r\n    return arrayKeys.indexOf(itemKey);\r\n  },\r\n\r\n  setSelectedIndex: (arrayKey: string, itemKey: string | undefined) => {\r\n    set((state) => {\r\n      const newMap = state.selectedIndicesMap;\r\n\r\n      if (itemKey === undefined) {\r\n        newMap.delete(arrayKey);\r\n      } else {\r\n        if (newMap.has(arrayKey)) {\r\n          get().notifyPathSubscribers(newMap.get(arrayKey)!, {\r\n            type: 'THIS_UNSELECTED',\r\n          });\r\n        }\r\n        newMap.set(arrayKey, itemKey);\r\n\r\n        get().notifyPathSubscribers(itemKey, {\r\n          type: 'THIS_SELECTED',\r\n        });\r\n      }\r\n      get().notifyPathSubscribers(arrayKey, {\r\n        type: 'GET_SELECTED',\r\n      });\r\n      return {\r\n        ...state,\r\n        selectedIndicesMap: newMap,\r\n      };\r\n    });\r\n  },\r\n  clearSelectedIndex: ({ arrayKey }: { arrayKey: string }): void => {\r\n    set((state) => {\r\n      const newMap = state.selectedIndicesMap;\r\n\r\n      newMap.delete(arrayKey);\r\n      get().notifyPathSubscribers(arrayKey, {\r\n        type: 'CLEAR_SELECTION',\r\n      });\r\n      return {\r\n        ...state,\r\n        selectedIndicesMap: newMap,\r\n      };\r\n    });\r\n  },\r\n  clearSelectedIndexesForState: (stateKey: string) => {\r\n    set((state) => {\r\n      const newOuterMap = new Map(state.selectedIndicesMap);\r\n      const changed = newOuterMap.delete(stateKey);\r\n      if (changed) {\r\n        return { selectedIndicesMap: newOuterMap };\r\n      } else {\r\n        return {};\r\n      }\r\n    });\r\n  },\r\n\r\n  initialStateOptions: {},\r\n\r\n  stateTimeline: {},\r\n  cogsStateStore: {},\r\n  stateLog: {},\r\n\r\n  initialStateGlobal: {},\r\n\r\n  validationErrors: new Map(),\r\n\r\n  setStateLog: (\r\n    key: string,\r\n    updater: (prevUpdates: UpdateTypeDetail[]) => UpdateTypeDetail[]\r\n  ) => {\r\n    set((prev) => {\r\n      const currentUpdates = prev.stateLog[key] ?? [];\r\n      const newUpdates = updater(currentUpdates);\r\n      return {\r\n        stateLog: {\r\n          ...prev.stateLog,\r\n          [key]: newUpdates,\r\n        },\r\n      };\r\n    });\r\n  },\r\n\r\n  addValidationError: (path, message) => {\r\n    set((prev) => {\r\n      const updatedErrors = new Map(prev.validationErrors);\r\n      const existingMessages = updatedErrors.get(path) || [];\r\n      console.log('addValidationError', path, message, existingMessages);\r\n      // Append the new message instead of replacing\r\n      updatedErrors.set(path, [...existingMessages, message]);\r\n      return { validationErrors: updatedErrors };\r\n    });\r\n  },\r\n  removeValidationError: (path) => {\r\n    set((prev) => {\r\n      const updatedErrors = new Map(prev.validationErrors);\r\n\r\n      let doSomething = false;\r\n      const pathArray = path.split('.');\r\n      Array.from(updatedErrors.keys()).forEach((key) => {\r\n        const keyArray = key.split('.');\r\n        if (keyArray.length >= pathArray.length) {\r\n          let match = true;\r\n          for (let i = 0; i < pathArray.length; i++) {\r\n            if (keyArray[i] !== pathArray[i]) {\r\n              match = false;\r\n              break;\r\n            }\r\n          }\r\n\r\n          if (match) {\r\n            doSomething = true;\r\n            updatedErrors.delete(key);\r\n          }\r\n        }\r\n      });\r\n\r\n      return doSomething ? { validationErrors: updatedErrors } : prev;\r\n    });\r\n  },\r\n  getValidationErrors: (path: string) => {\r\n    const errors: string[] = [];\r\n    const valErrors = get().validationErrors;\r\n    const pathArray = path.split('.');\r\n\r\n    // Helper to check if an index matches either a wildcard or is in an array of indices\r\n    const isIndexMatch = (pathSegment: string, keySegment: string) => {\r\n      if (pathSegment === '[*]') return true;\r\n      if (Array.isArray(pathSegment)) {\r\n        return pathSegment.includes(parseInt(keySegment));\r\n      }\r\n      return pathSegment === keySegment;\r\n    };\r\n\r\n    Array.from(valErrors.keys()).forEach((key) => {\r\n      const keyArray = key.split('.');\r\n      if (keyArray.length >= pathArray.length) {\r\n        let match = true;\r\n        for (let i = 0; i < pathArray.length; i++) {\r\n          const pathSegment = pathArray[i];\r\n          const keySegment = keyArray[i]!;\r\n\r\n          // If current path segment is a number or [*], we need special handling\r\n          if (pathSegment === '[*]' || Array.isArray(pathSegment)) {\r\n            // Key segment should be a number if we're using [*] or array indices\r\n            const keyIndex = parseInt(keySegment);\r\n            if (isNaN(keyIndex)) {\r\n              match = false;\r\n              break;\r\n            }\r\n\r\n            if (!isIndexMatch(pathSegment, keySegment)) {\r\n              match = false;\r\n              break;\r\n            }\r\n          } else if (pathSegment !== keySegment) {\r\n            match = false;\r\n            break;\r\n          }\r\n        }\r\n\r\n        if (match) {\r\n          const errorMessages = valErrors.get(key);\r\n          if (errorMessages) {\r\n            errors.push(...errorMessages);\r\n          }\r\n        }\r\n      }\r\n    });\r\n\r\n    return errors;\r\n  },\r\n  getInitialOptions: (key) => {\r\n    return get().initialStateOptions[key];\r\n  },\r\n\r\n  setInitialStateOptions: (key, value) => {\r\n    set((prev) => ({\r\n      initialStateOptions: {\r\n        ...prev.initialStateOptions,\r\n        [key]: value,\r\n      },\r\n    }));\r\n  },\r\n  updateInitialStateGlobal: (key, newState) => {\r\n    set((prev) => ({\r\n      initialStateGlobal: {\r\n        ...prev.initialStateGlobal,\r\n        [key]: newState,\r\n      },\r\n    }));\r\n  },\r\n\r\n  syncInfoStore: new Map<string, SyncInfo>(),\r\n  setSyncInfo: (key: string, syncInfo: SyncInfo) =>\r\n    set((state) => {\r\n      const newMap = new Map(state.syncInfoStore);\r\n      newMap.set(key, syncInfo);\r\n      return { ...state, syncInfoStore: newMap };\r\n    }),\r\n  getSyncInfo: (key: string) => get().syncInfoStore.get(key) || null,\r\n}));\r\n"],"names":["formRefStore","create","set","get","id","ref","state","newRefs","stateKey","allRefs","stateKeyPrefix","filteredRefs","isSimpleObject","value","getGlobalStore","key","path","options","newShadowStore","changed","setDirty","currentPath","fullKey","meta","parentPath","serverState","newMap","callback","subscribers","subsForPath","currentSubs","updatedPath","newValue","subs","initialState","existingShadowStore","processValue","nodeKey","childIds","item","itemId","ulid","index","fields","k","validArrayIds","shadowMeta","itemKey","reconstructedObject","fieldPath","metadata","existing","cacheKey","cacheData","arrayPath","newItem","arrayKey","parentMeta","newItemId","fullItemKey","newArrayKeys","processNewItem","v","itemPath","parentKey","arrayItemKey","prefixToDelete","updateValue","currentKey","valueToSet","fieldKey","childPath","childValue","validIds","arrayKeys","newOuterMap","updater","prev","currentUpdates","newUpdates","message","updatedErrors","existingMessages","doSomething","pathArray","keyArray","match","i","errors","valErrors","isIndexMatch","pathSegment","keySegment","keyIndex","errorMessages","newState","syncInfo"],"mappings":"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"}