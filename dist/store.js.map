{"version":3,"file":"store.js","sources":["../src/store.ts"],"sourcesContent":["import { create } from 'zustand';\r\n\r\nimport type {\r\n  OptionsType,\r\n  ReactivityType,\r\n  SyncInfo,\r\n  UpdateTypeDetail,\r\n} from './CogsState.js';\r\n\r\nimport { type ReactNode } from 'react';\r\n\r\nexport type FreshValuesObject = {\r\n  pathsToValues?: string[];\r\n  prevValue?: any;\r\n  newValue?: any;\r\n  timeStamp: number;\r\n};\r\n\r\ntype StateValue = any;\r\n\r\nexport type TrieNode = {\r\n  subscribers: Set<string>;\r\n  children: Map<string, TrieNode>;\r\n};\r\n\r\nexport type FormRefStoreState = {\r\n  formRefs: Map<string, React.RefObject<any>>;\r\n  registerFormRef: (id: string, ref: React.RefObject<any>) => void;\r\n  getFormRef: (id: string) => React.RefObject<any> | undefined;\r\n  removeFormRef: (id: string) => void;\r\n  getFormRefsByStateKey: (\r\n    stateKey: string\r\n  ) => Map<string, React.RefObject<any>>;\r\n};\r\n\r\nexport const formRefStore = create<FormRefStoreState>((set, get) => ({\r\n  formRefs: new Map(),\r\n\r\n  registerFormRef: (id, ref) =>\r\n    set((state) => {\r\n      const newRefs = new Map(state.formRefs);\r\n      newRefs.set(id, ref);\r\n      return { formRefs: newRefs };\r\n    }),\r\n\r\n  getFormRef: (id) => get().formRefs.get(id),\r\n\r\n  removeFormRef: (id) =>\r\n    set((state) => {\r\n      const newRefs = new Map(state.formRefs);\r\n      newRefs.delete(id);\r\n      return { formRefs: newRefs };\r\n    }),\r\n\r\n  getFormRefsByStateKey: (stateKey) => {\r\n    const allRefs = get().formRefs;\r\n    const stateKeyPrefix = stateKey + '.';\r\n    const filteredRefs = new Map();\r\n\r\n    allRefs.forEach((ref, id) => {\r\n      if (id.startsWith(stateKeyPrefix) || id === stateKey) {\r\n        filteredRefs.set(id, ref);\r\n      }\r\n    });\r\n\r\n    return filteredRefs;\r\n  },\r\n}));\r\nexport type ComponentsType = {\r\n  components?: Map<\r\n    string,\r\n    {\r\n      forceUpdate: () => void;\r\n      paths: Set<string>;\r\n      deps?: any[];\r\n      prevDeps?: any[];\r\n      depsFunction?: (state: any) => any[] | true;\r\n      reactiveType: ReactivityType[] | ReactivityType;\r\n    }\r\n  >;\r\n};\r\n\r\nexport type ValidationStatus =\r\n  | 'NOT_VALIDATED'\r\n  | 'VALIDATING'\r\n  | 'VALID'\r\n  | 'INVALID';\r\nexport type ValidationSeverity = 'warning' | 'error' | undefined;\r\nexport type ValidationError = {\r\n  source: 'client' | 'sync_engine' | 'api';\r\n  message: string;\r\n  severity: ValidationSeverity;\r\n  code?: string;\r\n};\r\n\r\nexport type ValidationState = {\r\n  status: ValidationStatus;\r\n  errors: ValidationError[];\r\n  lastValidated?: number;\r\n  validatedValue?: any;\r\n};\r\nexport type TypeInfo = {\r\n  type:\r\n    | 'string'\r\n    | 'number'\r\n    | 'boolean'\r\n    | 'array'\r\n    | 'object'\r\n    | 'date'\r\n    | 'unknown';\r\n  schema: any; // Store the actual Zod schema object\r\n  source: 'sync' | 'zod4' | 'zod3' | 'runtime' | 'default';\r\n  default: any;\r\n  nullable?: boolean;\r\n  optional?: boolean;\r\n};\r\n\r\n// Update ShadowMetadata to include typeInfo\r\nexport type ShadowMetadata = {\r\n  value?: any;\r\n  syncArrayIdPrefix?: string;\r\n  id?: string;\r\n  typeInfo?: TypeInfo;\r\n  stateSource?: 'default' | 'server' | 'localStorage';\r\n  lastServerSync?: number;\r\n  isDirty?: boolean;\r\n  baseServerState?: any;\r\n  arrayKeys?: string[];\r\n  fields?: Record<string, any>;\r\n  virtualizer?: {\r\n    itemHeight?: number;\r\n    domRef?: HTMLElement | null;\r\n  };\r\n  syncInfo?: { status: string };\r\n  validation?: ValidationState;\r\n  features?: {\r\n    syncEnabled: boolean;\r\n    validationEnabled: boolean;\r\n    localStorageEnabled: boolean;\r\n  };\r\n  signals?: Array<{\r\n    instanceId: string;\r\n    parentId: string;\r\n    position: number;\r\n    effect?: string;\r\n  }>;\r\n\r\n  transformCaches?: Map<\r\n    string,\r\n    {\r\n      validIds: string[];\r\n      computedAt: number;\r\n      transforms: Array<{ type: 'filter' | 'sort'; fn: Function }>;\r\n    }\r\n  >;\r\n  pathComponents?: Set<string>;\r\n  streams?: Map<\r\n    string,\r\n    {\r\n      buffer: any[];\r\n      flushTimer: NodeJS.Timeout | null;\r\n    }\r\n  >;\r\n} & ComponentsType;\r\n\r\ntype ShadowNode = {\r\n  _meta?: ShadowMetadata;\r\n  [key: string]: any;\r\n};\r\n\r\nexport type CogsGlobalState = {\r\n  setTransformCache: (\r\n    key: string,\r\n    path: string[],\r\n    cacheKey: string,\r\n    cacheData: any\r\n  ) => void;\r\n  initializeShadowState: (key: string, initialState: any) => void;\r\n  getShadowNode: (key: string, path: string[]) => ShadowNode | undefined;\r\n  getShadowMetadata: (\r\n    key: string,\r\n    path: string[]\r\n  ) => ShadowMetadata | undefined;\r\n\r\n  setShadowMetadata: (key: string, path: string[], metadata: any) => void;\r\n  getShadowValue: (\r\n    key: string,\r\n    path: string[],\r\n    validArrayIds?: string[],\r\n    log?: boolean\r\n  ) => any;\r\n  updateShadowAtPath: (key: string, path: string[], newValue: any) => void;\r\n  insertManyShadowArrayElements: (\r\n    key: string,\r\n    arrayPath: string[],\r\n    newItems: any[],\r\n    index?: number\r\n  ) => void;\r\n  addItemsToArrayNode: (\r\n    key: string,\r\n    arrayPath: string[],\r\n    newItems: any,\r\n    newKeys: string[]\r\n  ) => void;\r\n  insertShadowArrayElement: (\r\n    key: string,\r\n    arrayPath: string[],\r\n    newItem: any,\r\n    index?: number\r\n  ) => string;\r\n  removeShadowArrayElement: (key: string, itemPath: string[]) => void;\r\n  registerComponent: (\r\n    stateKey: string,\r\n    componentId: string,\r\n    registration: any\r\n  ) => void;\r\n  unregisterComponent: (stateKey: string, componentId: string) => void;\r\n  addPathComponent: (\r\n    stateKey: string,\r\n    dependencyPath: string[],\r\n    fullComponentId: string\r\n  ) => void;\r\n  markAsDirty: (\r\n    key: string,\r\n    path: string[],\r\n    options: { bubble: boolean }\r\n  ) => void;\r\n\r\n  pathSubscribers: Map<string, Set<(newValue: any) => void>>;\r\n  subscribeToPath: (\r\n    path: string,\r\n    callback: (newValue: any) => void\r\n  ) => () => void;\r\n  notifyPathSubscribers: (updatedPath: string, newValue: any) => void;\r\n\r\n  selectedIndicesMap: Map<string, string>; // stateKey -> (parentPath -> selectedIndex)\r\n  getSelectedIndex: (stateKey: string, validArrayIds?: string[]) => number;\r\n  setSelectedIndex: (key: string, itemKey: string) => void;\r\n  clearSelectedIndex: ({ arrayKey }: { arrayKey: string }) => void;\r\n  clearSelectedIndexesForState: (stateKey: string) => void;\r\n\r\n  initialStateOptions: { [key: string]: OptionsType };\r\n  initialStateGlobal: { [key: string]: StateValue };\r\n  updateInitialStateGlobal: (key: string, newState: StateValue) => void;\r\n\r\n  getInitialOptions: (key: string) => OptionsType | undefined;\r\n  setInitialStateOptions: (key: string, value: OptionsType) => void;\r\n\r\n  serverStateUpdates: Map<\r\n    string,\r\n    {\r\n      data: any;\r\n      status: 'loading' | 'success' | 'error';\r\n      timestamp: number;\r\n    }\r\n  >;\r\n\r\n  setServerStateUpdate: (key: string, serverState: any) => void;\r\n\r\n  stateLog: Map<string, Map<string, UpdateTypeDetail>>;\r\n  syncInfoStore: Map<string, SyncInfo>;\r\n  addStateLog: (updates: UpdateTypeDetail[]) => void;\r\n\r\n  setSyncInfo: (key: string, syncInfo: SyncInfo) => void;\r\n  getSyncInfo: (key: string) => SyncInfo | null;\r\n};\r\n\r\nfunction getTypeFromZodSchema(\r\n  schema: any,\r\n  source: 'zod4' | 'zod3' | 'sync' = 'zod4'\r\n): TypeInfo | null {\r\n  if (!schema) return null;\r\n\r\n  let baseSchema = schema;\r\n  let isNullable = false;\r\n  let isOptional = false;\r\n  let defaultValue: any = undefined;\r\n  let hasDefault = false;\r\n\r\n  // Zod v4 unwrapping\r\n  if (schema._def) {\r\n    let current = schema;\r\n\r\n    // Keep unwrapping until we get to the base type\r\n    while (current._def) {\r\n      const typeName = current._def.typeName;\r\n\r\n      if (typeName === 'ZodOptional') {\r\n        isOptional = true;\r\n        current = current._def.innerType || current.unwrap();\r\n      } else if (typeName === 'ZodNullable') {\r\n        isNullable = true;\r\n        current = current._def.innerType || current.unwrap();\r\n      } else if (typeName === 'ZodDefault') {\r\n        hasDefault = true;\r\n        defaultValue = current._def.defaultValue();\r\n        current = current._def.innerType;\r\n      } else if (typeName === 'ZodEffects') {\r\n        // Handle .refine(), .transform() etc\r\n        current = current._def.schema;\r\n      } else {\r\n        // We've reached the base type\r\n        break;\r\n      }\r\n    }\r\n\r\n    baseSchema = current;\r\n    const typeName = baseSchema._def?.typeName;\r\n\r\n    if (typeName === 'ZodNumber') {\r\n      return {\r\n        type: 'number',\r\n        schema: schema, // Store the original schema with wrappers\r\n        source,\r\n        default: hasDefault ? defaultValue : 0,\r\n        nullable: isNullable,\r\n        optional: isOptional,\r\n      };\r\n    } else if (typeName === 'ZodString') {\r\n      return {\r\n        type: 'string',\r\n        schema: schema,\r\n        source,\r\n        default: hasDefault ? defaultValue : '',\r\n        nullable: isNullable,\r\n        optional: isOptional,\r\n      };\r\n    } else if (typeName === 'ZodBoolean') {\r\n      return {\r\n        type: 'boolean',\r\n        schema: schema,\r\n        source,\r\n        default: hasDefault ? defaultValue : false,\r\n        nullable: isNullable,\r\n        optional: isOptional,\r\n      };\r\n    } else if (typeName === 'ZodArray') {\r\n      return {\r\n        type: 'array',\r\n        schema: schema,\r\n        source,\r\n        default: hasDefault ? defaultValue : [],\r\n        nullable: isNullable,\r\n        optional: isOptional,\r\n      };\r\n    } else if (typeName === 'ZodObject') {\r\n      return {\r\n        type: 'object',\r\n        schema: schema,\r\n        source,\r\n        default: hasDefault ? defaultValue : {},\r\n        nullable: isNullable,\r\n        optional: isOptional,\r\n      };\r\n    } else if (typeName === 'ZodDate') {\r\n      return {\r\n        type: 'date',\r\n        schema: schema,\r\n        source,\r\n        default: hasDefault ? defaultValue : new Date(),\r\n        nullable: isNullable,\r\n        optional: isOptional,\r\n      };\r\n    }\r\n  }\r\n\r\n  // Zod v3 unwrapping\r\n  if (schema._type) {\r\n    let current = schema;\r\n\r\n    // Check for wrappers in v3\r\n    while (current) {\r\n      if (current._type === 'optional') {\r\n        isOptional = true;\r\n        current = current._def?.innerType || current._inner;\r\n      } else if (current._type === 'nullable') {\r\n        isNullable = true;\r\n        current = current._def?.innerType || current._inner;\r\n      } else if (current._def?.defaultValue !== undefined) {\r\n        hasDefault = true;\r\n        defaultValue =\r\n          typeof current._def.defaultValue === 'function'\r\n            ? current._def.defaultValue()\r\n            : current._def.defaultValue;\r\n        break;\r\n      } else {\r\n        break;\r\n      }\r\n    }\r\n\r\n    baseSchema = current;\r\n\r\n    if (baseSchema._type === 'number') {\r\n      return {\r\n        type: 'number',\r\n        schema: schema,\r\n        source,\r\n        default: hasDefault ? defaultValue : 0,\r\n        nullable: isNullable,\r\n        optional: isOptional,\r\n      };\r\n    } else if (baseSchema._type === 'string') {\r\n      return {\r\n        type: 'string',\r\n        schema: schema,\r\n        source,\r\n        default: hasDefault ? defaultValue : '',\r\n        nullable: isNullable,\r\n        optional: isOptional,\r\n      };\r\n    } else if (baseSchema._type === 'boolean') {\r\n      return {\r\n        type: 'boolean',\r\n        schema: schema,\r\n        source,\r\n        default: hasDefault ? defaultValue : false,\r\n        nullable: isNullable,\r\n        optional: isOptional,\r\n      };\r\n    } else if (baseSchema._type === 'array') {\r\n      return {\r\n        type: 'array',\r\n        schema: schema,\r\n        source,\r\n        default: hasDefault ? defaultValue : [],\r\n        nullable: isNullable,\r\n        optional: isOptional,\r\n      };\r\n    } else if (baseSchema._type === 'object') {\r\n      return {\r\n        type: 'object',\r\n        schema: schema,\r\n        source,\r\n        default: hasDefault ? defaultValue : {},\r\n        nullable: isNullable,\r\n        optional: isOptional,\r\n      };\r\n    } else if (baseSchema._type === 'date') {\r\n      return {\r\n        type: 'date',\r\n        schema: schema,\r\n        source,\r\n        default: hasDefault ? defaultValue : new Date(),\r\n        nullable: isNullable,\r\n        optional: isOptional,\r\n      };\r\n    }\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\n// Helper to get type info from runtime value\r\nfunction getTypeFromValue(value: any): TypeInfo {\r\n  if (value === null) {\r\n    return {\r\n      type: 'unknown',\r\n      schema: null,\r\n      source: 'default',\r\n      default: null,\r\n      nullable: true,\r\n    };\r\n  }\r\n\r\n  if (value === undefined) {\r\n    return {\r\n      type: 'unknown',\r\n      schema: null,\r\n      source: 'default',\r\n      default: undefined,\r\n      optional: true,\r\n    };\r\n  }\r\n\r\n  const valueType = typeof value;\r\n\r\n  if (valueType === 'number') {\r\n    return { type: 'number', schema: null, source: 'runtime', default: value };\r\n  } else if (valueType === 'string') {\r\n    return { type: 'string', schema: null, source: 'runtime', default: value };\r\n  } else if (valueType === 'boolean') {\r\n    return { type: 'boolean', schema: null, source: 'runtime', default: value };\r\n  } else if (Array.isArray(value)) {\r\n    return { type: 'array', schema: null, source: 'runtime', default: [] };\r\n  } else if (value instanceof Date) {\r\n    return { type: 'date', schema: null, source: 'runtime', default: value };\r\n  } else if (valueType === 'object') {\r\n    return { type: 'object', schema: null, source: 'runtime', default: {} };\r\n  }\r\n\r\n  return { type: 'unknown', schema: null, source: 'runtime', default: value };\r\n}\r\ntype BuildContext = {\r\n  stateKey: string;\r\n  path: string[];\r\n  schemas: {\r\n    sync?: any;\r\n    zodV4?: any;\r\n    zodV3?: any;\r\n  };\r\n};\r\n// Update buildShadowNode to use the new schema storage\r\nexport function buildShadowNode(\r\n  stateKey: string,\r\n  value: any,\r\n  context?: BuildContext\r\n): ShadowNode {\r\n  // For primitive values\r\n  if (value === null || value === undefined || typeof value !== 'object') {\r\n    const node: ShadowNode = { _meta: {} };\r\n    node._meta!.value = value;\r\n    if (context) {\r\n      let typeInfo: TypeInfo | null = null;\r\n\r\n      // 1. Try to get type from sync schema\r\n      if (context.schemas.sync && context.schemas.sync[context.stateKey]) {\r\n        const syncEntry = context.schemas.sync[context.stateKey];\r\n        if (syncEntry.schemas?.validation) {\r\n          // Navigate to the field in the validation schema\r\n          let fieldSchema = syncEntry.schemas.validation;\r\n          for (const segment of context.path) {\r\n            if (fieldSchema?.shape) {\r\n              fieldSchema = fieldSchema.shape[segment];\r\n            } else if (fieldSchema?._def?.shape) {\r\n              fieldSchema = fieldSchema._def.shape()[segment];\r\n            }\r\n          }\r\n\r\n          if (fieldSchema) {\r\n            typeInfo = getTypeFromZodSchema(fieldSchema, 'sync');\r\n            if (typeInfo) {\r\n              // Use the default from sync schema if available\r\n              if (syncEntry.schemas.defaults) {\r\n                let defaultValue = syncEntry.schemas.defaults;\r\n                for (const segment of context.path) {\r\n                  if (defaultValue && typeof defaultValue === 'object') {\r\n                    defaultValue = defaultValue[segment];\r\n                  }\r\n                }\r\n                if (defaultValue !== undefined) {\r\n                  typeInfo.default = defaultValue;\r\n                  // If no value provided and not optional, use the default\r\n                  if (\r\n                    (value === undefined || value === null) &&\r\n                    !typeInfo.optional\r\n                  ) {\r\n                    node._meta!.value = defaultValue;\r\n                  }\r\n                }\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      // 2. If no sync schema, try Zod v4\r\n      if (!typeInfo && context.schemas.zodV4) {\r\n        let fieldSchema = context.schemas.zodV4;\r\n        for (const segment of context.path) {\r\n          if (fieldSchema?.shape) {\r\n            fieldSchema = fieldSchema.shape[segment];\r\n          } else if (fieldSchema?._def?.shape) {\r\n            fieldSchema = fieldSchema._def.shape()[segment];\r\n          }\r\n        }\r\n\r\n        if (fieldSchema) {\r\n          typeInfo = getTypeFromZodSchema(fieldSchema, 'zod4');\r\n          if (typeInfo && (value === undefined || value === null)) {\r\n            // Only use default if the field is not optional/nullable\r\n            if (!typeInfo.optional && !typeInfo.nullable) {\r\n              node.value = typeInfo.default;\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      // 3. If no Zod v4, try Zod v3\r\n      if (!typeInfo && context.schemas.zodV3) {\r\n        let fieldSchema = context.schemas.zodV3;\r\n        for (const segment of context.path) {\r\n          if (fieldSchema?.shape) {\r\n            fieldSchema = fieldSchema.shape[segment];\r\n          } else if (fieldSchema?._shape) {\r\n            fieldSchema = fieldSchema._shape[segment];\r\n          }\r\n        }\r\n\r\n        if (fieldSchema) {\r\n          typeInfo = getTypeFromZodSchema(fieldSchema, 'zod3');\r\n          if (typeInfo && (value === undefined || value === null)) {\r\n            // Only use default if the field is not optional/nullable\r\n            if (!typeInfo.optional && !typeInfo.nullable) {\r\n              node.value = typeInfo.default;\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      // 4. Fall back to runtime type\r\n      if (!typeInfo) {\r\n        typeInfo = getTypeFromValue(node._meta!.value);\r\n      }\r\n\r\n      // Store the type info\r\n      if (typeInfo) {\r\n        if (!node._meta) node._meta = {};\r\n        node._meta.typeInfo = typeInfo;\r\n      }\r\n    } else {\r\n      // No context, just use runtime type\r\n      const typeInfo = getTypeFromValue(value);\r\n      if (!node._meta) node._meta = {};\r\n      node._meta.typeInfo = typeInfo;\r\n    }\r\n\r\n    return node;\r\n  }\r\n\r\n  // For arrays\r\n  if (Array.isArray(value)) {\r\n    const arrayNode: ShadowNode = { _meta: { arrayKeys: [] } };\r\n    const idKeys: string[] = [];\r\n\r\n    value.forEach((item, index) => {\r\n      const itemId = `${generateId(stateKey)}`;\r\n      // Pass context down for array items\r\n      const itemContext = context\r\n        ? {\r\n            ...context,\r\n            path: [...context.path, index.toString()],\r\n          }\r\n        : undefined;\r\n      arrayNode[itemId] = buildShadowNode(stateKey, item, itemContext);\r\n      idKeys.push(itemId);\r\n    });\r\n\r\n    arrayNode._meta!.arrayKeys = idKeys;\r\n    if (context) {\r\n      // Try to get the array schema\r\n      let arraySchema = null;\r\n\r\n      if (context.schemas.zodV4) {\r\n        let fieldSchema = context.schemas.zodV4;\r\n        for (const segment of context.path) {\r\n          if (fieldSchema?.shape) {\r\n            fieldSchema = fieldSchema.shape[segment];\r\n          } else if (fieldSchema?._def?.shape) {\r\n            fieldSchema = fieldSchema._def.shape()[segment];\r\n          }\r\n        }\r\n        arraySchema = fieldSchema;\r\n      }\r\n\r\n      arrayNode._meta!.typeInfo = {\r\n        type: 'array',\r\n        schema: arraySchema,\r\n        source: arraySchema ? 'zod4' : 'runtime',\r\n        default: [],\r\n      };\r\n    }\r\n    return arrayNode;\r\n  }\r\n\r\n  // For objects\r\n  if (value.constructor === Object) {\r\n    const objectNode: ShadowNode = { _meta: {} };\r\n    for (const key in value) {\r\n      if (Object.prototype.hasOwnProperty.call(value, key)) {\r\n        // Pass context down for object properties\r\n        const propContext = context\r\n          ? {\r\n              ...context,\r\n              path: [...context.path, key],\r\n            }\r\n          : undefined;\r\n        objectNode[key] = buildShadowNode(stateKey, value[key], propContext);\r\n      }\r\n    }\r\n    if (context) {\r\n      // Try to get the object schema\r\n      let objectSchema = null;\r\n\r\n      if (context.schemas.zodV4) {\r\n        let fieldSchema = context.schemas.zodV4;\r\n        for (const segment of context.path) {\r\n          if (fieldSchema?.shape) {\r\n            fieldSchema = fieldSchema.shape[segment];\r\n          } else if (fieldSchema?._def?.shape) {\r\n            fieldSchema = fieldSchema._def.shape()[segment];\r\n          }\r\n        }\r\n        objectSchema = fieldSchema;\r\n      }\r\n\r\n      objectNode._meta!.typeInfo = {\r\n        type: 'object',\r\n        schema: objectSchema,\r\n        source: objectSchema ? 'zod4' : 'runtime',\r\n        default: {},\r\n      };\r\n    }\r\n    return objectNode;\r\n  }\r\n\r\n  return { value };\r\n}\r\n\r\n// store.ts - Replace the shadow store methods with mutable versions\r\n// store.ts - Replace the shadow store methods with mutable versions\r\n\r\n// Module-level mutable store\r\nconst shadowStateStore = new Map<string, ShadowNode>();\r\nlet globalCounter = 0;\r\n\r\nexport function generateId(stateKey: string): string {\r\n  const rootMeta = getGlobalStore.getState().getShadowMetadata(stateKey, []);\r\n  const prefix = rootMeta?.syncArrayIdPrefix || 'local';\r\n  return `id:${prefix}_${(globalCounter++).toString(36)}`;\r\n}\r\nexport const getGlobalStore = create<CogsGlobalState>((set, get) => ({\r\n  // Remove shadowStateStore from Zustand state\r\n\r\n  setTransformCache: (\r\n    key: string,\r\n    path: string[],\r\n    cacheKey: string,\r\n    cacheData: any\r\n  ) => {\r\n    const metadata = get().getShadowMetadata(key, path) || {};\r\n    if (!metadata.transformCaches) {\r\n      metadata.transformCaches = new Map();\r\n    }\r\n    metadata.transformCaches.set(cacheKey, cacheData);\r\n    get().setShadowMetadata(key, path, {\r\n      transformCaches: metadata.transformCaches,\r\n    });\r\n  },\r\n\r\n  initializeShadowState: (key: string, initialState: any) => {\r\n    const existingRoot =\r\n      shadowStateStore.get(key) || shadowStateStore.get(`[${key}`);\r\n    let preservedMetadata: Partial<ShadowMetadata> = {};\r\n\r\n    if (existingRoot?._meta) {\r\n      const {\r\n        components,\r\n        features,\r\n        lastServerSync,\r\n        stateSource,\r\n        baseServerState,\r\n      } = existingRoot._meta;\r\n      if (components) preservedMetadata.components = components;\r\n      if (features) preservedMetadata.features = features;\r\n      if (lastServerSync) preservedMetadata.lastServerSync = lastServerSync;\r\n      if (stateSource) preservedMetadata.stateSource = stateSource;\r\n      if (baseServerState) preservedMetadata.baseServerState = baseServerState;\r\n    }\r\n\r\n    shadowStateStore.delete(key);\r\n    shadowStateStore.delete(`[${key}`);\r\n\r\n    // Get all available schemas for this state\r\n    const options = get().getInitialOptions(key);\r\n    const syncSchemas = get().getInitialOptions('__syncSchemas');\r\n\r\n    const context: BuildContext = {\r\n      stateKey: key,\r\n      path: [],\r\n      schemas: {\r\n        sync: syncSchemas,\r\n        zodV4: options?.validation?.zodSchemaV4,\r\n        zodV3: options?.validation?.zodSchemaV3,\r\n      },\r\n    };\r\n\r\n    // Build with context so type info is stored\r\n    const newRoot = buildShadowNode(key, initialState, context);\r\n\r\n    if (!newRoot._meta) newRoot._meta = {};\r\n    Object.assign(newRoot._meta, preservedMetadata);\r\n\r\n    const storageKey = Array.isArray(initialState) ? `[${key}` : key;\r\n    shadowStateStore.set(storageKey, newRoot);\r\n  },\r\n  getShadowNode: (key: string, path: string[]): ShadowNode | undefined => {\r\n    let current: any =\r\n      shadowStateStore.get(key) || shadowStateStore.get(`[${key}`);\r\n    if (!current) return undefined;\r\n    if (path.length === 0) return current;\r\n\r\n    for (const segment of path) {\r\n      if (typeof current !== 'object' || current === null) return undefined;\r\n      current = current[segment];\r\n      if (current === undefined) return undefined;\r\n    }\r\n    return current;\r\n  },\r\n\r\n  getShadowMetadata: (\r\n    key: string,\r\n    path: string[]\r\n  ): ShadowMetadata | undefined => {\r\n    const node = get().getShadowNode(key, path);\r\n    return node?._meta;\r\n  },\r\n\r\n  setShadowMetadata: (\r\n    key: string,\r\n    path: string[],\r\n    newMetadata: Partial<ShadowMetadata>\r\n  ) => {\r\n    // Direct mutation - no cloning!\r\n    const rootKey = shadowStateStore.has(`[${key}`) ? `[${key}` : key;\r\n    let root = shadowStateStore.get(rootKey);\r\n\r\n    if (!root) {\r\n      root = { _meta: newMetadata };\r\n      shadowStateStore.set(rootKey, root);\r\n      return;\r\n    }\r\n\r\n    // Navigate to target without cloning\r\n    let current = root;\r\n    for (const segment of path) {\r\n      if (!current[segment]) {\r\n        current[segment] = {};\r\n      }\r\n      current = current[segment];\r\n    }\r\n\r\n    // Mutate metadata directly\r\n    if (!current._meta) {\r\n      current._meta = {};\r\n    }\r\n    Object.assign(current._meta, newMetadata);\r\n  },\r\n\r\n  getShadowValue: (\r\n    key: string,\r\n    path: string[],\r\n    validArrayIds?: string[],\r\n    log?: boolean\r\n  ) => {\r\n    const node = get().getShadowNode(key, path);\r\n\r\n    if (node === null || node === undefined) return undefined;\r\n\r\n    const nodeKeys = Object.keys(node);\r\n\r\n    if (\r\n      node._meta &&\r\n      Object.prototype.hasOwnProperty.call(node._meta, 'value') &&\r\n      nodeKeys.length === 1 &&\r\n      nodeKeys[0] === '_meta'\r\n    ) {\r\n      return node._meta.value;\r\n    }\r\n\r\n    const isArrayNode =\r\n      node._meta &&\r\n      Object.prototype.hasOwnProperty.call(node._meta, 'arrayKeys');\r\n    if (isArrayNode) {\r\n      const keysToIterate =\r\n        validArrayIds !== undefined && validArrayIds.length > 0\r\n          ? validArrayIds\r\n          : node._meta!.arrayKeys!;\r\n\r\n      return keysToIterate.map((itemKey: string) =>\r\n        get().getShadowValue(key, [...path, itemKey])\r\n      );\r\n    }\r\n\r\n    const result: any = {};\r\n    for (const propKey of nodeKeys) {\r\n      if (propKey !== '_meta' && !propKey.startsWith('id:')) {\r\n        result[propKey] = get().getShadowValue(key, [...path, propKey]);\r\n      }\r\n    }\r\n    return result;\r\n  },\r\n\r\n  updateShadowAtPath: (key, path, newValue) => {\r\n    // NO MORE set() wrapper - direct mutation!\r\n    const rootKey = shadowStateStore.has(`[${key}`) ? `[${key}` : key;\r\n    let root = shadowStateStore.get(rootKey);\r\n    if (!root) return;\r\n\r\n    // Navigate to parent without cloning\r\n    let parentNode = root;\r\n    for (let i = 0; i < path.length - 1; i++) {\r\n      if (!parentNode[path[i]!]) {\r\n        parentNode[path[i]!] = {};\r\n      }\r\n      parentNode = parentNode[path[i]!];\r\n    }\r\n\r\n    const targetNode =\r\n      path.length === 0 ? parentNode : parentNode[path[path.length - 1]!];\r\n\r\n    if (!targetNode) {\r\n      parentNode[path[path.length - 1]!] = buildShadowNode(key, newValue);\r\n      get().notifyPathSubscribers([key, ...path].join('.'), {\r\n        type: 'UPDATE',\r\n        newValue,\r\n      });\r\n      return;\r\n    }\r\n\r\n    function intelligentMerge(nodeToUpdate: any, plainValue: any) {\r\n      if (\r\n        typeof plainValue !== 'object' ||\r\n        plainValue === null ||\r\n        Array.isArray(plainValue)\r\n      ) {\r\n        const oldMeta = nodeToUpdate._meta;\r\n        // Clear existing properties\r\n        for (const key in nodeToUpdate) {\r\n          if (key !== '_meta') delete nodeToUpdate[key];\r\n        }\r\n        const newNode = buildShadowNode(key, plainValue);\r\n        Object.assign(nodeToUpdate, newNode);\r\n        if (oldMeta) {\r\n          nodeToUpdate._meta = { ...oldMeta, ...(nodeToUpdate._meta || {}) };\r\n        }\r\n        return;\r\n      }\r\n\r\n      const plainValueKeys = new Set(Object.keys(plainValue));\r\n\r\n      for (const propKey of plainValueKeys) {\r\n        const childValue = plainValue[propKey];\r\n        if (nodeToUpdate[propKey]) {\r\n          intelligentMerge(nodeToUpdate[propKey], childValue);\r\n        } else {\r\n          nodeToUpdate[propKey] = buildShadowNode(key, childValue);\r\n        }\r\n      }\r\n\r\n      for (const nodeKey in nodeToUpdate) {\r\n        if (\r\n          nodeKey === '_meta' ||\r\n          !Object.prototype.hasOwnProperty.call(nodeToUpdate, nodeKey)\r\n        )\r\n          continue;\r\n\r\n        if (!plainValueKeys.has(nodeKey)) {\r\n          delete nodeToUpdate[nodeKey];\r\n        }\r\n      }\r\n    }\r\n\r\n    intelligentMerge(targetNode, newValue);\r\n\r\n    get().notifyPathSubscribers([key, ...path].join('.'), {\r\n      type: 'UPDATE',\r\n      newValue,\r\n    });\r\n  },\r\n\r\n  addItemsToArrayNode: (key, arrayPath, newItems, newKeys) => {\r\n    // Direct mutation - no cloning!\r\n    const rootKey = shadowStateStore.has(`[${key}`) ? `[${key}` : key;\r\n    let root = shadowStateStore.get(rootKey);\r\n    if (!root) {\r\n      console.error('Root not found for state key:', key);\r\n      return;\r\n    }\r\n\r\n    // Navigate without cloning\r\n    let current = root;\r\n    for (const segment of arrayPath) {\r\n      if (!current[segment]) {\r\n        current[segment] = {};\r\n      }\r\n      current = current[segment];\r\n    }\r\n\r\n    // Mutate directly\r\n    Object.assign(current, newItems);\r\n    if (!current._meta) current._meta = {};\r\n    current._meta.arrayKeys = newKeys; // Direct assignment!\r\n  },\r\n\r\n  insertShadowArrayElement: (key, arrayPath, newItem, index) => {\r\n    const arrayNode = get().getShadowNode(key, arrayPath);\r\n    if (!arrayNode?._meta?.arrayKeys) {\r\n      throw new Error(\r\n        `Array not found at path: ${[key, ...arrayPath].join('.')}`\r\n      );\r\n    }\r\n\r\n    const newItemId = `${generateId(key)}`;\r\n    const itemsToAdd = { [newItemId]: buildShadowNode(key, newItem) };\r\n\r\n    // Mutate the array directly\r\n    const currentKeys = arrayNode._meta.arrayKeys;\r\n    const insertionPoint =\r\n      index !== undefined && index >= 0 && index <= currentKeys.length\r\n        ? index\r\n        : currentKeys.length;\r\n\r\n    if (insertionPoint >= currentKeys.length) {\r\n      currentKeys.push(newItemId); // O(1)\r\n    } else {\r\n      currentKeys.splice(insertionPoint, 0, newItemId); // O(n) only for middle\r\n    }\r\n\r\n    // Pass the mutated array\r\n    get().addItemsToArrayNode(key, arrayPath, itemsToAdd, currentKeys);\r\n\r\n    const arrayKey = [key, ...arrayPath].join('.');\r\n    get().notifyPathSubscribers(arrayKey, {\r\n      type: 'INSERT',\r\n      path: arrayKey,\r\n      itemKey: `${arrayKey}.${newItemId}`,\r\n      index: insertionPoint,\r\n    });\r\n\r\n    return newItemId;\r\n  },\r\n\r\n  insertManyShadowArrayElements: (key, arrayPath, newItems, index) => {\r\n    if (!newItems || newItems.length === 0) {\r\n      return;\r\n    }\r\n\r\n    const arrayNode = get().getShadowNode(key, arrayPath);\r\n    if (!arrayNode?._meta?.arrayKeys) {\r\n      console.error(\r\n        `Array not found at path: ${[key, ...arrayPath].join('.')}`\r\n      );\r\n      return;\r\n    }\r\n\r\n    const itemsToAdd: Record<string, any> = {};\r\n    const newIds: string[] = [];\r\n\r\n    newItems.forEach((item) => {\r\n      const newItemId = `${generateId(key)}`;\r\n      newIds.push(newItemId);\r\n      itemsToAdd[newItemId] = buildShadowNode(key, item);\r\n    });\r\n\r\n    // Mutate directly\r\n    const currentKeys = arrayNode._meta.arrayKeys;\r\n    const insertionPoint =\r\n      index !== undefined && index >= 0 && index <= currentKeys.length\r\n        ? index\r\n        : currentKeys.length;\r\n\r\n    if (insertionPoint >= currentKeys.length) {\r\n      currentKeys.push(...newIds); // O(k) where k is items being added\r\n    } else {\r\n      currentKeys.splice(insertionPoint, 0, ...newIds); // O(n + k)\r\n    }\r\n\r\n    get().addItemsToArrayNode(key, arrayPath, itemsToAdd, currentKeys);\r\n\r\n    const arrayKey = [key, ...arrayPath].join('.');\r\n    get().notifyPathSubscribers(arrayKey, {\r\n      type: 'INSERT_MANY',\r\n      path: arrayKey,\r\n      count: newItems.length,\r\n      index: insertionPoint,\r\n    });\r\n  },\r\n\r\n  removeShadowArrayElement: (key, itemPath) => {\r\n    if (itemPath.length === 0) return;\r\n\r\n    const arrayPath = itemPath.slice(0, -1);\r\n    const itemId = itemPath[itemPath.length - 1];\r\n    if (!itemId?.startsWith('id:')) return;\r\n\r\n    const arrayNode = get().getShadowNode(key, arrayPath);\r\n    if (!arrayNode?._meta?.arrayKeys) return;\r\n\r\n    // Mutate directly\r\n    const currentKeys = arrayNode._meta.arrayKeys;\r\n    const indexToRemove = currentKeys.indexOf(itemId);\r\n\r\n    if (indexToRemove === -1) return;\r\n\r\n    // O(1) for removing from end\r\n    if (indexToRemove === currentKeys.length - 1) {\r\n      currentKeys.pop();\r\n    }\r\n    // O(n) for removing from beginning or middle\r\n    else if (indexToRemove === 0) {\r\n      currentKeys.shift();\r\n    } else {\r\n      currentKeys.splice(indexToRemove, 1);\r\n    }\r\n\r\n    // Delete the actual item\r\n    delete arrayNode[itemId];\r\n\r\n    // No need to update metadata - already mutated!\r\n\r\n    const arrayKey = [key, ...arrayPath].join('.');\r\n    get().notifyPathSubscribers(arrayKey, {\r\n      type: 'REMOVE',\r\n      path: arrayKey,\r\n      itemKey: `${arrayKey}.${itemId}`,\r\n    });\r\n  },\r\n\r\n  registerComponent: (stateKey, fullComponentId, registration) => {\r\n    const rootMeta = get().getShadowMetadata(stateKey, []) || {};\r\n    const components = new Map(rootMeta.components);\r\n    components.set(fullComponentId, registration);\r\n    get().setShadowMetadata(stateKey, [], { components });\r\n  },\r\n\r\n  unregisterComponent: (stateKey, fullComponentId) => {\r\n    const rootMeta = get().getShadowMetadata(stateKey, []);\r\n    if (!rootMeta?.components) return;\r\n    const components = new Map(rootMeta.components);\r\n    if (components.delete(fullComponentId)) {\r\n      get().setShadowMetadata(stateKey, [], { components });\r\n    }\r\n  },\r\n\r\n  addPathComponent: (stateKey, dependencyPath, fullComponentId) => {\r\n    const metadata = get().getShadowMetadata(stateKey, dependencyPath) || {};\r\n    const newPathComponents = new Set(metadata.pathComponents);\r\n    newPathComponents.add(fullComponentId);\r\n    get().setShadowMetadata(stateKey, dependencyPath, {\r\n      pathComponents: newPathComponents,\r\n    });\r\n\r\n    const rootMeta = get().getShadowMetadata(stateKey, []);\r\n    if (rootMeta?.components) {\r\n      const component = rootMeta.components.get(fullComponentId);\r\n      if (component) {\r\n        const fullPathKey = [stateKey, ...dependencyPath].join('.');\r\n        const newPaths = new Set(component.paths);\r\n        newPaths.add(fullPathKey);\r\n        const newComponentRegistration = { ...component, paths: newPaths };\r\n        const newComponentsMap = new Map(rootMeta.components);\r\n        newComponentsMap.set(fullComponentId, newComponentRegistration);\r\n        get().setShadowMetadata(stateKey, [], { components: newComponentsMap });\r\n      }\r\n    }\r\n  },\r\n\r\n  markAsDirty: (key, path, options = { bubble: true }) => {\r\n    const setDirtyOnPath = (pathToMark: string[]) => {\r\n      const node = get().getShadowNode(key, pathToMark);\r\n      if (node?._meta?.isDirty) {\r\n        return true;\r\n      }\r\n      get().setShadowMetadata(key, pathToMark, { isDirty: true });\r\n      return false;\r\n    };\r\n\r\n    setDirtyOnPath(path);\r\n\r\n    if (options.bubble) {\r\n      let parentPath = [...path];\r\n      while (parentPath.length > 0) {\r\n        parentPath.pop();\r\n        if (setDirtyOnPath(parentPath)) {\r\n          break;\r\n        }\r\n      }\r\n    }\r\n  },\r\n\r\n  // Keep these in Zustand as they need React reactivity\r\n  serverStateUpdates: new Map(),\r\n  setServerStateUpdate: (key, serverState) => {\r\n    set((state) => ({\r\n      serverStateUpdates: new Map(state.serverStateUpdates).set(\r\n        key,\r\n        serverState\r\n      ),\r\n    }));\r\n    get().notifyPathSubscribers(key, {\r\n      type: 'SERVER_STATE_UPDATE',\r\n      serverState,\r\n    });\r\n  },\r\n\r\n  pathSubscribers: new Map<string, Set<(newValue: any) => void>>(),\r\n  subscribeToPath: (path, callback) => {\r\n    const subscribers = get().pathSubscribers;\r\n    const subsForPath = subscribers.get(path) || new Set();\r\n    subsForPath.add(callback);\r\n    subscribers.set(path, subsForPath);\r\n\r\n    return () => {\r\n      const currentSubs = get().pathSubscribers.get(path);\r\n      if (currentSubs) {\r\n        currentSubs.delete(callback);\r\n        if (currentSubs.size === 0) {\r\n          get().pathSubscribers.delete(path);\r\n        }\r\n      }\r\n    };\r\n  },\r\n\r\n  notifyPathSubscribers: (updatedPath, newValue) => {\r\n    const subscribers = get().pathSubscribers;\r\n    const subs = subscribers.get(updatedPath);\r\n    if (subs) {\r\n      subs.forEach((callback) => callback(newValue));\r\n    }\r\n  },\r\n\r\n  selectedIndicesMap: new Map<string, string>(),\r\n  getSelectedIndex: (arrayKey, validIds) => {\r\n    const itemKey = get().selectedIndicesMap.get(arrayKey);\r\n    if (!itemKey) return -1;\r\n\r\n    const arrayMeta = get().getShadowMetadata(\r\n      arrayKey.split('.')[0]!,\r\n      arrayKey.split('.').slice(1)\r\n    );\r\n    const arrayKeys = validIds || arrayMeta?.arrayKeys;\r\n\r\n    return arrayKeys ? arrayKeys.indexOf(itemKey) : -1;\r\n  },\r\n\r\n  setSelectedIndex: (arrayKey: string, itemKey: string | undefined) => {\r\n    set((state) => {\r\n      const newMap = new Map(state.selectedIndicesMap);\r\n\r\n      if (itemKey === undefined) {\r\n        newMap.delete(arrayKey);\r\n      } else {\r\n        if (newMap.has(arrayKey)) {\r\n          get().notifyPathSubscribers(newMap.get(arrayKey)!, {\r\n            type: 'THIS_UNSELECTED',\r\n          });\r\n        }\r\n        newMap.set(arrayKey, itemKey);\r\n        get().notifyPathSubscribers(itemKey, { type: 'THIS_SELECTED' });\r\n      }\r\n\r\n      get().notifyPathSubscribers(arrayKey, { type: 'GET_SELECTED' });\r\n\r\n      return {\r\n        ...state,\r\n        selectedIndicesMap: newMap,\r\n      };\r\n    });\r\n  },\r\n\r\n  clearSelectedIndex: ({ arrayKey }: { arrayKey: string }): void => {\r\n    set((state) => {\r\n      const newMap = new Map(state.selectedIndicesMap);\r\n      const actualKey = newMap.get(arrayKey);\r\n      if (actualKey) {\r\n        get().notifyPathSubscribers(actualKey, {\r\n          type: 'CLEAR_SELECTION',\r\n        });\r\n      }\r\n\r\n      newMap.delete(arrayKey);\r\n      get().notifyPathSubscribers(arrayKey, {\r\n        type: 'CLEAR_SELECTION',\r\n      });\r\n      return {\r\n        ...state,\r\n        selectedIndicesMap: newMap,\r\n      };\r\n    });\r\n  },\r\n\r\n  clearSelectedIndexesForState: (stateKey) => {\r\n    set((state) => {\r\n      const newMap = new Map(state.selectedIndicesMap);\r\n      let changed = false;\r\n      for (const key of newMap.keys()) {\r\n        if (key === stateKey || key.startsWith(stateKey + '.')) {\r\n          newMap.delete(key);\r\n          changed = true;\r\n        }\r\n      }\r\n      return changed ? { selectedIndicesMap: newMap } : {};\r\n    });\r\n  },\r\n\r\n  initialStateOptions: {},\r\n  stateLog: new Map(),\r\n  initialStateGlobal: {},\r\n\r\n  addStateLog: (updates) => {\r\n    if (!updates || updates.length === 0) return;\r\n    set((state) => {\r\n      const newLog = new Map(state.stateLog);\r\n      const logsGroupedByKey = new Map<string, UpdateTypeDetail[]>();\r\n      for (const update of updates) {\r\n        const group = logsGroupedByKey.get(update.stateKey) || [];\r\n        group.push(update);\r\n        logsGroupedByKey.set(update.stateKey, group);\r\n      }\r\n      for (const [key, batchOfUpdates] of logsGroupedByKey.entries()) {\r\n        const newStateLogForKey = new Map(newLog.get(key));\r\n        for (const update of batchOfUpdates) {\r\n          newStateLogForKey.set(JSON.stringify(update.path), { ...update });\r\n        }\r\n        newLog.set(key, newStateLogForKey);\r\n      }\r\n      return { stateLog: newLog };\r\n    });\r\n  },\r\n\r\n  getInitialOptions: (key) => get().initialStateOptions[key],\r\n  setInitialStateOptions: (key, value) => {\r\n    set((prev) => ({\r\n      initialStateOptions: { ...prev.initialStateOptions, [key]: value },\r\n    }));\r\n  },\r\n\r\n  updateInitialStateGlobal: (key, newState) => {\r\n    set((prev) => ({\r\n      initialStateGlobal: { ...prev.initialStateGlobal, [key]: newState },\r\n    }));\r\n  },\r\n\r\n  syncInfoStore: new Map<string, SyncInfo>(),\r\n  setSyncInfo: (key, syncInfo) =>\r\n    set((state) => {\r\n      const newMap = new Map(state.syncInfoStore);\r\n      newMap.set(key, syncInfo);\r\n      return { syncInfoStore: newMap };\r\n    }),\r\n  getSyncInfo: (key) => get().syncInfoStore.get(key) || null,\r\n}));\r\n"],"names":["formRefStore","create","set","get","id","ref","state","newRefs","stateKey","allRefs","stateKeyPrefix","filteredRefs","getTypeFromZodSchema","schema","source","baseSchema","isNullable","isOptional","defaultValue","hasDefault","current","typeName","getTypeFromValue","value","valueType","buildShadowNode","context","node","typeInfo","syncEntry","fieldSchema","segment","arrayNode","idKeys","item","index","itemId","generateId","itemContext","arraySchema","objectNode","key","propContext","objectSchema","shadowStateStore","globalCounter","getGlobalStore","path","cacheKey","cacheData","metadata","initialState","existingRoot","preservedMetadata","components","features","lastServerSync","stateSource","baseServerState","options","syncSchemas","newRoot","storageKey","newMetadata","rootKey","root","validArrayIds","log","nodeKeys","itemKey","result","propKey","newValue","parentNode","i","targetNode","intelligentMerge","nodeToUpdate","plainValue","oldMeta","newNode","plainValueKeys","childValue","nodeKey","arrayPath","newItems","newKeys","newItem","newItemId","itemsToAdd","currentKeys","insertionPoint","arrayKey","newIds","itemPath","indexToRemove","fullComponentId","registration","rootMeta","dependencyPath","newPathComponents","component","fullPathKey","newPaths","newComponentRegistration","newComponentsMap","setDirtyOnPath","pathToMark","parentPath","serverState","callback","subscribers","subsForPath","currentSubs","updatedPath","subs","validIds","arrayMeta","arrayKeys","newMap","actualKey","changed","updates","newLog","logsGroupedByKey","update","group","batchOfUpdates","newStateLogForKey","prev","newState","syncInfo"],"mappings":"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"}