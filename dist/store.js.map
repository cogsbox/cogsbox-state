{"version":3,"file":"store.js","sources":["../src/store.ts"],"sourcesContent":["import { create } from 'zustand';\r\n\r\nimport type {\r\n  OptionsType,\r\n  ReactivityType,\r\n  SyncInfo,\r\n  UpdateTypeDetail,\r\n} from './CogsState.js';\r\n\r\nexport type FreshValuesObject = {\r\n  pathsToValues?: string[];\r\n  prevValue?: any;\r\n  newValue?: any;\r\n  timeStamp: number;\r\n};\r\n\r\ntype StateValue = any;\r\nexport type FormEventType = {\r\n  type: 'focus' | 'blur' | 'input';\r\n  value?: any;\r\n  path: string[];\r\n};\r\nexport type TrieNode = {\r\n  subscribers: Set<string>;\r\n  children: Map<string, TrieNode>;\r\n};\r\n\r\nexport type ComponentsType = {\r\n  components?: Map<\r\n    string,\r\n    {\r\n      forceUpdate: () => void;\r\n      paths: Set<string>;\r\n      deps?: any[];\r\n      prevDeps?: any[];\r\n      depsFunction?: (state: any) => any[] | true;\r\n      reactiveType: ReactivityType[] | ReactivityType;\r\n    }\r\n  >;\r\n};\r\n\r\nexport type ValidationStatus =\r\n  | 'NOT_VALIDATED'\r\n  | 'VALIDATING'\r\n  | 'VALID'\r\n  | 'INVALID';\r\nexport type ValidationSeverity = 'warning' | 'error' | undefined;\r\nexport type ValidationError = {\r\n  source: 'client' | 'sync_engine' | 'api';\r\n  message: string;\r\n  severity: ValidationSeverity;\r\n  code?: string;\r\n};\r\n\r\nexport type ValidationState = {\r\n  status: ValidationStatus;\r\n  errors: ValidationError[];\r\n  lastValidated?: number;\r\n  validatedValue?: any;\r\n};\r\nexport type TypeInfo = {\r\n  type:\r\n    | 'string'\r\n    | 'number'\r\n    | 'boolean'\r\n    | 'array'\r\n    | 'object'\r\n    | 'date'\r\n    | 'unknown';\r\n  schema: any; // Store the actual Zod schema object\r\n  source: 'sync' | 'zod4' | 'zod3' | 'runtime' | 'default';\r\n  default: any;\r\n  nullable?: boolean;\r\n  optional?: boolean;\r\n};\r\n\r\nexport type UIState = {\r\n  isFocused?: boolean;\r\n  isTouched?: boolean;\r\n  isHovered?: boolean;\r\n};\r\n\r\n// Update ShadowMetadata to include typeInfo\r\nexport type ShadowMetadata = {\r\n  value?: any;\r\n\r\n  id?: string;\r\n  typeInfo?: TypeInfo;\r\n  stateSource?: 'default' | 'server' | 'localStorage';\r\n  lastServerSync?: number;\r\n  isDirty?: boolean;\r\n  baseServerState?: any;\r\n  arrayKeys?: string[];\r\n  fields?: Record<string, any>;\r\n  virtualizer?: {\r\n    itemHeight?: number;\r\n    domRef?: HTMLElement | null;\r\n  };\r\n  syncInfo?: { status: string };\r\n  validation?: ValidationState;\r\n  features?: {\r\n    localStorageEnabled: boolean;\r\n  };\r\n  signals?: Array<{\r\n    instanceId: string;\r\n    parentId: string;\r\n    position: number;\r\n    effect?: string;\r\n  }>;\r\n  transformCaches?: Map<\r\n    string,\r\n    {\r\n      validIds: string[];\r\n      computedAt: number;\r\n      transforms: Array<{ type: 'filter' | 'sort'; fn: Function }>;\r\n    }\r\n  >;\r\n  pathComponents?: Set<string>;\r\n\r\n  streams?: Map<\r\n    string,\r\n    {\r\n      buffer: any[];\r\n      flushTimer: NodeJS.Timeout | null;\r\n    }\r\n  >;\r\n  pluginMetaData?: Map<string, Record<string, any>>;\r\n  formRef?: React.RefObject<any>;\r\n  focusedElement?: { path: string[]; ref: React.RefObject<any> } | null;\r\n} & ComponentsType;\r\n\r\ntype ShadowNode = {\r\n  _meta?: ShadowMetadata;\r\n  [key: string]: any;\r\n};\r\n\r\nexport type CogsGlobalState = {\r\n  getPluginMetaDataMap: (\r\n    key: string,\r\n    path: string[]\r\n  ) => Map<string, Record<string, any>> | undefined;\r\n  setPluginMetaData: (\r\n    key: string,\r\n    path: string[],\r\n    pluginName: string,\r\n    data: Record<string, any>\r\n  ) => void;\r\n  removePluginMetaData: (\r\n    key: string,\r\n    path: string[],\r\n    pluginName: string\r\n  ) => void;\r\n  setTransformCache: (\r\n    key: string,\r\n    path: string[],\r\n    cacheKey: string,\r\n    cacheData: any\r\n  ) => void;\r\n  initializeAndMergeShadowState: (key: string, initialState: any) => void;\r\n  initializeShadowState: (key: string, initialState: any) => void;\r\n  getShadowNode: (key: string, path: string[]) => ShadowNode | undefined;\r\n  getShadowMetadata: (\r\n    key: string,\r\n    path: string[]\r\n  ) => ShadowMetadata | undefined;\r\n\r\n  setShadowMetadata: (key: string, path: string[], metadata: any) => void;\r\n  getShadowValue: (\r\n    key: string,\r\n    path: string[],\r\n    validArrayIds?: string[],\r\n    log?: boolean\r\n  ) => any;\r\n  updateShadowAtPath: (key: string, path: string[], newValue: any) => void;\r\n  insertManyShadowArrayElements: (\r\n    key: string,\r\n    arrayPath: string[],\r\n    newItems: any[],\r\n    index?: number\r\n  ) => void;\r\n  addItemsToArrayNode: (\r\n    key: string,\r\n    arrayPath: string[],\r\n    newItems: any\r\n  ) => void;\r\n  insertShadowArrayElement: (\r\n    key: string,\r\n    arrayPath: string[],\r\n    newItem: any,\r\n    index?: number,\r\n    itemId?: string\r\n  ) => string;\r\n  removeShadowArrayElement: (key: string, itemPath: string[]) => void;\r\n  registerComponent: (\r\n    stateKey: string,\r\n    componentId: string,\r\n    registration: any\r\n  ) => void;\r\n  unregisterComponent: (stateKey: string, componentId: string) => void;\r\n  addPathComponent: (\r\n    stateKey: string,\r\n    dependencyPath: string[],\r\n    fullComponentId: string\r\n  ) => void;\r\n  markAsDirty: (\r\n    key: string,\r\n    path: string[],\r\n    options: { bubble: boolean }\r\n  ) => void;\r\n\r\n  pathSubscribers: Map<string, Set<(newValue: any) => void>>;\r\n  subscribeToPath: (\r\n    path: string,\r\n    callback: (newValue: any) => void\r\n  ) => () => void;\r\n  notifyPathSubscribers: (updatedPath: string, newValue: any) => void;\r\n\r\n  selectedIndicesMap: Map<string, string>; // stateKey -> (parentPath -> selectedIndex)\r\n  getSelectedIndex: (stateKey: string, validArrayIds?: string[]) => number;\r\n  setSelectedIndex: (key: string, itemKey: string) => void;\r\n  clearSelectedIndex: ({ arrayKey }: { arrayKey: string }) => void;\r\n  clearSelectedIndexesForState: (stateKey: string) => void;\r\n\r\n  initialStateOptions: { [key: string]: OptionsType };\r\n  initialStateGlobal: { [key: string]: StateValue };\r\n  updateInitialStateGlobal: (key: string, newState: StateValue) => void;\r\n\r\n  getInitialOptions: (key: string) => OptionsType | undefined;\r\n  setInitialStateOptions: (key: string, value: OptionsType) => void;\r\n\r\n  serverStateUpdates: Map<\r\n    string,\r\n    {\r\n      data: any;\r\n      status: 'loading' | 'success' | 'error';\r\n      timestamp: number;\r\n    }\r\n  >;\r\n\r\n  setServerStateUpdate: (key: string, serverState: any) => void;\r\n\r\n  stateLog: Map<string, Map<string, UpdateTypeDetail>>;\r\n  syncInfoStore: Map<string, SyncInfo>;\r\n  addStateLog: (updates: UpdateTypeDetail[]) => void;\r\n\r\n  setSyncInfo: (key: string, syncInfo: SyncInfo) => void;\r\n  getSyncInfo: (key: string) => SyncInfo | null;\r\n};\r\n\r\nfunction getTypeFromZodSchema(\r\n  schema: any,\r\n  source: 'zod4' | 'zod3' | 'sync' = 'zod4'\r\n): TypeInfo | null {\r\n  if (!schema) return null;\r\n\r\n  let baseSchema = schema;\r\n  let isNullable = false;\r\n  let isOptional = false;\r\n  let defaultValue: any = undefined;\r\n  let hasDefault = false;\r\n\r\n  // Zod v4 unwrapping\r\n  if (schema._def) {\r\n    let current = schema;\r\n\r\n    // Keep unwrapping until we get to the base type\r\n    while (current._def) {\r\n      const typeName = current._def.typeName;\r\n\r\n      if (typeName === 'ZodOptional') {\r\n        isOptional = true;\r\n        current = current._def.innerType || current.unwrap();\r\n      } else if (typeName === 'ZodNullable') {\r\n        isNullable = true;\r\n        current = current._def.innerType || current.unwrap();\r\n      } else if (typeName === 'ZodDefault') {\r\n        hasDefault = true;\r\n        defaultValue = current._def.defaultValue();\r\n        current = current._def.innerType;\r\n      } else if (typeName === 'ZodEffects') {\r\n        // Handle .refine(), .transform() etc\r\n        current = current._def.schema;\r\n      } else {\r\n        // We've reached the base type\r\n        break;\r\n      }\r\n    }\r\n\r\n    baseSchema = current;\r\n    const typeName = baseSchema._def?.typeName;\r\n\r\n    if (typeName === 'ZodNumber') {\r\n      return {\r\n        type: 'number',\r\n        schema: schema, // Store the original schema with wrappers\r\n        source,\r\n        default: hasDefault ? defaultValue : 0,\r\n        nullable: isNullable,\r\n        optional: isOptional,\r\n      };\r\n    } else if (typeName === 'ZodString') {\r\n      return {\r\n        type: 'string',\r\n        schema: schema,\r\n        source,\r\n        default: hasDefault ? defaultValue : '',\r\n        nullable: isNullable,\r\n        optional: isOptional,\r\n      };\r\n    } else if (typeName === 'ZodBoolean') {\r\n      return {\r\n        type: 'boolean',\r\n        schema: schema,\r\n        source,\r\n        default: hasDefault ? defaultValue : false,\r\n        nullable: isNullable,\r\n        optional: isOptional,\r\n      };\r\n    } else if (typeName === 'ZodArray') {\r\n      return {\r\n        type: 'array',\r\n        schema: schema,\r\n        source,\r\n        default: hasDefault ? defaultValue : [],\r\n        nullable: isNullable,\r\n        optional: isOptional,\r\n      };\r\n    } else if (typeName === 'ZodObject') {\r\n      return {\r\n        type: 'object',\r\n        schema: schema,\r\n        source,\r\n        default: hasDefault ? defaultValue : {},\r\n        nullable: isNullable,\r\n        optional: isOptional,\r\n      };\r\n    } else if (typeName === 'ZodDate') {\r\n      return {\r\n        type: 'date',\r\n        schema: schema,\r\n        source,\r\n        default: hasDefault ? defaultValue : new Date(),\r\n        nullable: isNullable,\r\n        optional: isOptional,\r\n      };\r\n    }\r\n  }\r\n\r\n  // Zod v3 unwrapping\r\n  if (schema._type) {\r\n    let current = schema;\r\n\r\n    // Check for wrappers in v3\r\n    while (current) {\r\n      if (current._type === 'optional') {\r\n        isOptional = true;\r\n        current = current._def?.innerType || current._inner;\r\n      } else if (current._type === 'nullable') {\r\n        isNullable = true;\r\n        current = current._def?.innerType || current._inner;\r\n      } else if (current._def?.defaultValue !== undefined) {\r\n        hasDefault = true;\r\n        defaultValue =\r\n          typeof current._def.defaultValue === 'function'\r\n            ? current._def.defaultValue()\r\n            : current._def.defaultValue;\r\n        break;\r\n      } else {\r\n        break;\r\n      }\r\n    }\r\n\r\n    baseSchema = current;\r\n\r\n    if (baseSchema._type === 'number') {\r\n      return {\r\n        type: 'number',\r\n        schema: schema,\r\n        source,\r\n        default: hasDefault ? defaultValue : 0,\r\n        nullable: isNullable,\r\n        optional: isOptional,\r\n      };\r\n    } else if (baseSchema._type === 'string') {\r\n      return {\r\n        type: 'string',\r\n        schema: schema,\r\n        source,\r\n        default: hasDefault ? defaultValue : '',\r\n        nullable: isNullable,\r\n        optional: isOptional,\r\n      };\r\n    } else if (baseSchema._type === 'boolean') {\r\n      return {\r\n        type: 'boolean',\r\n        schema: schema,\r\n        source,\r\n        default: hasDefault ? defaultValue : false,\r\n        nullable: isNullable,\r\n        optional: isOptional,\r\n      };\r\n    } else if (baseSchema._type === 'array') {\r\n      return {\r\n        type: 'array',\r\n        schema: schema,\r\n        source,\r\n        default: hasDefault ? defaultValue : [],\r\n        nullable: isNullable,\r\n        optional: isOptional,\r\n      };\r\n    } else if (baseSchema._type === 'object') {\r\n      return {\r\n        type: 'object',\r\n        schema: schema,\r\n        source,\r\n        default: hasDefault ? defaultValue : {},\r\n        nullable: isNullable,\r\n        optional: isOptional,\r\n      };\r\n    } else if (baseSchema._type === 'date') {\r\n      return {\r\n        type: 'date',\r\n        schema: schema,\r\n        source,\r\n        default: hasDefault ? defaultValue : new Date(),\r\n        nullable: isNullable,\r\n        optional: isOptional,\r\n      };\r\n    }\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\n// Helper to get type info from runtime value\r\nfunction getTypeFromValue(value: any): TypeInfo {\r\n  if (value === null) {\r\n    return {\r\n      type: 'unknown',\r\n      schema: null,\r\n      source: 'default',\r\n      default: null,\r\n      nullable: true,\r\n    };\r\n  }\r\n\r\n  if (value === undefined) {\r\n    return {\r\n      type: 'unknown',\r\n      schema: null,\r\n      source: 'default',\r\n      default: undefined,\r\n      optional: true,\r\n    };\r\n  }\r\n\r\n  const valueType = typeof value;\r\n\r\n  if (valueType === 'number') {\r\n    return { type: 'number', schema: null, source: 'runtime', default: value };\r\n  } else if (valueType === 'string') {\r\n    return { type: 'string', schema: null, source: 'runtime', default: value };\r\n  } else if (valueType === 'boolean') {\r\n    return { type: 'boolean', schema: null, source: 'runtime', default: value };\r\n  } else if (Array.isArray(value)) {\r\n    return { type: 'array', schema: null, source: 'runtime', default: [] };\r\n  } else if (value instanceof Date) {\r\n    return { type: 'date', schema: null, source: 'runtime', default: value };\r\n  } else if (valueType === 'object') {\r\n    return { type: 'object', schema: null, source: 'runtime', default: {} };\r\n  }\r\n\r\n  return { type: 'unknown', schema: null, source: 'runtime', default: value };\r\n}\r\ntype BuildContext = {\r\n  stateKey: string;\r\n  path: string[];\r\n  schemas: {\r\n    sync?: any;\r\n    zodV4?: any;\r\n    zodV3?: any;\r\n  };\r\n};\r\n\r\nexport function buildShadowNode(\r\n  stateKey: string,\r\n  value: any,\r\n  context?: BuildContext\r\n): ShadowNode {\r\n  // Handle null/undefined/primitives first\r\n  if (value === null || value === undefined || typeof value !== 'object') {\r\n    const node: ShadowNode = {\r\n      _meta: {\r\n        value: value,\r\n      },\r\n    };\r\n\r\n    // Add type info\r\n    let typeInfo: TypeInfo | null = null;\r\n\r\n    if (context) {\r\n      // Check for schema-based type info\r\n      if (context.schemas.zodV4) {\r\n        const zodV4Path =\r\n          context.path.length === 0\r\n            ? context.schemas.zodV4\r\n            : getSchemaAtPath(context.schemas.zodV4, context.path);\r\n        if (zodV4Path) {\r\n          typeInfo = getTypeFromZodSchema(zodV4Path, 'zod4');\r\n        }\r\n      }\r\n\r\n      if (!typeInfo && context.schemas.zodV3) {\r\n        const zodV3Path =\r\n          context.path.length === 0\r\n            ? context.schemas.zodV3\r\n            : getSchemaAtPath(context.schemas.zodV3, context.path);\r\n        if (zodV3Path) {\r\n          typeInfo = getTypeFromZodSchema(zodV3Path, 'zod3');\r\n        }\r\n      }\r\n\r\n      if (!typeInfo && context.schemas.sync?.[stateKey]) {\r\n        // Handle sync schemas if needed\r\n        typeInfo = getTypeFromValue(value);\r\n        typeInfo.source = 'sync';\r\n      }\r\n    }\r\n\r\n    if (!typeInfo) {\r\n      typeInfo = getTypeFromValue(value);\r\n    }\r\n\r\n    node._meta!.typeInfo = typeInfo;\r\n    return node;\r\n  }\r\n\r\n  // Handle arrays\r\n  if (Array.isArray(value)) {\r\n    const arrayNode: ShadowNode = {\r\n      _meta: {\r\n        arrayKeys: [],\r\n      },\r\n    };\r\n\r\n    const idKeys: string[] = [];\r\n    value.forEach((item, index) => {\r\n      const itemId = generateId(stateKey);\r\n      const itemContext = context\r\n        ? {\r\n            ...context,\r\n            path: [...context.path, index.toString()],\r\n          }\r\n        : undefined;\r\n\r\n      arrayNode[itemId] = buildShadowNode(stateKey, item, itemContext);\r\n      idKeys.push(itemId);\r\n    });\r\n\r\n    arrayNode._meta!.arrayKeys = idKeys;\r\n\r\n    // Add array type info if context available\r\n    if (context) {\r\n      let typeInfo: TypeInfo | null = null;\r\n\r\n      if (context.schemas.zodV4) {\r\n        const schema =\r\n          context.path.length === 0\r\n            ? context.schemas.zodV4\r\n            : getSchemaAtPath(context.schemas.zodV4, context.path);\r\n        if (schema) {\r\n          typeInfo = getTypeFromZodSchema(schema, 'zod4');\r\n        }\r\n      }\r\n\r\n      if (!typeInfo && context.schemas.zodV3) {\r\n        const schema =\r\n          context.path.length === 0\r\n            ? context.schemas.zodV3\r\n            : getSchemaAtPath(context.schemas.zodV3, context.path);\r\n        if (schema) {\r\n          typeInfo = getTypeFromZodSchema(schema, 'zod3');\r\n        }\r\n      }\r\n\r\n      if (!typeInfo) {\r\n        typeInfo = {\r\n          type: 'array',\r\n          schema: null,\r\n          source: 'runtime',\r\n          default: [],\r\n        };\r\n      }\r\n\r\n      arrayNode._meta!.typeInfo = typeInfo;\r\n    }\r\n\r\n    return arrayNode;\r\n  }\r\n\r\n  // Handle objects\r\n  if (value.constructor === Object) {\r\n    // Check if it's a simple object for optimization\r\n    const keys = Object.keys(value);\r\n    let isSimpleObject = true;\r\n\r\n    for (const key of keys) {\r\n      const propValue = value[key];\r\n      const propType = typeof propValue;\r\n      if (\r\n        propValue !== null &&\r\n        propType !== 'string' &&\r\n        propType !== 'number' &&\r\n        propType !== 'boolean'\r\n      ) {\r\n        isSimpleObject = false;\r\n        break;\r\n      }\r\n    }\r\n\r\n    const objectNode: ShadowNode = {\r\n      _meta: {\r\n        typeInfo: {\r\n          type: 'object',\r\n          schema: context\r\n            ? getSchemaAtPath(\r\n                context.schemas.zodV4 || context.schemas.zodV3,\r\n                context.path\r\n              )\r\n            : null,\r\n          source: context?.schemas.zodV4\r\n            ? 'zod4'\r\n            : context?.schemas.zodV3\r\n              ? 'zod3'\r\n              : 'runtime',\r\n          default: {},\r\n        },\r\n      },\r\n    };\r\n\r\n    // Use optimized path for simple objects\r\n    if (isSimpleObject && !context) {\r\n      for (const key of keys) {\r\n        objectNode[key] = {\r\n          _meta: {\r\n            value: value[key],\r\n            typeInfo: getTypeFromValue(value[key]),\r\n          },\r\n        };\r\n      }\r\n    } else {\r\n      // Use recursive path for complex objects or when context is needed\r\n      for (const key in value) {\r\n        if (Object.prototype.hasOwnProperty.call(value, key)) {\r\n          const propContext = context\r\n            ? {\r\n                ...context,\r\n                path: [...context.path, key],\r\n              }\r\n            : undefined;\r\n\r\n          objectNode[key] = buildShadowNode(stateKey, value[key], propContext);\r\n        }\r\n      }\r\n    }\r\n\r\n    return objectNode;\r\n  }\r\n\r\n  // Fallback for other object types (Date, etc.)\r\n  return {\r\n    _meta: {\r\n      value: value,\r\n      typeInfo: getTypeFromValue(value),\r\n    },\r\n  };\r\n}\r\n\r\n// Helper function to get schema at a specific path\r\nfunction getSchemaAtPath(schema: any, path: string[]): any {\r\n  if (!schema || path.length === 0) return schema;\r\n\r\n  let current = schema;\r\n\r\n  for (const segment of path) {\r\n    // Handle Zod v4\r\n    if (current._def) {\r\n      // Unwrap modifiers\r\n      while (\r\n        current._def &&\r\n        (current._def.typeName === 'ZodOptional' ||\r\n          current._def.typeName === 'ZodNullable' ||\r\n          current._def.typeName === 'ZodDefault')\r\n      ) {\r\n        current = current._def.innerType || current.unwrap();\r\n      }\r\n\r\n      if (current._def.typeName === 'ZodObject') {\r\n        current = current.shape[segment];\r\n      } else if (current._def.typeName === 'ZodArray') {\r\n        // For array indices, get the element schema\r\n        current = current._def.type;\r\n      } else {\r\n        return null;\r\n      }\r\n    }\r\n    // Handle Zod v3\r\n    else if (current._type) {\r\n      if (current._type === 'object' && current._shape) {\r\n        current = current._shape[segment];\r\n      } else if (current._type === 'array' && current._def) {\r\n        current = current._def.type;\r\n      } else {\r\n        return null;\r\n      }\r\n    } else {\r\n      return null;\r\n    }\r\n\r\n    if (!current) return null;\r\n  }\r\n\r\n  return current;\r\n}\r\nexport const shadowStateStore = new Map<string, ShadowNode>();\r\nlet globalCounter = 0;\r\nconst instanceId = Date.now().toString(36);\r\n\r\nexport function generateId(stateKey: string): string {\r\n  const prefix = 'local';\r\n\r\n  return `id:${prefix}_${instanceId}_${(globalCounter++).toString(36)}`;\r\n}\r\nexport const getGlobalStore = create<CogsGlobalState>((set, get) => ({\r\n  getPluginMetaDataMap: (\r\n    key: string,\r\n    path: string[]\r\n  ): Map<string, Record<string, any>> | undefined => {\r\n    const metadata = get().getShadowMetadata(key, path);\r\n    return metadata?.pluginMetaData;\r\n  },\r\n\r\n  setPluginMetaData: (\r\n    key: string,\r\n    path: string[], // ADD THIS PARAMETER\r\n    pluginName: string,\r\n    data: Record<string, any>\r\n  ) => {\r\n    const metadata = get().getShadowMetadata(key, path) || {}; // Use the path!\r\n    const pluginMetaData = new Map(metadata.pluginMetaData || []);\r\n    const existingData = pluginMetaData.get(pluginName) || {};\r\n    pluginMetaData.set(pluginName, { ...existingData, ...data });\r\n    get().setShadowMetadata(key, path, { ...metadata, pluginMetaData });\r\n    get().notifyPathSubscribers([key, ...path].join('.'), {\r\n      type: 'METADATA_UPDATE',\r\n    });\r\n  },\r\n  removePluginMetaData: (key: string, path: string[], pluginName: string) => {\r\n    const metadata = get().getShadowMetadata(key, path);\r\n    if (!metadata?.pluginMetaData) return;\r\n    const pluginMetaData = new Map(metadata.pluginMetaData);\r\n    pluginMetaData.delete(pluginName);\r\n    get().setShadowMetadata(key, path, { ...metadata, pluginMetaData });\r\n  },\r\n\r\n  setTransformCache: (\r\n    key: string,\r\n    path: string[],\r\n    cacheKey: string,\r\n    cacheData: any\r\n  ) => {\r\n    const metadata = get().getShadowMetadata(key, path) || {};\r\n    if (!metadata.transformCaches) {\r\n      metadata.transformCaches = new Map();\r\n    }\r\n    metadata.transformCaches.set(cacheKey, cacheData);\r\n    get().setShadowMetadata(key, path, {\r\n      transformCaches: metadata.transformCaches,\r\n    });\r\n  },\r\n  initializeAndMergeShadowState: (key: string, shadowState: any) => {\r\n    const isArrayState = shadowState?._meta?.arrayKeys !== undefined;\r\n    const storageKey = isArrayState ? `[${key}` : key;\r\n\r\n    const existingRoot =\r\n      shadowStateStore.get(storageKey) ||\r\n      shadowStateStore.get(key) ||\r\n      shadowStateStore.get(`[${key}`);\r\n\r\n    let preservedMetadata: Partial<ShadowMetadata> = {};\r\n\r\n    if (existingRoot?._meta) {\r\n      const {\r\n        components,\r\n        features,\r\n        lastServerSync,\r\n        stateSource,\r\n        baseServerState,\r\n        pathComponents,\r\n        signals,\r\n        validation,\r\n      } = existingRoot._meta;\r\n\r\n      if (components) preservedMetadata.components = components;\r\n      if (features) preservedMetadata.features = features;\r\n      if (lastServerSync) preservedMetadata.lastServerSync = lastServerSync;\r\n      if (stateSource) preservedMetadata.stateSource = stateSource;\r\n      if (baseServerState) preservedMetadata.baseServerState = baseServerState;\r\n      if (pathComponents) preservedMetadata.pathComponents = pathComponents;\r\n      if (signals) preservedMetadata.signals = signals;\r\n      if (validation) preservedMetadata.validation = validation;\r\n    }\r\n\r\n    // Deep merge function that preserves shadow node structure\r\n    function deepMergeShadowNodes(\r\n      target: ShadowNode,\r\n      source: ShadowNode\r\n    ): ShadowNode {\r\n      // If source has a primitive value in _meta, use it\r\n      if (source._meta?.hasOwnProperty('value')) {\r\n        if (!target._meta) target._meta = {};\r\n        target._meta.value = source._meta.value;\r\n        // Clear any non-meta properties since this is a primitive\r\n        for (const key in target) {\r\n          if (key !== '_meta') {\r\n            delete target[key];\r\n          }\r\n        }\r\n        return target;\r\n      }\r\n\r\n      // Handle array nodes\r\n      if (source._meta?.arrayKeys) {\r\n        // For arrays, completely replace with new array structure\r\n        // but preserve non-array metadata\r\n        const preservedMeta = { ...target._meta };\r\n        delete preservedMeta.arrayKeys;\r\n\r\n        // Clear old array items\r\n        if (target._meta?.arrayKeys) {\r\n          target._meta.arrayKeys.forEach((itemKey) => {\r\n            delete target[itemKey];\r\n          });\r\n        }\r\n\r\n        // Copy new array structure\r\n        target._meta = { ...preservedMeta, ...source._meta };\r\n        source._meta.arrayKeys.forEach((itemKey) => {\r\n          target[itemKey] = source[itemKey];\r\n        });\r\n\r\n        return target;\r\n      }\r\n\r\n      // Handle object nodes - merge properties\r\n      for (const key in source) {\r\n        if (key === '_meta') {\r\n          // Merge metadata\r\n          target._meta = { ...(target._meta || {}), ...(source._meta || {}) };\r\n        } else {\r\n          // Recursively merge or set property\r\n          if (\r\n            target[key] &&\r\n            typeof target[key] === 'object' &&\r\n            typeof source[key] === 'object'\r\n          ) {\r\n            deepMergeShadowNodes(target[key], source[key]);\r\n          } else {\r\n            target[key] = source[key];\r\n          }\r\n        }\r\n      }\r\n\r\n      // Remove any keys in target that don't exist in source (for object nodes)\r\n      if (!source._meta?.arrayKeys && !source._meta?.hasOwnProperty('value')) {\r\n        for (const key in target) {\r\n          if (key !== '_meta' && !source.hasOwnProperty(key)) {\r\n            delete target[key];\r\n          }\r\n        }\r\n      }\r\n\r\n      return target;\r\n    }\r\n\r\n    if (existingRoot) {\r\n      // Merge the new shadow state into the existing one\r\n      deepMergeShadowNodes(existingRoot, shadowState);\r\n\r\n      // Restore preserved metadata (these should override what came from shadowState)\r\n      if (!existingRoot._meta) existingRoot._meta = {};\r\n      Object.assign(existingRoot._meta, preservedMetadata);\r\n\r\n      // Update the store with merged state\r\n      shadowStateStore.set(storageKey, existingRoot);\r\n    } else {\r\n      // No existing state, just use the provided shadowState\r\n      // But still preserve any metadata if it somehow exists\r\n      if (preservedMetadata && Object.keys(preservedMetadata).length > 0) {\r\n        if (!shadowState._meta) shadowState._meta = {};\r\n        Object.assign(shadowState._meta, preservedMetadata);\r\n      }\r\n\r\n      shadowStateStore.set(storageKey, shadowState);\r\n    }\r\n\r\n    // Clear any incorrect keys if they exist\r\n    if (storageKey === key) {\r\n      shadowStateStore.delete(`[${key}`);\r\n    } else {\r\n      shadowStateStore.delete(key);\r\n    }\r\n  },\r\n\r\n  initializeShadowState: (key: string, initialState: any) => {\r\n    const existingRoot =\r\n      shadowStateStore.get(key) || shadowStateStore.get(`[${key}`);\r\n    let preservedMetadata: Partial<ShadowMetadata> = {};\r\n\r\n    if (existingRoot?._meta) {\r\n      const {\r\n        components,\r\n        features,\r\n        lastServerSync,\r\n        stateSource,\r\n        baseServerState,\r\n      } = existingRoot._meta;\r\n      if (components) preservedMetadata.components = components;\r\n      if (features) preservedMetadata.features = features;\r\n      if (lastServerSync) preservedMetadata.lastServerSync = lastServerSync;\r\n      if (stateSource) preservedMetadata.stateSource = stateSource;\r\n      if (baseServerState) preservedMetadata.baseServerState = baseServerState;\r\n    }\r\n\r\n    shadowStateStore.delete(key);\r\n    shadowStateStore.delete(`[${key}`);\r\n\r\n    // Get all available schemas for this state\r\n    const options = get().getInitialOptions(key);\r\n    const syncSchemas = get().getInitialOptions('__syncSchemas');\r\n\r\n    const context: BuildContext = {\r\n      stateKey: key,\r\n      path: [],\r\n      schemas: {\r\n        sync: syncSchemas,\r\n        zodV4: options?.validation?.zodSchemaV4,\r\n        zodV3: options?.validation?.zodSchemaV3,\r\n      },\r\n    };\r\n\r\n    // Build with context so type info is stored\r\n    const newRoot = buildShadowNode(key, initialState, context);\r\n\r\n    if (!newRoot._meta) newRoot._meta = {};\r\n    Object.assign(newRoot._meta, preservedMetadata);\r\n\r\n    const storageKey = Array.isArray(initialState) ? `[${key}` : key;\r\n    shadowStateStore.set(storageKey, newRoot);\r\n  },\r\n  getShadowNode: (key: string, path: string[]): ShadowNode | undefined => {\r\n    let current: any =\r\n      shadowStateStore.get(key) || shadowStateStore.get(`[${key}`);\r\n    if (!current) return undefined;\r\n    if (path.length === 0) return current;\r\n\r\n    for (const segment of path) {\r\n      if (typeof current !== 'object' || current === null) return undefined;\r\n      current = current[segment];\r\n      if (current === undefined) return undefined;\r\n    }\r\n    return current;\r\n  },\r\n\r\n  getShadowMetadata: (\r\n    key: string,\r\n    path: string[]\r\n  ): ShadowMetadata | undefined => {\r\n    const node = get().getShadowNode(key, path);\r\n    return node?._meta;\r\n  },\r\n\r\n  setShadowMetadata: (\r\n    key: string,\r\n    path: string[],\r\n    newMetadata: Partial<ShadowMetadata>\r\n  ) => {\r\n    // Direct mutation - no cloning!\r\n    const rootKey = shadowStateStore.has(`[${key}`) ? `[${key}` : key;\r\n    let root = shadowStateStore.get(rootKey);\r\n\r\n    if (!root) {\r\n      root = { _meta: newMetadata };\r\n      shadowStateStore.set(rootKey, root);\r\n      return;\r\n    }\r\n\r\n    // Navigate to target without cloning\r\n    let current = root;\r\n    for (const segment of path) {\r\n      if (!current[segment]) {\r\n        current[segment] = {};\r\n      }\r\n      current = current[segment];\r\n    }\r\n\r\n    // Mutate metadata directly\r\n    if (!current._meta) {\r\n      current._meta = {};\r\n    }\r\n    Object.assign(current._meta, newMetadata);\r\n  },\r\n  getShadowValue: (key: string, path: string[], validArrayIds?: string[]) => {\r\n    const startNode = get().getShadowNode(key, path);\r\n\r\n    // If the path is invalid or leads nowhere, return undefined immediately.\r\n    if (!startNode) {\r\n      return undefined;\r\n    }\r\n\r\n    // --- High-Performance Iterative Materializer ---\r\n\r\n    // A single root object to hold the final, materialized result.\r\n    const rootResult: any = {};\r\n\r\n    // Stack to manage the traversal without recursion.\r\n    // Each item is [shadowNode, parentObjectInResult, keyToSetOnParent]\r\n    const stack: [ShadowNode, any, string | number][] = [\r\n      [startNode, rootResult, 'final'],\r\n    ];\r\n\r\n    while (stack.length > 0) {\r\n      const [currentNode, parentResult, resultKey] = stack.pop()!;\r\n\r\n      // 1. Handle primitive values\r\n      if (currentNode._meta?.hasOwnProperty('value')) {\r\n        parentResult[resultKey] = currentNode._meta.value;\r\n        continue; // Done with this branch\r\n      }\r\n\r\n      // 2. Handle arrays\r\n      if (currentNode._meta?.arrayKeys) {\r\n        const keysToIterate = validArrayIds || currentNode._meta.arrayKeys;\r\n        const newArray: any[] = [];\r\n        parentResult[resultKey] = newArray;\r\n\r\n        // Push children onto the stack in reverse order to process them from 0 to N\r\n        for (let i = keysToIterate.length - 1; i >= 0; i--) {\r\n          const itemKey = keysToIterate[i]!;\r\n          if (currentNode[itemKey]) {\r\n            // The child's result will be placed at index `i` in `newArray`\r\n            stack.push([currentNode[itemKey], newArray, i]);\r\n          }\r\n        }\r\n        continue; // Done with this branch\r\n      }\r\n\r\n      // 3. Handle objects\r\n      const newObject: any = {};\r\n      parentResult[resultKey] = newObject;\r\n\r\n      const objectKeys = Object.keys(currentNode);\r\n      // Push children onto the stack (order doesn't matter for objects)\r\n      for (const propKey of objectKeys) {\r\n        if (propKey !== '_meta') {\r\n          // The child's result will be set as a property on `newObject`\r\n          stack.push([currentNode[propKey], newObject, propKey]);\r\n        }\r\n      }\r\n    }\r\n\r\n    return rootResult.final;\r\n  },\r\n\r\n  updateShadowAtPath: (key, path, newValue) => {\r\n    // NO MORE set() wrapper - direct mutation!\r\n    const rootKey = shadowStateStore.has(`[${key}`) ? `[${key}` : key;\r\n    let root = shadowStateStore.get(rootKey);\r\n    if (!root) return;\r\n\r\n    // Navigate to parent without cloning\r\n    let parentNode = root;\r\n    for (let i = 0; i < path.length - 1; i++) {\r\n      if (!parentNode[path[i]!]) {\r\n        parentNode[path[i]!] = {};\r\n      }\r\n      parentNode = parentNode[path[i]!];\r\n    }\r\n    const targetNode =\r\n      path.length === 0 ? parentNode : parentNode[path[path.length - 1]!];\r\n\r\n    if (!targetNode) {\r\n      parentNode[path[path.length - 1]!] = buildShadowNode(key, newValue);\r\n      get().notifyPathSubscribers([key, ...path].join('.'), {\r\n        type: 'UPDATE',\r\n        newValue,\r\n      });\r\n      return;\r\n    }\r\n\r\n    function intelligentMerge(nodeToUpdate: any, plainValue: any) {\r\n      if (\r\n        typeof plainValue !== 'object' ||\r\n        plainValue === null ||\r\n        Array.isArray(plainValue)\r\n      ) {\r\n        const oldMeta = nodeToUpdate._meta;\r\n        // Clear existing properties\r\n        for (const key in nodeToUpdate) {\r\n          if (key !== '_meta') delete nodeToUpdate[key];\r\n        }\r\n        const newNode = buildShadowNode(key, plainValue);\r\n        Object.assign(nodeToUpdate, newNode);\r\n        if (oldMeta) {\r\n          nodeToUpdate._meta = { ...oldMeta, ...(nodeToUpdate._meta || {}) };\r\n        }\r\n        return;\r\n      }\r\n\r\n      const plainValueKeys = new Set(Object.keys(plainValue));\r\n\r\n      for (const propKey of plainValueKeys) {\r\n        const childValue = plainValue[propKey];\r\n        if (nodeToUpdate[propKey]) {\r\n          intelligentMerge(nodeToUpdate[propKey], childValue);\r\n        } else {\r\n          nodeToUpdate[propKey] = buildShadowNode(key, childValue);\r\n        }\r\n      }\r\n\r\n      for (const nodeKey in nodeToUpdate) {\r\n        if (\r\n          nodeKey === '_meta' ||\r\n          !Object.prototype.hasOwnProperty.call(nodeToUpdate, nodeKey)\r\n        )\r\n          continue;\r\n\r\n        if (!plainValueKeys.has(nodeKey)) {\r\n          delete nodeToUpdate[nodeKey];\r\n        }\r\n      }\r\n    }\r\n\r\n    intelligentMerge(targetNode, newValue);\r\n\r\n    get().notifyPathSubscribers([key, ...path].join('.'), {\r\n      type: 'UPDATE',\r\n      newValue,\r\n    });\r\n  },\r\n\r\n  addItemsToArrayNode: (key, arrayPath, newItems) => {\r\n    const rootKey = shadowStateStore.has(`[${key}`) ? `[${key}` : key;\r\n    let root = shadowStateStore.get(rootKey);\r\n    if (!root) {\r\n      console.error('Root not found for state key:', key);\r\n      return;\r\n    }\r\n\r\n    let current = root;\r\n    for (const segment of arrayPath) {\r\n      if (!current[segment]) {\r\n        current[segment] = {};\r\n      }\r\n      current = current[segment];\r\n    }\r\n\r\n    Object.assign(current, newItems);\r\n  },\r\n  insertShadowArrayElement: (key, arrayPath, newItem, index, itemId) => {\r\n    const arrayNode = get().getShadowNode(key, arrayPath);\r\n    if (!arrayNode?._meta?.arrayKeys) {\r\n      throw new Error(\r\n        `Array not found at path: ${[key, ...arrayPath].join('.')}`\r\n      );\r\n    }\r\n\r\n    const newItemId = itemId || `${generateId(key)}`;\r\n\r\n    // BUILD AND ADD the node directly - no need for addItemsToArrayNode\r\n    arrayNode[newItemId] = buildShadowNode(key, newItem);\r\n\r\n    // Mutate the array directly\r\n    const currentKeys = arrayNode._meta.arrayKeys;\r\n    const insertionPoint =\r\n      index !== undefined && index >= 0 && index <= currentKeys.length\r\n        ? index\r\n        : currentKeys.length;\r\n\r\n    if (insertionPoint >= currentKeys.length) {\r\n      currentKeys.push(newItemId);\r\n    } else {\r\n      currentKeys.splice(insertionPoint, 0, newItemId);\r\n    }\r\n\r\n    // Skip addItemsToArrayNode entirely - we already did everything it does!\r\n\r\n    const arrayKey = [key, ...arrayPath].join('.');\r\n    get().notifyPathSubscribers(arrayKey, {\r\n      type: 'INSERT',\r\n      path: arrayKey,\r\n      itemKey: `${arrayKey}.${newItemId}`,\r\n      index: insertionPoint,\r\n    });\r\n\r\n    return newItemId;\r\n  },\r\n  insertManyShadowArrayElements: (key, arrayPath, newItems, index) => {\r\n    if (!newItems || newItems.length === 0) {\r\n      return;\r\n    }\r\n\r\n    const arrayNode = get().getShadowNode(key, arrayPath);\r\n    if (!arrayNode?._meta?.arrayKeys) {\r\n      console.error(\r\n        `Array not found at path: ${[key, ...arrayPath].join('.')}`\r\n      );\r\n      return;\r\n    }\r\n\r\n    const newIds: string[] = [];\r\n\r\n    // Build and add items directly\r\n    newItems.forEach((item) => {\r\n      const newItemId = `${generateId(key)}`;\r\n      newIds.push(newItemId);\r\n      arrayNode[newItemId] = buildShadowNode(key, item); // ADD DIRECTLY!\r\n    });\r\n\r\n    // Mutate the keys array\r\n    const currentKeys = arrayNode._meta.arrayKeys;\r\n    const insertionPoint =\r\n      index !== undefined && index >= 0 && index <= currentKeys.length\r\n        ? index\r\n        : currentKeys.length;\r\n\r\n    if (insertionPoint >= currentKeys.length) {\r\n      currentKeys.push(...newIds);\r\n    } else {\r\n      currentKeys.splice(insertionPoint, 0, ...newIds);\r\n    }\r\n\r\n    // NO addItemsToArrayNode call needed!\r\n\r\n    const arrayKey = [key, ...arrayPath].join('.');\r\n    get().notifyPathSubscribers(arrayKey, {\r\n      type: 'INSERT_MANY',\r\n      path: arrayKey,\r\n      count: newItems.length,\r\n      index: insertionPoint,\r\n    });\r\n  },\r\n\r\n  removeShadowArrayElement: (key, itemPath) => {\r\n    if (itemPath.length === 0) return;\r\n\r\n    const arrayPath = itemPath.slice(0, -1);\r\n    const itemId = itemPath[itemPath.length - 1];\r\n    if (!itemId?.startsWith('id:')) return;\r\n\r\n    const arrayNode = get().getShadowNode(key, arrayPath);\r\n    if (!arrayNode?._meta?.arrayKeys) return;\r\n\r\n    // Mutate directly\r\n    const currentKeys = arrayNode._meta.arrayKeys;\r\n    const indexToRemove = currentKeys.indexOf(itemId);\r\n\r\n    if (indexToRemove === -1) return;\r\n\r\n    // O(1) for removing from end\r\n    if (indexToRemove === currentKeys.length - 1) {\r\n      currentKeys.pop();\r\n    }\r\n    // O(n) for removing from beginning or middle\r\n    else if (indexToRemove === 0) {\r\n      currentKeys.shift();\r\n    } else {\r\n      currentKeys.splice(indexToRemove, 1);\r\n    }\r\n\r\n    // Delete the actual item\r\n    delete arrayNode[itemId];\r\n\r\n    // No need to update metadata - already mutated!\r\n\r\n    const arrayKey = [key, ...arrayPath].join('.');\r\n    get().notifyPathSubscribers(arrayKey, {\r\n      type: 'REMOVE',\r\n      path: arrayKey,\r\n      itemKey: `${arrayKey}.${itemId}`,\r\n    });\r\n  },\r\n\r\n  registerComponent: (stateKey, fullComponentId, registration) => {\r\n    const rootMeta = get().getShadowMetadata(stateKey, []) || {};\r\n    const components = new Map(rootMeta.components);\r\n    components.set(fullComponentId, registration);\r\n    get().setShadowMetadata(stateKey, [], { components });\r\n  },\r\n\r\n  unregisterComponent: (stateKey, fullComponentId) => {\r\n    const rootMeta = get().getShadowMetadata(stateKey, []);\r\n    if (!rootMeta?.components) return;\r\n    const components = new Map(rootMeta.components);\r\n    if (components.delete(fullComponentId)) {\r\n      get().setShadowMetadata(stateKey, [], { components });\r\n    }\r\n  },\r\n\r\n  addPathComponent: (stateKey, dependencyPath, fullComponentId) => {\r\n    const metadata = get().getShadowMetadata(stateKey, dependencyPath) || {};\r\n    const newPathComponents = new Set(metadata.pathComponents);\r\n    newPathComponents.add(fullComponentId);\r\n    get().setShadowMetadata(stateKey, dependencyPath, {\r\n      pathComponents: newPathComponents,\r\n    });\r\n\r\n    const rootMeta = get().getShadowMetadata(stateKey, []);\r\n    if (rootMeta?.components) {\r\n      const component = rootMeta.components.get(fullComponentId);\r\n      if (component) {\r\n        const fullPathKey = [stateKey, ...dependencyPath].join('.');\r\n        const newPaths = new Set(component.paths);\r\n        newPaths.add(fullPathKey);\r\n        const newComponentRegistration = { ...component, paths: newPaths };\r\n        const newComponentsMap = new Map(rootMeta.components);\r\n        newComponentsMap.set(fullComponentId, newComponentRegistration);\r\n        get().setShadowMetadata(stateKey, [], { components: newComponentsMap });\r\n      }\r\n    }\r\n  },\r\n\r\n  markAsDirty: (key, path, options = { bubble: true }) => {\r\n    // Start at the root node once.\r\n    let rootNode = get().getShadowNode(key, []);\r\n    if (!rootNode) return;\r\n\r\n    // Navigate to the target node once.\r\n    let currentNode = rootNode;\r\n    for (const segment of path) {\r\n      currentNode = currentNode[segment];\r\n      if (!currentNode) return; // Path doesn't exist, nothing to mark.\r\n    }\r\n\r\n    // Mark the target node as dirty.\r\n    if (!currentNode._meta) currentNode._meta = {};\r\n    currentNode._meta.isDirty = true;\r\n\r\n    // If bubbling is disabled, we are done.\r\n    if (!options.bubble) return;\r\n\r\n    // Efficiently bubble up using the path segments.\r\n    let parentNode = rootNode;\r\n    for (let i = 0; i < path.length; i++) {\r\n      // The current node in the loop is the parent of the next one.\r\n      if (parentNode._meta?.isDirty) {\r\n        // Optimization: If a parent is already dirty, all of its ancestors are too.\r\n        // We can stop bubbling immediately.\r\n        return;\r\n      }\r\n      if (!parentNode._meta) parentNode._meta = {};\r\n      parentNode._meta.isDirty = true;\r\n      parentNode = parentNode[path[i]!];\r\n    }\r\n  },\r\n\r\n  // Keep these in Zustand as they need React reactivity\r\n  serverStateUpdates: new Map(),\r\n  setServerStateUpdate: (key, serverState) => {\r\n    set((state) => ({\r\n      serverStateUpdates: new Map(state.serverStateUpdates).set(\r\n        key,\r\n        serverState\r\n      ),\r\n    }));\r\n    get().notifyPathSubscribers(key, {\r\n      type: 'SERVER_STATE_UPDATE',\r\n      serverState,\r\n    });\r\n  },\r\n\r\n  pathSubscribers: new Map<string, Set<(newValue: any) => void>>(),\r\n  subscribeToPath: (path, callback) => {\r\n    const subscribers = get().pathSubscribers;\r\n    const subsForPath = subscribers.get(path) || new Set();\r\n    subsForPath.add(callback);\r\n    subscribers.set(path, subsForPath);\r\n\r\n    return () => {\r\n      const currentSubs = get().pathSubscribers.get(path);\r\n      if (currentSubs) {\r\n        currentSubs.delete(callback);\r\n        if (currentSubs.size === 0) {\r\n          get().pathSubscribers.delete(path);\r\n        }\r\n      }\r\n    };\r\n  },\r\n\r\n  notifyPathSubscribers: (updatedPath, newValue) => {\r\n    const subscribers = get().pathSubscribers;\r\n    const subs = subscribers.get(updatedPath);\r\n    if (subs) {\r\n      subs.forEach((callback) => callback(newValue));\r\n    }\r\n  },\r\n\r\n  selectedIndicesMap: new Map<string, string>(),\r\n  getSelectedIndex: (arrayKey, validIds) => {\r\n    const itemKey = get().selectedIndicesMap.get(arrayKey);\r\n    if (!itemKey) return -1;\r\n\r\n    const arrayMeta = get().getShadowMetadata(\r\n      arrayKey.split('.')[0]!,\r\n      arrayKey.split('.').slice(1)\r\n    );\r\n    const arrayKeys = validIds || arrayMeta?.arrayKeys;\r\n\r\n    return arrayKeys ? arrayKeys.indexOf(itemKey) : -1;\r\n  },\r\n\r\n  setSelectedIndex: (arrayKey: string, itemKey: string | undefined) => {\r\n    set((state) => {\r\n      const newMap = new Map(state.selectedIndicesMap);\r\n\r\n      if (itemKey === undefined) {\r\n        newMap.delete(arrayKey);\r\n      } else {\r\n        if (newMap.has(arrayKey)) {\r\n          get().notifyPathSubscribers(newMap.get(arrayKey)!, {\r\n            type: 'THIS_UNSELECTED',\r\n          });\r\n        }\r\n        newMap.set(arrayKey, itemKey);\r\n        get().notifyPathSubscribers(itemKey, { type: 'THIS_SELECTED' });\r\n      }\r\n\r\n      get().notifyPathSubscribers(arrayKey, { type: 'GET_SELECTED' });\r\n\r\n      return {\r\n        ...state,\r\n        selectedIndicesMap: newMap,\r\n      };\r\n    });\r\n  },\r\n\r\n  clearSelectedIndex: ({ arrayKey }: { arrayKey: string }): void => {\r\n    set((state) => {\r\n      const newMap = new Map(state.selectedIndicesMap);\r\n      const actualKey = newMap.get(arrayKey);\r\n      if (actualKey) {\r\n        get().notifyPathSubscribers(actualKey, {\r\n          type: 'CLEAR_SELECTION',\r\n        });\r\n      }\r\n\r\n      newMap.delete(arrayKey);\r\n      get().notifyPathSubscribers(arrayKey, {\r\n        type: 'CLEAR_SELECTION',\r\n      });\r\n      return {\r\n        ...state,\r\n        selectedIndicesMap: newMap,\r\n      };\r\n    });\r\n  },\r\n\r\n  clearSelectedIndexesForState: (stateKey) => {\r\n    set((state) => {\r\n      const newMap = new Map(state.selectedIndicesMap);\r\n      let changed = false;\r\n      for (const key of newMap.keys()) {\r\n        if (key === stateKey || key.startsWith(stateKey + '.')) {\r\n          newMap.delete(key);\r\n          changed = true;\r\n        }\r\n      }\r\n      return changed ? { selectedIndicesMap: newMap } : {};\r\n    });\r\n  },\r\n\r\n  initialStateOptions: {},\r\n  stateLog: new Map(),\r\n  initialStateGlobal: {},\r\n\r\n  addStateLog: (updates) => {\r\n    if (!updates || updates.length === 0) return;\r\n    set((state) => {\r\n      const newLog = new Map(state.stateLog);\r\n      const logsGroupedByKey = new Map<string, UpdateTypeDetail[]>();\r\n      for (const update of updates) {\r\n        const group = logsGroupedByKey.get(update.stateKey) || [];\r\n        group.push(update);\r\n        logsGroupedByKey.set(update.stateKey, group);\r\n      }\r\n      for (const [key, batchOfUpdates] of logsGroupedByKey.entries()) {\r\n        const newStateLogForKey = new Map(newLog.get(key));\r\n        for (const update of batchOfUpdates) {\r\n          newStateLogForKey.set(JSON.stringify(update.path), { ...update });\r\n        }\r\n        newLog.set(key, newStateLogForKey);\r\n      }\r\n      return { stateLog: newLog };\r\n    });\r\n  },\r\n\r\n  getInitialOptions: (key) => get().initialStateOptions[key],\r\n  setInitialStateOptions: (key, value) => {\r\n    set((prev) => ({\r\n      initialStateOptions: { ...prev.initialStateOptions, [key]: value },\r\n    }));\r\n  },\r\n\r\n  updateInitialStateGlobal: (key, newState) => {\r\n    set((prev) => ({\r\n      initialStateGlobal: { ...prev.initialStateGlobal, [key]: newState },\r\n    }));\r\n  },\r\n\r\n  syncInfoStore: new Map<string, SyncInfo>(),\r\n  setSyncInfo: (key, syncInfo) =>\r\n    set((state) => {\r\n      const newMap = new Map(state.syncInfoStore);\r\n      newMap.set(key, syncInfo);\r\n      return { syncInfoStore: newMap };\r\n    }),\r\n  getSyncInfo: (key) => get().syncInfoStore.get(key) || null,\r\n}));\r\n"],"names":["getTypeFromZodSchema","schema","source","baseSchema","isNullable","isOptional","defaultValue","hasDefault","current","typeName","getTypeFromValue","value","valueType","buildShadowNode","stateKey","context","node","typeInfo","zodV4Path","getSchemaAtPath","zodV3Path","arrayNode","idKeys","item","index","itemId","generateId","itemContext","keys","isSimpleObject","key","propValue","propType","objectNode","propContext","path","segment","shadowStateStore","globalCounter","instanceId","getGlobalStore","create","set","get","pluginName","data","metadata","pluginMetaData","existingData","cacheKey","cacheData","shadowState","storageKey","existingRoot","preservedMetadata","components","features","lastServerSync","stateSource","baseServerState","pathComponents","signals","validation","deepMergeShadowNodes","target","preservedMeta","itemKey","initialState","options","syncSchemas","newRoot","newMetadata","rootKey","root","validArrayIds","startNode","rootResult","stack","currentNode","parentResult","resultKey","keysToIterate","newArray","i","newObject","objectKeys","propKey","newValue","parentNode","targetNode","intelligentMerge","nodeToUpdate","plainValue","oldMeta","newNode","plainValueKeys","childValue","nodeKey","arrayPath","newItems","newItem","newItemId","currentKeys","insertionPoint","arrayKey","newIds","itemPath","indexToRemove","fullComponentId","registration","rootMeta","dependencyPath","newPathComponents","component","fullPathKey","newPaths","newComponentRegistration","newComponentsMap","rootNode","serverState","state","callback","subscribers","subsForPath","currentSubs","updatedPath","subs","validIds","arrayMeta","arrayKeys","newMap","actualKey","changed","updates","newLog","logsGroupedByKey","update","group","batchOfUpdates","newStateLogForKey","prev","newState","syncInfo"],"mappings":"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"}