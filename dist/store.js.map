{"version":3,"file":"store.js","sources":["../src/store.ts"],"sourcesContent":["import { create } from 'zustand';\r\nimport { ulid } from 'ulid';\r\nimport type {\r\n  OptionsType,\r\n  ReactivityType,\r\n  StateKeys,\r\n  SyncInfo,\r\n  UpdateTypeDetail,\r\n} from './CogsState.js';\r\n\r\nimport type { ReactNode } from 'react';\r\n\r\ntype StateUpdater<StateValue> =\r\n  | StateValue\r\n  | ((prevValue: StateValue) => StateValue);\r\n\r\nexport type FreshValuesObject = {\r\n  pathsToValues?: string[];\r\n  prevValue?: any;\r\n  newValue?: any;\r\n  timeStamp: number;\r\n};\r\n\r\ntype SyncLogType = {\r\n  timeStamp: number;\r\n};\r\ntype StateValue = any;\r\n\r\nexport type TrieNode = {\r\n  subscribers: Set<string>;\r\n  children: Map<string, TrieNode>;\r\n};\r\n\r\nexport type FormRefStoreState = {\r\n  formRefs: Map<string, React.RefObject<any>>;\r\n  registerFormRef: (id: string, ref: React.RefObject<any>) => void;\r\n  getFormRef: (id: string) => React.RefObject<any> | undefined;\r\n  removeFormRef: (id: string) => void;\r\n  // New method to get all refs for a stateKey\r\n  getFormRefsByStateKey: (\r\n    stateKey: string\r\n  ) => Map<string, React.RefObject<any>>;\r\n};\r\n\r\nexport const formRefStore = create<FormRefStoreState>((set, get) => ({\r\n  formRefs: new Map(),\r\n\r\n  registerFormRef: (id, ref) =>\r\n    set((state) => {\r\n      const newRefs = new Map(state.formRefs);\r\n      newRefs.set(id, ref);\r\n      return { formRefs: newRefs };\r\n    }),\r\n\r\n  getFormRef: (id) => get().formRefs.get(id),\r\n\r\n  removeFormRef: (id) =>\r\n    set((state) => {\r\n      const newRefs = new Map(state.formRefs);\r\n      newRefs.delete(id);\r\n      return { formRefs: newRefs };\r\n    }),\r\n\r\n  // Get all refs that start with the stateKey prefix\r\n  getFormRefsByStateKey: (stateKey) => {\r\n    const allRefs = get().formRefs;\r\n    const stateKeyPrefix = stateKey + '.';\r\n    const filteredRefs = new Map();\r\n\r\n    allRefs.forEach((ref, id) => {\r\n      if (id.startsWith(stateKeyPrefix) || id === stateKey) {\r\n        filteredRefs.set(id, ref);\r\n      }\r\n    });\r\n\r\n    return filteredRefs;\r\n  },\r\n}));\r\nexport type ComponentsType = {\r\n  components?: Map<\r\n    string,\r\n    {\r\n      forceUpdate: () => void;\r\n      paths: Set<string>;\r\n      deps?: any[];\r\n      prevDeps?: any[];\r\n      depsFunction?: (state: any) => any[] | true;\r\n      reactiveType: ReactivityType[] | ReactivityType;\r\n    }\r\n  >;\r\n};\r\nexport type ShadowMetadata = {\r\n  id?: string;\r\n\r\n  stateSource?: 'default' | 'server' | 'localStorage';\r\n  lastServerSync?: number;\r\n  isDirty?: boolean;\r\n  baseServerState?: any;\r\n\r\n  arrayKeys?: string[];\r\n\r\n  fields?: Record<string, any>;\r\n  virtualizer?: {\r\n    itemHeight?: number;\r\n    domRef?: HTMLElement | null;\r\n  };\r\n  syncInfo?: { status: string };\r\n  validation?: ValidationState;\r\n  lastUpdated?: number;\r\n  value?: any;\r\n  classSignals?: Array<{\r\n    // <-- ADD THIS BLOCK\r\n    id: string;\r\n    effect: string;\r\n    lastClasses: string;\r\n    deps: any[];\r\n  }>;\r\n  signals?: Array<{\r\n    instanceId: string;\r\n    parentId: string;\r\n    position: number;\r\n    effect?: string;\r\n  }>;\r\n  mapWrappers?: Array<{\r\n    instanceId: string;\r\n    path: string[];\r\n    componentId: string;\r\n    meta?: any;\r\n    mapFn: (\r\n      setter: any,\r\n      index: number,\r\n\r\n      arraySetter: any\r\n    ) => ReactNode;\r\n    containerRef: HTMLDivElement | null;\r\n    rebuildStateShape: any;\r\n  }>;\r\n  transformCaches?: Map<\r\n    string,\r\n    {\r\n      validIds: string[];\r\n      computedAt: number;\r\n      transforms: Array<{ type: 'filter' | 'sort'; fn: Function }>;\r\n    }\r\n  >;\r\n  pathComponents?: Set<string>;\r\n  streams?: Map<\r\n    string,\r\n    {\r\n      buffer: any[];\r\n      flushTimer: NodeJS.Timeout | null;\r\n    }\r\n  >;\r\n} & ComponentsType;\r\n\r\nexport type ValidationStatus =\r\n  | 'PRISTINE' // Untouched, matches initial state.\r\n  | 'DIRTY' // Changed, but no validation run yet.\r\n  | 'INVALID_LIVE' // Gentle error during typing.\r\n  | 'VALIDATION_FAILED' // Hard error on blur/submit.\r\n  | 'VALID_PENDING_SYNC' // Passed validation, ready for sync.\r\n  | 'SYNCING' // Actively being sent to the server.\r\n  | 'SYNCED' // Server confirmed success.\r\n  | 'SYNC_FAILED'; // Server rejected the data.\r\n\r\nexport type ValidationState = {\r\n  status: ValidationStatus;\r\n  message?: string;\r\n  lastValidated?: number;\r\n  validatedValue?: any;\r\n};\r\nexport type CogsEvent =\r\n  | { type: 'INSERT'; path: string; itemKey: string; index: number }\r\n  | { type: 'REMOVE'; path: string; itemKey: string }\r\n  | { type: 'UPDATE'; path: string; newValue: any }\r\n  | { type: 'ITEMHEIGHT'; itemKey: string; height: number } // For full re-initializations (e.g., when a component is removed)\r\n  | { type: 'RELOAD'; path: string }; // For full re-initializations\r\nexport type CogsGlobalState = {\r\n  // --- Shadow State and Subscription System ---\r\n  registerComponent: (\r\n    stateKey: string,\r\n    componentId: string,\r\n    registration: any\r\n  ) => void;\r\n  unregisterComponent: (stateKey: string, componentId: string) => void;\r\n  addPathComponent: (\r\n    stateKey: string,\r\n    dependencyPath: string[],\r\n    fullComponentId: string\r\n  ) => void;\r\n  shadowStateStore: Map<string, ShadowMetadata>;\r\n  markAsDirty: (\r\n    key: string,\r\n    path: string[],\r\n    options: { bubble: boolean }\r\n  ) => void;\r\n  // These method signatures stay the same\r\n  initializeShadowState: (key: string, initialState: any) => void;\r\n  updateShadowAtPath: (key: string, path: string[], newValue: any) => void;\r\n  insertShadowArrayElement: (\r\n    key: string,\r\n    arrayPath: string[],\r\n    newItem: any\r\n  ) => void;\r\n  removeShadowArrayElement: (key: string, arrayPath: string[]) => void;\r\n  getShadowValue: (\r\n    key: string,\r\n\r\n    validArrayIds?: string[]\r\n  ) => any;\r\n\r\n  getShadowMetadata: (\r\n    key: string,\r\n    path: string[]\r\n  ) => ShadowMetadata | undefined;\r\n  setShadowMetadata: (\r\n    key: string,\r\n    path: string[],\r\n    metadata: Omit<ShadowMetadata, 'id'>\r\n  ) => void;\r\n  setTransformCache: (\r\n    key: string,\r\n    path: string[],\r\n    cacheKey: string,\r\n    cacheData: any\r\n  ) => void;\r\n\r\n  pathSubscribers: Map<string, Set<(newValue: any) => void>>;\r\n  subscribeToPath: (\r\n    path: string,\r\n    callback: (newValue: any) => void\r\n  ) => () => void;\r\n  notifyPathSubscribers: (updatedPath: string, newValue: any) => void;\r\n\r\n  selectedIndicesMap: Map<string, string>; // stateKey -> (parentPath -> selectedIndex)\r\n  getSelectedIndex: (stateKey: string, validArrayIds?: string[]) => number;\r\n  setSelectedIndex: (key: string, itemKey: string) => void;\r\n  clearSelectedIndex: ({ arrayKey }: { arrayKey: string }) => void;\r\n  clearSelectedIndexesForState: (stateKey: string) => void;\r\n\r\n  // --- Core State and Updaters ---\r\n\r\n  initialStateOptions: { [key: string]: OptionsType };\r\n\r\n  initialStateGlobal: { [key: string]: StateValue };\r\n\r\n  updateInitialStateGlobal: (key: string, newState: StateValue) => void;\r\n\r\n  getInitialOptions: (key: string) => OptionsType | undefined;\r\n  setInitialStateOptions: (key: string, value: OptionsType) => void;\r\n\r\n  // --- Validation ---\r\n  validationErrors: Map<string, string[]>;\r\n  addValidationError: (path: string, message: string) => void;\r\n  getValidationErrors: (path: string) => string[];\r\n  removeValidationError: (path: string) => void;\r\n\r\n  // --- Server Sync and Logging ---\r\n\r\n  serverStateUpdates: Map<\r\n    string,\r\n    {\r\n      data: any;\r\n      status: 'loading' | 'success' | 'error';\r\n      timestamp: number;\r\n    }\r\n  >;\r\n\r\n  setServerStateUpdate: (key: string, serverState: any) => void;\r\n\r\n  stateLog: { [key: string]: UpdateTypeDetail[] };\r\n  syncInfoStore: Map<string, SyncInfo>;\r\n\r\n  setStateLog: (\r\n    key: string,\r\n    updater: (prevUpdates: UpdateTypeDetail[]) => UpdateTypeDetail[]\r\n  ) => void;\r\n  setSyncInfo: (key: string, syncInfo: SyncInfo) => void;\r\n  getSyncInfo: (key: string) => SyncInfo | null;\r\n};\r\nconst isSimpleObject = (value: any): boolean => {\r\n  if (value === null || typeof value !== 'object') return false;\r\n\r\n  // Handle special cases that should be treated as primitives\r\n  if (\r\n    value instanceof Uint8Array ||\r\n    value instanceof Int8Array ||\r\n    value instanceof Uint16Array ||\r\n    value instanceof Int16Array ||\r\n    value instanceof Uint32Array ||\r\n    value instanceof Int32Array ||\r\n    value instanceof Float32Array ||\r\n    value instanceof Float64Array ||\r\n    value instanceof ArrayBuffer ||\r\n    value instanceof Date ||\r\n    value instanceof RegExp ||\r\n    value instanceof Map ||\r\n    value instanceof Set\r\n  ) {\r\n    return false; // Treat as primitive\r\n  }\r\n\r\n  // Arrays and plain objects are complex\r\n  return Array.isArray(value) || value.constructor === Object;\r\n};\r\nexport const getGlobalStore = create<CogsGlobalState>((set, get) => ({\r\n  addPathComponent: (stateKey, dependencyPath, fullComponentId) => {\r\n    set((state) => {\r\n      const newShadowStore = new Map(state.shadowStateStore);\r\n      const dependencyKey = [stateKey, ...dependencyPath].join('.');\r\n\r\n      // --- Part 1: Update the path's own metadata ---\r\n      const pathMeta = newShadowStore.get(dependencyKey) || {};\r\n      // Create a *new* Set to ensure immutability\r\n      const pathComponents = new Set(pathMeta.pathComponents);\r\n      pathComponents.add(fullComponentId);\r\n      // Update the metadata for the specific path\r\n      newShadowStore.set(dependencyKey, { ...pathMeta, pathComponents });\r\n\r\n      // --- Part 2: Update the component's own list of paths ---\r\n      const rootMeta = newShadowStore.get(stateKey) || {};\r\n      const component = rootMeta.components?.get(fullComponentId);\r\n\r\n      // If the component exists, update its `paths` set immutably\r\n      if (component) {\r\n        const newPaths = new Set(component.paths);\r\n        newPaths.add(dependencyKey);\r\n\r\n        const newComponentRegistration = { ...component, paths: newPaths };\r\n        const newComponentsMap = new Map(rootMeta.components);\r\n        newComponentsMap.set(fullComponentId, newComponentRegistration);\r\n\r\n        // Update the root metadata with the new components map\r\n        newShadowStore.set(stateKey, {\r\n          ...rootMeta,\r\n          components: newComponentsMap,\r\n        });\r\n      }\r\n\r\n      // Return the final, updated state\r\n      return { shadowStateStore: newShadowStore };\r\n    });\r\n  },\r\n  registerComponent: (stateKey, fullComponentId, registration) => {\r\n    set((state) => {\r\n      // Create a new Map to ensure Zustand detects the change\r\n      const newShadowStore = new Map(state.shadowStateStore);\r\n\r\n      // Get the metadata for the ROOT of the state (where the components map lives)\r\n      const rootMeta = newShadowStore.get(stateKey) || {};\r\n\r\n      // Also clone the components map to avoid direct mutation\r\n      const components = new Map(rootMeta.components);\r\n      components.set(fullComponentId, registration);\r\n\r\n      // Update the root metadata with the new components map\r\n      newShadowStore.set(stateKey, { ...rootMeta, components });\r\n\r\n      // Return the updated state\r\n      return { shadowStateStore: newShadowStore };\r\n    });\r\n  },\r\n\r\n  unregisterComponent: (stateKey, fullComponentId) => {\r\n    set((state) => {\r\n      const newShadowStore = new Map(state.shadowStateStore);\r\n      const rootMeta = newShadowStore.get(stateKey);\r\n\r\n      // If there's no metadata or no components map, do nothing\r\n      if (!rootMeta?.components) {\r\n        return state; // Return original state, no change needed\r\n      }\r\n\r\n      const components = new Map(rootMeta.components);\r\n      const wasDeleted = components.delete(fullComponentId);\r\n\r\n      // Only update state if something was actually deleted\r\n      if (wasDeleted) {\r\n        newShadowStore.set(stateKey, { ...rootMeta, components });\r\n        return { shadowStateStore: newShadowStore };\r\n      }\r\n\r\n      return state; // Nothing changed\r\n    });\r\n  },\r\n  markAsDirty: (key: string, path: string[], options = { bubble: true }) => {\r\n    const newShadowStore = new Map(get().shadowStateStore);\r\n    let changed = false;\r\n\r\n    const setDirty = (currentPath: string[]) => {\r\n      const fullKey = [key, ...currentPath].join('.');\r\n      const meta = newShadowStore.get(fullKey);\r\n\r\n      // We mark something as dirty if it isn't already.\r\n      // The original data source doesn't matter.\r\n      if (meta && meta.isDirty !== true) {\r\n        newShadowStore.set(fullKey, { ...meta, isDirty: true });\r\n        changed = true;\r\n      } else if (!meta) {\r\n        // If there's no metadata, create it and mark it as dirty.\r\n        // This handles newly created fields within an object.\r\n        newShadowStore.set(fullKey, { isDirty: true });\r\n        changed = true;\r\n      }\r\n    };\r\n\r\n    // 1. Mark the target path itself as dirty.\r\n    setDirty(path);\r\n\r\n    // 2. If `bubble` is true, walk up the path and mark all parents as dirty.\r\n    if (options.bubble) {\r\n      let parentPath = [...path];\r\n      while (parentPath.length > 0) {\r\n        parentPath.pop();\r\n        setDirty(parentPath);\r\n      }\r\n    }\r\n\r\n    if (changed) {\r\n      set({ shadowStateStore: newShadowStore });\r\n    }\r\n  },\r\n  serverStateUpdates: new Map(),\r\n  setServerStateUpdate: (key, serverState) => {\r\n    set((state) => {\r\n      const newMap = new Map(state.serverStateUpdates);\r\n      newMap.set(key, serverState);\r\n      return { serverStateUpdates: newMap };\r\n    });\r\n\r\n    // Notify all subscribers for this key\r\n    get().notifyPathSubscribers(key, {\r\n      type: 'SERVER_STATE_UPDATE',\r\n      serverState,\r\n    });\r\n  },\r\n  shadowStateStore: new Map(),\r\n  pathSubscribers: new Map<string, Set<(newValue: any) => void>>(),\r\n\r\n  subscribeToPath: (path, callback) => {\r\n    const subscribers = get().pathSubscribers;\r\n    const subsForPath = subscribers.get(path) || new Set();\r\n    subsForPath.add(callback);\r\n    subscribers.set(path, subsForPath);\r\n\r\n    return () => {\r\n      const currentSubs = get().pathSubscribers.get(path);\r\n      if (currentSubs) {\r\n        currentSubs.delete(callback);\r\n        if (currentSubs.size === 0) {\r\n          get().pathSubscribers.delete(path);\r\n        }\r\n      }\r\n    };\r\n  },\r\n\r\n  notifyPathSubscribers: (updatedPath, newValue) => {\r\n    const subscribers = get().pathSubscribers;\r\n    const subs = subscribers.get(updatedPath);\r\n\r\n    if (subs) {\r\n      subs.forEach((callback) => callback(newValue));\r\n    }\r\n  },\r\n\r\n  initializeShadowState: (key: string, initialState: any) => {\r\n    set((state) => {\r\n      // 1. Make a copy of the current store to modify it\r\n      const newShadowStore = new Map(state.shadowStateStore);\r\n\r\n      // 2. PRESERVE the existing components map before doing anything else\r\n      const existingRootMeta = newShadowStore.get(key);\r\n      const preservedComponents = existingRootMeta?.components;\r\n\r\n      // 3. Wipe all old shadow entries for this state key\r\n      const prefixToDelete = key + '.';\r\n      for (const k of Array.from(newShadowStore.keys())) {\r\n        if (k === key || k.startsWith(prefixToDelete)) {\r\n          newShadowStore.delete(k);\r\n        }\r\n      }\r\n\r\n      // 4. Run your original logic to rebuild the state tree from scratch\r\n      const processValue = (value: any, path: string[]) => {\r\n        const nodeKey = [key, ...path].join('.');\r\n\r\n        if (Array.isArray(value)) {\r\n          const childIds: string[] = [];\r\n          value.forEach(() => {\r\n            const itemId = `id:${ulid()}`;\r\n            childIds.push(nodeKey + '.' + itemId);\r\n          });\r\n          newShadowStore.set(nodeKey, { arrayKeys: childIds });\r\n          value.forEach((item, index) => {\r\n            const itemId = childIds[index]!.split('.').pop();\r\n            processValue(item, [...path!, itemId!]);\r\n          });\r\n        } else if (isSimpleObject(value)) {\r\n          const fields = Object.fromEntries(\r\n            Object.keys(value).map((k) => [k, nodeKey + '.' + k])\r\n          );\r\n          newShadowStore.set(nodeKey, { fields });\r\n          Object.keys(value).forEach((k) => {\r\n            processValue(value[k], [...path, k]);\r\n          });\r\n        } else {\r\n          newShadowStore.set(nodeKey, { value });\r\n        }\r\n      };\r\n      processValue(initialState, []);\r\n\r\n      // 5. RESTORE the preserved components map onto the new root metadata\r\n      if (preservedComponents) {\r\n        const newRootMeta = newShadowStore.get(key) || {};\r\n        newShadowStore.set(key, {\r\n          ...newRootMeta,\r\n          components: preservedComponents,\r\n        });\r\n      }\r\n\r\n      // 6. Return the completely updated state\r\n      return { shadowStateStore: newShadowStore };\r\n    });\r\n  },\r\n\r\n  getShadowValue: (fullKey: string, validArrayIds?: string[]) => {\r\n    const shadowMeta = get().shadowStateStore.get(fullKey);\r\n\r\n    // If no metadata found, return undefined\r\n    if (!shadowMeta) {\r\n      return undefined;\r\n    }\r\n\r\n    // For primitive values, return the value\r\n    if (shadowMeta.value !== undefined) {\r\n      return shadowMeta.value;\r\n    }\r\n\r\n    // For arrays, reconstruct with possible validArrayIds\r\n    if (shadowMeta.arrayKeys) {\r\n      const arrayKeys = validArrayIds ?? shadowMeta.arrayKeys;\r\n      const items = arrayKeys.map((itemKey) => {\r\n        // RECURSIVELY call getShadowValue for each item\r\n        return get().getShadowValue(itemKey);\r\n      });\r\n      return items;\r\n    }\r\n\r\n    // For objects with fields, reconstruct object\r\n    if (shadowMeta.fields) {\r\n      const reconstructedObject: any = {};\r\n      Object.entries(shadowMeta.fields).forEach(([key, fieldPath]) => {\r\n        // RECURSIVELY call getShadowValue for each field\r\n        reconstructedObject[key] = get().getShadowValue(fieldPath as string);\r\n      });\r\n      return reconstructedObject;\r\n    }\r\n\r\n    return undefined;\r\n  },\r\n  getShadowMetadata: (\r\n    key: string,\r\n    path: string[],\r\n    validArrayIds?: string[]\r\n  ) => {\r\n    const fullKey = [key, ...path].join('.');\r\n    let data = get().shadowStateStore.get(fullKey);\r\n\r\n    return get().shadowStateStore.get(fullKey);\r\n  },\r\n\r\n  setShadowMetadata: (key, path, metadata) => {\r\n    const fullKey = [key, ...path].join('.');\r\n    const existingMeta = get().shadowStateStore.get(fullKey);\r\n\r\n    // --- THIS IS THE TRAP ---\r\n    // If the existing metadata HAS a components map, but the NEW metadata DOES NOT,\r\n    // it means we are about to wipe it out. This is the bug.\r\n    if (existingMeta?.components && !metadata.components) {\r\n      console.group(\r\n        '%c🚨 RACE CONDITION DETECTED! 🚨',\r\n        'color: red; font-size: 18px; font-weight: bold;'\r\n      );\r\n      console.error(\r\n        `An overwrite is about to happen on stateKey: \"${key}\" at path: [${path.join(', ')}]`\r\n      );\r\n      console.log(\r\n        'The EXISTING metadata had a components map:',\r\n        existingMeta.components\r\n      );\r\n      console.log(\r\n        'The NEW metadata is trying to save WITHOUT a components map:',\r\n        metadata\r\n      );\r\n      console.log(\r\n        '%cStack trace to the function that caused this overwrite:',\r\n        'font-weight: bold;'\r\n      );\r\n      console.trace(); // This prints the call stack, leading you to the bad code.\r\n      console.groupEnd();\r\n    }\r\n    // --- END OF TRAP ---\r\n\r\n    const newShadowStore = new Map(get().shadowStateStore);\r\n    const finalMeta = { ...(existingMeta || {}), ...metadata };\r\n    newShadowStore.set(fullKey, finalMeta);\r\n    set({ shadowStateStore: newShadowStore });\r\n  },\r\n  setTransformCache: (\r\n    key: string,\r\n    path: string[],\r\n    cacheKey: string,\r\n    cacheData: any\r\n  ) => {\r\n    const fullKey = [key, ...path].join('.');\r\n    const newShadowStore = new Map(get().shadowStateStore);\r\n    const existing = newShadowStore.get(fullKey) || {};\r\n\r\n    // Initialize transformCaches if it doesn't exist\r\n    if (!existing.transformCaches) {\r\n      existing.transformCaches = new Map();\r\n    }\r\n\r\n    // Update just the specific cache entry\r\n    existing.transformCaches.set(cacheKey, cacheData);\r\n\r\n    // Update shadow store WITHOUT notifying path subscribers\r\n    newShadowStore.set(fullKey, existing);\r\n    set({ shadowStateStore: newShadowStore });\r\n\r\n    // Don't call notifyPathSubscribers here - cache updates shouldn't trigger renders\r\n  },\r\n  insertShadowArrayElement: (\r\n    key: string,\r\n    arrayPath: string[],\r\n    newItem: any\r\n  ) => {\r\n    const newShadowStore = new Map(get().shadowStateStore);\r\n    const arrayKey = [key, ...arrayPath].join('.');\r\n    const parentMeta = newShadowStore.get(arrayKey);\r\n\r\n    if (!parentMeta || !parentMeta.arrayKeys) return;\r\n\r\n    const newItemId = `id:${ulid()}`;\r\n    const fullItemKey = arrayKey + '.' + newItemId;\r\n\r\n    // Just add to the end (or at a specific index if provided)\r\n    const newArrayKeys = [...parentMeta.arrayKeys];\r\n    newArrayKeys.push(fullItemKey); // Or use splice if you have an index\r\n    newShadowStore.set(arrayKey, { ...parentMeta, arrayKeys: newArrayKeys });\r\n\r\n    // Process the new item - but use the correct logic\r\n    const processNewItem = (value: any, path: string[]) => {\r\n      const nodeKey = [key, ...path].join('.');\r\n\r\n      if (Array.isArray(value)) {\r\n        // Handle arrays...\r\n      } else if (typeof value === 'object' && value !== null) {\r\n        // Create fields mapping\r\n        const fields = Object.fromEntries(\r\n          Object.keys(value).map((k) => [k, nodeKey + '.' + k])\r\n        );\r\n        newShadowStore.set(nodeKey, { fields });\r\n\r\n        // Process each field\r\n        Object.entries(value).forEach(([k, v]) => {\r\n          processNewItem(v, [...path, k]);\r\n        });\r\n      } else {\r\n        // Primitive value\r\n        newShadowStore.set(nodeKey, { value });\r\n      }\r\n    };\r\n\r\n    processNewItem(newItem, [...arrayPath, newItemId]);\r\n    set({ shadowStateStore: newShadowStore });\r\n\r\n    get().notifyPathSubscribers(arrayKey, {\r\n      type: 'INSERT',\r\n      path: arrayKey,\r\n      itemKey: fullItemKey,\r\n    });\r\n  },\r\n  removeShadowArrayElement: (key: string, itemPath: string[]) => {\r\n    const newShadowStore = new Map(get().shadowStateStore);\r\n\r\n    // Get the full item key (e.g., \"stateKey.products.id:xxx\")\r\n    const itemKey = [key, ...itemPath].join('.');\r\n\r\n    // Extract parent path and item ID\r\n    const parentPath = itemPath.slice(0, -1);\r\n    const parentKey = [key, ...parentPath].join('.');\r\n\r\n    // Get parent metadata\r\n    const parentMeta = newShadowStore.get(parentKey);\r\n\r\n    if (parentMeta && parentMeta.arrayKeys) {\r\n      // Find the index of the item to remove\r\n      const indexToRemove = parentMeta.arrayKeys.findIndex(\r\n        (arrayItemKey) => arrayItemKey === itemKey\r\n      );\r\n\r\n      if (indexToRemove !== -1) {\r\n        // Create new array keys with the item removed\r\n        const newArrayKeys = parentMeta.arrayKeys.filter(\r\n          (arrayItemKey) => arrayItemKey !== itemKey\r\n        );\r\n\r\n        // Update parent with new array keys\r\n        newShadowStore.set(parentKey, {\r\n          ...parentMeta,\r\n          arrayKeys: newArrayKeys,\r\n        });\r\n\r\n        // Delete all data associated with the removed item\r\n        const prefixToDelete = itemKey + '.';\r\n        for (const k of Array.from(newShadowStore.keys())) {\r\n          if (k === itemKey || k.startsWith(prefixToDelete)) {\r\n            newShadowStore.delete(k);\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    set({ shadowStateStore: newShadowStore });\r\n\r\n    get().notifyPathSubscribers(parentKey, {\r\n      type: 'REMOVE',\r\n      path: parentKey,\r\n      itemKey: itemKey, // The exact ID of the removed item\r\n    });\r\n  },\r\n  updateShadowAtPath: (key, path, newValue) => {\r\n    const newShadowStore = new Map(get().shadowStateStore);\r\n    const fullKey = [key, ...path].join('.');\r\n\r\n    const updateValue = (currentKey: string, valueToSet: any) => {\r\n      const meta = newShadowStore.get(currentKey);\r\n\r\n      // If it's a simple object with fields, update recursively\r\n      if (isSimpleObject(valueToSet) && meta && meta.fields) {\r\n        for (const fieldKey in valueToSet) {\r\n          if (Object.prototype.hasOwnProperty.call(valueToSet, fieldKey)) {\r\n            const childPath = meta.fields[fieldKey];\r\n            const childValue = valueToSet[fieldKey];\r\n\r\n            if (childPath) {\r\n              updateValue(childPath as string, childValue);\r\n            }\r\n          }\r\n        }\r\n      } else {\r\n        // For primitives (including Uint8Array), just replace the value\r\n        // This gives you useState-like behavior\r\n        const existing = newShadowStore.get(currentKey) || {};\r\n        newShadowStore.set(currentKey, { ...existing, value: valueToSet });\r\n      }\r\n    };\r\n\r\n    updateValue(fullKey, newValue);\r\n    get().notifyPathSubscribers(fullKey, { type: 'UPDATE', newValue });\r\n    set({ shadowStateStore: newShadowStore });\r\n  },\r\n  selectedIndicesMap: new Map<string, string>(),\r\n  getSelectedIndex: (arrayKey: string, validIds?: string[]): number => {\r\n    const itemKey = get().selectedIndicesMap.get(arrayKey);\r\n\r\n    if (!itemKey) return -1;\r\n\r\n    // Use validIds if provided (for filtered views), otherwise use all arrayKeys\r\n    const arrayKeys =\r\n      validIds ||\r\n      getGlobalStore.getState().getShadowMetadata(arrayKey, [])?.arrayKeys;\r\n\r\n    if (!arrayKeys) return -1;\r\n\r\n    return arrayKeys.indexOf(itemKey);\r\n  },\r\n\r\n  setSelectedIndex: (arrayKey: string, itemKey: string | undefined) => {\r\n    set((state) => {\r\n      const newMap = state.selectedIndicesMap;\r\n\r\n      if (itemKey === undefined) {\r\n        newMap.delete(arrayKey);\r\n      } else {\r\n        if (newMap.has(arrayKey)) {\r\n          get().notifyPathSubscribers(newMap.get(arrayKey)!, {\r\n            type: 'THIS_UNSELECTED',\r\n          });\r\n        }\r\n        newMap.set(arrayKey, itemKey);\r\n\r\n        get().notifyPathSubscribers(itemKey, {\r\n          type: 'THIS_SELECTED',\r\n        });\r\n      }\r\n      get().notifyPathSubscribers(arrayKey, {\r\n        type: 'GET_SELECTED',\r\n      });\r\n      return {\r\n        ...state,\r\n        selectedIndicesMap: newMap,\r\n      };\r\n    });\r\n  },\r\n  clearSelectedIndex: ({ arrayKey }: { arrayKey: string }): void => {\r\n    set((state) => {\r\n      const newMap = state.selectedIndicesMap;\r\n      const acutalKey = newMap.get(arrayKey);\r\n      if (acutalKey) {\r\n        get().notifyPathSubscribers(acutalKey, {\r\n          type: 'CLEAR_SELECTION',\r\n        });\r\n      }\r\n\r\n      newMap.delete(arrayKey);\r\n      get().notifyPathSubscribers(arrayKey, {\r\n        type: 'CLEAR_SELECTION',\r\n      });\r\n      return {\r\n        ...state,\r\n        selectedIndicesMap: newMap,\r\n      };\r\n    });\r\n  },\r\n  clearSelectedIndexesForState: (stateKey: string) => {\r\n    set((state) => {\r\n      const newOuterMap = new Map(state.selectedIndicesMap);\r\n      const changed = newOuterMap.delete(stateKey);\r\n      if (changed) {\r\n        return { selectedIndicesMap: newOuterMap };\r\n      } else {\r\n        return {};\r\n      }\r\n    });\r\n  },\r\n\r\n  initialStateOptions: {},\r\n\r\n  stateTimeline: {},\r\n  cogsStateStore: {},\r\n  stateLog: {},\r\n\r\n  initialStateGlobal: {},\r\n\r\n  validationErrors: new Map(),\r\n\r\n  setStateLog: (\r\n    key: string,\r\n    updater: (prevUpdates: UpdateTypeDetail[]) => UpdateTypeDetail[]\r\n  ) => {\r\n    set((prev) => {\r\n      const currentUpdates = prev.stateLog[key] ?? [];\r\n      const newUpdates = updater(currentUpdates);\r\n      return {\r\n        stateLog: {\r\n          ...prev.stateLog,\r\n          [key]: newUpdates,\r\n        },\r\n      };\r\n    });\r\n  },\r\n\r\n  addValidationError: (path, message) => {\r\n    set((prev) => {\r\n      const updatedErrors = new Map(prev.validationErrors);\r\n      const existingMessages = updatedErrors.get(path) || [];\r\n      console.log('addValidationError', path, message, existingMessages);\r\n      // Append the new message instead of replacing\r\n      updatedErrors.set(path, [...existingMessages, message]);\r\n      return { validationErrors: updatedErrors };\r\n    });\r\n  },\r\n  removeValidationError: (path) => {\r\n    set((prev) => {\r\n      const updatedErrors = new Map(prev.validationErrors);\r\n\r\n      let doSomething = false;\r\n      const pathArray = path.split('.');\r\n      Array.from(updatedErrors.keys()).forEach((key) => {\r\n        const keyArray = key.split('.');\r\n        if (keyArray.length >= pathArray.length) {\r\n          let match = true;\r\n          for (let i = 0; i < pathArray.length; i++) {\r\n            if (keyArray[i] !== pathArray[i]) {\r\n              match = false;\r\n              break;\r\n            }\r\n          }\r\n\r\n          if (match) {\r\n            doSomething = true;\r\n            updatedErrors.delete(key);\r\n          }\r\n        }\r\n      });\r\n\r\n      return doSomething ? { validationErrors: updatedErrors } : prev;\r\n    });\r\n  },\r\n  getValidationErrors: (path: string) => {\r\n    const errors: string[] = [];\r\n    const valErrors = get().validationErrors;\r\n    const pathArray = path.split('.');\r\n\r\n    // Helper to check if an index matches either a wildcard or is in an array of indices\r\n    const isIndexMatch = (pathSegment: string, keySegment: string) => {\r\n      if (pathSegment === '[*]') return true;\r\n      if (Array.isArray(pathSegment)) {\r\n        return pathSegment.includes(parseInt(keySegment));\r\n      }\r\n      return pathSegment === keySegment;\r\n    };\r\n\r\n    Array.from(valErrors.keys()).forEach((key) => {\r\n      const keyArray = key.split('.');\r\n      if (keyArray.length >= pathArray.length) {\r\n        let match = true;\r\n        for (let i = 0; i < pathArray.length; i++) {\r\n          const pathSegment = pathArray[i];\r\n          const keySegment = keyArray[i]!;\r\n\r\n          // If current path segment is a number or [*], we need special handling\r\n          if (pathSegment === '[*]' || Array.isArray(pathSegment)) {\r\n            // Key segment should be a number if we're using [*] or array indices\r\n            const keyIndex = parseInt(keySegment);\r\n            if (isNaN(keyIndex)) {\r\n              match = false;\r\n              break;\r\n            }\r\n\r\n            if (!isIndexMatch(pathSegment, keySegment)) {\r\n              match = false;\r\n              break;\r\n            }\r\n          } else if (pathSegment !== keySegment) {\r\n            match = false;\r\n            break;\r\n          }\r\n        }\r\n\r\n        if (match) {\r\n          const errorMessages = valErrors.get(key);\r\n          if (errorMessages) {\r\n            errors.push(...errorMessages);\r\n          }\r\n        }\r\n      }\r\n    });\r\n\r\n    return errors;\r\n  },\r\n  getInitialOptions: (key) => {\r\n    return get().initialStateOptions[key];\r\n  },\r\n\r\n  setInitialStateOptions: (key, value) => {\r\n    set((prev) => ({\r\n      initialStateOptions: {\r\n        ...prev.initialStateOptions,\r\n        [key]: value,\r\n      },\r\n    }));\r\n  },\r\n  updateInitialStateGlobal: (key, newState) => {\r\n    set((prev) => ({\r\n      initialStateGlobal: {\r\n        ...prev.initialStateGlobal,\r\n        [key]: newState,\r\n      },\r\n    }));\r\n  },\r\n\r\n  syncInfoStore: new Map<string, SyncInfo>(),\r\n  setSyncInfo: (key: string, syncInfo: SyncInfo) =>\r\n    set((state) => {\r\n      const newMap = new Map(state.syncInfoStore);\r\n      newMap.set(key, syncInfo);\r\n      return { ...state, syncInfoStore: newMap };\r\n    }),\r\n  getSyncInfo: (key: string) => get().syncInfoStore.get(key) || null,\r\n}));\r\n"],"names":["formRefStore","create","set","get","id","ref","state","newRefs","stateKey","allRefs","stateKeyPrefix","filteredRefs","isSimpleObject","value","getGlobalStore","dependencyPath","fullComponentId","newShadowStore","dependencyKey","pathMeta","pathComponents","rootMeta","component","newPaths","newComponentRegistration","newComponentsMap","registration","components","key","path","options","changed","setDirty","currentPath","fullKey","meta","parentPath","serverState","newMap","callback","subscribers","subsForPath","currentSubs","updatedPath","newValue","subs","initialState","preservedComponents","prefixToDelete","k","processValue","nodeKey","childIds","itemId","ulid","item","index","fields","newRootMeta","validArrayIds","shadowMeta","itemKey","reconstructedObject","fieldPath","metadata","existingMeta","finalMeta","cacheKey","cacheData","existing","arrayPath","newItem","arrayKey","parentMeta","newItemId","fullItemKey","newArrayKeys","processNewItem","v","itemPath","parentKey","arrayItemKey","updateValue","currentKey","valueToSet","fieldKey","childPath","childValue","validIds","arrayKeys","acutalKey","newOuterMap","updater","prev","currentUpdates","newUpdates","message","updatedErrors","existingMessages","doSomething","pathArray","keyArray","match","i","errors","valErrors","isIndexMatch","pathSegment","keySegment","keyIndex","errorMessages","newState","syncInfo"],"mappings":"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"}