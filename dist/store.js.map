{"version":3,"file":"store.js","sources":["../src/store.ts"],"sourcesContent":["import { create } from \"zustand\";\r\nimport { ulid } from \"ulid\";\r\nimport type {\r\n  OptionsType,\r\n  ReactivityType,\r\n  StateKeys,\r\n  SyncActionsType,\r\n  SyncInfo,\r\n  UpdateTypeDetail,\r\n} from \"./CogsState.js\";\r\n\r\ntype StateUpdater<StateValue> =\r\n  | StateValue\r\n  | ((prevValue: StateValue) => StateValue);\r\n\r\nexport type FreshValuesObject = {\r\n  pathsToValues?: string[];\r\n  prevValue?: any;\r\n  newValue?: any;\r\n  timeStamp: number;\r\n};\r\n\r\ntype SyncLogType = {\r\n  timeStamp: number;\r\n};\r\ntype StateValue = any;\r\n\r\nexport type TrieNode = {\r\n  subscribers: Set<string>;\r\n  children: Map<string, TrieNode>;\r\n};\r\nexport type ComponentsType = {\r\n  components: Map<\r\n    string,\r\n    {\r\n      forceUpdate: () => void;\r\n      paths: Set<string>;\r\n      deps?: any[];\r\n      depsFunction?: (state: any) => any[] | true;\r\n      reactiveType: ReactivityType[] | ReactivityType;\r\n    }\r\n  >;\r\n};\r\nexport type FormRefStoreState = {\r\n  formRefs: Map<string, React.RefObject<any>>;\r\n  registerFormRef: (id: string, ref: React.RefObject<any>) => void;\r\n  getFormRef: (id: string) => React.RefObject<any> | undefined;\r\n  removeFormRef: (id: string) => void;\r\n  // New method to get all refs for a stateKey\r\n  getFormRefsByStateKey: (\r\n    stateKey: string\r\n  ) => Map<string, React.RefObject<any>>;\r\n};\r\n\r\nexport const formRefStore = create<FormRefStoreState>((set, get) => ({\r\n  formRefs: new Map(),\r\n\r\n  registerFormRef: (id, ref) =>\r\n    set((state) => {\r\n      const newRefs = new Map(state.formRefs);\r\n      newRefs.set(id, ref);\r\n      return { formRefs: newRefs };\r\n    }),\r\n\r\n  getFormRef: (id) => get().formRefs.get(id),\r\n\r\n  removeFormRef: (id) =>\r\n    set((state) => {\r\n      const newRefs = new Map(state.formRefs);\r\n      newRefs.delete(id);\r\n      return { formRefs: newRefs };\r\n    }),\r\n\r\n  // Get all refs that start with the stateKey prefix\r\n  getFormRefsByStateKey: (stateKey) => {\r\n    const allRefs = get().formRefs;\r\n    const stateKeyPrefix = stateKey + \".\";\r\n    const filteredRefs = new Map();\r\n\r\n    allRefs.forEach((ref, id) => {\r\n      if (id.startsWith(stateKeyPrefix) || id === stateKey) {\r\n        filteredRefs.set(id, ref);\r\n      }\r\n    });\r\n\r\n    return filteredRefs;\r\n  },\r\n}));\r\n\r\nexport type ShadowMetadata = {\r\n  id: string;\r\n  arrayKeys?: string[];\r\n  virtualizer?: {\r\n    itemHeight?: number;\r\n    domRef?: HTMLElement | null;\r\n  };\r\n  syncInfo?: { status: string };\r\n  lastUpdated?: number;\r\n};\r\nexport type CogsGlobalState = {\r\n  // --- Shadow State and Subscription System ---\r\n  shadowStateStore: Map<string, ShadowMetadata>;\r\n\r\n  // These method signatures stay the same\r\n  initializeShadowState: (key: string, initialState: any) => void;\r\n  updateShadowAtPath: (key: string, path: string[], newValue: any) => void;\r\n  insertShadowArrayElement: (\r\n    key: string,\r\n    arrayPath: string[],\r\n    newItem: any\r\n  ) => void;\r\n  removeShadowArrayElement: (key: string, arrayPath: string[]) => void;\r\n  getShadowMetadata: (\r\n    key: string,\r\n    path: string[]\r\n  ) => ShadowMetadata | undefined;\r\n  setShadowMetadata: (\r\n    key: string,\r\n    path: string[],\r\n    metadata: Omit<ShadowMetadata, \"id\">\r\n  ) => void;\r\n\r\n  shadowStateSubscribers: Map<string, Set<() => void>>; // Stores subscribers for shadow state updates\r\n  subscribeToShadowState: (key: string, callback: () => void) => () => void;\r\n\r\n  selectedIndicesMap: Map<string, Map<string, number>>; // stateKey -> (parentPath -> selectedIndex)\r\n  getSelectedIndex: (\r\n    stateKey: string,\r\n    parentPath: string\r\n  ) => number | undefined;\r\n  setSelectedIndex: (\r\n    stateKey: string,\r\n    parentPath: string,\r\n    index: number | undefined\r\n  ) => void;\r\n  clearSelectedIndex: ({\r\n    stateKey,\r\n    path,\r\n  }: {\r\n    stateKey: string;\r\n    path: string[];\r\n  }) => void;\r\n  clearSelectedIndexesForState: (stateKey: string) => void;\r\n\r\n  // --- Core State and Updaters ---\r\n  updaterState: { [key: string]: any };\r\n  initialStateOptions: { [key: string]: OptionsType };\r\n  cogsStateStore: { [key: string]: StateValue };\r\n  isLoadingGlobal: { [key: string]: boolean };\r\n  initialStateGlobal: { [key: string]: StateValue };\r\n  iniitialCreatedState: { [key: string]: StateValue };\r\n  serverState: { [key: string]: StateValue };\r\n\r\n  getUpdaterState: (key: string) => StateUpdater<StateValue>;\r\n  setUpdaterState: (key: string, newUpdater: any) => void;\r\n  getKeyState: <StateKey extends StateKeys>(key: StateKey) => StateValue;\r\n  getNestedState: <StateKey extends StateKeys>(\r\n    key: StateKey,\r\n    path: string[]\r\n  ) => StateValue;\r\n  setState: <StateKey extends StateKeys>(\r\n    key: StateKey,\r\n    value: StateUpdater<StateValue>\r\n  ) => void;\r\n  setInitialStates: (initialState: StateValue) => void;\r\n  setCreatedState: (initialState: StateValue) => void;\r\n  updateInitialStateGlobal: (key: string, newState: StateValue) => void;\r\n  updateInitialCreatedState: (key: string, newState: StateValue) => void;\r\n  setIsLoadingGlobal: (key: string, value: boolean) => void;\r\n  setServerState: <StateKey extends StateKeys>(\r\n    key: StateKey,\r\n    value: StateValue\r\n  ) => void;\r\n  getInitialOptions: (key: string) => OptionsType | undefined;\r\n  setInitialStateOptions: (key: string, value: OptionsType) => void;\r\n\r\n  // --- Validation ---\r\n  validationErrors: Map<string, string[]>;\r\n  addValidationError: (path: string, message: string) => void;\r\n  getValidationErrors: (path: string) => string[];\r\n  removeValidationError: (path: string) => void;\r\n\r\n  // --- Server Sync and Logging ---\r\n  serverSyncActions: { [key: string]: SyncActionsType<any> };\r\n  serverSyncLog: { [key: string]: SyncLogType[] };\r\n  stateLog: { [key: string]: UpdateTypeDetail[] };\r\n  syncInfoStore: Map<string, SyncInfo>;\r\n  serverSideOrNot: { [key: string]: boolean };\r\n  setServerSyncLog: (key: string, newValue: SyncLogType) => void;\r\n  setServerSideOrNot: (key: string, value: boolean) => void;\r\n  getServerSideOrNot: (key: string) => boolean | undefined;\r\n  getThisLocalUpdate: (key: string) => UpdateTypeDetail[] | undefined;\r\n  setServerSyncActions: (key: string, value: SyncActionsType<any>) => void;\r\n  setStateLog: (\r\n    key: string,\r\n    updater: (prevUpdates: UpdateTypeDetail[]) => UpdateTypeDetail[]\r\n  ) => void;\r\n  setSyncInfo: (key: string, syncInfo: SyncInfo) => void;\r\n  getSyncInfo: (key: string) => SyncInfo | null;\r\n\r\n  // --- Component and DOM Integration ---\r\n  signalDomElements: Map<\r\n    string,\r\n    Set<{\r\n      instanceId: string;\r\n      parentId: string;\r\n      position: number;\r\n      effect?: string;\r\n      map?: string;\r\n    }>\r\n  >;\r\n  addSignalElement: (\r\n    signalId: string,\r\n    elementInfo: {\r\n      instanceId: string;\r\n      parentId: string;\r\n      position: number;\r\n      effect?: string;\r\n      map?: string;\r\n    }\r\n  ) => void;\r\n  removeSignalElement: (signalId: string, instanceId: string) => void;\r\n  stateComponents: Map<string, ComponentsType>;\r\n\r\n  // --- Deprecated/Legacy (Review for removal) ---\r\n  reRenderTriggerPrevValue: Record<string, any>;\r\n  reactiveDeps: Record<\r\n    string,\r\n    {\r\n      deps: any[];\r\n      updaters: Set<() => void>;\r\n      depsFunction: ((state: any) => any[] | true) | null;\r\n    }\r\n  >;\r\n  setReactiveDeps: (\r\n    key: string,\r\n    record: {\r\n      deps: any[];\r\n      updaters: Set<() => void>;\r\n      depsFunction: ((state: any) => any[] | true) | null;\r\n    }\r\n  ) => void;\r\n  deleteReactiveDeps: (key: string) => void;\r\n  subscribe: (listener: () => void) => () => void;\r\n};\r\n\r\nexport const getGlobalStore = create<CogsGlobalState>((set, get) => ({\r\n  shadowStateStore: new Map(),\r\n  shadowStateSubscribers: new Map(),\r\n\r\n  subscribeToShadowState: (key: string, callback: () => void) => {\r\n    set((state) => {\r\n      const newSubs = new Map(state.shadowStateSubscribers);\r\n      const subsForKey = newSubs.get(key) || new Set();\r\n      subsForKey.add(callback);\r\n      newSubs.set(key, subsForKey);\r\n      return { shadowStateSubscribers: newSubs };\r\n    });\r\n\r\n    // Return unsubscribe function\r\n    return () => {\r\n      set((state) => {\r\n        const newSubs = new Map(state.shadowStateSubscribers);\r\n        const subsForKey = newSubs.get(key);\r\n        if (subsForKey) {\r\n          subsForKey.delete(callback);\r\n          if (subsForKey.size === 0) {\r\n            newSubs.delete(key);\r\n          }\r\n        }\r\n        return { shadowStateSubscribers: newSubs };\r\n      });\r\n    };\r\n  },\r\n  initializeShadowState: (key: string, initialState: any) => {\r\n    const newShadowStore = new Map<string, ShadowMetadata>();\r\n\r\n    const processValue = (value: any, path: string[]) => {\r\n      const nodeKey = [key, ...path].join(\".\");\r\n\r\n      if (Array.isArray(value)) {\r\n        const childIds: string[] = [];\r\n\r\n        value.forEach((item) => {\r\n          if (typeof item === \"object\" && item !== null && !item.id) {\r\n            item.id = ulid();\r\n          }\r\n\r\n          const itemId = `id:${item.id}`;\r\n          childIds.push(itemId);\r\n\r\n          const itemPath = [...path, itemId];\r\n          processValue(item, itemPath);\r\n        });\r\n\r\n        const arrayContainerMetadata: ShadowMetadata = {\r\n          id: ulid(),\r\n          arrayKeys: childIds,\r\n        };\r\n        newShadowStore.set(nodeKey, arrayContainerMetadata);\r\n      } else if (typeof value === \"object\" && value !== null) {\r\n        newShadowStore.set(nodeKey, { id: ulid() });\r\n\r\n        Object.keys(value).forEach((k) => {\r\n          processValue(value[k], [...path, k]);\r\n        });\r\n      } else {\r\n        newShadowStore.set(nodeKey, { id: ulid() });\r\n      }\r\n    };\r\n\r\n    processValue(initialState, []);\r\n\r\n    set({ shadowStateStore: newShadowStore });\r\n  },\r\n  getShadowMetadata: (key: string, path: string[]) => {\r\n    const fullKey = [key, ...path].join(\".\");\r\n    return get().shadowStateStore.get(fullKey);\r\n  },\r\n\r\n  setShadowMetadata: (key: string, path: string[], metadata: any) => {\r\n    const fullKey = [key, ...path].join(\".\");\r\n    const newShadowStore = new Map(get().shadowStateStore);\r\n    const existing = newShadowStore.get(fullKey) || { id: ulid() };\r\n    newShadowStore.set(fullKey, { ...existing, ...metadata });\r\n    set({ shadowStateStore: newShadowStore });\r\n\r\n    if (metadata.virtualizer?.itemHeight) {\r\n      const subscribers = get().shadowStateSubscribers.get(key);\r\n      subscribers?.forEach((cb) => cb());\r\n    }\r\n  },\r\n\r\n  insertShadowArrayElement: (\r\n    key: string,\r\n    arrayPath: string[],\r\n    newItem: any\r\n  ) => {\r\n    const newShadowStore = new Map(get().shadowStateStore);\r\n    const arrayKey = [key, ...arrayPath].join(\".\");\r\n    const parentMeta = newShadowStore.get(arrayKey);\r\n    const newArrayState = get().getNestedState(key, arrayPath) as any[];\r\n\r\n    if (!parentMeta || !parentMeta.arrayKeys) return;\r\n\r\n    const newItemId = `id:${newItem.id}`;\r\n    const newIndex = newArrayState.findIndex((item) => item.id === newItem.id);\r\n\r\n    if (newIndex === -1) return;\r\n\r\n    const newArrayKeys = [...parentMeta.arrayKeys];\r\n    newArrayKeys.splice(newIndex, 0, newItemId);\r\n    newShadowStore.set(arrayKey, { ...parentMeta, arrayKeys: newArrayKeys });\r\n\r\n    const processNewItem = (value: any, path: string[]) => {\r\n      const nodeKey = [key, ...path].join(\".\");\r\n      if (typeof value === \"object\" && value !== null) {\r\n        newShadowStore.set(nodeKey, { id: ulid() });\r\n        Object.keys(value).forEach((k) => {\r\n          processNewItem(value[k], [...path, k]);\r\n        });\r\n      } else {\r\n        newShadowStore.set(nodeKey, { id: ulid() });\r\n      }\r\n    };\r\n\r\n    processNewItem(newItem, [...arrayPath, newItemId]);\r\n\r\n    set({ shadowStateStore: newShadowStore });\r\n  },\r\n\r\n  removeShadowArrayElement: (key: string, itemPath: string[]) => {\r\n    const newShadowStore = new Map(get().shadowStateStore);\r\n    const itemKey = [key, ...itemPath].join(\".\");\r\n    const itemIdToRemove = itemPath[itemPath.length - 1];\r\n\r\n    const parentPath = itemPath.slice(0, -1);\r\n    const parentKey = [key, ...parentPath].join(\".\");\r\n    const parentMeta = newShadowStore.get(parentKey);\r\n\r\n    if (parentMeta && parentMeta.arrayKeys) {\r\n      const newArrayKeys = parentMeta.arrayKeys.filter(\r\n        (id) => id !== itemIdToRemove\r\n      );\r\n      newShadowStore.set(parentKey, { ...parentMeta, arrayKeys: newArrayKeys });\r\n    }\r\n\r\n    const prefixToDelete = itemKey + \".\";\r\n    for (const k of Array.from(newShadowStore.keys())) {\r\n      if (k === itemKey || k.startsWith(prefixToDelete)) {\r\n        newShadowStore.delete(k);\r\n      }\r\n    }\r\n\r\n    set({ shadowStateStore: newShadowStore });\r\n  },\r\n  updateShadowAtPath: (key: string, path: string[], newValue: any) => {\r\n    const fullKey = [key, ...path].join(\".\");\r\n    const newShadowStore = new Map(get().shadowStateStore);\r\n    const existing = newShadowStore.get(fullKey) || { id: ulid() };\r\n    newShadowStore.set(fullKey, { ...existing, lastUpdated: Date.now() });\r\n    set({ shadowStateStore: newShadowStore });\r\n  },\r\n\r\n  selectedIndicesMap: new Map<string, Map<string, number>>(),\r\n\r\n  // Add the new methods\r\n  getSelectedIndex: (stateKey: string, parentPath: string) => {\r\n    const stateMap = get().selectedIndicesMap.get(stateKey);\r\n    if (!stateMap) return undefined;\r\n    return stateMap.get(parentPath);\r\n  },\r\n\r\n  setSelectedIndex: (\r\n    stateKey: string,\r\n    parentPath: string,\r\n    index: number | undefined\r\n  ) => {\r\n    set((state) => {\r\n      const newMap = new Map(state.selectedIndicesMap);\r\n      let stateMap = newMap.get(stateKey);\r\n\r\n      if (!stateMap) {\r\n        stateMap = new Map<string, number>();\r\n        newMap.set(stateKey, stateMap);\r\n      }\r\n\r\n      if (index === undefined) {\r\n        stateMap.delete(parentPath);\r\n      } else {\r\n        stateMap.set(parentPath, index);\r\n      }\r\n\r\n      return {\r\n        ...state,\r\n        selectedIndicesMap: newMap,\r\n      };\r\n    });\r\n  },\r\n  clearSelectedIndex: ({\r\n    stateKey,\r\n    path,\r\n  }: {\r\n    stateKey: string;\r\n    path: string[];\r\n  }) => {\r\n    set((state) => {\r\n      const newMap = new Map(state.selectedIndicesMap);\r\n      const stateMap = newMap.get(stateKey);\r\n      if (!stateMap) return state;\r\n      const parentPath = path.join(\".\");\r\n      stateMap.delete(parentPath);\r\n      return {\r\n        ...state,\r\n        selectedIndicesMap: newMap,\r\n      };\r\n    });\r\n  },\r\n  clearSelectedIndexesForState: (stateKey: string) => {\r\n    set((state) => {\r\n      const newOuterMap = new Map(state.selectedIndicesMap);\r\n      const changed = newOuterMap.delete(stateKey);\r\n      if (changed) {\r\n        console.log(\r\n          `Cleared selected indices map entry for stateKey: ${stateKey}`\r\n        );\r\n        return { selectedIndicesMap: newOuterMap };\r\n      } else {\r\n        return {};\r\n      }\r\n    });\r\n  },\r\n  stateComponents: new Map(),\r\n  subscribe: (listener: () => void) => {\r\n    // zustand's subscribe returns an unsubscribe function\r\n    return get().subscribe(listener);\r\n  },\r\n\r\n  reactiveDeps: {},\r\n  setReactiveDeps: (key, record) =>\r\n    set((state) => ({\r\n      ...state,\r\n      reactiveDeps: {\r\n        ...state.reactiveDeps,\r\n        [key]: record,\r\n      },\r\n    })),\r\n  deleteReactiveDeps: (key) =>\r\n    set((state) => {\r\n      const { [key]: _, ...rest } = state.reactiveDeps;\r\n      return {\r\n        ...state,\r\n        reactiveDeps: rest,\r\n      };\r\n    }),\r\n\r\n  reRenderTriggerPrevValue: {},\r\n  signalDomElements: new Map(),\r\n  addSignalElement: (\r\n    signalId: string,\r\n    elementInfo: { instanceId: string; parentId: string; position: number }\r\n  ) => {\r\n    const current = get().signalDomElements;\r\n    if (!current.has(signalId)) {\r\n      current.set(signalId, new Set());\r\n    }\r\n    current.get(signalId)!.add(elementInfo);\r\n\r\n    set({ signalDomElements: new Map(current) }); // Create new reference to trigger update\r\n  },\r\n  removeSignalElement: (signalId: string, instanceId: string) => {\r\n    const current = get().signalDomElements;\r\n    const elements = current.get(signalId);\r\n    if (elements) {\r\n      elements.forEach((el) => {\r\n        if (el.instanceId === instanceId) {\r\n          elements.delete(el);\r\n        }\r\n      });\r\n    }\r\n    set({ signalDomElements: new Map(current) });\r\n  },\r\n  initialStateOptions: {},\r\n  updaterState: {},\r\n  stateTimeline: {},\r\n  cogsStateStore: {},\r\n  stateLog: {},\r\n  isLoadingGlobal: {},\r\n\r\n  initialStateGlobal: {},\r\n  iniitialCreatedState: {},\r\n  updateInitialCreatedState: (key, newState) => {\r\n    set((prev) => ({\r\n      iniitialCreatedState: {\r\n        ...prev.iniitialCreatedState,\r\n        [key]: newState,\r\n      },\r\n    }));\r\n  },\r\n\r\n  validationErrors: new Map(),\r\n\r\n  serverState: {},\r\n\r\n  serverSyncActions: {},\r\n\r\n  serverSyncLog: {},\r\n  serverSideOrNot: {},\r\n  setServerSyncLog: (key, newValue) => {\r\n    set((state) => ({\r\n      serverSyncLog: {\r\n        ...state.serverSyncLog,\r\n        [key]: [...(state.serverSyncLog[key] ?? []), newValue],\r\n      },\r\n    }));\r\n  },\r\n  setServerSideOrNot: (key, value) => {\r\n    set((state) => ({\r\n      serverSideOrNot: {\r\n        ...state.serverSideOrNot,\r\n        [key]: value,\r\n      },\r\n    }));\r\n  },\r\n  getServerSideOrNot: (key) => {\r\n    return get().serverSideOrNot[key];\r\n  },\r\n\r\n  getThisLocalUpdate: (key: string) => {\r\n    return get().stateLog[key];\r\n  },\r\n  setServerState: <StateKey extends StateKeys>(\r\n    key: StateKey,\r\n    value: StateValue\r\n  ) => {\r\n    set((prev) => ({\r\n      serverState: {\r\n        ...prev.serverState,\r\n        [key]: value,\r\n      },\r\n    }));\r\n  },\r\n\r\n  setStateLog: (\r\n    key: string,\r\n    updater: (prevUpdates: UpdateTypeDetail[]) => UpdateTypeDetail[]\r\n  ) => {\r\n    set((prev) => {\r\n      const currentUpdates = prev.stateLog[key] ?? [];\r\n      const newUpdates = updater(currentUpdates);\r\n      return {\r\n        stateLog: {\r\n          ...prev.stateLog,\r\n          [key]: newUpdates,\r\n        },\r\n      };\r\n    });\r\n  },\r\n  setIsLoadingGlobal: (key: string, value: boolean) => {\r\n    set((prev) => ({\r\n      isLoadingGlobal: {\r\n        ...prev.isLoadingGlobal,\r\n        [key]: value,\r\n      },\r\n    }));\r\n  },\r\n  setServerSyncActions: (key: string, value: SyncActionsType<any>) => {\r\n    set((prev) => ({\r\n      serverSyncActions: {\r\n        ...prev.serverSyncActions,\r\n        [key]: value,\r\n      },\r\n    }));\r\n  },\r\n  addValidationError: (path, message) => {\r\n    console.log(\"addValidationError---\");\r\n    set((prev) => {\r\n      const updatedErrors = new Map(prev.validationErrors);\r\n      const existingMessages = updatedErrors.get(path) || [];\r\n      console.log(\"addValidationError\", path, message, existingMessages);\r\n      // Append the new message instead of replacing\r\n      updatedErrors.set(path, [...existingMessages, message]);\r\n      return { validationErrors: updatedErrors };\r\n    });\r\n  },\r\n  removeValidationError: (path) => {\r\n    set((prev) => {\r\n      const updatedErrors = new Map(prev.validationErrors);\r\n\r\n      let doSomething = false;\r\n      const pathArray = path.split(\".\");\r\n      Array.from(updatedErrors.keys()).forEach((key) => {\r\n        const keyArray = key.split(\".\");\r\n        if (keyArray.length >= pathArray.length) {\r\n          let match = true;\r\n          for (let i = 0; i < pathArray.length; i++) {\r\n            if (keyArray[i] !== pathArray[i]) {\r\n              match = false;\r\n              break;\r\n            }\r\n          }\r\n\r\n          if (match) {\r\n            doSomething = true;\r\n            updatedErrors.delete(key);\r\n          }\r\n        }\r\n      });\r\n\r\n      return doSomething ? { validationErrors: updatedErrors } : prev;\r\n    });\r\n  },\r\n  getValidationErrors: (path: string) => {\r\n    const errors: string[] = [];\r\n    const valErrors = get().validationErrors;\r\n    const pathArray = path.split(\".\");\r\n\r\n    // Helper to check if an index matches either a wildcard or is in an array of indices\r\n    const isIndexMatch = (pathSegment: string, keySegment: string) => {\r\n      if (pathSegment === \"[*]\") return true;\r\n      if (Array.isArray(pathSegment)) {\r\n        return pathSegment.includes(parseInt(keySegment));\r\n      }\r\n      return pathSegment === keySegment;\r\n    };\r\n\r\n    Array.from(valErrors.keys()).forEach((key) => {\r\n      const keyArray = key.split(\".\");\r\n      if (keyArray.length >= pathArray.length) {\r\n        let match = true;\r\n        for (let i = 0; i < pathArray.length; i++) {\r\n          const pathSegment = pathArray[i];\r\n          const keySegment = keyArray[i]!;\r\n\r\n          // If current path segment is a number or [*], we need special handling\r\n          if (pathSegment === \"[*]\" || Array.isArray(pathSegment)) {\r\n            // Key segment should be a number if we're using [*] or array indices\r\n            const keyIndex = parseInt(keySegment);\r\n            if (isNaN(keyIndex)) {\r\n              match = false;\r\n              break;\r\n            }\r\n\r\n            if (!isIndexMatch(pathSegment, keySegment)) {\r\n              match = false;\r\n              break;\r\n            }\r\n          } else if (pathSegment !== keySegment) {\r\n            match = false;\r\n            break;\r\n          }\r\n        }\r\n\r\n        if (match) {\r\n          const errorMessages = valErrors.get(key);\r\n          if (errorMessages) {\r\n            errors.push(...errorMessages);\r\n          }\r\n        }\r\n      }\r\n    });\r\n\r\n    return errors;\r\n  },\r\n  getInitialOptions: (key) => {\r\n    return get().initialStateOptions[key];\r\n  },\r\n  getNestedState: (key: string, path: string[]) => {\r\n    const rootState = get().cogsStateStore[key];\r\n\r\n    const resolvePath = (obj: any, pathArray: string[]): any => {\r\n      if (pathArray.length === 0 || obj === undefined) {\r\n        return obj;\r\n      }\r\n\r\n      const currentSegment = pathArray[0];\r\n      const remainingPath = pathArray.slice(1);\r\n\r\n      // FIX: Handle ID-based array access like 'id:xyz'\r\n      if (\r\n        Array.isArray(obj) &&\r\n        typeof currentSegment === \"string\" &&\r\n        currentSegment.startsWith(\"id:\")\r\n      ) {\r\n        const targetId = currentSegment.split(\":\")[1];\r\n        const foundItem = obj.find(\r\n          (item) => item && String(item.id) === targetId\r\n        );\r\n        return resolvePath(foundItem, remainingPath);\r\n      }\r\n\r\n      // Handle wildcard array access: '[*]'\r\n      if (currentSegment === \"[*]\") {\r\n        if (!Array.isArray(obj)) {\r\n          console.warn(\"Asterisk notation used on non-array value\");\r\n          return undefined;\r\n        }\r\n        if (remainingPath.length === 0) return obj;\r\n        const results = obj.map((item) => resolvePath(item, remainingPath));\r\n        return Array.isArray(results[0]) ? results.flat() : results;\r\n      }\r\n\r\n      // Handle standard object property access and numeric array indices\r\n      const nextObj = obj[currentSegment as keyof typeof obj];\r\n      return resolvePath(nextObj, remainingPath);\r\n    };\r\n\r\n    return resolvePath(rootState, path);\r\n  },\r\n  setInitialStateOptions: (key, value) => {\r\n    set((prev) => ({\r\n      initialStateOptions: {\r\n        ...prev.initialStateOptions,\r\n        [key]: value,\r\n      },\r\n    }));\r\n  },\r\n  updateInitialStateGlobal: (key, newState) => {\r\n    set((prev) => ({\r\n      initialStateGlobal: {\r\n        ...prev.initialStateGlobal,\r\n        [key]: newState,\r\n      },\r\n    }));\r\n  },\r\n  getUpdaterState: (key) => {\r\n    return get().updaterState[key];\r\n  },\r\n  setUpdaterState: (key, newUpdater) => {\r\n    const current = get().updaterState;\r\n\r\n    if (!key || !newUpdater) return;\r\n\r\n    set({ updaterState: { ...(current ?? {}), [key]: newUpdater } });\r\n  },\r\n  getKeyState: <StateKey extends StateKeys>(key: StateKey) => {\r\n    return get().cogsStateStore[key];\r\n  },\r\n\r\n  setState: <StateKey extends StateKeys>(key: StateKey, value: StateValue) => {\r\n    set((prev) => {\r\n      return {\r\n        cogsStateStore: {\r\n          ...prev.cogsStateStore,\r\n          [key]:\r\n            typeof value === \"function\"\r\n              ? value(prev.cogsStateStore[key])\r\n              : value,\r\n        },\r\n      };\r\n    });\r\n  },\r\n  setInitialStates: <StateKey extends StateKeys>(initialState: StateValue) => {\r\n    set((prev) => ({\r\n      cogsStateStore: {\r\n        ...prev.cogsStateStore,\r\n        ...initialState,\r\n      },\r\n    }));\r\n  },\r\n  setCreatedState: (initialState: StateValue) => {\r\n    set((prev) => ({\r\n      iniitialCreatedState: {\r\n        ...prev.cogsStateStore,\r\n        ...initialState,\r\n      },\r\n    }));\r\n  },\r\n\r\n  syncInfoStore: new Map<string, SyncInfo>(),\r\n  setSyncInfo: (key: string, syncInfo: SyncInfo) =>\r\n    set((state) => {\r\n      const newMap = new Map(state.syncInfoStore);\r\n      newMap.set(key, syncInfo);\r\n      return { ...state, syncInfoStore: newMap };\r\n    }),\r\n  getSyncInfo: (key: string) => get().syncInfoStore.get(key) || null,\r\n}));\r\n"],"names":["formRefStore","create","set","get","id","ref","state","newRefs","stateKey","allRefs","stateKeyPrefix","filteredRefs","getGlobalStore","key","callback","newSubs","subsForKey","initialState","newShadowStore","processValue","value","path","nodeKey","childIds","item","ulid","itemId","itemPath","arrayContainerMetadata","k","fullKey","metadata","existing","cb","arrayPath","newItem","arrayKey","parentMeta","newArrayState","newItemId","newIndex","newArrayKeys","processNewItem","itemKey","itemIdToRemove","parentPath","parentKey","prefixToDelete","newValue","stateMap","index","newMap","newOuterMap","listener","record","_","rest","signalId","elementInfo","current","instanceId","elements","el","newState","prev","updater","currentUpdates","newUpdates","message","updatedErrors","existingMessages","doSomething","pathArray","keyArray","match","i","errors","valErrors","isIndexMatch","pathSegment","keySegment","keyIndex","errorMessages","rootState","resolvePath","obj","currentSegment","remainingPath","targetId","foundItem","results","nextObj","newUpdater","syncInfo"],"mappings":"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"}