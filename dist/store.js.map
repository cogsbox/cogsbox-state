{"version":3,"file":"store.js","sources":["../src/store.ts"],"sourcesContent":["import { create } from \"zustand\";\r\nimport type {\r\n  OptionsType,\r\n  ReactivityType,\r\n  StateKeys,\r\n  SyncActionsType,\r\n  SyncInfo,\r\n  UpdateTypeDetail,\r\n} from \"./CogsState.js\";\r\n\r\ntype StateUpdater<StateValue> =\r\n  | StateValue\r\n  | ((prevValue: StateValue) => StateValue);\r\n\r\nexport type FreshValuesObject = {\r\n  pathsToValues?: string[];\r\n  prevValue?: any;\r\n  newValue?: any;\r\n  timeStamp: number;\r\n};\r\n\r\ntype SyncLogType = {\r\n  timeStamp: number;\r\n};\r\ntype StateValue = any;\r\n\r\nexport type ComponentsType = {\r\n  components: Map<\r\n    string,\r\n    {\r\n      forceUpdate: () => void;\r\n      paths: Set<string>;\r\n      deps?: any[];\r\n      depsFunction?: (state: any) => any[] | true;\r\n      reactiveType: ReactivityType[] | ReactivityType;\r\n    }\r\n  >;\r\n};\r\nexport type FormRefStoreState = {\r\n  formRefs: Map<string, React.RefObject<any>>;\r\n  registerFormRef: (id: string, ref: React.RefObject<any>) => void;\r\n  getFormRef: (id: string) => React.RefObject<any> | undefined;\r\n  removeFormRef: (id: string) => void;\r\n  // New method to get all refs for a stateKey\r\n  getFormRefsByStateKey: (\r\n    stateKey: string\r\n  ) => Map<string, React.RefObject<any>>;\r\n};\r\n\r\nexport const formRefStore = create<FormRefStoreState>((set, get) => ({\r\n  formRefs: new Map(),\r\n\r\n  registerFormRef: (id, ref) =>\r\n    set((state) => {\r\n      const newRefs = new Map(state.formRefs);\r\n      newRefs.set(id, ref);\r\n      return { formRefs: newRefs };\r\n    }),\r\n\r\n  getFormRef: (id) => get().formRefs.get(id),\r\n\r\n  removeFormRef: (id) =>\r\n    set((state) => {\r\n      const newRefs = new Map(state.formRefs);\r\n      newRefs.delete(id);\r\n      return { formRefs: newRefs };\r\n    }),\r\n\r\n  // Get all refs that start with the stateKey prefix\r\n  getFormRefsByStateKey: (stateKey) => {\r\n    const allRefs = get().formRefs;\r\n    const stateKeyPrefix = stateKey + \".\";\r\n    const filteredRefs = new Map();\r\n\r\n    allRefs.forEach((ref, id) => {\r\n      if (id.startsWith(stateKeyPrefix) || id === stateKey) {\r\n        filteredRefs.set(id, ref);\r\n      }\r\n    });\r\n\r\n    return filteredRefs;\r\n  },\r\n}));\r\nexport type CogsGlobalState = {\r\n  updaterState: { [key: string]: any };\r\n  initialStateOptions: { [key: string]: OptionsType };\r\n  cogsStateStore: { [key: string]: StateValue };\r\n  isLoadingGlobal: { [key: string]: boolean };\r\n\r\n  initialStateGlobal: { [key: string]: StateValue };\r\n  validationErrors: Map<string, string[]>;\r\n\r\n  serverState: { [key: string]: StateValue };\r\n  serverSyncActions: { [key: string]: SyncActionsType<any> };\r\n\r\n  serverSyncLog: { [key: string]: SyncLogType[] };\r\n  serverSideOrNot: { [key: string]: boolean };\r\n  setServerSyncLog: (key: string, newValue: SyncLogType) => void;\r\n\r\n  setServerSideOrNot: (key: string, value: boolean) => void;\r\n  getServerSideOrNot: (key: string) => boolean | undefined;\r\n  setServerState: <StateKey extends StateKeys>(\r\n    key: StateKey,\r\n    value: StateValue\r\n  ) => void;\r\n\r\n  getThisLocalUpdate: (key: string) => UpdateTypeDetail[] | undefined;\r\n  setServerSyncActions: (key: string, value: SyncActionsType<any>) => void;\r\n  addValidationError: (path: string, message: string) => void;\r\n  getValidationErrors: (path: string) => string[];\r\n  updateInitialStateGlobal: (key: string, newState: StateValue) => void;\r\n  getInitialOptions: (key: string) => OptionsType | undefined;\r\n  getUpdaterState: (key: string) => StateUpdater<StateValue>;\r\n  setUpdaterState: (key: string, newUpdater: any) => void;\r\n  getKeyState: <StateKey extends StateKeys>(key: StateKey) => StateValue;\r\n  getNestedState: <StateKey extends StateKeys>(\r\n    key: StateKey,\r\n    path: string[]\r\n  ) => StateValue;\r\n  setState: <StateKey extends StateKeys>(\r\n    key: StateKey,\r\n    value: StateUpdater<StateValue>\r\n  ) => void;\r\n  setInitialStates: (initialState: StateValue) => void;\r\n  stateLog: { [key: string]: UpdateTypeDetail[] };\r\n  setStateLog: (\r\n    key: string,\r\n    updater: (prevUpdates: UpdateTypeDetail[]) => UpdateTypeDetail[]\r\n  ) => void;\r\n  setIsLoadingGlobal: (key: string, value: boolean) => void;\r\n\r\n  setInitialStateOptions: (key: string, value: OptionsType) => void;\r\n  removeValidationError: (path: string) => void;\r\n  signalDomElements: Map<\r\n    string,\r\n    Set<{\r\n      instanceId: string;\r\n      parentId: string;\r\n      position: number;\r\n      effect?: string;\r\n      map?: string;\r\n    }>\r\n  >;\r\n  addSignalElement: (\r\n    signalId: string,\r\n    elementInfo: {\r\n      instanceId: string;\r\n      parentId: string;\r\n      position: number;\r\n      effect?: string;\r\n      map?: string;\r\n    }\r\n  ) => void;\r\n  removeSignalElement: (signalId: string, instanceId: string) => void;\r\n  reRenderTriggerPrevValue: Record<string, any>;\r\n\r\n  reactiveDeps: Record<\r\n    string,\r\n    {\r\n      deps: any[];\r\n      updaters: Set<() => void>;\r\n      depsFunction: ((state: any) => any[] | true) | null;\r\n    }\r\n  >;\r\n  setReactiveDeps: (\r\n    key: string,\r\n    record: {\r\n      deps: any[];\r\n      updaters: Set<() => void>;\r\n      depsFunction: ((state: any) => any[] | true) | null;\r\n    }\r\n  ) => void;\r\n  deleteReactiveDeps: (key: string) => void;\r\n  subscribe: (listener: () => void) => () => void;\r\n\r\n  stateComponents: Map<string, ComponentsType>;\r\n  syncInfoStore: Map<string, SyncInfo>;\r\n  setSyncInfo: (key: string, syncInfo: SyncInfo) => void;\r\n  getSyncInfo: (key: string) => SyncInfo | null;\r\n};\r\n\r\nexport const getGlobalStore = create<CogsGlobalState>((set, get) => ({\r\n  stateComponents: new Map(),\r\n  subscribe: (listener: () => void) => {\r\n    // zustand's subscribe returns an unsubscribe function\r\n    return get().subscribe(listener);\r\n  },\r\n\r\n  reactiveDeps: {},\r\n  setReactiveDeps: (key, record) =>\r\n    set((state) => ({\r\n      ...state,\r\n      reactiveDeps: {\r\n        ...state.reactiveDeps,\r\n        [key]: record,\r\n      },\r\n    })),\r\n  deleteReactiveDeps: (key) =>\r\n    set((state) => {\r\n      const { [key]: _, ...rest } = state.reactiveDeps;\r\n      return {\r\n        ...state,\r\n        reactiveDeps: rest,\r\n      };\r\n    }),\r\n\r\n  reRenderTriggerPrevValue: {},\r\n  signalDomElements: new Map(),\r\n  addSignalElement: (\r\n    signalId: string,\r\n    elementInfo: { instanceId: string; parentId: string; position: number }\r\n  ) => {\r\n    const current = get().signalDomElements;\r\n    if (!current.has(signalId)) {\r\n      current.set(signalId, new Set());\r\n    }\r\n    current.get(signalId)!.add(elementInfo);\r\n\r\n    set({ signalDomElements: new Map(current) }); // Create new reference to trigger update\r\n  },\r\n  removeSignalElement: (signalId: string, instanceId: string) => {\r\n    const current = get().signalDomElements;\r\n    const elements = current.get(signalId);\r\n    if (elements) {\r\n      elements.forEach((el) => {\r\n        if (el.instanceId === instanceId) {\r\n          elements.delete(el);\r\n        }\r\n      });\r\n    }\r\n    set({ signalDomElements: new Map(current) });\r\n  },\r\n  initialStateOptions: {},\r\n  updaterState: {},\r\n  stateTimeline: {},\r\n  cogsStateStore: {},\r\n  stateLog: {},\r\n  isLoadingGlobal: {},\r\n\r\n  initialStateGlobal: {},\r\n  validationErrors: new Map(),\r\n\r\n  serverState: {},\r\n\r\n  serverSyncActions: {},\r\n\r\n  serverSyncLog: {},\r\n  serverSideOrNot: {},\r\n  setServerSyncLog: (key, newValue) => {\r\n    set((state) => ({\r\n      serverSyncLog: {\r\n        ...state.serverSyncLog,\r\n        [key]: [...(state.serverSyncLog[key] ?? []), newValue],\r\n      },\r\n    }));\r\n  },\r\n  setServerSideOrNot: (key, value) => {\r\n    set((state) => ({\r\n      serverSideOrNot: {\r\n        ...state.serverSideOrNot,\r\n        [key]: value,\r\n      },\r\n    }));\r\n  },\r\n  getServerSideOrNot: (key) => {\r\n    return get().serverSideOrNot[key];\r\n  },\r\n\r\n  getThisLocalUpdate: (key: string) => {\r\n    return get().stateLog[key];\r\n  },\r\n  setServerState: <StateKey extends StateKeys>(\r\n    key: StateKey,\r\n    value: StateValue\r\n  ) => {\r\n    set((prev) => ({\r\n      serverState: {\r\n        ...prev.serverState,\r\n        [key]: value,\r\n      },\r\n    }));\r\n  },\r\n\r\n  setStateLog: (\r\n    key: string,\r\n    updater: (prevUpdates: UpdateTypeDetail[]) => UpdateTypeDetail[]\r\n  ) => {\r\n    set((prev) => {\r\n      const currentUpdates = prev.stateLog[key] ?? [];\r\n      const newUpdates = updater(currentUpdates);\r\n      return {\r\n        stateLog: {\r\n          ...prev.stateLog,\r\n          [key]: newUpdates,\r\n        },\r\n      };\r\n    });\r\n  },\r\n  setIsLoadingGlobal: (key: string, value: boolean) => {\r\n    set((prev) => ({\r\n      isLoadingGlobal: {\r\n        ...prev.isLoadingGlobal,\r\n        [key]: value,\r\n      },\r\n    }));\r\n  },\r\n  setServerSyncActions: (key: string, value: SyncActionsType<any>) => {\r\n    set((prev) => ({\r\n      serverSyncActions: {\r\n        ...prev.serverSyncActions,\r\n        [key]: value,\r\n      },\r\n    }));\r\n  },\r\n  addValidationError: (path, message) => {\r\n    console.log(\"addValidationError---\");\r\n    set((prev) => {\r\n      const updatedErrors = new Map(prev.validationErrors);\r\n      const existingMessages = updatedErrors.get(path) || [];\r\n      console.log(\"addValidationError\", path, message, existingMessages);\r\n      // Append the new message instead of replacing\r\n      updatedErrors.set(path, [...existingMessages, message]);\r\n      return { validationErrors: updatedErrors };\r\n    });\r\n  },\r\n  removeValidationError: (path) => {\r\n    set((prev) => {\r\n      const updatedErrors = new Map(prev.validationErrors);\r\n\r\n      let doSomething = false;\r\n      const pathArray = path.split(\".\");\r\n      Array.from(updatedErrors.keys()).forEach((key) => {\r\n        const keyArray = key.split(\".\");\r\n        if (keyArray.length >= pathArray.length) {\r\n          let match = true;\r\n          for (let i = 0; i < pathArray.length; i++) {\r\n            if (keyArray[i] !== pathArray[i]) {\r\n              match = false;\r\n              break;\r\n            }\r\n          }\r\n\r\n          if (match) {\r\n            doSomething = true;\r\n            updatedErrors.delete(key);\r\n          }\r\n        }\r\n      });\r\n\r\n      return doSomething ? { validationErrors: updatedErrors } : prev;\r\n    });\r\n  },\r\n  getValidationErrors: (path: string) => {\r\n    const errors: string[] = [];\r\n    const valErrors = get().validationErrors;\r\n    const pathArray = path.split(\".\");\r\n\r\n    // Helper to check if an index matches either a wildcard or is in an array of indices\r\n    const isIndexMatch = (pathSegment: string, keySegment: string) => {\r\n      if (pathSegment === \"[*]\") return true;\r\n      if (Array.isArray(pathSegment)) {\r\n        return pathSegment.includes(parseInt(keySegment));\r\n      }\r\n      return pathSegment === keySegment;\r\n    };\r\n\r\n    Array.from(valErrors.keys()).forEach((key) => {\r\n      const keyArray = key.split(\".\");\r\n      if (keyArray.length >= pathArray.length) {\r\n        let match = true;\r\n        for (let i = 0; i < pathArray.length; i++) {\r\n          const pathSegment = pathArray[i];\r\n          const keySegment = keyArray[i]!;\r\n\r\n          // If current path segment is a number or [*], we need special handling\r\n          if (pathSegment === \"[*]\" || Array.isArray(pathSegment)) {\r\n            // Key segment should be a number if we're using [*] or array indices\r\n            const keyIndex = parseInt(keySegment);\r\n            if (isNaN(keyIndex)) {\r\n              match = false;\r\n              break;\r\n            }\r\n\r\n            if (!isIndexMatch(pathSegment, keySegment)) {\r\n              match = false;\r\n              break;\r\n            }\r\n          } else if (pathSegment !== keySegment) {\r\n            match = false;\r\n            break;\r\n          }\r\n        }\r\n\r\n        if (match) {\r\n          const errorMessages = valErrors.get(key);\r\n          if (errorMessages) {\r\n            errors.push(...errorMessages);\r\n          }\r\n        }\r\n      }\r\n    });\r\n\r\n    return errors;\r\n  },\r\n  getInitialOptions: (key) => {\r\n    return get().initialStateOptions[key];\r\n  },\r\n  getNestedState: (key: string, path: string[]) => {\r\n    const rootState = get().cogsStateStore[key];\r\n\r\n    const getValueWithAsterisk = (obj: any, pathArray: string[]): any => {\r\n      if (pathArray.length === 0) return obj;\r\n\r\n      const currentPath = pathArray[0];\r\n      const remainingPath = pathArray.slice(1);\r\n\r\n      if (currentPath === \"[*]\") {\r\n        if (!Array.isArray(obj)) {\r\n          console.warn(\"Asterisk notation used on non-array value\");\r\n          return undefined;\r\n        }\r\n\r\n        if (remainingPath.length === 0) return obj;\r\n\r\n        // Get result for each array item\r\n        const results = obj.map((item) =>\r\n          getValueWithAsterisk(item, remainingPath)\r\n        );\r\n\r\n        // If the next path segment exists and returns arrays, flatten them\r\n        if (Array.isArray(results[0])) {\r\n          return results.flat();\r\n        }\r\n\r\n        return results;\r\n      }\r\n\r\n      const value = obj[currentPath as keyof typeof obj];\r\n      if (value === undefined) return undefined;\r\n\r\n      return getValueWithAsterisk(value, remainingPath);\r\n    };\r\n\r\n    // This will still get the value but we need to make it reactive only to specific paths\r\n    return getValueWithAsterisk(rootState, path);\r\n  },\r\n  setInitialStateOptions: (key, value) => {\r\n    set((prev) => ({\r\n      initialStateOptions: {\r\n        ...prev.initialStateOptions,\r\n        [key]: value,\r\n      },\r\n    }));\r\n  },\r\n  updateInitialStateGlobal: (key, newState) => {\r\n    set((prev) => ({\r\n      initialStateGlobal: {\r\n        ...prev.initialStateGlobal,\r\n        [key]: newState,\r\n      },\r\n    }));\r\n  },\r\n  getUpdaterState: (key) => {\r\n    return get().updaterState[key];\r\n  },\r\n  setUpdaterState: (key, newUpdater) => {\r\n    const current = get().updaterState;\r\n\r\n    if (!key || !newUpdater) return;\r\n\r\n    set({ updaterState: { ...(current ?? {}), [key]: newUpdater } });\r\n  },\r\n  getKeyState: <StateKey extends StateKeys>(key: StateKey) => {\r\n    return get().cogsStateStore[key];\r\n  },\r\n\r\n  setState: <StateKey extends StateKeys>(key: StateKey, value: StateValue) => {\r\n    set((prev) => {\r\n      return {\r\n        cogsStateStore: {\r\n          ...prev.cogsStateStore,\r\n          [key]:\r\n            typeof value === \"function\"\r\n              ? value(prev.cogsStateStore[key])\r\n              : value,\r\n        },\r\n      };\r\n    });\r\n  },\r\n  setInitialStates: <StateKey extends StateKeys>(initialState: StateValue) => {\r\n    set((prev) => ({\r\n      cogsStateStore: {\r\n        ...prev.cogsStateStore,\r\n        ...initialState,\r\n      },\r\n    }));\r\n  },\r\n  syncInfoStore: new Map<string, SyncInfo>(),\r\n  setSyncInfo: (key: string, syncInfo: SyncInfo) =>\r\n    set((state) => {\r\n      const newMap = new Map(state.syncInfoStore);\r\n      newMap.set(key, syncInfo);\r\n      return { ...state, syncInfoStore: newMap };\r\n    }),\r\n  getSyncInfo: (key: string) => get().syncInfoStore.get(key) || null,\r\n}));\r\n"],"names":["formRefStore","create","set","get","id","ref","state","newRefs","stateKey","allRefs","stateKeyPrefix","filteredRefs","getGlobalStore","listener","key","record","_","rest","signalId","elementInfo","current","instanceId","elements","el","newValue","value","prev","updater","currentUpdates","newUpdates","path","message","updatedErrors","existingMessages","doSomething","pathArray","keyArray","match","i","errors","valErrors","isIndexMatch","pathSegment","keySegment","keyIndex","errorMessages","rootState","getValueWithAsterisk","obj","currentPath","remainingPath","results","item","newState","newUpdater","initialState","syncInfo","newMap"],"mappings":"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"}