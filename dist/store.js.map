{"version":3,"file":"store.js","sources":["../src/store.ts"],"sourcesContent":["import { create } from \"zustand\";\r\nimport type {\r\n  OptionsType,\r\n  ReactivityType,\r\n  StateKeys,\r\n  SyncActionsType,\r\n  SyncInfo,\r\n  UpdateTypeDetail,\r\n} from \"./CogsState.js\";\r\n\r\ntype StateUpdater<StateValue> =\r\n  | StateValue\r\n  | ((prevValue: StateValue) => StateValue);\r\n\r\nexport type FreshValuesObject = {\r\n  pathsToValues?: string[];\r\n  prevValue?: any;\r\n  newValue?: any;\r\n  timeStamp: number;\r\n};\r\n\r\ntype SyncLogType = {\r\n  timeStamp: number;\r\n};\r\ntype StateValue = any;\r\n\r\nexport type ComponentsType = {\r\n  components: Map<\r\n    string,\r\n    {\r\n      forceUpdate: () => void;\r\n      paths: Set<string>;\r\n      deps?: any[];\r\n      depsFunction?: (state: any) => any[] | true;\r\n      reactiveType: ReactivityType[] | ReactivityType;\r\n    }\r\n  >;\r\n};\r\nexport type FormRefStoreState = {\r\n  formRefs: Map<string, React.RefObject<any>>;\r\n  registerFormRef: (id: string, ref: React.RefObject<any>) => void;\r\n  getFormRef: (id: string) => React.RefObject<any> | undefined;\r\n  removeFormRef: (id: string) => void;\r\n  // New method to get all refs for a stateKey\r\n  getFormRefsByStateKey: (\r\n    stateKey: string\r\n  ) => Map<string, React.RefObject<any>>;\r\n};\r\n\r\nexport const formRefStore = create<FormRefStoreState>((set, get) => ({\r\n  formRefs: new Map(),\r\n\r\n  registerFormRef: (id, ref) =>\r\n    set((state) => {\r\n      const newRefs = new Map(state.formRefs);\r\n      newRefs.set(id, ref);\r\n      return { formRefs: newRefs };\r\n    }),\r\n\r\n  getFormRef: (id) => get().formRefs.get(id),\r\n\r\n  removeFormRef: (id) =>\r\n    set((state) => {\r\n      const newRefs = new Map(state.formRefs);\r\n      newRefs.delete(id);\r\n      return { formRefs: newRefs };\r\n    }),\r\n\r\n  // Get all refs that start with the stateKey prefix\r\n  getFormRefsByStateKey: (stateKey) => {\r\n    const allRefs = get().formRefs;\r\n    const stateKeyPrefix = stateKey + \".\";\r\n    const filteredRefs = new Map();\r\n\r\n    allRefs.forEach((ref, id) => {\r\n      if (id.startsWith(stateKeyPrefix) || id === stateKey) {\r\n        filteredRefs.set(id, ref);\r\n      }\r\n    });\r\n\r\n    return filteredRefs;\r\n  },\r\n}));\r\nexport type CogsGlobalState = {\r\n  selectedIndicesMap: Map<string, Map<string, number>>; // stateKey -> (parentPath -> selectedIndex)\r\n\r\n  // Add these new methods\r\n  getSelectedIndex: (\r\n    stateKey: string,\r\n    parentPath: string\r\n  ) => number | undefined;\r\n  setSelectedIndex: (\r\n    stateKey: string,\r\n    parentPath: string,\r\n    index: number | undefined\r\n  ) => void;\r\n  clearSelectedIndex: ({\r\n    stateKey,\r\n    path,\r\n  }: {\r\n    stateKey: string;\r\n    path: string[];\r\n  }) => void;\r\n  clearSelectedIndexesForState: (stateKey: string) => void;\r\n  updaterState: { [key: string]: any };\r\n  initialStateOptions: { [key: string]: OptionsType };\r\n  cogsStateStore: { [key: string]: StateValue };\r\n  isLoadingGlobal: { [key: string]: boolean };\r\n\r\n  initialStateGlobal: { [key: string]: StateValue };\r\n  iniitialCreatedState: { [key: string]: StateValue };\r\n  validationErrors: Map<string, string[]>;\r\n\r\n  serverState: { [key: string]: StateValue };\r\n  serverSyncActions: { [key: string]: SyncActionsType<any> };\r\n\r\n  serverSyncLog: { [key: string]: SyncLogType[] };\r\n  serverSideOrNot: { [key: string]: boolean };\r\n  setServerSyncLog: (key: string, newValue: SyncLogType) => void;\r\n\r\n  setServerSideOrNot: (key: string, value: boolean) => void;\r\n  getServerSideOrNot: (key: string) => boolean | undefined;\r\n  setServerState: <StateKey extends StateKeys>(\r\n    key: StateKey,\r\n    value: StateValue\r\n  ) => void;\r\n\r\n  getThisLocalUpdate: (key: string) => UpdateTypeDetail[] | undefined;\r\n  setServerSyncActions: (key: string, value: SyncActionsType<any>) => void;\r\n  addValidationError: (path: string, message: string) => void;\r\n  getValidationErrors: (path: string) => string[];\r\n  updateInitialStateGlobal: (key: string, newState: StateValue) => void;\r\n  updateInitialCreatedState: (key: string, newState: StateValue) => void;\r\n  getInitialOptions: (key: string) => OptionsType | undefined;\r\n  getUpdaterState: (key: string) => StateUpdater<StateValue>;\r\n  setUpdaterState: (key: string, newUpdater: any) => void;\r\n  getKeyState: <StateKey extends StateKeys>(key: StateKey) => StateValue;\r\n  getNestedState: <StateKey extends StateKeys>(\r\n    key: StateKey,\r\n    path: string[]\r\n  ) => StateValue;\r\n  setState: <StateKey extends StateKeys>(\r\n    key: StateKey,\r\n    value: StateUpdater<StateValue>\r\n  ) => void;\r\n  setInitialStates: (initialState: StateValue) => void;\r\n  setCreatedState: (initialState: StateValue) => void;\r\n  stateLog: { [key: string]: UpdateTypeDetail[] };\r\n  setStateLog: (\r\n    key: string,\r\n    updater: (prevUpdates: UpdateTypeDetail[]) => UpdateTypeDetail[]\r\n  ) => void;\r\n  setIsLoadingGlobal: (key: string, value: boolean) => void;\r\n\r\n  setInitialStateOptions: (key: string, value: OptionsType) => void;\r\n  removeValidationError: (path: string) => void;\r\n  signalDomElements: Map<\r\n    string,\r\n    Set<{\r\n      instanceId: string;\r\n      parentId: string;\r\n      position: number;\r\n      effect?: string;\r\n      map?: string;\r\n    }>\r\n  >;\r\n  addSignalElement: (\r\n    signalId: string,\r\n    elementInfo: {\r\n      instanceId: string;\r\n      parentId: string;\r\n      position: number;\r\n      effect?: string;\r\n      map?: string;\r\n    }\r\n  ) => void;\r\n  removeSignalElement: (signalId: string, instanceId: string) => void;\r\n  reRenderTriggerPrevValue: Record<string, any>;\r\n\r\n  reactiveDeps: Record<\r\n    string,\r\n    {\r\n      deps: any[];\r\n      updaters: Set<() => void>;\r\n      depsFunction: ((state: any) => any[] | true) | null;\r\n    }\r\n  >;\r\n  setReactiveDeps: (\r\n    key: string,\r\n    record: {\r\n      deps: any[];\r\n      updaters: Set<() => void>;\r\n      depsFunction: ((state: any) => any[] | true) | null;\r\n    }\r\n  ) => void;\r\n  deleteReactiveDeps: (key: string) => void;\r\n  subscribe: (listener: () => void) => () => void;\r\n\r\n  stateComponents: Map<string, ComponentsType>;\r\n  syncInfoStore: Map<string, SyncInfo>;\r\n  setSyncInfo: (key: string, syncInfo: SyncInfo) => void;\r\n  getSyncInfo: (key: string) => SyncInfo | null;\r\n};\r\n\r\nexport const getGlobalStore = create<CogsGlobalState>((set, get) => ({\r\n  selectedIndicesMap: new Map<string, Map<string, number>>(),\r\n\r\n  // Add the new methods\r\n  getSelectedIndex: (stateKey: string, parentPath: string) => {\r\n    const stateMap = get().selectedIndicesMap.get(stateKey);\r\n    if (!stateMap) return undefined;\r\n    return stateMap.get(parentPath);\r\n  },\r\n\r\n  setSelectedIndex: (\r\n    stateKey: string,\r\n    parentPath: string,\r\n    index: number | undefined\r\n  ) => {\r\n    set((state) => {\r\n      const newMap = new Map(state.selectedIndicesMap);\r\n      let stateMap = newMap.get(stateKey);\r\n\r\n      if (!stateMap) {\r\n        stateMap = new Map<string, number>();\r\n        newMap.set(stateKey, stateMap);\r\n      }\r\n\r\n      if (index === undefined) {\r\n        stateMap.delete(parentPath);\r\n      } else {\r\n        stateMap.set(parentPath, index);\r\n      }\r\n\r\n      return {\r\n        ...state,\r\n        selectedIndicesMap: newMap,\r\n      };\r\n    });\r\n  },\r\n  clearSelectedIndex: ({\r\n    stateKey,\r\n    path,\r\n  }: {\r\n    stateKey: string;\r\n    path: string[];\r\n  }) => {\r\n    set((state) => {\r\n      const newMap = new Map(state.selectedIndicesMap);\r\n      const stateMap = newMap.get(stateKey);\r\n      if (!stateMap) return state;\r\n      const parentPath = path.join(\".\");\r\n      stateMap.delete(parentPath);\r\n      return {\r\n        ...state,\r\n        selectedIndicesMap: newMap,\r\n      };\r\n    });\r\n  },\r\n  clearSelectedIndexesForState: (stateKey: string) => {\r\n    set((state) => {\r\n      const newOuterMap = new Map(state.selectedIndicesMap);\r\n      const changed = newOuterMap.delete(stateKey);\r\n      if (changed) {\r\n        console.log(\r\n          `Cleared selected indices map entry for stateKey: ${stateKey}`\r\n        );\r\n        return { selectedIndicesMap: newOuterMap };\r\n      } else {\r\n        return {};\r\n      }\r\n    });\r\n  },\r\n  stateComponents: new Map(),\r\n  subscribe: (listener: () => void) => {\r\n    // zustand's subscribe returns an unsubscribe function\r\n    return get().subscribe(listener);\r\n  },\r\n\r\n  reactiveDeps: {},\r\n  setReactiveDeps: (key, record) =>\r\n    set((state) => ({\r\n      ...state,\r\n      reactiveDeps: {\r\n        ...state.reactiveDeps,\r\n        [key]: record,\r\n      },\r\n    })),\r\n  deleteReactiveDeps: (key) =>\r\n    set((state) => {\r\n      const { [key]: _, ...rest } = state.reactiveDeps;\r\n      return {\r\n        ...state,\r\n        reactiveDeps: rest,\r\n      };\r\n    }),\r\n\r\n  reRenderTriggerPrevValue: {},\r\n  signalDomElements: new Map(),\r\n  addSignalElement: (\r\n    signalId: string,\r\n    elementInfo: { instanceId: string; parentId: string; position: number }\r\n  ) => {\r\n    const current = get().signalDomElements;\r\n    if (!current.has(signalId)) {\r\n      current.set(signalId, new Set());\r\n    }\r\n    current.get(signalId)!.add(elementInfo);\r\n\r\n    set({ signalDomElements: new Map(current) }); // Create new reference to trigger update\r\n  },\r\n  removeSignalElement: (signalId: string, instanceId: string) => {\r\n    const current = get().signalDomElements;\r\n    const elements = current.get(signalId);\r\n    if (elements) {\r\n      elements.forEach((el) => {\r\n        if (el.instanceId === instanceId) {\r\n          elements.delete(el);\r\n        }\r\n      });\r\n    }\r\n    set({ signalDomElements: new Map(current) });\r\n  },\r\n  initialStateOptions: {},\r\n  updaterState: {},\r\n  stateTimeline: {},\r\n  cogsStateStore: {},\r\n  stateLog: {},\r\n  isLoadingGlobal: {},\r\n\r\n  initialStateGlobal: {},\r\n  iniitialCreatedState: {},\r\n  updateInitialCreatedState: (key, newState) => {\r\n    set((prev) => ({\r\n      iniitialCreatedState: {\r\n        ...prev.iniitialCreatedState,\r\n        [key]: newState,\r\n      },\r\n    }));\r\n  },\r\n\r\n  validationErrors: new Map(),\r\n\r\n  serverState: {},\r\n\r\n  serverSyncActions: {},\r\n\r\n  serverSyncLog: {},\r\n  serverSideOrNot: {},\r\n  setServerSyncLog: (key, newValue) => {\r\n    set((state) => ({\r\n      serverSyncLog: {\r\n        ...state.serverSyncLog,\r\n        [key]: [...(state.serverSyncLog[key] ?? []), newValue],\r\n      },\r\n    }));\r\n  },\r\n  setServerSideOrNot: (key, value) => {\r\n    set((state) => ({\r\n      serverSideOrNot: {\r\n        ...state.serverSideOrNot,\r\n        [key]: value,\r\n      },\r\n    }));\r\n  },\r\n  getServerSideOrNot: (key) => {\r\n    return get().serverSideOrNot[key];\r\n  },\r\n\r\n  getThisLocalUpdate: (key: string) => {\r\n    return get().stateLog[key];\r\n  },\r\n  setServerState: <StateKey extends StateKeys>(\r\n    key: StateKey,\r\n    value: StateValue\r\n  ) => {\r\n    set((prev) => ({\r\n      serverState: {\r\n        ...prev.serverState,\r\n        [key]: value,\r\n      },\r\n    }));\r\n  },\r\n\r\n  setStateLog: (\r\n    key: string,\r\n    updater: (prevUpdates: UpdateTypeDetail[]) => UpdateTypeDetail[]\r\n  ) => {\r\n    set((prev) => {\r\n      const currentUpdates = prev.stateLog[key] ?? [];\r\n      const newUpdates = updater(currentUpdates);\r\n      return {\r\n        stateLog: {\r\n          ...prev.stateLog,\r\n          [key]: newUpdates,\r\n        },\r\n      };\r\n    });\r\n  },\r\n  setIsLoadingGlobal: (key: string, value: boolean) => {\r\n    set((prev) => ({\r\n      isLoadingGlobal: {\r\n        ...prev.isLoadingGlobal,\r\n        [key]: value,\r\n      },\r\n    }));\r\n  },\r\n  setServerSyncActions: (key: string, value: SyncActionsType<any>) => {\r\n    set((prev) => ({\r\n      serverSyncActions: {\r\n        ...prev.serverSyncActions,\r\n        [key]: value,\r\n      },\r\n    }));\r\n  },\r\n  addValidationError: (path, message) => {\r\n    console.log(\"addValidationError---\");\r\n    set((prev) => {\r\n      const updatedErrors = new Map(prev.validationErrors);\r\n      const existingMessages = updatedErrors.get(path) || [];\r\n      console.log(\"addValidationError\", path, message, existingMessages);\r\n      // Append the new message instead of replacing\r\n      updatedErrors.set(path, [...existingMessages, message]);\r\n      return { validationErrors: updatedErrors };\r\n    });\r\n  },\r\n  removeValidationError: (path) => {\r\n    set((prev) => {\r\n      const updatedErrors = new Map(prev.validationErrors);\r\n\r\n      let doSomething = false;\r\n      const pathArray = path.split(\".\");\r\n      Array.from(updatedErrors.keys()).forEach((key) => {\r\n        const keyArray = key.split(\".\");\r\n        if (keyArray.length >= pathArray.length) {\r\n          let match = true;\r\n          for (let i = 0; i < pathArray.length; i++) {\r\n            if (keyArray[i] !== pathArray[i]) {\r\n              match = false;\r\n              break;\r\n            }\r\n          }\r\n\r\n          if (match) {\r\n            doSomething = true;\r\n            updatedErrors.delete(key);\r\n          }\r\n        }\r\n      });\r\n\r\n      return doSomething ? { validationErrors: updatedErrors } : prev;\r\n    });\r\n  },\r\n  getValidationErrors: (path: string) => {\r\n    const errors: string[] = [];\r\n    const valErrors = get().validationErrors;\r\n    const pathArray = path.split(\".\");\r\n\r\n    // Helper to check if an index matches either a wildcard or is in an array of indices\r\n    const isIndexMatch = (pathSegment: string, keySegment: string) => {\r\n      if (pathSegment === \"[*]\") return true;\r\n      if (Array.isArray(pathSegment)) {\r\n        return pathSegment.includes(parseInt(keySegment));\r\n      }\r\n      return pathSegment === keySegment;\r\n    };\r\n\r\n    Array.from(valErrors.keys()).forEach((key) => {\r\n      const keyArray = key.split(\".\");\r\n      if (keyArray.length >= pathArray.length) {\r\n        let match = true;\r\n        for (let i = 0; i < pathArray.length; i++) {\r\n          const pathSegment = pathArray[i];\r\n          const keySegment = keyArray[i]!;\r\n\r\n          // If current path segment is a number or [*], we need special handling\r\n          if (pathSegment === \"[*]\" || Array.isArray(pathSegment)) {\r\n            // Key segment should be a number if we're using [*] or array indices\r\n            const keyIndex = parseInt(keySegment);\r\n            if (isNaN(keyIndex)) {\r\n              match = false;\r\n              break;\r\n            }\r\n\r\n            if (!isIndexMatch(pathSegment, keySegment)) {\r\n              match = false;\r\n              break;\r\n            }\r\n          } else if (pathSegment !== keySegment) {\r\n            match = false;\r\n            break;\r\n          }\r\n        }\r\n\r\n        if (match) {\r\n          const errorMessages = valErrors.get(key);\r\n          if (errorMessages) {\r\n            errors.push(...errorMessages);\r\n          }\r\n        }\r\n      }\r\n    });\r\n\r\n    return errors;\r\n  },\r\n  getInitialOptions: (key) => {\r\n    return get().initialStateOptions[key];\r\n  },\r\n  getNestedState: (key: string, path: string[]) => {\r\n    const rootState = get().cogsStateStore[key];\r\n\r\n    const getValueWithAsterisk = (obj: any, pathArray: string[]): any => {\r\n      if (pathArray.length === 0) return obj;\r\n\r\n      const currentPath = pathArray[0];\r\n      const remainingPath = pathArray.slice(1);\r\n\r\n      if (currentPath === \"[*]\") {\r\n        if (!Array.isArray(obj)) {\r\n          console.warn(\"Asterisk notation used on non-array value\");\r\n          return undefined;\r\n        }\r\n\r\n        if (remainingPath.length === 0) return obj;\r\n\r\n        // Get result for each array item\r\n        const results = obj.map((item) =>\r\n          getValueWithAsterisk(item, remainingPath)\r\n        );\r\n\r\n        // If the next path segment exists and returns arrays, flatten them\r\n        if (Array.isArray(results[0])) {\r\n          return results.flat();\r\n        }\r\n\r\n        return results;\r\n      }\r\n\r\n      const value = obj[currentPath as keyof typeof obj];\r\n      if (value === undefined) return undefined;\r\n\r\n      return getValueWithAsterisk(value, remainingPath);\r\n    };\r\n\r\n    // This will still get the value but we need to make it reactive only to specific paths\r\n    return getValueWithAsterisk(rootState, path);\r\n  },\r\n  setInitialStateOptions: (key, value) => {\r\n    set((prev) => ({\r\n      initialStateOptions: {\r\n        ...prev.initialStateOptions,\r\n        [key]: value,\r\n      },\r\n    }));\r\n  },\r\n  updateInitialStateGlobal: (key, newState) => {\r\n    set((prev) => ({\r\n      initialStateGlobal: {\r\n        ...prev.initialStateGlobal,\r\n        [key]: newState,\r\n      },\r\n    }));\r\n  },\r\n  getUpdaterState: (key) => {\r\n    return get().updaterState[key];\r\n  },\r\n  setUpdaterState: (key, newUpdater) => {\r\n    const current = get().updaterState;\r\n\r\n    if (!key || !newUpdater) return;\r\n\r\n    set({ updaterState: { ...(current ?? {}), [key]: newUpdater } });\r\n  },\r\n  getKeyState: <StateKey extends StateKeys>(key: StateKey) => {\r\n    return get().cogsStateStore[key];\r\n  },\r\n\r\n  setState: <StateKey extends StateKeys>(key: StateKey, value: StateValue) => {\r\n    set((prev) => {\r\n      return {\r\n        cogsStateStore: {\r\n          ...prev.cogsStateStore,\r\n          [key]:\r\n            typeof value === \"function\"\r\n              ? value(prev.cogsStateStore[key])\r\n              : value,\r\n        },\r\n      };\r\n    });\r\n  },\r\n  setInitialStates: <StateKey extends StateKeys>(initialState: StateValue) => {\r\n    set((prev) => ({\r\n      cogsStateStore: {\r\n        ...prev.cogsStateStore,\r\n        ...initialState,\r\n      },\r\n    }));\r\n  },\r\n  setCreatedState: (initialState: StateValue) => {\r\n    set((prev) => ({\r\n      iniitialCreatedState: {\r\n        ...prev.cogsStateStore,\r\n        ...initialState,\r\n      },\r\n    }));\r\n  },\r\n\r\n  syncInfoStore: new Map<string, SyncInfo>(),\r\n  setSyncInfo: (key: string, syncInfo: SyncInfo) =>\r\n    set((state) => {\r\n      const newMap = new Map(state.syncInfoStore);\r\n      newMap.set(key, syncInfo);\r\n      return { ...state, syncInfoStore: newMap };\r\n    }),\r\n  getSyncInfo: (key: string) => get().syncInfoStore.get(key) || null,\r\n}));\r\n"],"names":["formRefStore","create","set","get","id","ref","state","newRefs","stateKey","allRefs","stateKeyPrefix","filteredRefs","getGlobalStore","parentPath","stateMap","index","newMap","path","newOuterMap","listener","key","record","_","rest","signalId","elementInfo","current","instanceId","elements","el","newState","prev","newValue","value","updater","currentUpdates","newUpdates","message","updatedErrors","existingMessages","doSomething","pathArray","keyArray","match","i","errors","valErrors","isIndexMatch","pathSegment","keySegment","keyIndex","errorMessages","rootState","getValueWithAsterisk","obj","currentPath","remainingPath","results","item","newUpdater","initialState","syncInfo"],"mappings":"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"}