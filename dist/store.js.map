{"version":3,"file":"store.js","sources":["../src/store.ts"],"sourcesContent":["import { create } from 'zustand';\r\nimport { ulid } from 'ulid';\r\nimport type {\r\n  OptionsType,\r\n  ReactivityType,\r\n  SyncInfo,\r\n  UpdateTypeDetail,\r\n} from './CogsState.js';\r\n\r\nimport { type ReactNode } from 'react';\r\n\r\nexport type FreshValuesObject = {\r\n  pathsToValues?: string[];\r\n  prevValue?: any;\r\n  newValue?: any;\r\n  timeStamp: number;\r\n};\r\n\r\ntype StateValue = any;\r\n\r\nexport type TrieNode = {\r\n  subscribers: Set<string>;\r\n  children: Map<string, TrieNode>;\r\n};\r\n\r\nexport type FormRefStoreState = {\r\n  formRefs: Map<string, React.RefObject<any>>;\r\n  registerFormRef: (id: string, ref: React.RefObject<any>) => void;\r\n  getFormRef: (id: string) => React.RefObject<any> | undefined;\r\n  removeFormRef: (id: string) => void;\r\n  getFormRefsByStateKey: (\r\n    stateKey: string\r\n  ) => Map<string, React.RefObject<any>>;\r\n};\r\n\r\nexport const formRefStore = create<FormRefStoreState>((set, get) => ({\r\n  formRefs: new Map(),\r\n\r\n  registerFormRef: (id, ref) =>\r\n    set((state) => {\r\n      const newRefs = new Map(state.formRefs);\r\n      newRefs.set(id, ref);\r\n      return { formRefs: newRefs };\r\n    }),\r\n\r\n  getFormRef: (id) => get().formRefs.get(id),\r\n\r\n  removeFormRef: (id) =>\r\n    set((state) => {\r\n      const newRefs = new Map(state.formRefs);\r\n      newRefs.delete(id);\r\n      return { formRefs: newRefs };\r\n    }),\r\n\r\n  getFormRefsByStateKey: (stateKey) => {\r\n    const allRefs = get().formRefs;\r\n    const stateKeyPrefix = stateKey + '.';\r\n    const filteredRefs = new Map();\r\n\r\n    allRefs.forEach((ref, id) => {\r\n      if (id.startsWith(stateKeyPrefix) || id === stateKey) {\r\n        filteredRefs.set(id, ref);\r\n      }\r\n    });\r\n\r\n    return filteredRefs;\r\n  },\r\n}));\r\nexport type ComponentsType = {\r\n  components?: Map<\r\n    string,\r\n    {\r\n      forceUpdate: () => void;\r\n      paths: Set<string>;\r\n      deps?: any[];\r\n      prevDeps?: any[];\r\n      depsFunction?: (state: any) => any[] | true;\r\n      reactiveType: ReactivityType[] | ReactivityType;\r\n    }\r\n  >;\r\n};\r\n\r\nexport type ValidationStatus =\r\n  | 'NOT_VALIDATED'\r\n  | 'VALIDATING'\r\n  | 'VALID'\r\n  | 'INVALID';\r\n\r\nexport type ValidationError = {\r\n  source: 'client' | 'sync_engine' | 'api';\r\n  message: string;\r\n  severity: 'warning' | 'error';\r\n  code?: string;\r\n};\r\n\r\nexport type ValidationState = {\r\n  status: ValidationStatus;\r\n  errors: ValidationError[];\r\n  lastValidated?: number;\r\n  validatedValue?: any;\r\n};\r\n\r\nexport type ShadowMetadata = {\r\n  id?: string;\r\n  stateSource?: 'default' | 'server' | 'localStorage';\r\n  lastServerSync?: number;\r\n  isDirty?: boolean;\r\n  baseServerState?: any;\r\n  arrayKeys?: string[];\r\n  fields?: Record<string, any>;\r\n  virtualizer?: {\r\n    itemHeight?: number;\r\n    domRef?: HTMLElement | null;\r\n  };\r\n  syncInfo?: { status: string };\r\n  validation?: ValidationState;\r\n  features?: {\r\n    syncEnabled: boolean;\r\n    validationEnabled: boolean;\r\n    localStorageEnabled: boolean;\r\n  };\r\n  lastUpdated?: number;\r\n  signals?: Array<{\r\n    instanceId: string;\r\n    parentId: string;\r\n    position: number;\r\n    effect?: string;\r\n  }>;\r\n  mapWrappers?: Array<{\r\n    instanceId: string;\r\n    path: string[];\r\n    componentId: string;\r\n    meta?: any;\r\n    mapFn: (setter: any, index: number, arraySetter: any) => ReactNode;\r\n    containerRef: HTMLDivElement | null;\r\n    rebuildStateShape: any;\r\n  }>;\r\n  transformCaches?: Map<\r\n    string,\r\n    {\r\n      validIds: string[];\r\n      computedAt: number;\r\n      transforms: Array<{ type: 'filter' | 'sort'; fn: Function }>;\r\n    }\r\n  >;\r\n  pathComponents?: Set<string>;\r\n  streams?: Map<\r\n    string,\r\n    {\r\n      buffer: any[];\r\n      flushTimer: NodeJS.Timeout | null;\r\n    }\r\n  >;\r\n} & ComponentsType;\r\n\r\ntype ShadowNode = {\r\n  value?: any;\r\n  _meta?: ShadowMetadata;\r\n  [key: string]: any;\r\n};\r\n\r\nexport type CogsGlobalState = {\r\n  // NEW shadow store\r\n  shadowStateStore: Map<string, ShadowNode>;\r\n  setTransformCache: (\r\n    key: string,\r\n    path: string[],\r\n    cacheKey: string,\r\n    cacheData: any\r\n  ) => void;\r\n  initializeShadowState: (key: string, initialState: any) => void;\r\n  getShadowNode: (key: string, path: string[]) => ShadowNode | undefined;\r\n  getShadowMetadata: (\r\n    key: string,\r\n    path: string[]\r\n  ) => ShadowMetadata | undefined;\r\n\r\n  setShadowMetadata: (key: string, path: string[], metadata: any) => void;\r\n  getShadowValue: (\r\n    key: string,\r\n    path: string[],\r\n    validArrayIds?: string[],\r\n    log?: boolean\r\n  ) => any;\r\n  updateShadowAtPath: (key: string, path: string[], newValue: any) => void;\r\n  insertManyShadowArrayElements: (\r\n    key: string,\r\n    arrayPath: string[],\r\n    newItems: any[],\r\n    index?: number\r\n  ) => void;\r\n  addItemsToArrayNode: (\r\n    key: string,\r\n    arrayPath: string[],\r\n    newItems: any,\r\n    newKeys: string[]\r\n  ) => void;\r\n  insertShadowArrayElement: (\r\n    key: string,\r\n    arrayPath: string[],\r\n    newItem: any,\r\n    index?: number\r\n  ) => void;\r\n  removeShadowArrayElement: (key: string, itemPath: string[]) => void;\r\n  registerComponent: (\r\n    stateKey: string,\r\n    componentId: string,\r\n    registration: any\r\n  ) => void;\r\n  unregisterComponent: (stateKey: string, componentId: string) => void;\r\n  addPathComponent: (\r\n    stateKey: string,\r\n    dependencyPath: string[],\r\n    fullComponentId: string\r\n  ) => void;\r\n  markAsDirty: (\r\n    key: string,\r\n    path: string[],\r\n    options: { bubble: boolean }\r\n  ) => void;\r\n\r\n  pathSubscribers: Map<string, Set<(newValue: any) => void>>;\r\n  subscribeToPath: (\r\n    path: string,\r\n    callback: (newValue: any) => void\r\n  ) => () => void;\r\n  notifyPathSubscribers: (updatedPath: string, newValue: any) => void;\r\n\r\n  selectedIndicesMap: Map<string, string>; // stateKey -> (parentPath -> selectedIndex)\r\n  getSelectedIndex: (stateKey: string, validArrayIds?: string[]) => number;\r\n  setSelectedIndex: (key: string, itemKey: string) => void;\r\n  clearSelectedIndex: ({ arrayKey }: { arrayKey: string }) => void;\r\n  clearSelectedIndexesForState: (stateKey: string) => void;\r\n\r\n  initialStateOptions: { [key: string]: OptionsType };\r\n  initialStateGlobal: { [key: string]: StateValue };\r\n  updateInitialStateGlobal: (key: string, newState: StateValue) => void;\r\n\r\n  getInitialOptions: (key: string) => OptionsType | undefined;\r\n  setInitialStateOptions: (key: string, value: OptionsType) => void;\r\n\r\n  serverStateUpdates: Map<\r\n    string,\r\n    {\r\n      data: any;\r\n      status: 'loading' | 'success' | 'error';\r\n      timestamp: number;\r\n    }\r\n  >;\r\n\r\n  setServerStateUpdate: (key: string, serverState: any) => void;\r\n\r\n  stateLog: Map<string, Map<string, UpdateTypeDetail>>;\r\n  syncInfoStore: Map<string, SyncInfo>;\r\n  addStateLog: (updates: UpdateTypeDetail[]) => void;\r\n\r\n  setSyncInfo: (key: string, syncInfo: SyncInfo) => void;\r\n  getSyncInfo: (key: string) => SyncInfo | null;\r\n};\r\n\r\nexport function buildShadowNode(value: any): ShadowNode {\r\n  if (value === null || typeof value !== 'object') {\r\n    return { value };\r\n  }\r\n\r\n  if (Array.isArray(value)) {\r\n    const arrayNode: ShadowNode = { _meta: { arrayKeys: [] } };\r\n    const idKeys: string[] = [];\r\n\r\n    value.forEach((item) => {\r\n      const itemId = `id:${ulid()}`;\r\n      arrayNode[itemId] = buildShadowNode(item);\r\n      idKeys.push(itemId);\r\n    });\r\n\r\n    arrayNode._meta!.arrayKeys = idKeys;\r\n    return arrayNode;\r\n  }\r\n\r\n  if (value.constructor === Object) {\r\n    const objectNode: ShadowNode = { _meta: {} };\r\n    for (const key in value) {\r\n      if (Object.prototype.hasOwnProperty.call(value, key)) {\r\n        objectNode[key] = buildShadowNode(value[key]);\r\n      }\r\n    }\r\n    return objectNode;\r\n  }\r\n\r\n  return { value };\r\n}\r\n\r\nexport const getGlobalStore = create<CogsGlobalState>((set, get) => ({\r\n  shadowStateStore: new Map<string, ShadowNode>(),\r\n\r\n  setTransformCache: (\r\n    key: string,\r\n    path: string[],\r\n    cacheKey: string,\r\n    cacheData: any\r\n  ) => {\r\n    const metadata = get().getShadowMetadata(key, path) || {};\r\n    if (!metadata.transformCaches) {\r\n      metadata.transformCaches = new Map();\r\n    }\r\n    metadata.transformCaches.set(cacheKey, cacheData);\r\n    get().setShadowMetadata(key, path, {\r\n      transformCaches: metadata.transformCaches,\r\n    });\r\n  },\r\n\r\n  initializeShadowState: (key: string, initialState: any) => {\r\n    set((state) => {\r\n      const newShadowStore = new Map(state.shadowStateStore);\r\n      const existingRoot =\r\n        newShadowStore.get(key) || newShadowStore.get(`[${key}`);\r\n      let preservedMetadata: Partial<ShadowMetadata> = {};\r\n\r\n      if (existingRoot?._meta) {\r\n        const {\r\n          components,\r\n          features,\r\n          lastServerSync,\r\n          stateSource,\r\n          baseServerState,\r\n        } = existingRoot._meta;\r\n        if (components) preservedMetadata.components = components;\r\n        if (features) preservedMetadata.features = features;\r\n        if (lastServerSync) preservedMetadata.lastServerSync = lastServerSync;\r\n        if (stateSource) preservedMetadata.stateSource = stateSource;\r\n        if (baseServerState)\r\n          preservedMetadata.baseServerState = baseServerState;\r\n      }\r\n\r\n      newShadowStore.delete(key);\r\n      newShadowStore.delete(`[${key}`);\r\n\r\n      const newRoot = buildShadowNode(initialState);\r\n\r\n      if (!newRoot._meta) newRoot._meta = {};\r\n      Object.assign(newRoot._meta, preservedMetadata);\r\n\r\n      const storageKey = Array.isArray(initialState) ? `[${key}` : key;\r\n      newShadowStore.set(storageKey, newRoot);\r\n\r\n      return { shadowStateStore: newShadowStore };\r\n    });\r\n  },\r\n\r\n  getShadowNode: (key: string, path: string[]): ShadowNode | undefined => {\r\n    const store = get().shadowStateStore;\r\n    let current: any = store.get(key) || store.get(`[${key}`);\r\n\r\n    if (!current) return undefined;\r\n    if (path.length === 0) return current;\r\n\r\n    for (const segment of path) {\r\n      if (typeof current !== 'object' || current === null) return undefined;\r\n      current = current[segment];\r\n      if (current === undefined) return undefined;\r\n    }\r\n    return current;\r\n  },\r\n\r\n  getShadowMetadata: (\r\n    key: string,\r\n    path: string[]\r\n  ): ShadowMetadata | undefined => {\r\n    const node = get().getShadowNode(key, path);\r\n    return node?._meta;\r\n  },\r\n\r\n  setShadowMetadata: (\r\n    key: string,\r\n    path: string[],\r\n    newMetadata: Partial<ShadowMetadata>\r\n  ) => {\r\n    set((state) => {\r\n      const newStore = new Map(state.shadowStateStore);\r\n      const rootKey = newStore.has(`[${key}`) ? `[${key}` : key;\r\n      let root = newStore.get(rootKey);\r\n\r\n      if (!root) {\r\n        root = {};\r\n        newStore.set(rootKey, root);\r\n      }\r\n\r\n      const clonedRoot: any = { ...root };\r\n      newStore.set(rootKey, clonedRoot);\r\n\r\n      let current = clonedRoot;\r\n      for (const segment of path) {\r\n        const nextNode = current[segment] || {};\r\n        current[segment] = { ...nextNode };\r\n        current = current[segment];\r\n      }\r\n\r\n      current._meta = { ...(current._meta || {}), ...newMetadata };\r\n\r\n      return { shadowStateStore: newStore };\r\n    });\r\n  },\r\n  getShadowValue: (\r\n    key: string,\r\n    path: string[],\r\n    validArrayIds?: string[],\r\n    log?: boolean\r\n  ) => {\r\n    const node = get().getShadowNode(key, path);\r\n\r\n    if (node === null || node === undefined) return undefined;\r\n\r\n    const nodeKeys = Object.keys(node);\r\n\r\n    const isPrimitiveWrapper =\r\n      Object.prototype.hasOwnProperty.call(node, 'value') &&\r\n      nodeKeys.every((k) => k === 'value' || k === '_meta');\r\n\r\n    if (isPrimitiveWrapper) {\r\n      return node.value;\r\n    }\r\n\r\n    // Array Check (This part is correct)\r\n    const isArrayNode =\r\n      node._meta &&\r\n      Object.prototype.hasOwnProperty.call(node._meta, 'arrayKeys');\r\n    if (isArrayNode) {\r\n      const keysToIterate =\r\n        validArrayIds !== undefined && validArrayIds.length > 0\r\n          ? validArrayIds\r\n          : node._meta!.arrayKeys!;\r\n\r\n      return keysToIterate.map((itemKey: string) =>\r\n        get().getShadowValue(key, [...path, itemKey])\r\n      );\r\n    }\r\n\r\n    const result: any = {};\r\n    for (const propKey of nodeKeys) {\r\n      if (propKey !== '_meta' && !propKey.startsWith('id:')) {\r\n        result[propKey] = get().getShadowValue(key, [...path, propKey]);\r\n      }\r\n    }\r\n    return result;\r\n  },\r\n  updateShadowAtPath: (key, path, newValue) => {\r\n    set((state) => {\r\n      const newStore = new Map(state.shadowStateStore);\r\n      const rootKey = newStore.has(`[${key}`) ? `[${key}` : key;\r\n      let root = newStore.get(rootKey);\r\n      if (!root) return state;\r\n      const clonedRoot: any = { ...root };\r\n      newStore.set(rootKey, clonedRoot);\r\n      let parentNode = clonedRoot;\r\n      for (let i = 0; i < path.length - 1; i++) {\r\n        parentNode[path[i]!] = { ...(parentNode[path[i]!] || {}) };\r\n        parentNode = parentNode[path[i]!];\r\n      }\r\n      const targetNode =\r\n        path.length === 0 ? parentNode : parentNode[path[path.length - 1]!];\r\n\r\n      if (!targetNode) {\r\n        parentNode[path[path.length - 1]!] = buildShadowNode(newValue);\r\n        return { shadowStateStore: newStore };\r\n      }\r\n\r\n      function intelligentMerge(nodeToUpdate: any, plainValue: any) {\r\n        if (\r\n          typeof plainValue !== 'object' ||\r\n          plainValue === null ||\r\n          Array.isArray(plainValue)\r\n        ) {\r\n          const oldMeta = nodeToUpdate._meta;\r\n          const newNode = buildShadowNode(plainValue);\r\n          if (oldMeta) {\r\n            newNode._meta = { ...oldMeta, ...(newNode._meta || {}) };\r\n          }\r\n          Object.keys(nodeToUpdate).forEach((key) => delete nodeToUpdate[key]);\r\n          Object.assign(nodeToUpdate, newNode);\r\n          return;\r\n        }\r\n\r\n        const plainValueKeys = new Set(Object.keys(plainValue));\r\n\r\n        for (const propKey of plainValueKeys) {\r\n          const childValue = plainValue[propKey];\r\n          if (nodeToUpdate[propKey]) {\r\n            intelligentMerge(nodeToUpdate[propKey], childValue);\r\n          } else {\r\n            nodeToUpdate[propKey] = buildShadowNode(childValue);\r\n          }\r\n        }\r\n\r\n        for (const nodeKey in nodeToUpdate) {\r\n          if (\r\n            nodeKey === '_meta' ||\r\n            !Object.prototype.hasOwnProperty.call(nodeToUpdate, nodeKey)\r\n          )\r\n            continue;\r\n\r\n          if (!plainValueKeys.has(nodeKey)) {\r\n            delete nodeToUpdate[nodeKey];\r\n          }\r\n        }\r\n      }\r\n\r\n      intelligentMerge(targetNode, newValue);\r\n\r\n      get().notifyPathSubscribers([key, ...path].join('.'), {\r\n        type: 'UPDATE',\r\n        newValue,\r\n      });\r\n      return { shadowStateStore: newStore };\r\n    });\r\n  },\r\n  addItemsToArrayNode: (key, arrayPath, newItems, newKeys) => {\r\n    set((state) => {\r\n      const newStore = new Map(state.shadowStateStore);\r\n      const rootKey = newStore.has(`[${key}`) ? `[${key}` : key;\r\n      let root = newStore.get(rootKey);\r\n      if (!root) {\r\n        console.error('Root not found for state key:', key);\r\n        return state;\r\n      }\r\n\r\n      const clonedRoot = { ...root };\r\n      newStore.set(rootKey, clonedRoot);\r\n\r\n      let current = clonedRoot;\r\n      for (const segment of arrayPath) {\r\n        const nextNode = current[segment] || {};\r\n        current[segment] = { ...nextNode };\r\n        current = current[segment];\r\n      }\r\n\r\n      Object.assign(current, newItems);\r\n      current._meta = { ...(current._meta || {}), arrayKeys: newKeys };\r\n\r\n      return { shadowStateStore: newStore };\r\n    });\r\n  },\r\n\r\n  insertShadowArrayElement: (key, arrayPath, newItem, index) => {\r\n    const arrayNode = get().getShadowNode(key, arrayPath);\r\n    if (!arrayNode?._meta?.arrayKeys) {\r\n      console.error(\r\n        `Array not found at path: ${[key, ...arrayPath].join('.')}`\r\n      );\r\n      return;\r\n    }\r\n\r\n    const newItemId = `id:${ulid()}`;\r\n    const itemsToAdd = { [newItemId]: buildShadowNode(newItem) };\r\n\r\n    const currentKeys = arrayNode._meta.arrayKeys;\r\n    const newKeys = [...currentKeys];\r\n    const insertionPoint =\r\n      index !== undefined && index >= 0 && index <= newKeys.length\r\n        ? index\r\n        : newKeys.length;\r\n    newKeys.splice(insertionPoint, 0, newItemId);\r\n\r\n    get().addItemsToArrayNode(key, arrayPath, itemsToAdd, newKeys);\r\n\r\n    const arrayKey = [key, ...arrayPath].join('.');\r\n    get().notifyPathSubscribers(arrayKey, {\r\n      type: 'INSERT',\r\n      path: arrayKey,\r\n      itemKey: `${arrayKey}.${newItemId}`,\r\n      index: insertionPoint,\r\n    });\r\n  },\r\n  insertManyShadowArrayElements: (key, arrayPath, newItems, index) => {\r\n    if (!newItems || newItems.length === 0) {\r\n      return;\r\n    }\r\n\r\n    const arrayNode = get().getShadowNode(key, arrayPath);\r\n    if (!arrayNode?._meta?.arrayKeys) {\r\n      console.error(\r\n        `Array not found at path: ${[key, ...arrayPath].join('.')}`\r\n      );\r\n      return;\r\n    }\r\n\r\n    const itemsToAdd: Record<string, any> = {};\r\n    const newIds: string[] = [];\r\n\r\n    newItems.forEach((item) => {\r\n      const newItemId = `id:${ulid()}`;\r\n      newIds.push(newItemId);\r\n      itemsToAdd[newItemId] = buildShadowNode(item);\r\n    });\r\n\r\n    const currentKeys = arrayNode._meta.arrayKeys;\r\n    const finalKeys = [...currentKeys];\r\n    const insertionPoint =\r\n      index !== undefined && index >= 0 && index <= finalKeys.length\r\n        ? index\r\n        : finalKeys.length;\r\n    finalKeys.splice(insertionPoint, 0, ...newIds);\r\n\r\n    get().addItemsToArrayNode(key, arrayPath, itemsToAdd, finalKeys);\r\n\r\n    const arrayKey = [key, ...arrayPath].join('.');\r\n    get().notifyPathSubscribers(arrayKey, {\r\n      type: 'INSERT_MANY',\r\n      path: arrayKey,\r\n      count: newItems.length,\r\n      index: insertionPoint,\r\n    });\r\n  },\r\n\r\n  removeShadowArrayElement: (key, itemPath) => {\r\n    if (itemPath.length === 0) return;\r\n\r\n    const arrayPath = itemPath.slice(0, -1);\r\n    const itemId = itemPath[itemPath.length - 1];\r\n    if (!itemId?.startsWith('id:')) return;\r\n\r\n    const arrayNode = get().getShadowNode(key, arrayPath);\r\n    if (!arrayNode?._meta?.arrayKeys) return;\r\n\r\n    const newKeys = arrayNode._meta.arrayKeys.filter((k) => k !== itemId);\r\n    delete arrayNode[itemId];\r\n\r\n    get().setShadowMetadata(key, arrayPath, { arrayKeys: newKeys });\r\n\r\n    const arrayKey = [key, ...arrayPath].join('.');\r\n    get().notifyPathSubscribers(arrayKey, {\r\n      type: 'REMOVE',\r\n      path: arrayKey,\r\n      itemKey: `${arrayKey}.${itemId}`,\r\n    });\r\n  },\r\n\r\n  addPathComponent: (stateKey, dependencyPath, fullComponentId) => {\r\n    const metadata = get().getShadowMetadata(stateKey, dependencyPath) || {};\r\n    const newPathComponents = new Set(metadata.pathComponents);\r\n    newPathComponents.add(fullComponentId);\r\n    get().setShadowMetadata(stateKey, dependencyPath, {\r\n      pathComponents: newPathComponents,\r\n    });\r\n\r\n    const rootMeta = get().getShadowMetadata(stateKey, []);\r\n    if (rootMeta?.components) {\r\n      const component = rootMeta.components.get(fullComponentId);\r\n      if (component) {\r\n        const fullPathKey = [stateKey, ...dependencyPath].join('.');\r\n        const newPaths = new Set(component.paths);\r\n        newPaths.add(fullPathKey);\r\n        const newComponentRegistration = { ...component, paths: newPaths };\r\n        const newComponentsMap = new Map(rootMeta.components);\r\n        newComponentsMap.set(fullComponentId, newComponentRegistration);\r\n        get().setShadowMetadata(stateKey, [], { components: newComponentsMap });\r\n      }\r\n    }\r\n  },\r\n\r\n  registerComponent: (stateKey, fullComponentId, registration) => {\r\n    const rootMeta = get().getShadowMetadata(stateKey, []) || {};\r\n    const components = new Map(rootMeta.components);\r\n    components.set(fullComponentId, registration);\r\n    get().setShadowMetadata(stateKey, [], { components });\r\n  },\r\n\r\n  unregisterComponent: (stateKey, fullComponentId) => {\r\n    const rootMeta = get().getShadowMetadata(stateKey, []);\r\n    if (!rootMeta?.components) return;\r\n    const components = new Map(rootMeta.components);\r\n    if (components.delete(fullComponentId)) {\r\n      get().setShadowMetadata(stateKey, [], { components });\r\n    }\r\n  },\r\n\r\n  markAsDirty: (key, path, options = { bubble: true }) => {\r\n    const setDirtyOnPath = (pathToMark: string[]) => {\r\n      const node = get().getShadowNode(key, pathToMark);\r\n      if (node?._meta?.isDirty) {\r\n        return true;\r\n      }\r\n      get().setShadowMetadata(key, pathToMark, { isDirty: true });\r\n      return false;\r\n    };\r\n\r\n    setDirtyOnPath(path);\r\n\r\n    if (options.bubble) {\r\n      let parentPath = [...path];\r\n      while (parentPath.length > 0) {\r\n        parentPath.pop();\r\n        if (setDirtyOnPath(parentPath)) {\r\n          break;\r\n        }\r\n      }\r\n    }\r\n  },\r\n\r\n  serverStateUpdates: new Map(),\r\n  setServerStateUpdate: (key, serverState) => {\r\n    set((state) => ({\r\n      serverStateUpdates: new Map(state.serverStateUpdates).set(\r\n        key,\r\n        serverState\r\n      ),\r\n    }));\r\n    get().notifyPathSubscribers(key, {\r\n      type: 'SERVER_STATE_UPDATE',\r\n      serverState,\r\n    });\r\n  },\r\n\r\n  pathSubscribers: new Map<string, Set<(newValue: any) => void>>(),\r\n  subscribeToPath: (path, callback) => {\r\n    const subscribers = get().pathSubscribers;\r\n    const subsForPath = subscribers.get(path) || new Set();\r\n    subsForPath.add(callback);\r\n    subscribers.set(path, subsForPath);\r\n\r\n    return () => {\r\n      const currentSubs = get().pathSubscribers.get(path);\r\n      if (currentSubs) {\r\n        currentSubs.delete(callback);\r\n        if (currentSubs.size === 0) {\r\n          get().pathSubscribers.delete(path);\r\n        }\r\n      }\r\n    };\r\n  },\r\n  notifyPathSubscribers: (updatedPath, newValue) => {\r\n    const subscribers = get().pathSubscribers;\r\n    const subs = subscribers.get(updatedPath);\r\n    if (subs) {\r\n      subs.forEach((callback) => callback(newValue));\r\n    }\r\n  },\r\n  selectedIndicesMap: new Map<string, string>(),\r\n  getSelectedIndex: (arrayKey, validIds) => {\r\n    const itemKey = get().selectedIndicesMap.get(arrayKey);\r\n    if (!itemKey) return -1;\r\n\r\n    const arrayMeta = get().getShadowMetadata(\r\n      arrayKey.split('.')[0]!,\r\n      arrayKey.split('.').slice(1)\r\n    );\r\n    const arrayKeys = validIds || arrayMeta?.arrayKeys;\r\n\r\n    return arrayKeys ? arrayKeys.indexOf(itemKey) : -1;\r\n  },\r\n\r\n  setSelectedIndex: (arrayKey: string, itemKey: string | undefined) => {\r\n    set((state) => {\r\n      const newMap = new Map(state.selectedIndicesMap); // CREATE A NEW MAP!\r\n\r\n      if (itemKey === undefined) {\r\n        newMap.delete(arrayKey);\r\n      } else {\r\n        if (newMap.has(arrayKey)) {\r\n          get().notifyPathSubscribers(newMap.get(arrayKey)!, {\r\n            type: 'THIS_UNSELECTED',\r\n          });\r\n        }\r\n        newMap.set(arrayKey, itemKey);\r\n        get().notifyPathSubscribers(itemKey, { type: 'THIS_SELECTED' });\r\n      }\r\n\r\n      get().notifyPathSubscribers(arrayKey, { type: 'GET_SELECTED' });\r\n\r\n      return {\r\n        ...state,\r\n        selectedIndicesMap: newMap,\r\n      };\r\n    });\r\n  },\r\n\r\n  clearSelectedIndex: ({ arrayKey }: { arrayKey: string }): void => {\r\n    set((state) => {\r\n      const newMap = new Map(state.selectedIndicesMap); // CREATE A NEW MAP!\r\n      const actualKey = newMap.get(arrayKey);\r\n      if (actualKey) {\r\n        get().notifyPathSubscribers(actualKey, {\r\n          type: 'CLEAR_SELECTION',\r\n        });\r\n      }\r\n\r\n      newMap.delete(arrayKey);\r\n      get().notifyPathSubscribers(arrayKey, {\r\n        type: 'CLEAR_SELECTION',\r\n      });\r\n      return {\r\n        ...state,\r\n        selectedIndicesMap: newMap,\r\n      };\r\n    });\r\n  },\r\n  clearSelectedIndexesForState: (stateKey) => {\r\n    set((state) => {\r\n      const newMap = new Map(state.selectedIndicesMap);\r\n      let changed = false;\r\n      for (const key of newMap.keys()) {\r\n        if (key === stateKey || key.startsWith(stateKey + '.')) {\r\n          newMap.delete(key);\r\n          changed = true;\r\n        }\r\n      }\r\n      return changed ? { selectedIndicesMap: newMap } : {};\r\n    });\r\n  },\r\n\r\n  initialStateOptions: {},\r\n  stateLog: new Map(),\r\n  initialStateGlobal: {},\r\n\r\n  addStateLog: (updates) => {\r\n    if (!updates || updates.length === 0) return;\r\n    set((state) => {\r\n      const newLog = new Map(state.stateLog);\r\n      const logsGroupedByKey = new Map<string, UpdateTypeDetail[]>();\r\n      for (const update of updates) {\r\n        const group = logsGroupedByKey.get(update.stateKey) || [];\r\n        group.push(update);\r\n        logsGroupedByKey.set(update.stateKey, group);\r\n      }\r\n      for (const [key, batchOfUpdates] of logsGroupedByKey.entries()) {\r\n        const newStateLogForKey = new Map(newLog.get(key));\r\n        for (const update of batchOfUpdates) {\r\n          newStateLogForKey.set(JSON.stringify(update.path), { ...update });\r\n        }\r\n        newLog.set(key, newStateLogForKey);\r\n      }\r\n      return { stateLog: newLog };\r\n    });\r\n  },\r\n\r\n  getInitialOptions: (key) => get().initialStateOptions[key],\r\n  setInitialStateOptions: (key, value) => {\r\n    set((prev) => ({\r\n      initialStateOptions: { ...prev.initialStateOptions, [key]: value },\r\n    }));\r\n  },\r\n  updateInitialStateGlobal: (key, newState) => {\r\n    set((prev) => ({\r\n      initialStateGlobal: { ...prev.initialStateGlobal, [key]: newState },\r\n    }));\r\n  },\r\n\r\n  syncInfoStore: new Map<string, SyncInfo>(),\r\n  setSyncInfo: (key, syncInfo) =>\r\n    set((state) => {\r\n      const newMap = new Map(state.syncInfoStore);\r\n      newMap.set(key, syncInfo);\r\n      return { syncInfoStore: newMap };\r\n    }),\r\n  getSyncInfo: (key) => get().syncInfoStore.get(key) || null,\r\n}));\r\n"],"names":["formRefStore","create","set","get","id","ref","state","newRefs","stateKey","allRefs","stateKeyPrefix","filteredRefs","buildShadowNode","value","arrayNode","idKeys","item","itemId","ulid","objectNode","key","getGlobalStore","path","cacheKey","cacheData","metadata","initialState","newShadowStore","existingRoot","preservedMetadata","components","features","lastServerSync","stateSource","baseServerState","newRoot","storageKey","store","current","segment","newMetadata","newStore","rootKey","root","clonedRoot","nextNode","validArrayIds","log","node","nodeKeys","k","itemKey","result","propKey","newValue","parentNode","i","targetNode","intelligentMerge","nodeToUpdate","plainValue","oldMeta","newNode","plainValueKeys","childValue","nodeKey","arrayPath","newItems","newKeys","newItem","index","newItemId","itemsToAdd","insertionPoint","arrayKey","newIds","finalKeys","itemPath","dependencyPath","fullComponentId","newPathComponents","rootMeta","component","fullPathKey","newPaths","newComponentRegistration","newComponentsMap","registration","options","setDirtyOnPath","pathToMark","parentPath","serverState","callback","subscribers","subsForPath","currentSubs","updatedPath","subs","validIds","arrayMeta","arrayKeys","newMap","actualKey","changed","updates","newLog","logsGroupedByKey","update","group","batchOfUpdates","newStateLogForKey","prev","newState","syncInfo"],"mappings":"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"}