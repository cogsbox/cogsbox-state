{"version":3,"file":"store.js","sources":["../src/store.ts"],"sourcesContent":["import { create } from \"zustand\";\r\nimport type {\r\n  OptionsType,\r\n  ReactivityType,\r\n  StateKeys,\r\n  SyncActionsType,\r\n  SyncInfo,\r\n  UpdateTypeDetail,\r\n} from \"./CogsState.js\";\r\n\r\ntype StateUpdater<StateValue> =\r\n  | StateValue\r\n  | ((prevValue: StateValue) => StateValue);\r\n\r\nexport type FreshValuesObject = {\r\n  pathsToValues?: string[];\r\n  prevValue?: any;\r\n  newValue?: any;\r\n  timeStamp: number;\r\n};\r\n\r\ntype SyncLogType = {\r\n  timeStamp: number;\r\n};\r\ntype StateValue = any;\r\n\r\nexport type TrieNode = {\r\n  subscribers: Set<string>;\r\n  children: Map<string, TrieNode>;\r\n};\r\nexport type ComponentsType = {\r\n  components: Map<\r\n    string,\r\n    {\r\n      forceUpdate: () => void;\r\n      paths: Set<string>;\r\n      deps?: any[];\r\n      depsFunction?: (state: any) => any[] | true;\r\n      reactiveType: ReactivityType[] | ReactivityType;\r\n    }\r\n  >;\r\n};\r\nexport type FormRefStoreState = {\r\n  formRefs: Map<string, React.RefObject<any>>;\r\n  registerFormRef: (id: string, ref: React.RefObject<any>) => void;\r\n  getFormRef: (id: string) => React.RefObject<any> | undefined;\r\n  removeFormRef: (id: string) => void;\r\n  // New method to get all refs for a stateKey\r\n  getFormRefsByStateKey: (\r\n    stateKey: string\r\n  ) => Map<string, React.RefObject<any>>;\r\n};\r\n\r\nexport const formRefStore = create<FormRefStoreState>((set, get) => ({\r\n  formRefs: new Map(),\r\n\r\n  registerFormRef: (id, ref) =>\r\n    set((state) => {\r\n      const newRefs = new Map(state.formRefs);\r\n      newRefs.set(id, ref);\r\n      return { formRefs: newRefs };\r\n    }),\r\n\r\n  getFormRef: (id) => get().formRefs.get(id),\r\n\r\n  removeFormRef: (id) =>\r\n    set((state) => {\r\n      const newRefs = new Map(state.formRefs);\r\n      newRefs.delete(id);\r\n      return { formRefs: newRefs };\r\n    }),\r\n\r\n  // Get all refs that start with the stateKey prefix\r\n  getFormRefsByStateKey: (stateKey) => {\r\n    const allRefs = get().formRefs;\r\n    const stateKeyPrefix = stateKey + \".\";\r\n    const filteredRefs = new Map();\r\n\r\n    allRefs.forEach((ref, id) => {\r\n      if (id.startsWith(stateKeyPrefix) || id === stateKey) {\r\n        filteredRefs.set(id, ref);\r\n      }\r\n    });\r\n\r\n    return filteredRefs;\r\n  },\r\n}));\r\n\r\ntype ShadowMetadata = {\r\n  virtualisedState?: { listItemHeight: number };\r\n  syncInfo?: { status: string };\r\n  // Add other metadata fields you need\r\n};\r\n\r\ntype ShadowState<T> =\r\n  T extends Array<infer U>\r\n    ? Array<ShadowState<U>> & ShadowMetadata\r\n    : T extends object\r\n      ? { [K in keyof T]: ShadowState<T[K]> } & ShadowMetadata\r\n      : ShadowMetadata;\r\nexport type CogsGlobalState = {\r\n  shadowStateStore: { [key: string]: any };\r\n  initializeShadowState: (key: string, initialState: any) => void;\r\n  updateShadowAtPath: (key: string, path: string[], newValue: any) => void;\r\n  insertShadowArrayElement: (\r\n    key: string,\r\n    arrayPath: string[],\r\n    newItem: any\r\n  ) => void;\r\n  removeShadowArrayElement: (\r\n    key: string,\r\n    arrayPath: string[],\r\n    index: number\r\n  ) => void;\r\n  getShadowMetadata: (key: string, path: string[]) => any;\r\n  setShadowMetadata: (key: string, path: string[], metadata: any) => void;\r\n\r\n  selectedIndicesMap: Map<string, Map<string, number>>; // stateKey -> (parentPath -> selectedIndex)\r\n\r\n  // Add these new methods\r\n  getSelectedIndex: (\r\n    stateKey: string,\r\n    parentPath: string\r\n  ) => number | undefined;\r\n  setSelectedIndex: (\r\n    stateKey: string,\r\n    parentPath: string,\r\n    index: number | undefined\r\n  ) => void;\r\n  clearSelectedIndex: ({\r\n    stateKey,\r\n    path,\r\n  }: {\r\n    stateKey: string;\r\n    path: string[];\r\n  }) => void;\r\n  clearSelectedIndexesForState: (stateKey: string) => void;\r\n  updaterState: { [key: string]: any };\r\n  initialStateOptions: { [key: string]: OptionsType };\r\n  cogsStateStore: { [key: string]: StateValue };\r\n  isLoadingGlobal: { [key: string]: boolean };\r\n\r\n  initialStateGlobal: { [key: string]: StateValue };\r\n  iniitialCreatedState: { [key: string]: StateValue };\r\n  validationErrors: Map<string, string[]>;\r\n\r\n  serverState: { [key: string]: StateValue };\r\n  serverSyncActions: { [key: string]: SyncActionsType<any> };\r\n\r\n  serverSyncLog: { [key: string]: SyncLogType[] };\r\n  serverSideOrNot: { [key: string]: boolean };\r\n  setServerSyncLog: (key: string, newValue: SyncLogType) => void;\r\n\r\n  setServerSideOrNot: (key: string, value: boolean) => void;\r\n  getServerSideOrNot: (key: string) => boolean | undefined;\r\n  setServerState: <StateKey extends StateKeys>(\r\n    key: StateKey,\r\n    value: StateValue\r\n  ) => void;\r\n\r\n  getThisLocalUpdate: (key: string) => UpdateTypeDetail[] | undefined;\r\n  setServerSyncActions: (key: string, value: SyncActionsType<any>) => void;\r\n  addValidationError: (path: string, message: string) => void;\r\n  getValidationErrors: (path: string) => string[];\r\n  updateInitialStateGlobal: (key: string, newState: StateValue) => void;\r\n  updateInitialCreatedState: (key: string, newState: StateValue) => void;\r\n  getInitialOptions: (key: string) => OptionsType | undefined;\r\n  getUpdaterState: (key: string) => StateUpdater<StateValue>;\r\n  setUpdaterState: (key: string, newUpdater: any) => void;\r\n  getKeyState: <StateKey extends StateKeys>(key: StateKey) => StateValue;\r\n  getNestedState: <StateKey extends StateKeys>(\r\n    key: StateKey,\r\n    path: string[]\r\n  ) => StateValue;\r\n  setState: <StateKey extends StateKeys>(\r\n    key: StateKey,\r\n    value: StateUpdater<StateValue>\r\n  ) => void;\r\n  setInitialStates: (initialState: StateValue) => void;\r\n  setCreatedState: (initialState: StateValue) => void;\r\n  stateLog: { [key: string]: UpdateTypeDetail[] };\r\n  setStateLog: (\r\n    key: string,\r\n    updater: (prevUpdates: UpdateTypeDetail[]) => UpdateTypeDetail[]\r\n  ) => void;\r\n  setIsLoadingGlobal: (key: string, value: boolean) => void;\r\n\r\n  setInitialStateOptions: (key: string, value: OptionsType) => void;\r\n  removeValidationError: (path: string) => void;\r\n  signalDomElements: Map<\r\n    string,\r\n    Set<{\r\n      instanceId: string;\r\n      parentId: string;\r\n      position: number;\r\n      effect?: string;\r\n      map?: string;\r\n    }>\r\n  >;\r\n  addSignalElement: (\r\n    signalId: string,\r\n    elementInfo: {\r\n      instanceId: string;\r\n      parentId: string;\r\n      position: number;\r\n      effect?: string;\r\n      map?: string;\r\n    }\r\n  ) => void;\r\n  removeSignalElement: (signalId: string, instanceId: string) => void;\r\n  reRenderTriggerPrevValue: Record<string, any>;\r\n\r\n  reactiveDeps: Record<\r\n    string,\r\n    {\r\n      deps: any[];\r\n      updaters: Set<() => void>;\r\n      depsFunction: ((state: any) => any[] | true) | null;\r\n    }\r\n  >;\r\n  setReactiveDeps: (\r\n    key: string,\r\n    record: {\r\n      deps: any[];\r\n      updaters: Set<() => void>;\r\n      depsFunction: ((state: any) => any[] | true) | null;\r\n    }\r\n  ) => void;\r\n  deleteReactiveDeps: (key: string) => void;\r\n  subscribe: (listener: () => void) => () => void;\r\n\r\n  stateComponents: Map<string, ComponentsType>;\r\n  syncInfoStore: Map<string, SyncInfo>;\r\n  setSyncInfo: (key: string, syncInfo: SyncInfo) => void;\r\n  getSyncInfo: (key: string) => SyncInfo | null;\r\n};\r\n\r\nexport const getGlobalStore = create<CogsGlobalState>((set, get) => ({\r\n  shadowStateStore: {},\r\n  getShadowMetadata: (key: string, path: string[]) => {\r\n    const shadow = get().shadowStateStore[key];\r\n    if (!shadow) return null;\r\n\r\n    let current = shadow;\r\n    for (const segment of path) {\r\n      current = current?.[segment];\r\n      if (!current) return null;\r\n    }\r\n\r\n    return current;\r\n  },\r\n\r\n  setShadowMetadata: (key: string, path: string[], metadata: any) => {\r\n    set((state) => {\r\n      const newShadow = { ...state.shadowStateStore };\r\n      if (!newShadow[key]) return state;\r\n\r\n      newShadow[key] = JSON.parse(JSON.stringify(newShadow[key]));\r\n\r\n      let current: any = newShadow[key];\r\n      for (const segment of path) {\r\n        if (!current[segment]) current[segment] = {};\r\n        current = current[segment];\r\n      }\r\n\r\n      // Merge the metadata into the existing structure\r\n      Object.keys(metadata).forEach((category) => {\r\n        if (!current[category]) {\r\n          current[category] = {};\r\n        }\r\n        Object.assign(current[category], metadata[category]);\r\n      });\r\n\r\n      return { shadowStateStore: newShadow };\r\n    });\r\n  },\r\n  initializeShadowState: (key: string, initialState: any) => {\r\n    const createShadowStructure = (obj: any): any => {\r\n      if (Array.isArray(obj)) {\r\n        return new Array(obj.length)\r\n          .fill(null)\r\n          .map((_, i) => createShadowStructure(obj[i]));\r\n      }\r\n      if (typeof obj === \"object\" && obj !== null) {\r\n        const shadow: any = {};\r\n        for (const k in obj) {\r\n          shadow[k] = createShadowStructure(obj[k]);\r\n        }\r\n        return shadow;\r\n      }\r\n      return {}; // Leaf node - empty object for metadata\r\n    };\r\n\r\n    set((state) => ({\r\n      shadowStateStore: {\r\n        ...state.shadowStateStore,\r\n        [key]: createShadowStructure(initialState),\r\n      },\r\n    }));\r\n  },\r\n\r\n  updateShadowAtPath: (key: string, path: string[], newValue: any) => {\r\n    set((state) => {\r\n      const newShadow = { ...state.shadowStateStore };\r\n      if (!newShadow[key]) return state;\r\n\r\n      let current = newShadow[key];\r\n      const pathCopy = [...path];\r\n      const lastSegment = pathCopy.pop();\r\n\r\n      // Navigate to parent\r\n      for (const segment of pathCopy) {\r\n        if (!current[segment]) current[segment] = {};\r\n        current = current[segment];\r\n      }\r\n\r\n      // Update shadow structure to match new value structure\r\n      if (lastSegment !== undefined) {\r\n        if (Array.isArray(newValue)) {\r\n          current[lastSegment] = new Array(newValue.length);\r\n        } else if (typeof newValue === \"object\" && newValue !== null) {\r\n          current[lastSegment] = {};\r\n        } else {\r\n          current[lastSegment] = current[lastSegment] || {};\r\n        }\r\n      }\r\n\r\n      return { shadowStateStore: newShadow };\r\n    });\r\n  },\r\n\r\n  insertShadowArrayElement: (\r\n    key: string,\r\n    arrayPath: string[],\r\n    newItem: any\r\n  ) => {\r\n    set((state) => {\r\n      const newShadow = { ...state.shadowStateStore };\r\n      if (!newShadow[key]) return state;\r\n\r\n      newShadow[key] = JSON.parse(JSON.stringify(newShadow[key]));\r\n\r\n      let current: any = newShadow[key];\r\n\r\n      for (const segment of arrayPath) {\r\n        current = current[segment];\r\n        if (!current) return state;\r\n      }\r\n\r\n      if (Array.isArray(current)) {\r\n        // Create shadow structure based on the actual new item\r\n        const createShadowStructure = (obj: any): any => {\r\n          if (Array.isArray(obj)) {\r\n            return obj.map((item) => createShadowStructure(item));\r\n          }\r\n          if (typeof obj === \"object\" && obj !== null) {\r\n            const shadow: any = {};\r\n            for (const k in obj) {\r\n              shadow[k] = createShadowStructure(obj[k]);\r\n            }\r\n            return shadow;\r\n          }\r\n          return {}; // Leaf nodes get empty object for metadata\r\n        };\r\n\r\n        current.push(createShadowStructure(newItem));\r\n      }\r\n\r\n      return { shadowStateStore: newShadow };\r\n    });\r\n  },\r\n\r\n  removeShadowArrayElement: (\r\n    key: string,\r\n    arrayPath: string[],\r\n    index: number\r\n  ) => {\r\n    set((state) => {\r\n      const newShadow = { ...state.shadowStateStore };\r\n      let current = newShadow[key];\r\n\r\n      for (const segment of arrayPath) {\r\n        current = current?.[segment];\r\n      }\r\n\r\n      if (Array.isArray(current)) {\r\n        current.splice(index, 1);\r\n      }\r\n\r\n      return { shadowStateStore: newShadow };\r\n    });\r\n  },\r\n  selectedIndicesMap: new Map<string, Map<string, number>>(),\r\n\r\n  // Add the new methods\r\n  getSelectedIndex: (stateKey: string, parentPath: string) => {\r\n    const stateMap = get().selectedIndicesMap.get(stateKey);\r\n    if (!stateMap) return undefined;\r\n    return stateMap.get(parentPath);\r\n  },\r\n\r\n  setSelectedIndex: (\r\n    stateKey: string,\r\n    parentPath: string,\r\n    index: number | undefined\r\n  ) => {\r\n    set((state) => {\r\n      const newMap = new Map(state.selectedIndicesMap);\r\n      let stateMap = newMap.get(stateKey);\r\n\r\n      if (!stateMap) {\r\n        stateMap = new Map<string, number>();\r\n        newMap.set(stateKey, stateMap);\r\n      }\r\n\r\n      if (index === undefined) {\r\n        stateMap.delete(parentPath);\r\n      } else {\r\n        stateMap.set(parentPath, index);\r\n      }\r\n\r\n      return {\r\n        ...state,\r\n        selectedIndicesMap: newMap,\r\n      };\r\n    });\r\n  },\r\n  clearSelectedIndex: ({\r\n    stateKey,\r\n    path,\r\n  }: {\r\n    stateKey: string;\r\n    path: string[];\r\n  }) => {\r\n    set((state) => {\r\n      const newMap = new Map(state.selectedIndicesMap);\r\n      const stateMap = newMap.get(stateKey);\r\n      if (!stateMap) return state;\r\n      const parentPath = path.join(\".\");\r\n      stateMap.delete(parentPath);\r\n      return {\r\n        ...state,\r\n        selectedIndicesMap: newMap,\r\n      };\r\n    });\r\n  },\r\n  clearSelectedIndexesForState: (stateKey: string) => {\r\n    set((state) => {\r\n      const newOuterMap = new Map(state.selectedIndicesMap);\r\n      const changed = newOuterMap.delete(stateKey);\r\n      if (changed) {\r\n        console.log(\r\n          `Cleared selected indices map entry for stateKey: ${stateKey}`\r\n        );\r\n        return { selectedIndicesMap: newOuterMap };\r\n      } else {\r\n        return {};\r\n      }\r\n    });\r\n  },\r\n  stateComponents: new Map(),\r\n  subscribe: (listener: () => void) => {\r\n    // zustand's subscribe returns an unsubscribe function\r\n    return get().subscribe(listener);\r\n  },\r\n\r\n  reactiveDeps: {},\r\n  setReactiveDeps: (key, record) =>\r\n    set((state) => ({\r\n      ...state,\r\n      reactiveDeps: {\r\n        ...state.reactiveDeps,\r\n        [key]: record,\r\n      },\r\n    })),\r\n  deleteReactiveDeps: (key) =>\r\n    set((state) => {\r\n      const { [key]: _, ...rest } = state.reactiveDeps;\r\n      return {\r\n        ...state,\r\n        reactiveDeps: rest,\r\n      };\r\n    }),\r\n\r\n  reRenderTriggerPrevValue: {},\r\n  signalDomElements: new Map(),\r\n  addSignalElement: (\r\n    signalId: string,\r\n    elementInfo: { instanceId: string; parentId: string; position: number }\r\n  ) => {\r\n    const current = get().signalDomElements;\r\n    if (!current.has(signalId)) {\r\n      current.set(signalId, new Set());\r\n    }\r\n    current.get(signalId)!.add(elementInfo);\r\n\r\n    set({ signalDomElements: new Map(current) }); // Create new reference to trigger update\r\n  },\r\n  removeSignalElement: (signalId: string, instanceId: string) => {\r\n    const current = get().signalDomElements;\r\n    const elements = current.get(signalId);\r\n    if (elements) {\r\n      elements.forEach((el) => {\r\n        if (el.instanceId === instanceId) {\r\n          elements.delete(el);\r\n        }\r\n      });\r\n    }\r\n    set({ signalDomElements: new Map(current) });\r\n  },\r\n  initialStateOptions: {},\r\n  updaterState: {},\r\n  stateTimeline: {},\r\n  cogsStateStore: {},\r\n  stateLog: {},\r\n  isLoadingGlobal: {},\r\n\r\n  initialStateGlobal: {},\r\n  iniitialCreatedState: {},\r\n  updateInitialCreatedState: (key, newState) => {\r\n    set((prev) => ({\r\n      iniitialCreatedState: {\r\n        ...prev.iniitialCreatedState,\r\n        [key]: newState,\r\n      },\r\n    }));\r\n  },\r\n\r\n  validationErrors: new Map(),\r\n\r\n  serverState: {},\r\n\r\n  serverSyncActions: {},\r\n\r\n  serverSyncLog: {},\r\n  serverSideOrNot: {},\r\n  setServerSyncLog: (key, newValue) => {\r\n    set((state) => ({\r\n      serverSyncLog: {\r\n        ...state.serverSyncLog,\r\n        [key]: [...(state.serverSyncLog[key] ?? []), newValue],\r\n      },\r\n    }));\r\n  },\r\n  setServerSideOrNot: (key, value) => {\r\n    set((state) => ({\r\n      serverSideOrNot: {\r\n        ...state.serverSideOrNot,\r\n        [key]: value,\r\n      },\r\n    }));\r\n  },\r\n  getServerSideOrNot: (key) => {\r\n    return get().serverSideOrNot[key];\r\n  },\r\n\r\n  getThisLocalUpdate: (key: string) => {\r\n    return get().stateLog[key];\r\n  },\r\n  setServerState: <StateKey extends StateKeys>(\r\n    key: StateKey,\r\n    value: StateValue\r\n  ) => {\r\n    set((prev) => ({\r\n      serverState: {\r\n        ...prev.serverState,\r\n        [key]: value,\r\n      },\r\n    }));\r\n  },\r\n\r\n  setStateLog: (\r\n    key: string,\r\n    updater: (prevUpdates: UpdateTypeDetail[]) => UpdateTypeDetail[]\r\n  ) => {\r\n    set((prev) => {\r\n      const currentUpdates = prev.stateLog[key] ?? [];\r\n      const newUpdates = updater(currentUpdates);\r\n      return {\r\n        stateLog: {\r\n          ...prev.stateLog,\r\n          [key]: newUpdates,\r\n        },\r\n      };\r\n    });\r\n  },\r\n  setIsLoadingGlobal: (key: string, value: boolean) => {\r\n    set((prev) => ({\r\n      isLoadingGlobal: {\r\n        ...prev.isLoadingGlobal,\r\n        [key]: value,\r\n      },\r\n    }));\r\n  },\r\n  setServerSyncActions: (key: string, value: SyncActionsType<any>) => {\r\n    set((prev) => ({\r\n      serverSyncActions: {\r\n        ...prev.serverSyncActions,\r\n        [key]: value,\r\n      },\r\n    }));\r\n  },\r\n  addValidationError: (path, message) => {\r\n    console.log(\"addValidationError---\");\r\n    set((prev) => {\r\n      const updatedErrors = new Map(prev.validationErrors);\r\n      const existingMessages = updatedErrors.get(path) || [];\r\n      console.log(\"addValidationError\", path, message, existingMessages);\r\n      // Append the new message instead of replacing\r\n      updatedErrors.set(path, [...existingMessages, message]);\r\n      return { validationErrors: updatedErrors };\r\n    });\r\n  },\r\n  removeValidationError: (path) => {\r\n    set((prev) => {\r\n      const updatedErrors = new Map(prev.validationErrors);\r\n\r\n      let doSomething = false;\r\n      const pathArray = path.split(\".\");\r\n      Array.from(updatedErrors.keys()).forEach((key) => {\r\n        const keyArray = key.split(\".\");\r\n        if (keyArray.length >= pathArray.length) {\r\n          let match = true;\r\n          for (let i = 0; i < pathArray.length; i++) {\r\n            if (keyArray[i] !== pathArray[i]) {\r\n              match = false;\r\n              break;\r\n            }\r\n          }\r\n\r\n          if (match) {\r\n            doSomething = true;\r\n            updatedErrors.delete(key);\r\n          }\r\n        }\r\n      });\r\n\r\n      return doSomething ? { validationErrors: updatedErrors } : prev;\r\n    });\r\n  },\r\n  getValidationErrors: (path: string) => {\r\n    const errors: string[] = [];\r\n    const valErrors = get().validationErrors;\r\n    const pathArray = path.split(\".\");\r\n\r\n    // Helper to check if an index matches either a wildcard or is in an array of indices\r\n    const isIndexMatch = (pathSegment: string, keySegment: string) => {\r\n      if (pathSegment === \"[*]\") return true;\r\n      if (Array.isArray(pathSegment)) {\r\n        return pathSegment.includes(parseInt(keySegment));\r\n      }\r\n      return pathSegment === keySegment;\r\n    };\r\n\r\n    Array.from(valErrors.keys()).forEach((key) => {\r\n      const keyArray = key.split(\".\");\r\n      if (keyArray.length >= pathArray.length) {\r\n        let match = true;\r\n        for (let i = 0; i < pathArray.length; i++) {\r\n          const pathSegment = pathArray[i];\r\n          const keySegment = keyArray[i]!;\r\n\r\n          // If current path segment is a number or [*], we need special handling\r\n          if (pathSegment === \"[*]\" || Array.isArray(pathSegment)) {\r\n            // Key segment should be a number if we're using [*] or array indices\r\n            const keyIndex = parseInt(keySegment);\r\n            if (isNaN(keyIndex)) {\r\n              match = false;\r\n              break;\r\n            }\r\n\r\n            if (!isIndexMatch(pathSegment, keySegment)) {\r\n              match = false;\r\n              break;\r\n            }\r\n          } else if (pathSegment !== keySegment) {\r\n            match = false;\r\n            break;\r\n          }\r\n        }\r\n\r\n        if (match) {\r\n          const errorMessages = valErrors.get(key);\r\n          if (errorMessages) {\r\n            errors.push(...errorMessages);\r\n          }\r\n        }\r\n      }\r\n    });\r\n\r\n    return errors;\r\n  },\r\n  getInitialOptions: (key) => {\r\n    return get().initialStateOptions[key];\r\n  },\r\n  getNestedState: (key: string, path: string[]) => {\r\n    const rootState = get().cogsStateStore[key];\r\n\r\n    const getValueWithAsterisk = (obj: any, pathArray: string[]): any => {\r\n      if (pathArray.length === 0) return obj;\r\n\r\n      const currentPath = pathArray[0];\r\n      const remainingPath = pathArray.slice(1);\r\n\r\n      if (currentPath === \"[*]\") {\r\n        if (!Array.isArray(obj)) {\r\n          console.warn(\"Asterisk notation used on non-array value\");\r\n          return undefined;\r\n        }\r\n\r\n        if (remainingPath.length === 0) return obj;\r\n\r\n        // Get result for each array item\r\n        const results = obj.map((item) =>\r\n          getValueWithAsterisk(item, remainingPath)\r\n        );\r\n\r\n        // If the next path segment exists and returns arrays, flatten them\r\n        if (Array.isArray(results[0])) {\r\n          return results.flat();\r\n        }\r\n\r\n        return results;\r\n      }\r\n\r\n      const value = obj[currentPath as keyof typeof obj];\r\n      if (value === undefined) return undefined;\r\n\r\n      return getValueWithAsterisk(value, remainingPath);\r\n    };\r\n\r\n    // This will still get the value but we need to make it reactive only to specific paths\r\n    return getValueWithAsterisk(rootState, path);\r\n  },\r\n  setInitialStateOptions: (key, value) => {\r\n    set((prev) => ({\r\n      initialStateOptions: {\r\n        ...prev.initialStateOptions,\r\n        [key]: value,\r\n      },\r\n    }));\r\n  },\r\n  updateInitialStateGlobal: (key, newState) => {\r\n    set((prev) => ({\r\n      initialStateGlobal: {\r\n        ...prev.initialStateGlobal,\r\n        [key]: newState,\r\n      },\r\n    }));\r\n  },\r\n  getUpdaterState: (key) => {\r\n    return get().updaterState[key];\r\n  },\r\n  setUpdaterState: (key, newUpdater) => {\r\n    const current = get().updaterState;\r\n\r\n    if (!key || !newUpdater) return;\r\n\r\n    set({ updaterState: { ...(current ?? {}), [key]: newUpdater } });\r\n  },\r\n  getKeyState: <StateKey extends StateKeys>(key: StateKey) => {\r\n    return get().cogsStateStore[key];\r\n  },\r\n\r\n  setState: <StateKey extends StateKeys>(key: StateKey, value: StateValue) => {\r\n    set((prev) => {\r\n      return {\r\n        cogsStateStore: {\r\n          ...prev.cogsStateStore,\r\n          [key]:\r\n            typeof value === \"function\"\r\n              ? value(prev.cogsStateStore[key])\r\n              : value,\r\n        },\r\n      };\r\n    });\r\n  },\r\n  setInitialStates: <StateKey extends StateKeys>(initialState: StateValue) => {\r\n    set((prev) => ({\r\n      cogsStateStore: {\r\n        ...prev.cogsStateStore,\r\n        ...initialState,\r\n      },\r\n    }));\r\n  },\r\n  setCreatedState: (initialState: StateValue) => {\r\n    set((prev) => ({\r\n      iniitialCreatedState: {\r\n        ...prev.cogsStateStore,\r\n        ...initialState,\r\n      },\r\n    }));\r\n  },\r\n\r\n  syncInfoStore: new Map<string, SyncInfo>(),\r\n  setSyncInfo: (key: string, syncInfo: SyncInfo) =>\r\n    set((state) => {\r\n      const newMap = new Map(state.syncInfoStore);\r\n      newMap.set(key, syncInfo);\r\n      return { ...state, syncInfoStore: newMap };\r\n    }),\r\n  getSyncInfo: (key: string) => get().syncInfoStore.get(key) || null,\r\n}));\r\n"],"names":["formRefStore","create","set","get","id","ref","state","newRefs","stateKey","allRefs","stateKeyPrefix","filteredRefs","getGlobalStore","key","path","shadow","current","segment","metadata","newShadow","category","initialState","createShadowStructure","obj","_","i","k","newValue","pathCopy","lastSegment","arrayPath","newItem","item","index","parentPath","stateMap","newMap","newOuterMap","listener","record","rest","signalId","elementInfo","instanceId","elements","el","newState","prev","value","updater","currentUpdates","newUpdates","message","updatedErrors","existingMessages","doSomething","pathArray","keyArray","match","errors","valErrors","isIndexMatch","pathSegment","keySegment","keyIndex","errorMessages","rootState","getValueWithAsterisk","currentPath","remainingPath","results","newUpdater","syncInfo"],"mappings":"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"}