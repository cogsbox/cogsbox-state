{"version":3,"file":"store.js","sources":["../src/store.ts"],"sourcesContent":["import { create } from \"zustand\";\r\nimport type {\r\n    OptionsType,\r\n    StateKeys,\r\n    SyncActionsType,\r\n    SyncInfo,\r\n    UpdateTypeDetail,\r\n} from \"./CogsState.js\";\r\n\r\ntype StateUpdater<StateValue> =\r\n    | StateValue\r\n    | ((prevValue: StateValue) => StateValue);\r\n\r\nexport type FreshValuesObject = {\r\n    pathsToValues?: string[];\r\n    prevValue?: any;\r\n    newValue?: any;\r\n    timeStamp: number;\r\n};\r\n\r\ntype SyncLogType = {\r\n    timeStamp: number;\r\n};\r\ntype StateValue = any;\r\n\r\nexport type CogsGlobalState = {\r\n    updaterState: { [key: string]: any };\r\n    initialStateOptions: { [key: string]: OptionsType };\r\n    cogsStateStore: { [key: string]: StateValue };\r\n    isLoadingGlobal: { [key: string]: boolean };\r\n\r\n    initialStateGlobal: { [key: string]: StateValue };\r\n    validationErrors: Map<string, string[]>;\r\n\r\n    serverState: { [key: string]: StateValue };\r\n    serverSyncActions: { [key: string]: SyncActionsType<any> };\r\n\r\n    serverSyncLog: { [key: string]: SyncLogType[] };\r\n    serverSideOrNot: { [key: string]: boolean };\r\n    setServerSyncLog: (key: string, newValue: SyncLogType) => void;\r\n\r\n    setServerSideOrNot: (key: string, value: boolean) => void;\r\n    getServerSideOrNot: (key: string) => boolean | undefined;\r\n    setServerState: <StateKey extends StateKeys>(\r\n        key: StateKey,\r\n        value: StateValue,\r\n    ) => void;\r\n\r\n    getThisLocalUpdate: (key: string) => UpdateTypeDetail[] | undefined;\r\n    setServerSyncActions: (key: string, value: SyncActionsType<any>) => void;\r\n    addValidationError: (path: string, message: string) => void;\r\n    getValidationErrors: (path: string) => string[];\r\n    updateInitialStateGlobal: (key: string, newState: StateValue) => void;\r\n    getInitialOptions: (key: string) => OptionsType | undefined;\r\n    getUpdaterState: (key: string) => StateUpdater<StateValue>;\r\n    setUpdaterState: (key: string, newUpdater: any) => void;\r\n    getKeyState: <StateKey extends StateKeys>(key: StateKey) => StateValue;\r\n    getNestedState: <StateKey extends StateKeys>(\r\n        key: StateKey,\r\n        path: string[],\r\n    ) => StateValue;\r\n    setState: <StateKey extends StateKeys>(\r\n        key: StateKey,\r\n        value: StateUpdater<StateValue>,\r\n    ) => void;\r\n    setInitialStates: (initialState: StateValue) => void;\r\n    stateLog: { [key: string]: UpdateTypeDetail[] };\r\n    setStateLog: (\r\n        key: string,\r\n        updater: (prevUpdates: UpdateTypeDetail[]) => UpdateTypeDetail[],\r\n    ) => void;\r\n    setIsLoadingGlobal: (key: string, value: boolean) => void;\r\n\r\n    setInitialStateOptions: (key: string, value: OptionsType) => void;\r\n    removeValidationError: (path: string) => void;\r\n    signalDomElements: Map<\r\n        string,\r\n        Set<{\r\n            instanceId: string;\r\n            parentId: string;\r\n            position: number;\r\n            effect?: string;\r\n        }>\r\n    >;\r\n    addSignalElement: (\r\n        signalId: string,\r\n        elementInfo: {\r\n            instanceId: string;\r\n            parentId: string;\r\n            position: number;\r\n            effect?: string;\r\n        },\r\n    ) => void;\r\n    removeSignalElement: (signalId: string, instanceId: string) => void;\r\n    reRenderTriggerPrevValue: Record<string, any>;\r\n\r\n    reactiveDeps: Record<\r\n        string,\r\n        {\r\n            deps: any[];\r\n            updaters: Set<() => void>;\r\n            depsFunction: ((state: any) => any[] | true) | null;\r\n        }\r\n    >;\r\n    setReactiveDeps: (\r\n        key: string,\r\n        record: {\r\n            deps: any[];\r\n            updaters: Set<() => void>;\r\n            depsFunction: ((state: any) => any[] | true) | null;\r\n        },\r\n    ) => void;\r\n    deleteReactiveDeps: (key: string) => void;\r\n    subscribe: (listener: () => void) => () => void;\r\n\r\n    stateComponents: Map<\r\n        string,\r\n        {\r\n            components: Map<\r\n                string,\r\n                {\r\n                    forceUpdate: () => void;\r\n                    paths: Set<string>;\r\n                    deps?: any[];\r\n                    depsFunction?: (state: any) => any[] | true;\r\n                }\r\n            >;\r\n        }\r\n    >;\r\n    syncInfoStore: Map<string, SyncInfo>;\r\n    setSyncInfo: (key: string, syncInfo: SyncInfo) => void;\r\n    getSyncInfo: (key: string) => SyncInfo | null;\r\n};\r\n\r\nexport const getGlobalStore = create<CogsGlobalState>((set, get) => ({\r\n    stateComponents: new Map(),\r\n    subscribe: (listener: () => void) => {\r\n        // zustand's subscribe returns an unsubscribe function\r\n        return get().subscribe(listener);\r\n    },\r\n\r\n    reactiveDeps: {},\r\n    setReactiveDeps: (key, record) =>\r\n        set((state) => ({\r\n            ...state,\r\n            reactiveDeps: {\r\n                ...state.reactiveDeps,\r\n                [key]: record,\r\n            },\r\n        })),\r\n    deleteReactiveDeps: (key) =>\r\n        set((state) => {\r\n            const { [key]: _, ...rest } = state.reactiveDeps;\r\n            return {\r\n                ...state,\r\n                reactiveDeps: rest,\r\n            };\r\n        }),\r\n\r\n    reRenderTriggerPrevValue: {},\r\n    signalDomElements: new Map(),\r\n    addSignalElement: (\r\n        signalId: string,\r\n        elementInfo: { instanceId: string; parentId: string; position: number },\r\n    ) => {\r\n        console.log(\"Adding signal element\", signalId, elementInfo);\r\n        const current = get().signalDomElements;\r\n        if (!current.has(signalId)) {\r\n            current.set(signalId, new Set());\r\n        }\r\n        current.get(signalId)!.add(elementInfo);\r\n        console.log(\"After adding\", current.get(signalId));\r\n        set({ signalDomElements: new Map(current) }); // Create new reference to trigger update\r\n    },\r\n    removeSignalElement: (signalId: string, instanceId: string) => {\r\n        console.log(\"Removing signal element\", signalId, instanceId);\r\n        const current = get().signalDomElements;\r\n        const elements = current.get(signalId);\r\n        if (elements) {\r\n            elements.forEach((el) => {\r\n                if (el.instanceId === instanceId) {\r\n                    elements.delete(el);\r\n                }\r\n            });\r\n        }\r\n        set({ signalDomElements: new Map(current) });\r\n    },\r\n    initialStateOptions: {},\r\n    updaterState: {},\r\n    stateTimeline: {},\r\n    cogsStateStore: {},\r\n    stateLog: {},\r\n    isLoadingGlobal: {},\r\n\r\n    initialStateGlobal: {},\r\n    validationErrors: new Map(),\r\n\r\n    serverState: {},\r\n\r\n    serverSyncActions: {},\r\n\r\n    serverSyncLog: {},\r\n    serverSideOrNot: {},\r\n    setServerSyncLog: (key, newValue) => {\r\n        set((state) => ({\r\n            serverSyncLog: {\r\n                ...state.serverSyncLog,\r\n                [key]: [...(state.serverSyncLog[key] ?? []), newValue],\r\n            },\r\n        }));\r\n    },\r\n    setServerSideOrNot: (key, value) => {\r\n        set((state) => ({\r\n            serverSideOrNot: {\r\n                ...state.serverSideOrNot,\r\n                [key]: value,\r\n            },\r\n        }));\r\n    },\r\n    getServerSideOrNot: (key) => {\r\n        return get().serverSideOrNot[key];\r\n    },\r\n\r\n    getThisLocalUpdate: (key: string) => {\r\n        return get().stateLog[key];\r\n    },\r\n    setServerState: <StateKey extends StateKeys>(\r\n        key: StateKey,\r\n        value: StateValue,\r\n    ) => {\r\n        set((prev) => ({\r\n            serverState: {\r\n                ...prev.serverState,\r\n                [key]: value,\r\n            },\r\n        }));\r\n    },\r\n\r\n    setStateLog: (\r\n        key: string,\r\n        updater: (prevUpdates: UpdateTypeDetail[]) => UpdateTypeDetail[],\r\n    ) => {\r\n        set((prev) => {\r\n            const currentUpdates = prev.stateLog[key] ?? [];\r\n            const newUpdates = updater(currentUpdates);\r\n            return {\r\n                stateLog: {\r\n                    ...prev.stateLog,\r\n                    [key]: newUpdates,\r\n                },\r\n            };\r\n        });\r\n    },\r\n    setIsLoadingGlobal: (key: string, value: boolean) => {\r\n        set((prev) => ({\r\n            isLoadingGlobal: {\r\n                ...prev.isLoadingGlobal,\r\n                [key]: value,\r\n            },\r\n        }));\r\n    },\r\n    setServerSyncActions: (key: string, value: SyncActionsType<any>) => {\r\n        set((prev) => ({\r\n            serverSyncActions: {\r\n                ...prev.serverSyncActions,\r\n                [key]: value,\r\n            },\r\n        }));\r\n    },\r\n    addValidationError: (path, message) => {\r\n        set((prev) => {\r\n            const updatedErrors = new Map(prev.validationErrors);\r\n\r\n            const existingMessages = updatedErrors.get(path) || [];\r\n            updatedErrors.set(path, [...existingMessages, message]);\r\n            return { validationErrors: updatedErrors };\r\n        });\r\n    },\r\n    removeValidationError: (path) => {\r\n        set((prev) => {\r\n            const updatedErrors = new Map(prev.validationErrors);\r\n            console.log(\"updatedErrors\", updatedErrors);\r\n            let doSomething = false;\r\n            const pathArray = path.split(\".\");\r\n            Array.from(updatedErrors.keys()).forEach((key) => {\r\n                const keyArray = key.split(\".\");\r\n                if (keyArray.length >= pathArray.length) {\r\n                    let match = true;\r\n                    for (let i = 0; i < pathArray.length; i++) {\r\n                        if (keyArray[i] !== pathArray[i]) {\r\n                            match = false;\r\n                            break;\r\n                        }\r\n                    }\r\n\r\n                    if (match) {\r\n                        doSomething = true;\r\n                        updatedErrors.delete(key);\r\n                    }\r\n                }\r\n            });\r\n\r\n            return doSomething ? { validationErrors: updatedErrors } : prev;\r\n        });\r\n    },\r\n    getValidationErrors: (path: string) => {\r\n        const errors: string[] = [];\r\n        const valErrors = get().validationErrors;\r\n        const pathArray = path.split(\".\");\r\n\r\n        // Helper to check if an index matches either a wildcard or is in an array of indices\r\n        const isIndexMatch = (pathSegment: string, keySegment: string) => {\r\n            if (pathSegment === \"[*]\") return true;\r\n            if (Array.isArray(pathSegment)) {\r\n                return pathSegment.includes(parseInt(keySegment));\r\n            }\r\n            return pathSegment === keySegment;\r\n        };\r\n\r\n        Array.from(valErrors.keys()).forEach((key) => {\r\n            const keyArray = key.split(\".\");\r\n            if (keyArray.length >= pathArray.length) {\r\n                let match = true;\r\n                for (let i = 0; i < pathArray.length; i++) {\r\n                    const pathSegment = pathArray[i];\r\n                    const keySegment = keyArray[i]!;\r\n\r\n                    // If current path segment is a number or [*], we need special handling\r\n                    if (pathSegment === \"[*]\" || Array.isArray(pathSegment)) {\r\n                        // Key segment should be a number if we're using [*] or array indices\r\n                        const keyIndex = parseInt(keySegment);\r\n                        if (isNaN(keyIndex)) {\r\n                            match = false;\r\n                            break;\r\n                        }\r\n\r\n                        if (!isIndexMatch(pathSegment, keySegment)) {\r\n                            match = false;\r\n                            break;\r\n                        }\r\n                    } else if (pathSegment !== keySegment) {\r\n                        match = false;\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                if (match) {\r\n                    const errorMessages = valErrors.get(key);\r\n                    if (errorMessages) {\r\n                        errors.push(...errorMessages);\r\n                    }\r\n                }\r\n            }\r\n        });\r\n\r\n        return errors;\r\n    },\r\n    getInitialOptions: (key) => {\r\n        return get().initialStateOptions[key];\r\n    },\r\n    getNestedState: (key: string, path: string[]) => {\r\n        const rootState = get().cogsStateStore[key];\r\n\r\n        const getValueWithAsterisk = (obj: any, pathArray: string[]): any => {\r\n            if (pathArray.length === 0) return obj;\r\n\r\n            const currentPath = pathArray[0];\r\n            const remainingPath = pathArray.slice(1);\r\n\r\n            if (currentPath === \"[*]\") {\r\n                if (!Array.isArray(obj)) {\r\n                    console.warn(\"Asterisk notation used on non-array value\");\r\n                    return undefined;\r\n                }\r\n\r\n                if (remainingPath.length === 0) return obj;\r\n\r\n                // Get result for each array item\r\n                const results = obj.map((item) =>\r\n                    getValueWithAsterisk(item, remainingPath),\r\n                );\r\n\r\n                // If the next path segment exists and returns arrays, flatten them\r\n                if (Array.isArray(results[0])) {\r\n                    return results.flat();\r\n                }\r\n\r\n                return results;\r\n            }\r\n\r\n            const value = obj[currentPath as keyof typeof obj];\r\n            if (value === undefined) return undefined;\r\n\r\n            return getValueWithAsterisk(value, remainingPath);\r\n        };\r\n\r\n        // This will still get the value but we need to make it reactive only to specific paths\r\n        return getValueWithAsterisk(rootState, path);\r\n    },\r\n    setInitialStateOptions: (key, value) => {\r\n        set((prev) => ({\r\n            initialStateOptions: {\r\n                ...prev.initialStateOptions,\r\n                [key]: value,\r\n            },\r\n        }));\r\n    },\r\n    updateInitialStateGlobal: (key, newState) => {\r\n        set((prev) => ({\r\n            initialStateGlobal: {\r\n                ...prev.initialStateGlobal,\r\n                [key]: newState,\r\n            },\r\n        }));\r\n    },\r\n    getUpdaterState: (key) => {\r\n        return get().updaterState[key];\r\n    },\r\n    setUpdaterState: (key, newUpdater) => {\r\n        const current = get().updaterState;\r\n\r\n        if (!key || !newUpdater) return;\r\n\r\n        set({ updaterState: { ...(current ?? {}), [key]: newUpdater } });\r\n    },\r\n    getKeyState: <StateKey extends StateKeys>(key: StateKey) => {\r\n        return get().cogsStateStore[key];\r\n    },\r\n\r\n    setState: <StateKey extends StateKeys>(\r\n        key: StateKey,\r\n        value: StateValue,\r\n    ) => {\r\n        set((prev) => {\r\n            return {\r\n                cogsStateStore: {\r\n                    ...prev.cogsStateStore,\r\n                    [key]:\r\n                        typeof value === \"function\"\r\n                            ? value(prev.cogsStateStore[key])\r\n                            : value,\r\n                },\r\n            };\r\n        });\r\n    },\r\n    setInitialStates: <StateKey extends StateKeys>(\r\n        initialState: StateValue,\r\n    ) => {\r\n        set((prev) => ({\r\n            cogsStateStore: {\r\n                ...prev.cogsStateStore,\r\n                ...initialState,\r\n            },\r\n        }));\r\n    },\r\n    syncInfoStore: new Map<string, SyncInfo>(),\r\n    setSyncInfo: (key: string, syncInfo: SyncInfo) =>\r\n        set((state) => {\r\n            const newMap = new Map(state.syncInfoStore);\r\n            newMap.set(key, syncInfo);\r\n            return { ...state, syncInfoStore: newMap };\r\n        }),\r\n    getSyncInfo: (key: string) => get().syncInfoStore.get(key) || null,\r\n}));\r\n"],"names":["getGlobalStore","create","set","get","listener","key","record","state","_","rest","signalId","elementInfo","current","instanceId","elements","el","newValue","value","prev","updater","currentUpdates","newUpdates","path","message","updatedErrors","existingMessages","doSomething","pathArray","keyArray","match","i","errors","valErrors","isIndexMatch","pathSegment","keySegment","keyIndex","errorMessages","rootState","getValueWithAsterisk","obj","currentPath","remainingPath","results","item","newState","newUpdater","initialState","syncInfo","newMap"],"mappings":"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"}