{"version":3,"file":"store.js","sources":["../src/store.ts"],"sourcesContent":["import { create } from 'zustand';\r\nimport { ulid } from 'ulid';\r\nimport type {\r\n  OptionsType,\r\n  ReactivityType,\r\n  StateKeys,\r\n  SyncInfo,\r\n  UpdateTypeDetail,\r\n} from './CogsState.js';\r\n\r\nimport { startTransition, type ReactNode } from 'react';\r\n\r\ntype StateUpdater<StateValue> =\r\n  | StateValue\r\n  | ((prevValue: StateValue) => StateValue);\r\n\r\nexport type FreshValuesObject = {\r\n  pathsToValues?: string[];\r\n  prevValue?: any;\r\n  newValue?: any;\r\n  timeStamp: number;\r\n};\r\n\r\ntype SyncLogType = {\r\n  timeStamp: number;\r\n};\r\ntype StateValue = any;\r\n\r\nexport type TrieNode = {\r\n  subscribers: Set<string>;\r\n  children: Map<string, TrieNode>;\r\n};\r\n\r\nexport type FormRefStoreState = {\r\n  formRefs: Map<string, React.RefObject<any>>;\r\n  registerFormRef: (id: string, ref: React.RefObject<any>) => void;\r\n  getFormRef: (id: string) => React.RefObject<any> | undefined;\r\n  removeFormRef: (id: string) => void;\r\n  // New method to get all refs for a stateKey\r\n  getFormRefsByStateKey: (\r\n    stateKey: string\r\n  ) => Map<string, React.RefObject<any>>;\r\n};\r\n\r\nexport const formRefStore = create<FormRefStoreState>((set, get) => ({\r\n  formRefs: new Map(),\r\n\r\n  registerFormRef: (id, ref) =>\r\n    set((state) => {\r\n      const newRefs = new Map(state.formRefs);\r\n      newRefs.set(id, ref);\r\n      return { formRefs: newRefs };\r\n    }),\r\n\r\n  getFormRef: (id) => get().formRefs.get(id),\r\n\r\n  removeFormRef: (id) =>\r\n    set((state) => {\r\n      const newRefs = new Map(state.formRefs);\r\n      newRefs.delete(id);\r\n      return { formRefs: newRefs };\r\n    }),\r\n\r\n  // Get all refs that start with the stateKey prefix\r\n  getFormRefsByStateKey: (stateKey) => {\r\n    const allRefs = get().formRefs;\r\n    const stateKeyPrefix = stateKey + '.';\r\n    const filteredRefs = new Map();\r\n\r\n    allRefs.forEach((ref, id) => {\r\n      if (id.startsWith(stateKeyPrefix) || id === stateKey) {\r\n        filteredRefs.set(id, ref);\r\n      }\r\n    });\r\n\r\n    return filteredRefs;\r\n  },\r\n}));\r\nexport type ComponentsType = {\r\n  components?: Map<\r\n    string,\r\n    {\r\n      forceUpdate: () => void;\r\n      paths: Set<string>;\r\n      deps?: any[];\r\n      prevDeps?: any[];\r\n      depsFunction?: (state: any) => any[] | true;\r\n      reactiveType: ReactivityType[] | ReactivityType;\r\n    }\r\n  >;\r\n};\r\nexport type ShadowMetadata = {\r\n  id?: string;\r\n\r\n  stateSource?: 'default' | 'server' | 'localStorage';\r\n  lastServerSync?: number;\r\n  isDirty?: boolean;\r\n  baseServerState?: any;\r\n\r\n  arrayKeys?: string[];\r\n\r\n  fields?: Record<string, any>;\r\n  virtualizer?: {\r\n    itemHeight?: number;\r\n    domRef?: HTMLElement | null;\r\n  };\r\n  syncInfo?: { status: string };\r\n  validation?: ValidationState;\r\n  lastUpdated?: number;\r\n  value?: any;\r\n  classSignals?: Array<{\r\n    // <-- ADD THIS BLOCK\r\n    id: string;\r\n    effect: string;\r\n    lastClasses: string;\r\n    deps: any[];\r\n  }>;\r\n  signals?: Array<{\r\n    instanceId: string;\r\n    parentId: string;\r\n    position: number;\r\n    effect?: string;\r\n  }>;\r\n  mapWrappers?: Array<{\r\n    instanceId: string;\r\n    path: string[];\r\n    componentId: string;\r\n    meta?: any;\r\n    mapFn: (\r\n      setter: any,\r\n      index: number,\r\n\r\n      arraySetter: any\r\n    ) => ReactNode;\r\n    containerRef: HTMLDivElement | null;\r\n    rebuildStateShape: any;\r\n  }>;\r\n  transformCaches?: Map<\r\n    string,\r\n    {\r\n      validIds: string[];\r\n      computedAt: number;\r\n      transforms: Array<{ type: 'filter' | 'sort'; fn: Function }>;\r\n    }\r\n  >;\r\n  pathComponents?: Set<string>;\r\n  streams?: Map<\r\n    string,\r\n    {\r\n      buffer: any[];\r\n      flushTimer: NodeJS.Timeout | null;\r\n    }\r\n  >;\r\n} & ComponentsType;\r\n\r\nexport type ValidationStatus =\r\n  | 'PRISTINE' // Untouched, matches initial state.\r\n  | 'DIRTY' // Changed, but no validation run yet.\r\n  | 'VALID_LIVE' // Valid while typing.\r\n  | 'INVALID_LIVE' // Gentle error during typing.\r\n  | 'VALIDATION_FAILED' // Hard error on blur/submit.\r\n  | 'VALID_PENDING_SYNC' // Passed validation, ready for sync.\r\n  | 'SYNCING' // Actively being sent to the server.\r\n  | 'SYNCED' // Server confirmed success.\r\n  | 'SYNC_FAILED'; // Server rejected the data.\r\n\r\nexport type ValidationState = {\r\n  status: ValidationStatus;\r\n  message?: string;\r\n  lastValidated?: number;\r\n  validatedValue?: any;\r\n};\r\nexport type CogsEvent =\r\n  | { type: 'INSERT'; path: string; itemKey: string; index: number }\r\n  | { type: 'REMOVE'; path: string; itemKey: string }\r\n  | { type: 'UPDATE'; path: string; newValue: any }\r\n  | { type: 'ITEMHEIGHT'; itemKey: string; height: number } // For full re-initializations (e.g., when a component is removed)\r\n  | { type: 'RELOAD'; path: string }; // For full re-initializations\r\nexport type CogsGlobalState = {\r\n  updateQueue: Set<() => void>;\r\n  isFlushScheduled: boolean;\r\n\r\n  flushUpdates: () => void;\r\n\r\n  // --- Shadow State and Subscription System ---\r\n  registerComponent: (\r\n    stateKey: string,\r\n    componentId: string,\r\n    registration: any\r\n  ) => void;\r\n  unregisterComponent: (stateKey: string, componentId: string) => void;\r\n  addPathComponent: (\r\n    stateKey: string,\r\n    dependencyPath: string[],\r\n    fullComponentId: string\r\n  ) => void;\r\n  shadowStateStore: Map<string, ShadowMetadata>;\r\n\r\n  markAsDirty: (\r\n    key: string,\r\n    path: string[],\r\n    options: { bubble: boolean }\r\n  ) => void;\r\n  // These method signatures stay the same\r\n  initializeShadowState: (key: string, initialState: any) => void;\r\n  updateShadowAtPath: (key: string, path: string[], newValue: any) => void;\r\n  insertShadowArrayElement: (\r\n    key: string,\r\n    arrayPath: string[],\r\n    newItem: any\r\n  ) => void;\r\n  removeShadowArrayElement: (key: string, arrayPath: string[]) => void;\r\n  getShadowValue: (\r\n    key: string,\r\n\r\n    validArrayIds?: string[]\r\n  ) => any;\r\n\r\n  getShadowMetadata: (\r\n    key: string,\r\n    path: string[]\r\n  ) => ShadowMetadata | undefined;\r\n  setShadowMetadata: (\r\n    key: string,\r\n    path: string[],\r\n    metadata: Omit<ShadowMetadata, 'id'>\r\n  ) => void;\r\n  setTransformCache: (\r\n    key: string,\r\n    path: string[],\r\n    cacheKey: string,\r\n    cacheData: any\r\n  ) => void;\r\n\r\n  pathSubscribers: Map<string, Set<(newValue: any) => void>>;\r\n  subscribeToPath: (\r\n    path: string,\r\n    callback: (newValue: any) => void\r\n  ) => () => void;\r\n  notifyPathSubscribers: (updatedPath: string, newValue: any) => void;\r\n\r\n  selectedIndicesMap: Map<string, string>; // stateKey -> (parentPath -> selectedIndex)\r\n  getSelectedIndex: (stateKey: string, validArrayIds?: string[]) => number;\r\n  setSelectedIndex: (key: string, itemKey: string) => void;\r\n  clearSelectedIndex: ({ arrayKey }: { arrayKey: string }) => void;\r\n  clearSelectedIndexesForState: (stateKey: string) => void;\r\n\r\n  // --- Core State and Updaters ---\r\n\r\n  initialStateOptions: { [key: string]: OptionsType };\r\n\r\n  initialStateGlobal: { [key: string]: StateValue };\r\n\r\n  updateInitialStateGlobal: (key: string, newState: StateValue) => void;\r\n\r\n  getInitialOptions: (key: string) => OptionsType | undefined;\r\n  setInitialStateOptions: (key: string, value: OptionsType) => void;\r\n\r\n  // --- Validation ---\r\n\r\n  // --- Server Sync and Logging ---\r\n\r\n  serverStateUpdates: Map<\r\n    string,\r\n    {\r\n      data: any;\r\n      status: 'loading' | 'success' | 'error';\r\n      timestamp: number;\r\n    }\r\n  >;\r\n\r\n  setServerStateUpdate: (key: string, serverState: any) => void;\r\n\r\n  stateLog: Map<string, Map<string, UpdateTypeDetail>>;\r\n  syncInfoStore: Map<string, SyncInfo>;\r\n  addStateLog: (key: string, update: UpdateTypeDetail) => void;\r\n\r\n  setSyncInfo: (key: string, syncInfo: SyncInfo) => void;\r\n  getSyncInfo: (key: string) => SyncInfo | null;\r\n};\r\nconst isSimpleObject = (value: any): boolean => {\r\n  if (value === null || typeof value !== 'object') return false;\r\n\r\n  // Handle special cases that should be treated as primitives\r\n  if (\r\n    value instanceof Uint8Array ||\r\n    value instanceof Int8Array ||\r\n    value instanceof Uint16Array ||\r\n    value instanceof Int16Array ||\r\n    value instanceof Uint32Array ||\r\n    value instanceof Int32Array ||\r\n    value instanceof Float32Array ||\r\n    value instanceof Float64Array ||\r\n    value instanceof ArrayBuffer ||\r\n    value instanceof Date ||\r\n    value instanceof RegExp ||\r\n    value instanceof Map ||\r\n    value instanceof Set\r\n  ) {\r\n    return false; // Treat as primitive\r\n  }\r\n\r\n  // Arrays and plain objects are complex\r\n  return Array.isArray(value) || value.constructor === Object;\r\n};\r\nexport const getGlobalStore = create<CogsGlobalState>((set, get) => ({\r\n  updateQueue: new Set<() => void>(),\r\n  // A flag to ensure we only schedule the flush once per event-loop tick.\r\n  isFlushScheduled: false,\r\n\r\n  // This function is called by queueMicrotask to execute all queued updates.\r\n  flushUpdates: () => {\r\n    const { updateQueue } = get();\r\n\r\n    if (updateQueue.size > 0) {\r\n      startTransition(() => {\r\n        updateQueue.forEach((updateFn) => updateFn());\r\n      });\r\n    }\r\n\r\n    // Clear the queue and reset the flag for the next event loop tick.\r\n    set({ updateQueue: new Set(), isFlushScheduled: false });\r\n  },\r\n  addPathComponent: (stateKey, dependencyPath, fullComponentId) => {\r\n    set((state) => {\r\n      const newShadowStore = new Map(state.shadowStateStore);\r\n      const dependencyKey = [stateKey, ...dependencyPath].join('.');\r\n\r\n      // --- Part 1: Update the path's own metadata ---\r\n      const pathMeta = newShadowStore.get(dependencyKey) || {};\r\n      // Create a *new* Set to ensure immutability\r\n      const pathComponents = new Set(pathMeta.pathComponents);\r\n      pathComponents.add(fullComponentId);\r\n      // Update the metadata for the specific path\r\n      newShadowStore.set(dependencyKey, { ...pathMeta, pathComponents });\r\n\r\n      // --- Part 2: Update the component's own list of paths ---\r\n      const rootMeta = newShadowStore.get(stateKey) || {};\r\n      const component = rootMeta.components?.get(fullComponentId);\r\n\r\n      // If the component exists, update its `paths` set immutably\r\n      if (component) {\r\n        const newPaths = new Set(component.paths);\r\n        newPaths.add(dependencyKey);\r\n\r\n        const newComponentRegistration = { ...component, paths: newPaths };\r\n        const newComponentsMap = new Map(rootMeta.components);\r\n        newComponentsMap.set(fullComponentId, newComponentRegistration);\r\n\r\n        // Update the root metadata with the new components map\r\n        newShadowStore.set(stateKey, {\r\n          ...rootMeta,\r\n          components: newComponentsMap,\r\n        });\r\n      }\r\n\r\n      // Return the final, updated state\r\n      return { shadowStateStore: newShadowStore };\r\n    });\r\n  },\r\n  registerComponent: (stateKey, fullComponentId, registration) => {\r\n    set((state) => {\r\n      // Create a new Map to ensure Zustand detects the change\r\n      const newShadowStore = new Map(state.shadowStateStore);\r\n\r\n      // Get the metadata for the ROOT of the state (where the components map lives)\r\n      const rootMeta = newShadowStore.get(stateKey) || {};\r\n\r\n      // Also clone the components map to avoid direct mutation\r\n      const components = new Map(rootMeta.components);\r\n      components.set(fullComponentId, registration);\r\n\r\n      // Update the root metadata with the new components map\r\n      newShadowStore.set(stateKey, { ...rootMeta, components });\r\n\r\n      // Return the updated state\r\n      return { shadowStateStore: newShadowStore };\r\n    });\r\n  },\r\n\r\n  unregisterComponent: (stateKey, fullComponentId) => {\r\n    set((state) => {\r\n      const newShadowStore = new Map(state.shadowStateStore);\r\n      const rootMeta = newShadowStore.get(stateKey);\r\n\r\n      // If there's no metadata or no components map, do nothing\r\n      if (!rootMeta?.components) {\r\n        return state; // Return original state, no change needed\r\n      }\r\n\r\n      const components = new Map(rootMeta.components);\r\n      const wasDeleted = components.delete(fullComponentId);\r\n\r\n      // Only update state if something was actually deleted\r\n      if (wasDeleted) {\r\n        newShadowStore.set(stateKey, { ...rootMeta, components });\r\n        return { shadowStateStore: newShadowStore };\r\n      }\r\n\r\n      return state; // Nothing changed\r\n    });\r\n  },\r\n  markAsDirty: (key: string, path: string[], options = { bubble: true }) => {\r\n    const newShadowStore = new Map(get().shadowStateStore);\r\n    let changed = false;\r\n\r\n    const setDirty = (currentPath: string[]) => {\r\n      const fullKey = [key, ...currentPath].join('.');\r\n      const meta = newShadowStore.get(fullKey);\r\n\r\n      // We mark something as dirty if it isn't already.\r\n      // The original data source doesn't matter.\r\n      if (meta && meta.isDirty !== true) {\r\n        newShadowStore.set(fullKey, { ...meta, isDirty: true });\r\n        changed = true;\r\n      } else if (!meta) {\r\n        // If there's no metadata, create it and mark it as dirty.\r\n        // This handles newly created fields within an object.\r\n        newShadowStore.set(fullKey, { isDirty: true });\r\n        changed = true;\r\n      }\r\n    };\r\n\r\n    // 1. Mark the target path itself as dirty.\r\n    setDirty(path);\r\n\r\n    // 2. If `bubble` is true, walk up the path and mark all parents as dirty.\r\n    if (options.bubble) {\r\n      let parentPath = [...path];\r\n      while (parentPath.length > 0) {\r\n        parentPath.pop();\r\n        setDirty(parentPath);\r\n      }\r\n    }\r\n\r\n    if (changed) {\r\n      set({ shadowStateStore: newShadowStore });\r\n    }\r\n  },\r\n  serverStateUpdates: new Map(),\r\n  setServerStateUpdate: (key, serverState) => {\r\n    set((state) => {\r\n      const newMap = new Map(state.serverStateUpdates);\r\n      newMap.set(key, serverState);\r\n      return { serverStateUpdates: newMap };\r\n    });\r\n\r\n    // Notify all subscribers for this key\r\n    get().notifyPathSubscribers(key, {\r\n      type: 'SERVER_STATE_UPDATE',\r\n      serverState,\r\n    });\r\n  },\r\n  shadowStateStore: new Map(),\r\n  getShadowNode: (key: string) => get().shadowStateStore.get(key),\r\n  pathSubscribers: new Map<string, Set<(newValue: any) => void>>(),\r\n\r\n  subscribeToPath: (path, callback) => {\r\n    const subscribers = get().pathSubscribers;\r\n    const subsForPath = subscribers.get(path) || new Set();\r\n    subsForPath.add(callback);\r\n    subscribers.set(path, subsForPath);\r\n\r\n    return () => {\r\n      const currentSubs = get().pathSubscribers.get(path);\r\n      if (currentSubs) {\r\n        currentSubs.delete(callback);\r\n        if (currentSubs.size === 0) {\r\n          get().pathSubscribers.delete(path);\r\n        }\r\n      }\r\n    };\r\n  },\r\n\r\n  notifyPathSubscribers: (updatedPath, newValue) => {\r\n    const subscribers = get().pathSubscribers;\r\n    const subs = subscribers.get(updatedPath);\r\n\r\n    if (subs) {\r\n      subs.forEach((callback) => callback(newValue));\r\n    }\r\n  },\r\n\r\n  initializeShadowState: (key: string, initialState: any) => {\r\n    set((state) => {\r\n      // 1. Make a copy of the current store to modify it\r\n      const newShadowStore = new Map(state.shadowStateStore);\r\n\r\n      // 2. PRESERVE the existing components map before doing anything else\r\n      const existingRootMeta = newShadowStore.get(key);\r\n      const preservedComponents = existingRootMeta?.components;\r\n\r\n      // 3. Wipe all old shadow entries for this state key\r\n      const prefixToDelete = key + '.';\r\n      for (const k of Array.from(newShadowStore.keys())) {\r\n        if (k === key || k.startsWith(prefixToDelete)) {\r\n          newShadowStore.delete(k);\r\n        }\r\n      }\r\n\r\n      // 4. Run your original logic to rebuild the state tree from scratch\r\n      const processValue = (value: any, path: string[]) => {\r\n        const nodeKey = [key, ...path].join('.');\r\n\r\n        if (Array.isArray(value)) {\r\n          const childIds: string[] = [];\r\n          value.forEach(() => {\r\n            const itemId = `id:${ulid()}`;\r\n            childIds.push(nodeKey + '.' + itemId);\r\n          });\r\n          newShadowStore.set(nodeKey, { arrayKeys: childIds });\r\n          value.forEach((item, index) => {\r\n            const itemId = childIds[index]!.split('.').pop();\r\n            processValue(item, [...path!, itemId!]);\r\n          });\r\n        } else if (isSimpleObject(value)) {\r\n          const fields = Object.fromEntries(\r\n            Object.keys(value).map((k) => [k, nodeKey + '.' + k])\r\n          );\r\n          newShadowStore.set(nodeKey, { fields });\r\n          Object.keys(value).forEach((k) => {\r\n            processValue(value[k], [...path, k]);\r\n          });\r\n        } else {\r\n          newShadowStore.set(nodeKey, { value });\r\n        }\r\n      };\r\n      processValue(initialState, []);\r\n\r\n      // 5. RESTORE the preserved components map onto the new root metadata\r\n      if (preservedComponents) {\r\n        const newRootMeta = newShadowStore.get(key) || {};\r\n        newShadowStore.set(key, {\r\n          ...newRootMeta,\r\n          components: preservedComponents,\r\n        });\r\n      }\r\n\r\n      // 6. Return the completely updated state\r\n      return { shadowStateStore: newShadowStore };\r\n    });\r\n  },\r\n\r\n  getShadowValue: (fullKey: string, validArrayIds?: string[]) => {\r\n    // The cache is created here. It's temporary and exists only for this one top-level call.\r\n    const memo = new Map<string, any>();\r\n\r\n    // This is the inner recursive function that does the real work.\r\n    const reconstruct = (keyToBuild: string, ids?: string[]): any => {\r\n      // --- STEP 1: Check the cache first ---\r\n      // If we have already built the object for this path *during this call*, return it instantly.\r\n      if (memo.has(keyToBuild)) {\r\n        return memo.get(keyToBuild);\r\n      }\r\n\r\n      const shadowMeta = get().shadowStateStore.get(keyToBuild);\r\n\r\n      if (!shadowMeta) {\r\n        return undefined;\r\n      }\r\n\r\n      if (shadowMeta.value !== undefined) {\r\n        return shadowMeta.value;\r\n      }\r\n\r\n      let result: any; // The value we are about to build.\r\n\r\n      if (shadowMeta.arrayKeys) {\r\n        const keys = ids ?? shadowMeta.arrayKeys;\r\n        // --- IMPORTANT: Set the cache BEFORE the recursive calls ---\r\n        // This handles circular references gracefully. We put an empty array in the cache now.\r\n        result = [];\r\n        memo.set(keyToBuild, result);\r\n        // Now, fill the array with the recursively constructed items.\r\n        keys.forEach((itemKey) => {\r\n          result.push(reconstruct(itemKey)); // Pass the memo cache along implicitly via closure\r\n        });\r\n      } else if (shadowMeta.fields) {\r\n        // --- IMPORTANT: Set the cache BEFORE the recursive calls ---\r\n        result = {};\r\n        memo.set(keyToBuild, result);\r\n        // Now, fill the object with the recursively constructed items.\r\n        Object.entries(shadowMeta.fields).forEach(([key, fieldPath]) => {\r\n          result[key] = reconstruct(fieldPath as string);\r\n        });\r\n      } else {\r\n        result = undefined;\r\n      }\r\n\r\n      // Return the final, fully populated result.\r\n      return result;\r\n    };\r\n\r\n    // Start the process by calling the inner function on the root key.\r\n    return reconstruct(fullKey, validArrayIds);\r\n  },\r\n  getShadowMetadata: (\r\n    key: string,\r\n    path: string[],\r\n    validArrayIds?: string[]\r\n  ) => {\r\n    const fullKey = [key, ...path].join('.');\r\n    let data = get().shadowStateStore.get(fullKey);\r\n\r\n    return get().shadowStateStore.get(fullKey);\r\n  },\r\n\r\n  setShadowMetadata: (key, path, metadata) => {\r\n    const fullKey = [key, ...path].join('.');\r\n    const existingMeta = get().shadowStateStore.get(fullKey);\r\n\r\n    // --- THIS IS THE TRAP ---\r\n    // If the existing metadata HAS a components map, but the NEW metadata DOES NOT,\r\n    // it means we are about to wipe it out. This is the bug.\r\n    if (existingMeta?.components && !metadata.components) {\r\n      console.group(\r\n        '%c🚨 RACE CONDITION DETECTED! 🚨',\r\n        'color: red; font-size: 18px; font-weight: bold;'\r\n      );\r\n      console.error(\r\n        `An overwrite is about to happen on stateKey: \"${key}\" at path: [${path.join(', ')}]`\r\n      );\r\n      console.log(\r\n        'The EXISTING metadata had a components map:',\r\n        existingMeta.components\r\n      );\r\n      console.log(\r\n        'The NEW metadata is trying to save WITHOUT a components map:',\r\n        metadata\r\n      );\r\n      console.log(\r\n        '%cStack trace to the function that caused this overwrite:',\r\n        'font-weight: bold;'\r\n      );\r\n      console.trace(); // This prints the call stack, leading you to the bad code.\r\n      console.groupEnd();\r\n    }\r\n    // --- END OF TRAP ---\r\n\r\n    const newShadowStore = new Map(get().shadowStateStore);\r\n    const finalMeta = { ...(existingMeta || {}), ...metadata };\r\n    newShadowStore.set(fullKey, finalMeta);\r\n    set({ shadowStateStore: newShadowStore });\r\n  },\r\n  setTransformCache: (\r\n    key: string,\r\n    path: string[],\r\n    cacheKey: string,\r\n    cacheData: any\r\n  ) => {\r\n    const fullKey = [key, ...path].join('.');\r\n    const newShadowStore = new Map(get().shadowStateStore);\r\n    const existing = newShadowStore.get(fullKey) || {};\r\n\r\n    // Initialize transformCaches if it doesn't exist\r\n    if (!existing.transformCaches) {\r\n      existing.transformCaches = new Map();\r\n    }\r\n\r\n    // Update just the specific cache entry\r\n    existing.transformCaches.set(cacheKey, cacheData);\r\n\r\n    // Update shadow store WITHOUT notifying path subscribers\r\n    newShadowStore.set(fullKey, existing);\r\n    set({ shadowStateStore: newShadowStore });\r\n\r\n    // Don't call notifyPathSubscribers here - cache updates shouldn't trigger renders\r\n  },\r\n  insertShadowArrayElement: (\r\n    key: string,\r\n    arrayPath: string[],\r\n    newItem: any\r\n  ) => {\r\n    const newShadowStore = new Map(get().shadowStateStore);\r\n    const arrayKey = [key, ...arrayPath].join('.');\r\n    const parentMeta = newShadowStore.get(arrayKey);\r\n\r\n    if (!parentMeta || !parentMeta.arrayKeys) return;\r\n\r\n    const newItemId = `id:${ulid()}`;\r\n    const fullItemKey = arrayKey + '.' + newItemId;\r\n\r\n    // Just add to the end (or at a specific index if provided)\r\n    const newArrayKeys = [...parentMeta.arrayKeys];\r\n    newArrayKeys.push(fullItemKey); // Or use splice if you have an index\r\n    newShadowStore.set(arrayKey, { ...parentMeta, arrayKeys: newArrayKeys });\r\n\r\n    // Process the new item - but use the correct logic\r\n    const processNewItem = (value: any, path: string[]) => {\r\n      const nodeKey = [key, ...path].join('.');\r\n\r\n      if (Array.isArray(value)) {\r\n        // Handle arrays...\r\n      } else if (typeof value === 'object' && value !== null) {\r\n        // Create fields mapping\r\n        const fields = Object.fromEntries(\r\n          Object.keys(value).map((k) => [k, nodeKey + '.' + k])\r\n        );\r\n        newShadowStore.set(nodeKey, { fields });\r\n\r\n        // Process each field\r\n        Object.entries(value).forEach(([k, v]) => {\r\n          processNewItem(v, [...path, k]);\r\n        });\r\n      } else {\r\n        // Primitive value\r\n        newShadowStore.set(nodeKey, { value });\r\n      }\r\n    };\r\n\r\n    processNewItem(newItem, [...arrayPath, newItemId]);\r\n    set({ shadowStateStore: newShadowStore });\r\n\r\n    get().notifyPathSubscribers(arrayKey, {\r\n      type: 'INSERT',\r\n      path: arrayKey,\r\n      itemKey: fullItemKey,\r\n    });\r\n  },\r\n  removeShadowArrayElement: (key: string, itemPath: string[]) => {\r\n    const newShadowStore = new Map(get().shadowStateStore);\r\n\r\n    // Get the full item key (e.g., \"stateKey.products.id:xxx\")\r\n    const itemKey = [key, ...itemPath].join('.');\r\n\r\n    // Extract parent path and item ID\r\n    const parentPath = itemPath.slice(0, -1);\r\n    const parentKey = [key, ...parentPath].join('.');\r\n\r\n    // Get parent metadata\r\n    const parentMeta = newShadowStore.get(parentKey);\r\n\r\n    if (parentMeta && parentMeta.arrayKeys) {\r\n      // Find the index of the item to remove\r\n      const indexToRemove = parentMeta.arrayKeys.findIndex(\r\n        (arrayItemKey) => arrayItemKey === itemKey\r\n      );\r\n\r\n      if (indexToRemove !== -1) {\r\n        // Create new array keys with the item removed\r\n        const newArrayKeys = parentMeta.arrayKeys.filter(\r\n          (arrayItemKey) => arrayItemKey !== itemKey\r\n        );\r\n\r\n        // Update parent with new array keys\r\n        newShadowStore.set(parentKey, {\r\n          ...parentMeta,\r\n          arrayKeys: newArrayKeys,\r\n        });\r\n\r\n        // Delete all data associated with the removed item\r\n        const prefixToDelete = itemKey + '.';\r\n        for (const k of Array.from(newShadowStore.keys())) {\r\n          if (k === itemKey || k.startsWith(prefixToDelete)) {\r\n            newShadowStore.delete(k);\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    set({ shadowStateStore: newShadowStore });\r\n\r\n    get().notifyPathSubscribers(parentKey, {\r\n      type: 'REMOVE',\r\n      path: parentKey,\r\n      itemKey: itemKey, // The exact ID of the removed item\r\n    });\r\n  },\r\n  updateShadowAtPath: (key, path, newValue) => {\r\n    const newShadowStore = new Map(get().shadowStateStore);\r\n    const fullKey = [key, ...path].join('.');\r\n\r\n    const updateValue = (currentKey: string, valueToSet: any) => {\r\n      const meta = newShadowStore.get(currentKey);\r\n\r\n      // If it's a simple object with fields, update recursively\r\n      if (isSimpleObject(valueToSet) && meta && meta.fields) {\r\n        for (const fieldKey in valueToSet) {\r\n          if (Object.prototype.hasOwnProperty.call(valueToSet, fieldKey)) {\r\n            const childPath = meta.fields[fieldKey];\r\n            const childValue = valueToSet[fieldKey];\r\n\r\n            if (childPath) {\r\n              updateValue(childPath as string, childValue);\r\n            }\r\n          }\r\n        }\r\n      } else {\r\n        // For primitives (including Uint8Array), just replace the value\r\n        // This gives you useState-like behavior\r\n        const existing = newShadowStore.get(currentKey) || {};\r\n        newShadowStore.set(currentKey, { ...existing, value: valueToSet });\r\n      }\r\n    };\r\n\r\n    updateValue(fullKey, newValue);\r\n    get().notifyPathSubscribers(fullKey, { type: 'UPDATE', newValue });\r\n    set({ shadowStateStore: newShadowStore });\r\n  },\r\n  selectedIndicesMap: new Map<string, string>(),\r\n  getSelectedIndex: (arrayKey: string, validIds?: string[]): number => {\r\n    const itemKey = get().selectedIndicesMap.get(arrayKey);\r\n\r\n    if (!itemKey) return -1;\r\n\r\n    // Use validIds if provided (for filtered views), otherwise use all arrayKeys\r\n    const arrayKeys =\r\n      validIds ||\r\n      getGlobalStore.getState().getShadowMetadata(arrayKey, [])?.arrayKeys;\r\n\r\n    if (!arrayKeys) return -1;\r\n\r\n    return arrayKeys.indexOf(itemKey);\r\n  },\r\n\r\n  setSelectedIndex: (arrayKey: string, itemKey: string | undefined) => {\r\n    set((state) => {\r\n      const newMap = state.selectedIndicesMap;\r\n\r\n      if (itemKey === undefined) {\r\n        newMap.delete(arrayKey);\r\n      } else {\r\n        if (newMap.has(arrayKey)) {\r\n          get().notifyPathSubscribers(newMap.get(arrayKey)!, {\r\n            type: 'THIS_UNSELECTED',\r\n          });\r\n        }\r\n        newMap.set(arrayKey, itemKey);\r\n\r\n        get().notifyPathSubscribers(itemKey, {\r\n          type: 'THIS_SELECTED',\r\n        });\r\n      }\r\n      get().notifyPathSubscribers(arrayKey, {\r\n        type: 'GET_SELECTED',\r\n      });\r\n      return {\r\n        ...state,\r\n        selectedIndicesMap: newMap,\r\n      };\r\n    });\r\n  },\r\n  clearSelectedIndex: ({ arrayKey }: { arrayKey: string }): void => {\r\n    set((state) => {\r\n      const newMap = state.selectedIndicesMap;\r\n      const acutalKey = newMap.get(arrayKey);\r\n      if (acutalKey) {\r\n        get().notifyPathSubscribers(acutalKey, {\r\n          type: 'CLEAR_SELECTION',\r\n        });\r\n      }\r\n\r\n      newMap.delete(arrayKey);\r\n      get().notifyPathSubscribers(arrayKey, {\r\n        type: 'CLEAR_SELECTION',\r\n      });\r\n      return {\r\n        ...state,\r\n        selectedIndicesMap: newMap,\r\n      };\r\n    });\r\n  },\r\n  clearSelectedIndexesForState: (stateKey: string) => {\r\n    set((state) => {\r\n      const newOuterMap = new Map(state.selectedIndicesMap);\r\n      const changed = newOuterMap.delete(stateKey);\r\n      if (changed) {\r\n        return { selectedIndicesMap: newOuterMap };\r\n      } else {\r\n        return {};\r\n      }\r\n    });\r\n  },\r\n\r\n  initialStateOptions: {},\r\n\r\n  stateTimeline: {},\r\n  cogsStateStore: {},\r\n  stateLog: new Map(),\r\n\r\n  initialStateGlobal: {},\r\n\r\n  validationErrors: new Map(),\r\n  addStateLog: (key, update) => {\r\n    set((state) => {\r\n      const newLog = new Map(state.stateLog);\r\n      const stateLogForKey = new Map(newLog.get(key));\r\n      const uniquePathKey = JSON.stringify(update.path);\r\n\r\n      const existing = stateLogForKey.get(uniquePathKey);\r\n      if (existing) {\r\n        // If an update for this path already exists, just modify it. (Fast)\r\n        existing.newValue = update.newValue;\r\n        existing.timeStamp = update.timeStamp;\r\n      } else {\r\n        // Otherwise, add the new update. (Fast)\r\n        stateLogForKey.set(uniquePathKey, { ...update });\r\n      }\r\n\r\n      newLog.set(key, stateLogForKey);\r\n      return { stateLog: newLog };\r\n    });\r\n  },\r\n\r\n  getInitialOptions: (key) => {\r\n    return get().initialStateOptions[key];\r\n  },\r\n\r\n  setInitialStateOptions: (key, value) => {\r\n    set((prev) => ({\r\n      initialStateOptions: {\r\n        ...prev.initialStateOptions,\r\n        [key]: value,\r\n      },\r\n    }));\r\n  },\r\n  updateInitialStateGlobal: (key, newState) => {\r\n    set((prev) => ({\r\n      initialStateGlobal: {\r\n        ...prev.initialStateGlobal,\r\n        [key]: newState,\r\n      },\r\n    }));\r\n  },\r\n\r\n  syncInfoStore: new Map<string, SyncInfo>(),\r\n  setSyncInfo: (key: string, syncInfo: SyncInfo) =>\r\n    set((state) => {\r\n      const newMap = new Map(state.syncInfoStore);\r\n      newMap.set(key, syncInfo);\r\n      return { ...state, syncInfoStore: newMap };\r\n    }),\r\n  getSyncInfo: (key: string) => get().syncInfoStore.get(key) || null,\r\n}));\r\n"],"names":["formRefStore","create","set","get","id","ref","state","newRefs","stateKey","allRefs","stateKeyPrefix","filteredRefs","isSimpleObject","value","getGlobalStore","updateQueue","startTransition","updateFn","dependencyPath","fullComponentId","newShadowStore","dependencyKey","pathMeta","pathComponents","rootMeta","component","newPaths","newComponentRegistration","newComponentsMap","registration","components","key","path","options","changed","setDirty","currentPath","fullKey","meta","parentPath","serverState","newMap","callback","subscribers","subsForPath","currentSubs","updatedPath","newValue","subs","initialState","preservedComponents","prefixToDelete","k","processValue","nodeKey","childIds","itemId","ulid","item","index","fields","newRootMeta","validArrayIds","memo","reconstruct","keyToBuild","ids","shadowMeta","result","keys","itemKey","fieldPath","metadata","existingMeta","finalMeta","cacheKey","cacheData","existing","arrayPath","newItem","arrayKey","parentMeta","newItemId","fullItemKey","newArrayKeys","processNewItem","v","itemPath","parentKey","arrayItemKey","updateValue","currentKey","valueToSet","fieldKey","childPath","childValue","validIds","arrayKeys","acutalKey","newOuterMap","update","newLog","stateLogForKey","uniquePathKey","prev","newState","syncInfo"],"mappings":"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"}