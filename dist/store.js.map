{"version":3,"file":"store.js","sources":["../src/store.ts"],"sourcesContent":["import { create } from 'zustand';\r\n\r\nimport type {\r\n  OptionsType,\r\n  ReactivityType,\r\n  SyncInfo,\r\n  UpdateTypeDetail,\r\n} from './CogsState.js';\r\n\r\nexport type FreshValuesObject = {\r\n  pathsToValues?: string[];\r\n  prevValue?: any;\r\n  newValue?: any;\r\n  timeStamp: number;\r\n};\r\n\r\ntype StateValue = any;\r\n\r\nexport type TrieNode = {\r\n  subscribers: Set<string>;\r\n  children: Map<string, TrieNode>;\r\n};\r\n\r\nexport type ComponentsType = {\r\n  components?: Map<\r\n    string,\r\n    {\r\n      forceUpdate: () => void;\r\n      paths: Set<string>;\r\n      deps?: any[];\r\n      prevDeps?: any[];\r\n      depsFunction?: (state: any) => any[] | true;\r\n      reactiveType: ReactivityType[] | ReactivityType;\r\n    }\r\n  >;\r\n};\r\n\r\nexport type ValidationStatus =\r\n  | 'NOT_VALIDATED'\r\n  | 'VALIDATING'\r\n  | 'VALID'\r\n  | 'INVALID';\r\nexport type ValidationSeverity = 'warning' | 'error' | undefined;\r\nexport type ValidationError = {\r\n  source: 'client' | 'sync_engine' | 'api';\r\n  message: string;\r\n  severity: ValidationSeverity;\r\n  code?: string;\r\n};\r\n\r\nexport type ValidationState = {\r\n  status: ValidationStatus;\r\n  errors: ValidationError[];\r\n  lastValidated?: number;\r\n  validatedValue?: any;\r\n};\r\nexport type TypeInfo = {\r\n  type:\r\n    | 'string'\r\n    | 'number'\r\n    | 'boolean'\r\n    | 'array'\r\n    | 'object'\r\n    | 'date'\r\n    | 'unknown';\r\n  schema: any; // Store the actual Zod schema object\r\n  source: 'sync' | 'zod4' | 'zod3' | 'runtime' | 'default';\r\n  default: any;\r\n  nullable?: boolean;\r\n  optional?: boolean;\r\n};\r\n\r\nexport type UIState = {\r\n  isFocused?: boolean;\r\n  isTouched?: boolean;\r\n  isHovered?: boolean;\r\n};\r\n\r\n// Update ShadowMetadata to include typeInfo\r\nexport type ShadowMetadata = {\r\n  value?: any;\r\n\r\n  id?: string;\r\n  typeInfo?: TypeInfo;\r\n  stateSource?: 'default' | 'server' | 'localStorage';\r\n  lastServerSync?: number;\r\n  isDirty?: boolean;\r\n  baseServerState?: any;\r\n  arrayKeys?: string[];\r\n  fields?: Record<string, any>;\r\n  virtualizer?: {\r\n    itemHeight?: number;\r\n    domRef?: HTMLElement | null;\r\n  };\r\n  syncInfo?: { status: string };\r\n  validation?: ValidationState;\r\n  features?: {\r\n    validationEnabled: boolean;\r\n    localStorageEnabled: boolean;\r\n  };\r\n  signals?: Array<{\r\n    instanceId: string;\r\n    parentId: string;\r\n    position: number;\r\n    effect?: string;\r\n  }>;\r\n  transformCaches?: Map<\r\n    string,\r\n    {\r\n      validIds: string[];\r\n      computedAt: number;\r\n      transforms: Array<{ type: 'filter' | 'sort'; fn: Function }>;\r\n    }\r\n  >;\r\n  pathComponents?: Set<string>;\r\n  streams?: Map<\r\n    string,\r\n    {\r\n      buffer: any[];\r\n      flushTimer: NodeJS.Timeout | null;\r\n    }\r\n  >;\r\n  pluginMetaData?: Map<string, Record<string, any>>;\r\n  formRef?: React.RefObject<any>;\r\n  focusedElement?: { path: string[]; ref: React.RefObject<any> } | null;\r\n} & ComponentsType;\r\n\r\ntype ShadowNode = {\r\n  _meta?: ShadowMetadata;\r\n  [key: string]: any;\r\n};\r\n\r\nexport type CogsGlobalState = {\r\n  getPluginMetaDataMap: (\r\n    key: string,\r\n    path: string[]\r\n  ) => Map<string, Record<string, any>> | undefined;\r\n  setPluginMetaData: (\r\n    key: string,\r\n    path: string[],\r\n    pluginName: string,\r\n    data: Record<string, any>\r\n  ) => void;\r\n  removePluginMetaData: (\r\n    key: string,\r\n    path: string[],\r\n    pluginName: string\r\n  ) => void;\r\n  setTransformCache: (\r\n    key: string,\r\n    path: string[],\r\n    cacheKey: string,\r\n    cacheData: any\r\n  ) => void;\r\n  initializeAndMergeShadowState: (key: string, initialState: any) => void;\r\n  initializeShadowState: (key: string, initialState: any) => void;\r\n  getShadowNode: (key: string, path: string[]) => ShadowNode | undefined;\r\n  getShadowMetadata: (\r\n    key: string,\r\n    path: string[]\r\n  ) => ShadowMetadata | undefined;\r\n\r\n  setShadowMetadata: (key: string, path: string[], metadata: any) => void;\r\n  getShadowValue: (\r\n    key: string,\r\n    path: string[],\r\n    validArrayIds?: string[],\r\n    log?: boolean\r\n  ) => any;\r\n  updateShadowAtPath: (key: string, path: string[], newValue: any) => void;\r\n  insertManyShadowArrayElements: (\r\n    key: string,\r\n    arrayPath: string[],\r\n    newItems: any[],\r\n    index?: number\r\n  ) => void;\r\n  addItemsToArrayNode: (\r\n    key: string,\r\n    arrayPath: string[],\r\n    newItems: any,\r\n    newKeys: string[]\r\n  ) => void;\r\n  insertShadowArrayElement: (\r\n    key: string,\r\n    arrayPath: string[],\r\n    newItem: any,\r\n    index?: number,\r\n    itemId?: string\r\n  ) => string;\r\n  removeShadowArrayElement: (key: string, itemPath: string[]) => void;\r\n  registerComponent: (\r\n    stateKey: string,\r\n    componentId: string,\r\n    registration: any\r\n  ) => void;\r\n  unregisterComponent: (stateKey: string, componentId: string) => void;\r\n  addPathComponent: (\r\n    stateKey: string,\r\n    dependencyPath: string[],\r\n    fullComponentId: string\r\n  ) => void;\r\n  markAsDirty: (\r\n    key: string,\r\n    path: string[],\r\n    options: { bubble: boolean }\r\n  ) => void;\r\n\r\n  pathSubscribers: Map<string, Set<(newValue: any) => void>>;\r\n  subscribeToPath: (\r\n    path: string,\r\n    callback: (newValue: any) => void\r\n  ) => () => void;\r\n  notifyPathSubscribers: (updatedPath: string, newValue: any) => void;\r\n\r\n  selectedIndicesMap: Map<string, string>; // stateKey -> (parentPath -> selectedIndex)\r\n  getSelectedIndex: (stateKey: string, validArrayIds?: string[]) => number;\r\n  setSelectedIndex: (key: string, itemKey: string) => void;\r\n  clearSelectedIndex: ({ arrayKey }: { arrayKey: string }) => void;\r\n  clearSelectedIndexesForState: (stateKey: string) => void;\r\n\r\n  initialStateOptions: { [key: string]: OptionsType };\r\n  initialStateGlobal: { [key: string]: StateValue };\r\n  updateInitialStateGlobal: (key: string, newState: StateValue) => void;\r\n\r\n  getInitialOptions: (key: string) => OptionsType | undefined;\r\n  setInitialStateOptions: (key: string, value: OptionsType) => void;\r\n\r\n  serverStateUpdates: Map<\r\n    string,\r\n    {\r\n      data: any;\r\n      status: 'loading' | 'success' | 'error';\r\n      timestamp: number;\r\n    }\r\n  >;\r\n\r\n  setServerStateUpdate: (key: string, serverState: any) => void;\r\n\r\n  stateLog: Map<string, Map<string, UpdateTypeDetail>>;\r\n  syncInfoStore: Map<string, SyncInfo>;\r\n  addStateLog: (updates: UpdateTypeDetail[]) => void;\r\n\r\n  setSyncInfo: (key: string, syncInfo: SyncInfo) => void;\r\n  getSyncInfo: (key: string) => SyncInfo | null;\r\n};\r\n\r\nfunction getTypeFromZodSchema(\r\n  schema: any,\r\n  source: 'zod4' | 'zod3' | 'sync' = 'zod4'\r\n): TypeInfo | null {\r\n  if (!schema) return null;\r\n\r\n  let baseSchema = schema;\r\n  let isNullable = false;\r\n  let isOptional = false;\r\n  let defaultValue: any = undefined;\r\n  let hasDefault = false;\r\n\r\n  // Zod v4 unwrapping\r\n  if (schema._def) {\r\n    let current = schema;\r\n\r\n    // Keep unwrapping until we get to the base type\r\n    while (current._def) {\r\n      const typeName = current._def.typeName;\r\n\r\n      if (typeName === 'ZodOptional') {\r\n        isOptional = true;\r\n        current = current._def.innerType || current.unwrap();\r\n      } else if (typeName === 'ZodNullable') {\r\n        isNullable = true;\r\n        current = current._def.innerType || current.unwrap();\r\n      } else if (typeName === 'ZodDefault') {\r\n        hasDefault = true;\r\n        defaultValue = current._def.defaultValue();\r\n        current = current._def.innerType;\r\n      } else if (typeName === 'ZodEffects') {\r\n        // Handle .refine(), .transform() etc\r\n        current = current._def.schema;\r\n      } else {\r\n        // We've reached the base type\r\n        break;\r\n      }\r\n    }\r\n\r\n    baseSchema = current;\r\n    const typeName = baseSchema._def?.typeName;\r\n\r\n    if (typeName === 'ZodNumber') {\r\n      return {\r\n        type: 'number',\r\n        schema: schema, // Store the original schema with wrappers\r\n        source,\r\n        default: hasDefault ? defaultValue : 0,\r\n        nullable: isNullable,\r\n        optional: isOptional,\r\n      };\r\n    } else if (typeName === 'ZodString') {\r\n      return {\r\n        type: 'string',\r\n        schema: schema,\r\n        source,\r\n        default: hasDefault ? defaultValue : '',\r\n        nullable: isNullable,\r\n        optional: isOptional,\r\n      };\r\n    } else if (typeName === 'ZodBoolean') {\r\n      return {\r\n        type: 'boolean',\r\n        schema: schema,\r\n        source,\r\n        default: hasDefault ? defaultValue : false,\r\n        nullable: isNullable,\r\n        optional: isOptional,\r\n      };\r\n    } else if (typeName === 'ZodArray') {\r\n      return {\r\n        type: 'array',\r\n        schema: schema,\r\n        source,\r\n        default: hasDefault ? defaultValue : [],\r\n        nullable: isNullable,\r\n        optional: isOptional,\r\n      };\r\n    } else if (typeName === 'ZodObject') {\r\n      return {\r\n        type: 'object',\r\n        schema: schema,\r\n        source,\r\n        default: hasDefault ? defaultValue : {},\r\n        nullable: isNullable,\r\n        optional: isOptional,\r\n      };\r\n    } else if (typeName === 'ZodDate') {\r\n      return {\r\n        type: 'date',\r\n        schema: schema,\r\n        source,\r\n        default: hasDefault ? defaultValue : new Date(),\r\n        nullable: isNullable,\r\n        optional: isOptional,\r\n      };\r\n    }\r\n  }\r\n\r\n  // Zod v3 unwrapping\r\n  if (schema._type) {\r\n    let current = schema;\r\n\r\n    // Check for wrappers in v3\r\n    while (current) {\r\n      if (current._type === 'optional') {\r\n        isOptional = true;\r\n        current = current._def?.innerType || current._inner;\r\n      } else if (current._type === 'nullable') {\r\n        isNullable = true;\r\n        current = current._def?.innerType || current._inner;\r\n      } else if (current._def?.defaultValue !== undefined) {\r\n        hasDefault = true;\r\n        defaultValue =\r\n          typeof current._def.defaultValue === 'function'\r\n            ? current._def.defaultValue()\r\n            : current._def.defaultValue;\r\n        break;\r\n      } else {\r\n        break;\r\n      }\r\n    }\r\n\r\n    baseSchema = current;\r\n\r\n    if (baseSchema._type === 'number') {\r\n      return {\r\n        type: 'number',\r\n        schema: schema,\r\n        source,\r\n        default: hasDefault ? defaultValue : 0,\r\n        nullable: isNullable,\r\n        optional: isOptional,\r\n      };\r\n    } else if (baseSchema._type === 'string') {\r\n      return {\r\n        type: 'string',\r\n        schema: schema,\r\n        source,\r\n        default: hasDefault ? defaultValue : '',\r\n        nullable: isNullable,\r\n        optional: isOptional,\r\n      };\r\n    } else if (baseSchema._type === 'boolean') {\r\n      return {\r\n        type: 'boolean',\r\n        schema: schema,\r\n        source,\r\n        default: hasDefault ? defaultValue : false,\r\n        nullable: isNullable,\r\n        optional: isOptional,\r\n      };\r\n    } else if (baseSchema._type === 'array') {\r\n      return {\r\n        type: 'array',\r\n        schema: schema,\r\n        source,\r\n        default: hasDefault ? defaultValue : [],\r\n        nullable: isNullable,\r\n        optional: isOptional,\r\n      };\r\n    } else if (baseSchema._type === 'object') {\r\n      return {\r\n        type: 'object',\r\n        schema: schema,\r\n        source,\r\n        default: hasDefault ? defaultValue : {},\r\n        nullable: isNullable,\r\n        optional: isOptional,\r\n      };\r\n    } else if (baseSchema._type === 'date') {\r\n      return {\r\n        type: 'date',\r\n        schema: schema,\r\n        source,\r\n        default: hasDefault ? defaultValue : new Date(),\r\n        nullable: isNullable,\r\n        optional: isOptional,\r\n      };\r\n    }\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\n// Helper to get type info from runtime value\r\nfunction getTypeFromValue(value: any): TypeInfo {\r\n  if (value === null) {\r\n    return {\r\n      type: 'unknown',\r\n      schema: null,\r\n      source: 'default',\r\n      default: null,\r\n      nullable: true,\r\n    };\r\n  }\r\n\r\n  if (value === undefined) {\r\n    return {\r\n      type: 'unknown',\r\n      schema: null,\r\n      source: 'default',\r\n      default: undefined,\r\n      optional: true,\r\n    };\r\n  }\r\n\r\n  const valueType = typeof value;\r\n\r\n  if (valueType === 'number') {\r\n    return { type: 'number', schema: null, source: 'runtime', default: value };\r\n  } else if (valueType === 'string') {\r\n    return { type: 'string', schema: null, source: 'runtime', default: value };\r\n  } else if (valueType === 'boolean') {\r\n    return { type: 'boolean', schema: null, source: 'runtime', default: value };\r\n  } else if (Array.isArray(value)) {\r\n    return { type: 'array', schema: null, source: 'runtime', default: [] };\r\n  } else if (value instanceof Date) {\r\n    return { type: 'date', schema: null, source: 'runtime', default: value };\r\n  } else if (valueType === 'object') {\r\n    return { type: 'object', schema: null, source: 'runtime', default: {} };\r\n  }\r\n\r\n  return { type: 'unknown', schema: null, source: 'runtime', default: value };\r\n}\r\ntype BuildContext = {\r\n  stateKey: string;\r\n  path: string[];\r\n  schemas: {\r\n    sync?: any;\r\n    zodV4?: any;\r\n    zodV3?: any;\r\n  };\r\n};\r\n// Update buildShadowNode to use the new schema storage\r\nexport function buildShadowNode(\r\n  stateKey: string,\r\n  value: any,\r\n  context?: BuildContext\r\n): ShadowNode {\r\n  // For primitive values\r\n  if (value === null || value === undefined || typeof value !== 'object') {\r\n    const node: ShadowNode = { _meta: {} };\r\n    node._meta!.value = value;\r\n    if (context) {\r\n      let typeInfo: TypeInfo | null = null;\r\n\r\n      // 1. Try to get type from sync schema\r\n      if (context.schemas.sync && context.schemas.sync[context.stateKey]) {\r\n        const syncEntry = context.schemas.sync[context.stateKey];\r\n        if (syncEntry.schemas?.validation) {\r\n          // Navigate to the field in the validation schema\r\n          let fieldSchema = syncEntry.schemas.validation;\r\n          for (const segment of context.path) {\r\n            if (fieldSchema?.shape) {\r\n              fieldSchema = fieldSchema.shape[segment];\r\n            } else if (fieldSchema?._def?.shape) {\r\n              fieldSchema = fieldSchema._def.shape()[segment];\r\n            }\r\n          }\r\n\r\n          if (fieldSchema) {\r\n            typeInfo = getTypeFromZodSchema(fieldSchema, 'sync');\r\n            if (typeInfo) {\r\n              // Use the default from sync schema if available\r\n              if (syncEntry.schemas.defaults) {\r\n                let defaultValue = syncEntry.schemas.defaults;\r\n                for (const segment of context.path) {\r\n                  if (defaultValue && typeof defaultValue === 'object') {\r\n                    defaultValue = defaultValue[segment];\r\n                  }\r\n                }\r\n                if (defaultValue !== undefined) {\r\n                  typeInfo.default = defaultValue;\r\n                  // If no value provided and not optional, use the default\r\n                  if (\r\n                    (value === undefined || value === null) &&\r\n                    !typeInfo.optional\r\n                  ) {\r\n                    node._meta!.value = defaultValue;\r\n                  }\r\n                }\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      // 2. If no sync schema, try Zod v4\r\n      if (!typeInfo && context.schemas.zodV4) {\r\n        let fieldSchema = context.schemas.zodV4;\r\n        for (const segment of context.path) {\r\n          if (fieldSchema?.shape) {\r\n            fieldSchema = fieldSchema.shape[segment];\r\n          } else if (fieldSchema?._def?.shape) {\r\n            fieldSchema = fieldSchema._def.shape()[segment];\r\n          }\r\n        }\r\n\r\n        if (fieldSchema) {\r\n          typeInfo = getTypeFromZodSchema(fieldSchema, 'zod4');\r\n          if (typeInfo && (value === undefined || value === null)) {\r\n            // Only use default if the field is not optional/nullable\r\n            if (!typeInfo.optional && !typeInfo.nullable) {\r\n              node.value = typeInfo.default;\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      // 3. If no Zod v4, try Zod v3\r\n      if (!typeInfo && context.schemas.zodV3) {\r\n        let fieldSchema = context.schemas.zodV3;\r\n        for (const segment of context.path) {\r\n          if (fieldSchema?.shape) {\r\n            fieldSchema = fieldSchema.shape[segment];\r\n          } else if (fieldSchema?._shape) {\r\n            fieldSchema = fieldSchema._shape[segment];\r\n          }\r\n        }\r\n\r\n        if (fieldSchema) {\r\n          typeInfo = getTypeFromZodSchema(fieldSchema, 'zod3');\r\n          if (typeInfo && (value === undefined || value === null)) {\r\n            // Only use default if the field is not optional/nullable\r\n            if (!typeInfo.optional && !typeInfo.nullable) {\r\n              node.value = typeInfo.default;\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      // 4. Fall back to runtime type\r\n      if (!typeInfo) {\r\n        typeInfo = getTypeFromValue(node._meta!.value);\r\n      }\r\n\r\n      // Store the type info\r\n      if (typeInfo) {\r\n        if (!node._meta) node._meta = {};\r\n        node._meta.typeInfo = typeInfo;\r\n      }\r\n    } else {\r\n      // No context, just use runtime type\r\n      const typeInfo = getTypeFromValue(value);\r\n      if (!node._meta) node._meta = {};\r\n      node._meta.typeInfo = typeInfo;\r\n    }\r\n\r\n    return node;\r\n  }\r\n\r\n  // For arrays\r\n  if (Array.isArray(value)) {\r\n    const arrayNode: ShadowNode = { _meta: { arrayKeys: [] } };\r\n    const idKeys: string[] = [];\r\n\r\n    value.forEach((item, index) => {\r\n      const itemId = `${generateId(stateKey)}`;\r\n      // Pass context down for array items\r\n      const itemContext = context\r\n        ? {\r\n            ...context,\r\n            path: [...context.path, index.toString()],\r\n          }\r\n        : undefined;\r\n      arrayNode[itemId] = buildShadowNode(stateKey, item, itemContext);\r\n      idKeys.push(itemId);\r\n    });\r\n\r\n    arrayNode._meta!.arrayKeys = idKeys;\r\n    if (context) {\r\n      // Try to get the array schema\r\n      let arraySchema = null;\r\n\r\n      if (context.schemas.zodV4) {\r\n        let fieldSchema = context.schemas.zodV4;\r\n        for (const segment of context.path) {\r\n          if (fieldSchema?.shape) {\r\n            fieldSchema = fieldSchema.shape[segment];\r\n          } else if (fieldSchema?._def?.shape) {\r\n            fieldSchema = fieldSchema._def.shape()[segment];\r\n          }\r\n        }\r\n        arraySchema = fieldSchema;\r\n      }\r\n\r\n      arrayNode._meta!.typeInfo = {\r\n        type: 'array',\r\n        schema: arraySchema,\r\n        source: arraySchema ? 'zod4' : 'runtime',\r\n        default: [],\r\n      };\r\n    }\r\n    return arrayNode;\r\n  }\r\n\r\n  // For objects\r\n  if (value.constructor === Object) {\r\n    const objectNode: ShadowNode = { _meta: {} };\r\n    for (const key in value) {\r\n      if (Object.prototype.hasOwnProperty.call(value, key)) {\r\n        // Pass context down for object properties\r\n        const propContext = context\r\n          ? {\r\n              ...context,\r\n              path: [...context.path, key],\r\n            }\r\n          : undefined;\r\n        objectNode[key] = buildShadowNode(stateKey, value[key], propContext);\r\n      }\r\n    }\r\n    if (context) {\r\n      // Try to get the object schema\r\n      let objectSchema = null;\r\n\r\n      if (context.schemas.zodV4) {\r\n        let fieldSchema = context.schemas.zodV4;\r\n        for (const segment of context.path) {\r\n          if (fieldSchema?.shape) {\r\n            fieldSchema = fieldSchema.shape[segment];\r\n          } else if (fieldSchema?._def?.shape) {\r\n            fieldSchema = fieldSchema._def.shape()[segment];\r\n          }\r\n        }\r\n        objectSchema = fieldSchema;\r\n      }\r\n\r\n      objectNode._meta!.typeInfo = {\r\n        type: 'object',\r\n        schema: objectSchema,\r\n        source: objectSchema ? 'zod4' : 'runtime',\r\n        default: {},\r\n      };\r\n    }\r\n    return objectNode;\r\n  }\r\n\r\n  return { value };\r\n}\r\n\r\nexport const shadowStateStore = new Map<string, ShadowNode>();\r\nlet globalCounter = 0;\r\nconst instanceId = Date.now().toString(36);\r\n\r\nexport function generateId(stateKey: string): string {\r\n  const prefix = 'local';\r\n\r\n  return `id:${prefix}_${instanceId}_${(globalCounter++).toString(36)}`;\r\n}\r\nexport const getGlobalStore = create<CogsGlobalState>((set, get) => ({\r\n  getPluginMetaDataMap: (\r\n    key: string,\r\n    path: string[]\r\n  ): Map<string, Record<string, any>> | undefined => {\r\n    const metadata = get().getShadowMetadata(key, path);\r\n    return metadata?.pluginMetaData;\r\n  },\r\n\r\n  setPluginMetaData: (\r\n    key: string,\r\n    path: string[], // ADD THIS PARAMETER\r\n    pluginName: string,\r\n    data: Record<string, any>\r\n  ) => {\r\n    const metadata = get().getShadowMetadata(key, path) || {}; // Use the path!\r\n    const pluginMetaData = new Map(metadata.pluginMetaData || []);\r\n    const existingData = pluginMetaData.get(pluginName) || {};\r\n    pluginMetaData.set(pluginName, { ...existingData, ...data });\r\n    get().setShadowMetadata(key, path, { ...metadata, pluginMetaData });\r\n  },\r\n  removePluginMetaData: (key: string, path: string[], pluginName: string) => {\r\n    const metadata = get().getShadowMetadata(key, path);\r\n    if (!metadata?.pluginMetaData) return;\r\n    const pluginMetaData = new Map(metadata.pluginMetaData);\r\n    pluginMetaData.delete(pluginName);\r\n    get().setShadowMetadata(key, path, { ...metadata, pluginMetaData });\r\n  },\r\n\r\n  setTransformCache: (\r\n    key: string,\r\n    path: string[],\r\n    cacheKey: string,\r\n    cacheData: any\r\n  ) => {\r\n    const metadata = get().getShadowMetadata(key, path) || {};\r\n    if (!metadata.transformCaches) {\r\n      metadata.transformCaches = new Map();\r\n    }\r\n    metadata.transformCaches.set(cacheKey, cacheData);\r\n    get().setShadowMetadata(key, path, {\r\n      transformCaches: metadata.transformCaches,\r\n    });\r\n  },\r\n  initializeAndMergeShadowState: (key: string, shadowState: any) => {\r\n    const isArrayState = shadowState?._meta?.arrayKeys !== undefined;\r\n    const storageKey = isArrayState ? `[${key}` : key;\r\n\r\n    const existingRoot =\r\n      shadowStateStore.get(storageKey) ||\r\n      shadowStateStore.get(key) ||\r\n      shadowStateStore.get(`[${key}`);\r\n\r\n    let preservedMetadata: Partial<ShadowMetadata> = {};\r\n\r\n    if (existingRoot?._meta) {\r\n      const {\r\n        components,\r\n        features,\r\n        lastServerSync,\r\n        stateSource,\r\n        baseServerState,\r\n        pathComponents,\r\n        signals,\r\n        validation,\r\n      } = existingRoot._meta;\r\n\r\n      if (components) preservedMetadata.components = components;\r\n      if (features) preservedMetadata.features = features;\r\n      if (lastServerSync) preservedMetadata.lastServerSync = lastServerSync;\r\n      if (stateSource) preservedMetadata.stateSource = stateSource;\r\n      if (baseServerState) preservedMetadata.baseServerState = baseServerState;\r\n      if (pathComponents) preservedMetadata.pathComponents = pathComponents;\r\n      if (signals) preservedMetadata.signals = signals;\r\n      if (validation) preservedMetadata.validation = validation;\r\n    }\r\n\r\n    // Deep merge function that preserves shadow node structure\r\n    function deepMergeShadowNodes(\r\n      target: ShadowNode,\r\n      source: ShadowNode\r\n    ): ShadowNode {\r\n      // If source has a primitive value in _meta, use it\r\n      if (source._meta?.hasOwnProperty('value')) {\r\n        if (!target._meta) target._meta = {};\r\n        target._meta.value = source._meta.value;\r\n        // Clear any non-meta properties since this is a primitive\r\n        for (const key in target) {\r\n          if (key !== '_meta') {\r\n            delete target[key];\r\n          }\r\n        }\r\n        return target;\r\n      }\r\n\r\n      // Handle array nodes\r\n      if (source._meta?.arrayKeys) {\r\n        // For arrays, completely replace with new array structure\r\n        // but preserve non-array metadata\r\n        const preservedMeta = { ...target._meta };\r\n        delete preservedMeta.arrayKeys;\r\n\r\n        // Clear old array items\r\n        if (target._meta?.arrayKeys) {\r\n          target._meta.arrayKeys.forEach((itemKey) => {\r\n            delete target[itemKey];\r\n          });\r\n        }\r\n\r\n        // Copy new array structure\r\n        target._meta = { ...preservedMeta, ...source._meta };\r\n        source._meta.arrayKeys.forEach((itemKey) => {\r\n          target[itemKey] = source[itemKey];\r\n        });\r\n\r\n        return target;\r\n      }\r\n\r\n      // Handle object nodes - merge properties\r\n      for (const key in source) {\r\n        if (key === '_meta') {\r\n          // Merge metadata\r\n          target._meta = { ...(target._meta || {}), ...(source._meta || {}) };\r\n        } else {\r\n          // Recursively merge or set property\r\n          if (\r\n            target[key] &&\r\n            typeof target[key] === 'object' &&\r\n            typeof source[key] === 'object'\r\n          ) {\r\n            deepMergeShadowNodes(target[key], source[key]);\r\n          } else {\r\n            target[key] = source[key];\r\n          }\r\n        }\r\n      }\r\n\r\n      // Remove any keys in target that don't exist in source (for object nodes)\r\n      if (!source._meta?.arrayKeys && !source._meta?.hasOwnProperty('value')) {\r\n        for (const key in target) {\r\n          if (key !== '_meta' && !source.hasOwnProperty(key)) {\r\n            delete target[key];\r\n          }\r\n        }\r\n      }\r\n\r\n      return target;\r\n    }\r\n\r\n    if (existingRoot) {\r\n      // Merge the new shadow state into the existing one\r\n      deepMergeShadowNodes(existingRoot, shadowState);\r\n\r\n      // Restore preserved metadata (these should override what came from shadowState)\r\n      if (!existingRoot._meta) existingRoot._meta = {};\r\n      Object.assign(existingRoot._meta, preservedMetadata);\r\n\r\n      // Update the store with merged state\r\n      shadowStateStore.set(storageKey, existingRoot);\r\n    } else {\r\n      // No existing state, just use the provided shadowState\r\n      // But still preserve any metadata if it somehow exists\r\n      if (preservedMetadata && Object.keys(preservedMetadata).length > 0) {\r\n        if (!shadowState._meta) shadowState._meta = {};\r\n        Object.assign(shadowState._meta, preservedMetadata);\r\n      }\r\n\r\n      shadowStateStore.set(storageKey, shadowState);\r\n    }\r\n\r\n    // Clear any incorrect keys if they exist\r\n    if (storageKey === key) {\r\n      shadowStateStore.delete(`[${key}`);\r\n    } else {\r\n      shadowStateStore.delete(key);\r\n    }\r\n  },\r\n\r\n  initializeShadowState: (key: string, initialState: any) => {\r\n    const existingRoot =\r\n      shadowStateStore.get(key) || shadowStateStore.get(`[${key}`);\r\n    let preservedMetadata: Partial<ShadowMetadata> = {};\r\n\r\n    if (existingRoot?._meta) {\r\n      const {\r\n        components,\r\n        features,\r\n        lastServerSync,\r\n        stateSource,\r\n        baseServerState,\r\n      } = existingRoot._meta;\r\n      if (components) preservedMetadata.components = components;\r\n      if (features) preservedMetadata.features = features;\r\n      if (lastServerSync) preservedMetadata.lastServerSync = lastServerSync;\r\n      if (stateSource) preservedMetadata.stateSource = stateSource;\r\n      if (baseServerState) preservedMetadata.baseServerState = baseServerState;\r\n    }\r\n\r\n    shadowStateStore.delete(key);\r\n    shadowStateStore.delete(`[${key}`);\r\n\r\n    // Get all available schemas for this state\r\n    const options = get().getInitialOptions(key);\r\n    const syncSchemas = get().getInitialOptions('__syncSchemas');\r\n\r\n    const context: BuildContext = {\r\n      stateKey: key,\r\n      path: [],\r\n      schemas: {\r\n        sync: syncSchemas,\r\n        zodV4: options?.validation?.zodSchemaV4,\r\n        zodV3: options?.validation?.zodSchemaV3,\r\n      },\r\n    };\r\n\r\n    // Build with context so type info is stored\r\n    const newRoot = buildShadowNode(key, initialState, context);\r\n\r\n    if (!newRoot._meta) newRoot._meta = {};\r\n    Object.assign(newRoot._meta, preservedMetadata);\r\n\r\n    const storageKey = Array.isArray(initialState) ? `[${key}` : key;\r\n    shadowStateStore.set(storageKey, newRoot);\r\n  },\r\n  getShadowNode: (key: string, path: string[]): ShadowNode | undefined => {\r\n    let current: any =\r\n      shadowStateStore.get(key) || shadowStateStore.get(`[${key}`);\r\n    if (!current) return undefined;\r\n    if (path.length === 0) return current;\r\n\r\n    for (const segment of path) {\r\n      if (typeof current !== 'object' || current === null) return undefined;\r\n      current = current[segment];\r\n      if (current === undefined) return undefined;\r\n    }\r\n    return current;\r\n  },\r\n\r\n  getShadowMetadata: (\r\n    key: string,\r\n    path: string[]\r\n  ): ShadowMetadata | undefined => {\r\n    const node = get().getShadowNode(key, path);\r\n    return node?._meta;\r\n  },\r\n\r\n  setShadowMetadata: (\r\n    key: string,\r\n    path: string[],\r\n    newMetadata: Partial<ShadowMetadata>\r\n  ) => {\r\n    // Direct mutation - no cloning!\r\n    const rootKey = shadowStateStore.has(`[${key}`) ? `[${key}` : key;\r\n    let root = shadowStateStore.get(rootKey);\r\n\r\n    if (!root) {\r\n      root = { _meta: newMetadata };\r\n      shadowStateStore.set(rootKey, root);\r\n      return;\r\n    }\r\n\r\n    // Navigate to target without cloning\r\n    let current = root;\r\n    for (const segment of path) {\r\n      if (!current[segment]) {\r\n        current[segment] = {};\r\n      }\r\n      current = current[segment];\r\n    }\r\n\r\n    // Mutate metadata directly\r\n    if (!current._meta) {\r\n      current._meta = {};\r\n    }\r\n    Object.assign(current._meta, newMetadata);\r\n  },\r\n\r\n  getShadowValue: (\r\n    key: string,\r\n    path: string[],\r\n    validArrayIds?: string[],\r\n    log?: boolean\r\n  ) => {\r\n    const node = get().getShadowNode(key, path);\r\n\r\n    if (node === null || node === undefined) return undefined;\r\n\r\n    const nodeKeys = Object.keys(node);\r\n\r\n    if (\r\n      node._meta &&\r\n      Object.prototype.hasOwnProperty.call(node._meta, 'value') &&\r\n      nodeKeys.length === 1 &&\r\n      nodeKeys[0] === '_meta'\r\n    ) {\r\n      return node._meta.value;\r\n    }\r\n\r\n    const isArrayNode =\r\n      node._meta &&\r\n      Object.prototype.hasOwnProperty.call(node._meta, 'arrayKeys');\r\n    if (isArrayNode) {\r\n      const keysToIterate =\r\n        validArrayIds !== undefined && validArrayIds.length > 0\r\n          ? validArrayIds\r\n          : node._meta!.arrayKeys!;\r\n\r\n      return keysToIterate.map((itemKey: string) =>\r\n        get().getShadowValue(key, [...path, itemKey])\r\n      );\r\n    }\r\n\r\n    const result: any = {};\r\n    for (const propKey of nodeKeys) {\r\n      if (propKey !== '_meta' && !propKey.startsWith('id:')) {\r\n        result[propKey] = get().getShadowValue(key, [...path, propKey]);\r\n      }\r\n    }\r\n    return result;\r\n  },\r\n\r\n  updateShadowAtPath: (key, path, newValue) => {\r\n    // NO MORE set() wrapper - direct mutation!\r\n    const rootKey = shadowStateStore.has(`[${key}`) ? `[${key}` : key;\r\n    let root = shadowStateStore.get(rootKey);\r\n    if (!root) return;\r\n\r\n    // Navigate to parent without cloning\r\n    let parentNode = root;\r\n    for (let i = 0; i < path.length - 1; i++) {\r\n      if (!parentNode[path[i]!]) {\r\n        parentNode[path[i]!] = {};\r\n      }\r\n      parentNode = parentNode[path[i]!];\r\n    }\r\n\r\n    const targetNode =\r\n      path.length === 0 ? parentNode : parentNode[path[path.length - 1]!];\r\n\r\n    if (!targetNode) {\r\n      parentNode[path[path.length - 1]!] = buildShadowNode(key, newValue);\r\n      get().notifyPathSubscribers([key, ...path].join('.'), {\r\n        type: 'UPDATE',\r\n        newValue,\r\n      });\r\n      return;\r\n    }\r\n\r\n    function intelligentMerge(nodeToUpdate: any, plainValue: any) {\r\n      if (\r\n        typeof plainValue !== 'object' ||\r\n        plainValue === null ||\r\n        Array.isArray(plainValue)\r\n      ) {\r\n        const oldMeta = nodeToUpdate._meta;\r\n        // Clear existing properties\r\n        for (const key in nodeToUpdate) {\r\n          if (key !== '_meta') delete nodeToUpdate[key];\r\n        }\r\n        const newNode = buildShadowNode(key, plainValue);\r\n        Object.assign(nodeToUpdate, newNode);\r\n        if (oldMeta) {\r\n          nodeToUpdate._meta = { ...oldMeta, ...(nodeToUpdate._meta || {}) };\r\n        }\r\n        return;\r\n      }\r\n\r\n      const plainValueKeys = new Set(Object.keys(plainValue));\r\n\r\n      for (const propKey of plainValueKeys) {\r\n        const childValue = plainValue[propKey];\r\n        if (nodeToUpdate[propKey]) {\r\n          intelligentMerge(nodeToUpdate[propKey], childValue);\r\n        } else {\r\n          nodeToUpdate[propKey] = buildShadowNode(key, childValue);\r\n        }\r\n      }\r\n\r\n      for (const nodeKey in nodeToUpdate) {\r\n        if (\r\n          nodeKey === '_meta' ||\r\n          !Object.prototype.hasOwnProperty.call(nodeToUpdate, nodeKey)\r\n        )\r\n          continue;\r\n\r\n        if (!plainValueKeys.has(nodeKey)) {\r\n          delete nodeToUpdate[nodeKey];\r\n        }\r\n      }\r\n    }\r\n\r\n    intelligentMerge(targetNode, newValue);\r\n\r\n    get().notifyPathSubscribers([key, ...path].join('.'), {\r\n      type: 'UPDATE',\r\n      newValue,\r\n    });\r\n  },\r\n\r\n  addItemsToArrayNode: (key, arrayPath, newItems, newKeys) => {\r\n    // Direct mutation - no cloning!\r\n    const rootKey = shadowStateStore.has(`[${key}`) ? `[${key}` : key;\r\n    let root = shadowStateStore.get(rootKey);\r\n    if (!root) {\r\n      console.error('Root not found for state key:', key);\r\n      return;\r\n    }\r\n\r\n    // Navigate without cloning\r\n    let current = root;\r\n    for (const segment of arrayPath) {\r\n      if (!current[segment]) {\r\n        current[segment] = {};\r\n      }\r\n      current = current[segment];\r\n    }\r\n\r\n    // Mutate directly\r\n    Object.assign(current, newItems);\r\n    if (!current._meta) current._meta = {};\r\n    current._meta.arrayKeys = newKeys; // Direct assignment!\r\n  },\r\n  insertShadowArrayElement: (\r\n    key: string,\r\n    arrayPath: string[],\r\n    newItem: any,\r\n    index?: number,\r\n    itemId?: string // Add optional itemId parameter\r\n  ) => {\r\n    const arrayNode = get().getShadowNode(key, arrayPath);\r\n    if (!arrayNode?._meta?.arrayKeys) {\r\n      throw new Error(\r\n        `Array not found at path: ${[key, ...arrayPath].join('.')}`\r\n      );\r\n    }\r\n\r\n    // Use provided itemId or generate a new one\r\n    const newItemId = itemId || generateId(key);\r\n    const itemsToAdd = { [newItemId]: buildShadowNode(key, newItem) };\r\n\r\n    // Rest of the function remains the same...\r\n    const currentKeys = arrayNode._meta.arrayKeys;\r\n    const insertionPoint =\r\n      index !== undefined && index >= 0 && index <= currentKeys.length\r\n        ? index\r\n        : currentKeys.length;\r\n\r\n    if (insertionPoint >= currentKeys.length) {\r\n      currentKeys.push(newItemId);\r\n    } else {\r\n      currentKeys.splice(insertionPoint, 0, newItemId);\r\n    }\r\n\r\n    get().addItemsToArrayNode(key, arrayPath, itemsToAdd, currentKeys);\r\n\r\n    const arrayKey = [key, ...arrayPath].join('.');\r\n    get().notifyPathSubscribers(arrayKey, {\r\n      type: 'INSERT',\r\n      path: arrayKey,\r\n      itemKey: `${arrayKey}.${newItemId}`,\r\n      index: insertionPoint,\r\n    });\r\n\r\n    return newItemId;\r\n  },\r\n\r\n  insertManyShadowArrayElements: (key, arrayPath, newItems, index) => {\r\n    if (!newItems || newItems.length === 0) {\r\n      return;\r\n    }\r\n\r\n    const arrayNode = get().getShadowNode(key, arrayPath);\r\n    if (!arrayNode?._meta?.arrayKeys) {\r\n      console.error(\r\n        `Array not found at path: ${[key, ...arrayPath].join('.')}`\r\n      );\r\n      return;\r\n    }\r\n\r\n    const itemsToAdd: Record<string, any> = {};\r\n    const newIds: string[] = [];\r\n\r\n    newItems.forEach((item) => {\r\n      const newItemId = `${generateId(key)}`;\r\n      newIds.push(newItemId);\r\n      itemsToAdd[newItemId] = buildShadowNode(key, item);\r\n    });\r\n\r\n    // Mutate directly\r\n    const currentKeys = arrayNode._meta.arrayKeys;\r\n    const insertionPoint =\r\n      index !== undefined && index >= 0 && index <= currentKeys.length\r\n        ? index\r\n        : currentKeys.length;\r\n\r\n    if (insertionPoint >= currentKeys.length) {\r\n      currentKeys.push(...newIds); // O(k) where k is items being added\r\n    } else {\r\n      currentKeys.splice(insertionPoint, 0, ...newIds); // O(n + k)\r\n    }\r\n\r\n    get().addItemsToArrayNode(key, arrayPath, itemsToAdd, currentKeys);\r\n\r\n    const arrayKey = [key, ...arrayPath].join('.');\r\n    get().notifyPathSubscribers(arrayKey, {\r\n      type: 'INSERT_MANY',\r\n      path: arrayKey,\r\n      count: newItems.length,\r\n      index: insertionPoint,\r\n    });\r\n  },\r\n\r\n  removeShadowArrayElement: (key, itemPath) => {\r\n    if (itemPath.length === 0) return;\r\n\r\n    const arrayPath = itemPath.slice(0, -1);\r\n    const itemId = itemPath[itemPath.length - 1];\r\n    if (!itemId?.startsWith('id:')) return;\r\n\r\n    const arrayNode = get().getShadowNode(key, arrayPath);\r\n    if (!arrayNode?._meta?.arrayKeys) return;\r\n\r\n    // Mutate directly\r\n    const currentKeys = arrayNode._meta.arrayKeys;\r\n    const indexToRemove = currentKeys.indexOf(itemId);\r\n\r\n    if (indexToRemove === -1) return;\r\n\r\n    // O(1) for removing from end\r\n    if (indexToRemove === currentKeys.length - 1) {\r\n      currentKeys.pop();\r\n    }\r\n    // O(n) for removing from beginning or middle\r\n    else if (indexToRemove === 0) {\r\n      currentKeys.shift();\r\n    } else {\r\n      currentKeys.splice(indexToRemove, 1);\r\n    }\r\n\r\n    // Delete the actual item\r\n    delete arrayNode[itemId];\r\n\r\n    // No need to update metadata - already mutated!\r\n\r\n    const arrayKey = [key, ...arrayPath].join('.');\r\n    get().notifyPathSubscribers(arrayKey, {\r\n      type: 'REMOVE',\r\n      path: arrayKey,\r\n      itemKey: `${arrayKey}.${itemId}`,\r\n    });\r\n  },\r\n\r\n  registerComponent: (stateKey, fullComponentId, registration) => {\r\n    const rootMeta = get().getShadowMetadata(stateKey, []) || {};\r\n    const components = new Map(rootMeta.components);\r\n    components.set(fullComponentId, registration);\r\n    get().setShadowMetadata(stateKey, [], { components });\r\n  },\r\n\r\n  unregisterComponent: (stateKey, fullComponentId) => {\r\n    const rootMeta = get().getShadowMetadata(stateKey, []);\r\n    if (!rootMeta?.components) return;\r\n    const components = new Map(rootMeta.components);\r\n    if (components.delete(fullComponentId)) {\r\n      get().setShadowMetadata(stateKey, [], { components });\r\n    }\r\n  },\r\n\r\n  addPathComponent: (stateKey, dependencyPath, fullComponentId) => {\r\n    const metadata = get().getShadowMetadata(stateKey, dependencyPath) || {};\r\n    const newPathComponents = new Set(metadata.pathComponents);\r\n    newPathComponents.add(fullComponentId);\r\n    get().setShadowMetadata(stateKey, dependencyPath, {\r\n      pathComponents: newPathComponents,\r\n    });\r\n\r\n    const rootMeta = get().getShadowMetadata(stateKey, []);\r\n    if (rootMeta?.components) {\r\n      const component = rootMeta.components.get(fullComponentId);\r\n      if (component) {\r\n        const fullPathKey = [stateKey, ...dependencyPath].join('.');\r\n        const newPaths = new Set(component.paths);\r\n        newPaths.add(fullPathKey);\r\n        const newComponentRegistration = { ...component, paths: newPaths };\r\n        const newComponentsMap = new Map(rootMeta.components);\r\n        newComponentsMap.set(fullComponentId, newComponentRegistration);\r\n        get().setShadowMetadata(stateKey, [], { components: newComponentsMap });\r\n      }\r\n    }\r\n  },\r\n\r\n  markAsDirty: (key, path, options = { bubble: true }) => {\r\n    const setDirtyOnPath = (pathToMark: string[]) => {\r\n      const node = get().getShadowNode(key, pathToMark);\r\n      if (node?._meta?.isDirty) {\r\n        return true;\r\n      }\r\n      get().setShadowMetadata(key, pathToMark, { isDirty: true });\r\n      return false;\r\n    };\r\n\r\n    setDirtyOnPath(path);\r\n\r\n    if (options.bubble) {\r\n      let parentPath = [...path];\r\n      while (parentPath.length > 0) {\r\n        parentPath.pop();\r\n        if (setDirtyOnPath(parentPath)) {\r\n          break;\r\n        }\r\n      }\r\n    }\r\n  },\r\n\r\n  // Keep these in Zustand as they need React reactivity\r\n  serverStateUpdates: new Map(),\r\n  setServerStateUpdate: (key, serverState) => {\r\n    set((state) => ({\r\n      serverStateUpdates: new Map(state.serverStateUpdates).set(\r\n        key,\r\n        serverState\r\n      ),\r\n    }));\r\n    get().notifyPathSubscribers(key, {\r\n      type: 'SERVER_STATE_UPDATE',\r\n      serverState,\r\n    });\r\n  },\r\n\r\n  pathSubscribers: new Map<string, Set<(newValue: any) => void>>(),\r\n  subscribeToPath: (path, callback) => {\r\n    const subscribers = get().pathSubscribers;\r\n    const subsForPath = subscribers.get(path) || new Set();\r\n    subsForPath.add(callback);\r\n    subscribers.set(path, subsForPath);\r\n\r\n    return () => {\r\n      const currentSubs = get().pathSubscribers.get(path);\r\n      if (currentSubs) {\r\n        currentSubs.delete(callback);\r\n        if (currentSubs.size === 0) {\r\n          get().pathSubscribers.delete(path);\r\n        }\r\n      }\r\n    };\r\n  },\r\n\r\n  notifyPathSubscribers: (updatedPath, newValue) => {\r\n    const subscribers = get().pathSubscribers;\r\n    const subs = subscribers.get(updatedPath);\r\n    if (subs) {\r\n      subs.forEach((callback) => callback(newValue));\r\n    }\r\n  },\r\n\r\n  selectedIndicesMap: new Map<string, string>(),\r\n  getSelectedIndex: (arrayKey, validIds) => {\r\n    const itemKey = get().selectedIndicesMap.get(arrayKey);\r\n    if (!itemKey) return -1;\r\n\r\n    const arrayMeta = get().getShadowMetadata(\r\n      arrayKey.split('.')[0]!,\r\n      arrayKey.split('.').slice(1)\r\n    );\r\n    const arrayKeys = validIds || arrayMeta?.arrayKeys;\r\n\r\n    return arrayKeys ? arrayKeys.indexOf(itemKey) : -1;\r\n  },\r\n\r\n  setSelectedIndex: (arrayKey: string, itemKey: string | undefined) => {\r\n    set((state) => {\r\n      const newMap = new Map(state.selectedIndicesMap);\r\n\r\n      if (itemKey === undefined) {\r\n        newMap.delete(arrayKey);\r\n      } else {\r\n        if (newMap.has(arrayKey)) {\r\n          get().notifyPathSubscribers(newMap.get(arrayKey)!, {\r\n            type: 'THIS_UNSELECTED',\r\n          });\r\n        }\r\n        newMap.set(arrayKey, itemKey);\r\n        get().notifyPathSubscribers(itemKey, { type: 'THIS_SELECTED' });\r\n      }\r\n\r\n      get().notifyPathSubscribers(arrayKey, { type: 'GET_SELECTED' });\r\n\r\n      return {\r\n        ...state,\r\n        selectedIndicesMap: newMap,\r\n      };\r\n    });\r\n  },\r\n\r\n  clearSelectedIndex: ({ arrayKey }: { arrayKey: string }): void => {\r\n    set((state) => {\r\n      const newMap = new Map(state.selectedIndicesMap);\r\n      const actualKey = newMap.get(arrayKey);\r\n      if (actualKey) {\r\n        get().notifyPathSubscribers(actualKey, {\r\n          type: 'CLEAR_SELECTION',\r\n        });\r\n      }\r\n\r\n      newMap.delete(arrayKey);\r\n      get().notifyPathSubscribers(arrayKey, {\r\n        type: 'CLEAR_SELECTION',\r\n      });\r\n      return {\r\n        ...state,\r\n        selectedIndicesMap: newMap,\r\n      };\r\n    });\r\n  },\r\n\r\n  clearSelectedIndexesForState: (stateKey) => {\r\n    set((state) => {\r\n      const newMap = new Map(state.selectedIndicesMap);\r\n      let changed = false;\r\n      for (const key of newMap.keys()) {\r\n        if (key === stateKey || key.startsWith(stateKey + '.')) {\r\n          newMap.delete(key);\r\n          changed = true;\r\n        }\r\n      }\r\n      return changed ? { selectedIndicesMap: newMap } : {};\r\n    });\r\n  },\r\n\r\n  initialStateOptions: {},\r\n  stateLog: new Map(),\r\n  initialStateGlobal: {},\r\n\r\n  addStateLog: (updates) => {\r\n    if (!updates || updates.length === 0) return;\r\n    set((state) => {\r\n      const newLog = new Map(state.stateLog);\r\n      const logsGroupedByKey = new Map<string, UpdateTypeDetail[]>();\r\n      for (const update of updates) {\r\n        const group = logsGroupedByKey.get(update.stateKey) || [];\r\n        group.push(update);\r\n        logsGroupedByKey.set(update.stateKey, group);\r\n      }\r\n      for (const [key, batchOfUpdates] of logsGroupedByKey.entries()) {\r\n        const newStateLogForKey = new Map(newLog.get(key));\r\n        for (const update of batchOfUpdates) {\r\n          newStateLogForKey.set(JSON.stringify(update.path), { ...update });\r\n        }\r\n        newLog.set(key, newStateLogForKey);\r\n      }\r\n      return { stateLog: newLog };\r\n    });\r\n  },\r\n\r\n  getInitialOptions: (key) => get().initialStateOptions[key],\r\n  setInitialStateOptions: (key, value) => {\r\n    set((prev) => ({\r\n      initialStateOptions: { ...prev.initialStateOptions, [key]: value },\r\n    }));\r\n  },\r\n\r\n  updateInitialStateGlobal: (key, newState) => {\r\n    set((prev) => ({\r\n      initialStateGlobal: { ...prev.initialStateGlobal, [key]: newState },\r\n    }));\r\n  },\r\n\r\n  syncInfoStore: new Map<string, SyncInfo>(),\r\n  setSyncInfo: (key, syncInfo) =>\r\n    set((state) => {\r\n      const newMap = new Map(state.syncInfoStore);\r\n      newMap.set(key, syncInfo);\r\n      return { syncInfoStore: newMap };\r\n    }),\r\n  getSyncInfo: (key) => get().syncInfoStore.get(key) || null,\r\n}));\r\n"],"names":["getTypeFromZodSchema","schema","source","baseSchema","isNullable","isOptional","defaultValue","hasDefault","current","typeName","getTypeFromValue","value","valueType","buildShadowNode","stateKey","context","node","typeInfo","syncEntry","fieldSchema","segment","arrayNode","idKeys","item","index","itemId","generateId","itemContext","arraySchema","objectNode","key","propContext","objectSchema","shadowStateStore","globalCounter","instanceId","getGlobalStore","create","set","get","path","pluginName","data","metadata","pluginMetaData","existingData","cacheKey","cacheData","shadowState","storageKey","existingRoot","preservedMetadata","components","features","lastServerSync","stateSource","baseServerState","pathComponents","signals","validation","deepMergeShadowNodes","target","preservedMeta","itemKey","initialState","options","syncSchemas","newRoot","newMetadata","rootKey","root","validArrayIds","log","nodeKeys","result","propKey","newValue","parentNode","i","targetNode","intelligentMerge","nodeToUpdate","plainValue","oldMeta","newNode","plainValueKeys","childValue","nodeKey","arrayPath","newItems","newKeys","newItem","newItemId","itemsToAdd","currentKeys","insertionPoint","arrayKey","newIds","itemPath","indexToRemove","fullComponentId","registration","rootMeta","dependencyPath","newPathComponents","component","fullPathKey","newPaths","newComponentRegistration","newComponentsMap","setDirtyOnPath","pathToMark","parentPath","serverState","state","callback","subscribers","subsForPath","currentSubs","updatedPath","subs","validIds","arrayMeta","arrayKeys","newMap","actualKey","changed","updates","newLog","logsGroupedByKey","update","group","batchOfUpdates","newStateLogForKey","prev","newState","syncInfo"],"mappings":"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"}