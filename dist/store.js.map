{"version":3,"file":"store.js","sources":["../src/store.ts"],"sourcesContent":["import { create } from \"zustand\";\r\nimport type {\r\n  OptionsType,\r\n  ReactivityType,\r\n  StateKeys,\r\n  SyncActionsType,\r\n  SyncInfo,\r\n  UpdateTypeDetail,\r\n} from \"./CogsState.js\";\r\n\r\ntype StateUpdater<StateValue> =\r\n  | StateValue\r\n  | ((prevValue: StateValue) => StateValue);\r\n\r\nexport type FreshValuesObject = {\r\n  pathsToValues?: string[];\r\n  prevValue?: any;\r\n  newValue?: any;\r\n  timeStamp: number;\r\n};\r\n\r\ntype SyncLogType = {\r\n  timeStamp: number;\r\n};\r\ntype StateValue = any;\r\n\r\nexport type TrieNode = {\r\n  subscribers: Set<string>;\r\n  children: Map<string, TrieNode>;\r\n};\r\nexport type ComponentsType = {\r\n  components: Map<\r\n    string,\r\n    {\r\n      forceUpdate: () => void;\r\n      paths: Set<string>;\r\n      deps?: any[];\r\n      depsFunction?: (state: any) => any[] | true;\r\n      reactiveType: ReactivityType[] | ReactivityType;\r\n    }\r\n  >;\r\n};\r\nexport type FormRefStoreState = {\r\n  formRefs: Map<string, React.RefObject<any>>;\r\n  registerFormRef: (id: string, ref: React.RefObject<any>) => void;\r\n  getFormRef: (id: string) => React.RefObject<any> | undefined;\r\n  removeFormRef: (id: string) => void;\r\n  // New method to get all refs for a stateKey\r\n  getFormRefsByStateKey: (\r\n    stateKey: string\r\n  ) => Map<string, React.RefObject<any>>;\r\n};\r\n\r\nexport const formRefStore = create<FormRefStoreState>((set, get) => ({\r\n  formRefs: new Map(),\r\n\r\n  registerFormRef: (id, ref) =>\r\n    set((state) => {\r\n      const newRefs = new Map(state.formRefs);\r\n      newRefs.set(id, ref);\r\n      return { formRefs: newRefs };\r\n    }),\r\n\r\n  getFormRef: (id) => get().formRefs.get(id),\r\n\r\n  removeFormRef: (id) =>\r\n    set((state) => {\r\n      const newRefs = new Map(state.formRefs);\r\n      newRefs.delete(id);\r\n      return { formRefs: newRefs };\r\n    }),\r\n\r\n  // Get all refs that start with the stateKey prefix\r\n  getFormRefsByStateKey: (stateKey) => {\r\n    const allRefs = get().formRefs;\r\n    const stateKeyPrefix = stateKey + \".\";\r\n    const filteredRefs = new Map();\r\n\r\n    allRefs.forEach((ref, id) => {\r\n      if (id.startsWith(stateKeyPrefix) || id === stateKey) {\r\n        filteredRefs.set(id, ref);\r\n      }\r\n    });\r\n\r\n    return filteredRefs;\r\n  },\r\n}));\r\n\r\nexport type ItemMeta = {\r\n  _cogsId: string;\r\n  virtualizer?: {\r\n    itemHeight?: number;\r\n    domRef?: HTMLDivElement | null;\r\n  };\r\n  syncStatus?: \"new\" | \"syncing\" | \"synced\" | \"failed\";\r\n  error?: string;\r\n};\r\n\r\n// THE NEW, CORRECT, RECURSIVE TYPE FOR THE SHADOW STATE\r\n// A ShadowNode is either:\r\n// 1. An array of ItemMeta (if it represents a user's array).\r\n// 2. An object that can be indexed by any string, whose values are other ShadowNodes.\r\nexport type ShadowNode = ItemMeta[] | { [key: string]: ShadowNode };\r\n\r\n// This is the top-level type for the store, mapping state keys to our ShadowNode structure.\r\nexport type ShadowStateStore = {\r\n  [key: string]: ShadowNode;\r\n};\r\n\r\nexport type CogsGlobalState = {\r\n  // --- Shadow State and Subscription System ---\r\n  shadowStateStore: ShadowStateStore;\r\n  shadowStateSubscribers: Map<string, Set<() => void>>;\r\n  subscribeToShadowState: (key: string, callback: () => void) => () => void;\r\n  initializeShadowState: <T>(key: string, initialState: T) => void;\r\n  updateShadowAtPath: <T>(key: string, path: string[], newValue: T) => void;\r\n  insertShadowArrayElement: (\r\n    key: string,\r\n    arrayPath: string[],\r\n    newItemMeta: ItemMeta\r\n  ) => void;\r\n  removeShadowArrayElement: (\r\n    key: string,\r\n    arrayPath: string[],\r\n    index: number\r\n  ) => void;\r\n  getShadowMetadata: (key: string, path: string[]) => ShadowNode | null;\r\n  setShadowMetadata: (\r\n    key: string,\r\n    path: string[],\r\n    metadata: Partial<ItemMeta>\r\n  ) => void;\r\n  // --- Selected Item State ---\r\n  selectedIndicesMap: Map<string, Map<string, number>>; // stateKey -> (parentPath -> selectedIndex)\r\n  getSelectedIndex: (\r\n    stateKey: string,\r\n    parentPath: string\r\n  ) => number | undefined;\r\n  setSelectedIndex: (\r\n    stateKey: string,\r\n    parentPath: string,\r\n    index: number | undefined\r\n  ) => void;\r\n  clearSelectedIndex: ({\r\n    stateKey,\r\n    path,\r\n  }: {\r\n    stateKey: string;\r\n    path: string[];\r\n  }) => void;\r\n  clearSelectedIndexesForState: (stateKey: string) => void;\r\n\r\n  // --- Core State and Updaters ---\r\n  updaterState: { [key: string]: any };\r\n  initialStateOptions: { [key: string]: OptionsType };\r\n  cogsStateStore: { [key: string]: StateValue };\r\n  isLoadingGlobal: { [key: string]: boolean };\r\n  initialStateGlobal: { [key: string]: StateValue };\r\n  iniitialCreatedState: { [key: string]: StateValue };\r\n  serverState: { [key: string]: StateValue };\r\n\r\n  getUpdaterState: (key: string) => StateUpdater<StateValue>;\r\n  setUpdaterState: (key: string, newUpdater: any) => void;\r\n  getKeyState: <StateKey extends StateKeys>(key: StateKey) => StateValue;\r\n  getNestedState: <StateKey extends StateKeys>(\r\n    key: StateKey,\r\n    path: string[]\r\n  ) => StateValue;\r\n  setState: <StateKey extends StateKeys>(\r\n    key: StateKey,\r\n    value: StateUpdater<StateValue>\r\n  ) => void;\r\n  setInitialStates: (initialState: StateValue) => void;\r\n  setCreatedState: (initialState: StateValue) => void;\r\n  updateInitialStateGlobal: (key: string, newState: StateValue) => void;\r\n  updateInitialCreatedState: (key: string, newState: StateValue) => void;\r\n  setIsLoadingGlobal: (key: string, value: boolean) => void;\r\n  setServerState: <StateKey extends StateKeys>(\r\n    key: StateKey,\r\n    value: StateValue\r\n  ) => void;\r\n  getInitialOptions: (key: string) => OptionsType | undefined;\r\n  setInitialStateOptions: (key: string, value: OptionsType) => void;\r\n\r\n  // --- Validation ---\r\n  validationErrors: Map<string, string[]>;\r\n  addValidationError: (path: string, message: string) => void;\r\n  getValidationErrors: (path: string) => string[];\r\n  removeValidationError: (path: string) => void;\r\n\r\n  // --- Server Sync and Logging ---\r\n  serverSyncActions: { [key: string]: SyncActionsType<any> };\r\n  serverSyncLog: { [key: string]: SyncLogType[] };\r\n  stateLog: { [key: string]: UpdateTypeDetail[] };\r\n  syncInfoStore: Map<string, SyncInfo>;\r\n  serverSideOrNot: { [key: string]: boolean };\r\n  setServerSyncLog: (key: string, newValue: SyncLogType) => void;\r\n  setServerSideOrNot: (key: string, value: boolean) => void;\r\n  getServerSideOrNot: (key: string) => boolean | undefined;\r\n  getThisLocalUpdate: (key: string) => UpdateTypeDetail[] | undefined;\r\n  setServerSyncActions: (key: string, value: SyncActionsType<any>) => void;\r\n  setStateLog: (\r\n    key: string,\r\n    updater: (prevUpdates: UpdateTypeDetail[]) => UpdateTypeDetail[]\r\n  ) => void;\r\n  setSyncInfo: (key: string, syncInfo: SyncInfo) => void;\r\n  getSyncInfo: (key: string) => SyncInfo | null;\r\n\r\n  // --- Component and DOM Integration ---\r\n  signalDomElements: Map<\r\n    string,\r\n    Set<{\r\n      instanceId: string;\r\n      parentId: string;\r\n      position: number;\r\n      effect?: string;\r\n      map?: string;\r\n    }>\r\n  >;\r\n  addSignalElement: (\r\n    signalId: string,\r\n    elementInfo: {\r\n      instanceId: string;\r\n      parentId: string;\r\n      position: number;\r\n      effect?: string;\r\n      map?: string;\r\n    }\r\n  ) => void;\r\n  removeSignalElement: (signalId: string, instanceId: string) => void;\r\n  stateComponents: Map<string, ComponentsType>;\r\n\r\n  // --- Deprecated/Legacy (Review for removal) ---\r\n  reRenderTriggerPrevValue: Record<string, any>;\r\n  reactiveDeps: Record<\r\n    string,\r\n    {\r\n      deps: any[];\r\n      updaters: Set<() => void>;\r\n      depsFunction: ((state: any) => any[] | true) | null;\r\n    }\r\n  >;\r\n  setReactiveDeps: (\r\n    key: string,\r\n    record: {\r\n      deps: any[];\r\n      updaters: Set<() => void>;\r\n      depsFunction: ((state: any) => any[] | true) | null;\r\n    }\r\n  ) => void;\r\n  deleteReactiveDeps: (key: string) => void;\r\n  subscribe: (listener: () => void) => () => void;\r\n};\r\n\r\nexport const getGlobalStore = create<CogsGlobalState>((set, get) => ({\r\n  shadowStateStore: {},\r\n  getShadowMetadata: (key: string, path: string[]) => {\r\n    const shadow = get().shadowStateStore[key];\r\n    if (!shadow) return null;\r\n\r\n    let current: any = shadow;\r\n    for (const segment of path) {\r\n      current = current?.[segment];\r\n      if (!current) return null;\r\n    }\r\n\r\n    return current;\r\n  },\r\n\r\n  initializeShadowState: (key: string, initialState: any) => {\r\n    const createShadowStructure = (obj: any): any => {\r\n      if (Array.isArray(obj)) {\r\n        return new Array(obj.length)\r\n          .fill(null)\r\n          .map((_, i) => createShadowStructure(obj[i]));\r\n      }\r\n      if (typeof obj === \"object\" && obj !== null) {\r\n        const shadow: any = {};\r\n        for (const k in obj) {\r\n          shadow[k] = createShadowStructure(obj[k]);\r\n        }\r\n        return shadow;\r\n      }\r\n      return {}; // Leaf node - empty object for metadata\r\n    };\r\n\r\n    set((state) => ({\r\n      shadowStateStore: {\r\n        ...state.shadowStateStore,\r\n        [key]: createShadowStructure(initialState),\r\n      },\r\n    }));\r\n  },\r\n\r\n  updateShadowAtPath: (key: string, path: string[], newValue: any) => {\r\n    set((state) => {\r\n      const newShadow = { ...state.shadowStateStore };\r\n      if (!newShadow[key]) return state;\r\n\r\n      let current: any = newShadow[key];\r\n      const pathCopy = [...path];\r\n      const lastSegment = pathCopy.pop();\r\n\r\n      // Navigate to parent\r\n      for (const segment of pathCopy) {\r\n        if (!current[segment]) current[segment] = {};\r\n        current = current[segment];\r\n      }\r\n\r\n      // Update shadow structure to match new value structure\r\n      if (lastSegment !== undefined) {\r\n        if (Array.isArray(newValue)) {\r\n          current[lastSegment] = new Array(newValue.length);\r\n        } else if (typeof newValue === \"object\" && newValue !== null) {\r\n          current[lastSegment] = {};\r\n        } else {\r\n          current[lastSegment] = current[lastSegment] || {};\r\n        }\r\n      }\r\n\r\n      return { shadowStateStore: newShadow };\r\n    });\r\n  },\r\n\r\n  insertShadowArrayElement: (\r\n    key: string,\r\n    arrayPath: string[],\r\n    newItem: any\r\n  ) => {\r\n    set((state) => {\r\n      const newShadow = { ...state.shadowStateStore };\r\n      if (!newShadow[key]) return state;\r\n\r\n      newShadow[key] = JSON.parse(JSON.stringify(newShadow[key]));\r\n\r\n      let current: any = newShadow[key];\r\n\r\n      for (const segment of arrayPath) {\r\n        current = current[segment];\r\n        if (!current) return state;\r\n      }\r\n\r\n      if (Array.isArray(current)) {\r\n        // Create shadow structure based on the actual new item\r\n        const createShadowStructure = (obj: any): any => {\r\n          if (Array.isArray(obj)) {\r\n            return obj.map((item) => createShadowStructure(item));\r\n          }\r\n          if (typeof obj === \"object\" && obj !== null) {\r\n            const shadow: any = {};\r\n            for (const k in obj) {\r\n              shadow[k] = createShadowStructure(obj[k]);\r\n            }\r\n            return shadow;\r\n          }\r\n          return {}; // Leaf nodes get empty object for metadata\r\n        };\r\n\r\n        current.push(createShadowStructure(newItem));\r\n      }\r\n\r\n      return { shadowStateStore: newShadow };\r\n    });\r\n  },\r\n  removeShadowArrayElement: (\r\n    key: string,\r\n    arrayPath: string[],\r\n    index: number\r\n  ) => {\r\n    set((state) => {\r\n      const newShadow = { ...state.shadowStateStore };\r\n      let current: any = newShadow[key];\r\n\r\n      for (const segment of arrayPath) {\r\n        current = current?.[segment];\r\n      }\r\n\r\n      if (Array.isArray(current)) {\r\n        current.splice(index, 1);\r\n      }\r\n\r\n      return { shadowStateStore: newShadow };\r\n    });\r\n  },\r\n  shadowStateSubscribers: new Map<string, Set<() => void>>(), // key -> Set of callbacks\r\n\r\n  subscribeToShadowState: (key: string, callback: () => void) => {\r\n    set((state) => {\r\n      const newSubs = new Map(state.shadowStateSubscribers);\r\n      const subsForKey = newSubs.get(key) || new Set();\r\n      subsForKey.add(callback);\r\n      newSubs.set(key, subsForKey);\r\n      return { shadowStateSubscribers: newSubs };\r\n    });\r\n    // Return an unsubscribe function\r\n    return () => {\r\n      set((state) => {\r\n        const newSubs = new Map(state.shadowStateSubscribers);\r\n        const subsForKey = newSubs.get(key);\r\n        if (subsForKey) {\r\n          subsForKey.delete(callback);\r\n        }\r\n        return { shadowStateSubscribers: newSubs };\r\n      });\r\n    };\r\n  },\r\n\r\n  setShadowMetadata: (key: string, path: string[], metadata: any) => {\r\n    let hasChanged = false;\r\n    set((state) => {\r\n      const newShadow = { ...state.shadowStateStore };\r\n      if (!newShadow[key]) return state;\r\n\r\n      newShadow[key] = JSON.parse(JSON.stringify(newShadow[key]));\r\n\r\n      let current: any = newShadow[key];\r\n      for (const segment of path) {\r\n        if (!current[segment]) current[segment] = {};\r\n        current = current[segment];\r\n      }\r\n\r\n      const oldHeight = current.virtualizer?.itemHeight;\r\n      const newHeight = metadata.virtualizer?.itemHeight;\r\n\r\n      if (newHeight && oldHeight !== newHeight) {\r\n        hasChanged = true;\r\n        if (!current.virtualizer) current.virtualizer = {};\r\n        current.virtualizer.itemHeight = newHeight;\r\n      }\r\n\r\n      return { shadowStateStore: newShadow };\r\n    });\r\n\r\n    // If a height value was actually changed, notify the specific subscribers.\r\n    if (hasChanged) {\r\n      const subscribers = get().shadowStateSubscribers.get(key);\r\n      if (subscribers) {\r\n        subscribers.forEach((callback) => callback());\r\n      }\r\n    }\r\n  },\r\n  selectedIndicesMap: new Map<string, Map<string, number>>(),\r\n\r\n  // Add the new methods\r\n  getSelectedIndex: (stateKey: string, parentPath: string) => {\r\n    const stateMap = get().selectedIndicesMap.get(stateKey);\r\n    if (!stateMap) return undefined;\r\n    return stateMap.get(parentPath);\r\n  },\r\n\r\n  setSelectedIndex: (\r\n    stateKey: string,\r\n    parentPath: string,\r\n    index: number | undefined\r\n  ) => {\r\n    set((state) => {\r\n      const newMap = new Map(state.selectedIndicesMap);\r\n      let stateMap = newMap.get(stateKey);\r\n\r\n      if (!stateMap) {\r\n        stateMap = new Map<string, number>();\r\n        newMap.set(stateKey, stateMap);\r\n      }\r\n\r\n      if (index === undefined) {\r\n        stateMap.delete(parentPath);\r\n      } else {\r\n        stateMap.set(parentPath, index);\r\n      }\r\n\r\n      return {\r\n        ...state,\r\n        selectedIndicesMap: newMap,\r\n      };\r\n    });\r\n  },\r\n  clearSelectedIndex: ({\r\n    stateKey,\r\n    path,\r\n  }: {\r\n    stateKey: string;\r\n    path: string[];\r\n  }) => {\r\n    set((state) => {\r\n      const newMap = new Map(state.selectedIndicesMap);\r\n      const stateMap = newMap.get(stateKey);\r\n      if (!stateMap) return state;\r\n      const parentPath = path.join(\".\");\r\n      stateMap.delete(parentPath);\r\n      return {\r\n        ...state,\r\n        selectedIndicesMap: newMap,\r\n      };\r\n    });\r\n  },\r\n  clearSelectedIndexesForState: (stateKey: string) => {\r\n    set((state) => {\r\n      const newOuterMap = new Map(state.selectedIndicesMap);\r\n      const changed = newOuterMap.delete(stateKey);\r\n      if (changed) {\r\n        console.log(\r\n          `Cleared selected indices map entry for stateKey: ${stateKey}`\r\n        );\r\n        return { selectedIndicesMap: newOuterMap };\r\n      } else {\r\n        return {};\r\n      }\r\n    });\r\n  },\r\n  stateComponents: new Map(),\r\n  subscribe: (listener: () => void) => {\r\n    // zustand's subscribe returns an unsubscribe function\r\n    return get().subscribe(listener);\r\n  },\r\n\r\n  reactiveDeps: {},\r\n  setReactiveDeps: (key, record) =>\r\n    set((state) => ({\r\n      ...state,\r\n      reactiveDeps: {\r\n        ...state.reactiveDeps,\r\n        [key]: record,\r\n      },\r\n    })),\r\n  deleteReactiveDeps: (key) =>\r\n    set((state) => {\r\n      const { [key]: _, ...rest } = state.reactiveDeps;\r\n      return {\r\n        ...state,\r\n        reactiveDeps: rest,\r\n      };\r\n    }),\r\n\r\n  reRenderTriggerPrevValue: {},\r\n  signalDomElements: new Map(),\r\n  addSignalElement: (\r\n    signalId: string,\r\n    elementInfo: { instanceId: string; parentId: string; position: number }\r\n  ) => {\r\n    const current = get().signalDomElements;\r\n    if (!current.has(signalId)) {\r\n      current.set(signalId, new Set());\r\n    }\r\n    current.get(signalId)!.add(elementInfo);\r\n\r\n    set({ signalDomElements: new Map(current) }); // Create new reference to trigger update\r\n  },\r\n  removeSignalElement: (signalId: string, instanceId: string) => {\r\n    const current = get().signalDomElements;\r\n    const elements = current.get(signalId);\r\n    if (elements) {\r\n      elements.forEach((el) => {\r\n        if (el.instanceId === instanceId) {\r\n          elements.delete(el);\r\n        }\r\n      });\r\n    }\r\n    set({ signalDomElements: new Map(current) });\r\n  },\r\n  initialStateOptions: {},\r\n  updaterState: {},\r\n  stateTimeline: {},\r\n  cogsStateStore: {},\r\n  stateLog: {},\r\n  isLoadingGlobal: {},\r\n\r\n  initialStateGlobal: {},\r\n  iniitialCreatedState: {},\r\n  updateInitialCreatedState: (key, newState) => {\r\n    set((prev) => ({\r\n      iniitialCreatedState: {\r\n        ...prev.iniitialCreatedState,\r\n        [key]: newState,\r\n      },\r\n    }));\r\n  },\r\n\r\n  validationErrors: new Map(),\r\n\r\n  serverState: {},\r\n\r\n  serverSyncActions: {},\r\n\r\n  serverSyncLog: {},\r\n  serverSideOrNot: {},\r\n  setServerSyncLog: (key, newValue) => {\r\n    set((state) => ({\r\n      serverSyncLog: {\r\n        ...state.serverSyncLog,\r\n        [key]: [...(state.serverSyncLog[key] ?? []), newValue],\r\n      },\r\n    }));\r\n  },\r\n  setServerSideOrNot: (key, value) => {\r\n    set((state) => ({\r\n      serverSideOrNot: {\r\n        ...state.serverSideOrNot,\r\n        [key]: value,\r\n      },\r\n    }));\r\n  },\r\n  getServerSideOrNot: (key) => {\r\n    return get().serverSideOrNot[key];\r\n  },\r\n\r\n  getThisLocalUpdate: (key: string) => {\r\n    return get().stateLog[key];\r\n  },\r\n  setServerState: <StateKey extends StateKeys>(\r\n    key: StateKey,\r\n    value: StateValue\r\n  ) => {\r\n    set((prev) => ({\r\n      serverState: {\r\n        ...prev.serverState,\r\n        [key]: value,\r\n      },\r\n    }));\r\n  },\r\n\r\n  setStateLog: (\r\n    key: string,\r\n    updater: (prevUpdates: UpdateTypeDetail[]) => UpdateTypeDetail[]\r\n  ) => {\r\n    set((prev) => {\r\n      const currentUpdates = prev.stateLog[key] ?? [];\r\n      const newUpdates = updater(currentUpdates);\r\n      return {\r\n        stateLog: {\r\n          ...prev.stateLog,\r\n          [key]: newUpdates,\r\n        },\r\n      };\r\n    });\r\n  },\r\n  setIsLoadingGlobal: (key: string, value: boolean) => {\r\n    set((prev) => ({\r\n      isLoadingGlobal: {\r\n        ...prev.isLoadingGlobal,\r\n        [key]: value,\r\n      },\r\n    }));\r\n  },\r\n  setServerSyncActions: (key: string, value: SyncActionsType<any>) => {\r\n    set((prev) => ({\r\n      serverSyncActions: {\r\n        ...prev.serverSyncActions,\r\n        [key]: value,\r\n      },\r\n    }));\r\n  },\r\n  addValidationError: (path, message) => {\r\n    console.log(\"addValidationError---\");\r\n    set((prev) => {\r\n      const updatedErrors = new Map(prev.validationErrors);\r\n      const existingMessages = updatedErrors.get(path) || [];\r\n      console.log(\"addValidationError\", path, message, existingMessages);\r\n      // Append the new message instead of replacing\r\n      updatedErrors.set(path, [...existingMessages, message]);\r\n      return { validationErrors: updatedErrors };\r\n    });\r\n  },\r\n  removeValidationError: (path) => {\r\n    set((prev) => {\r\n      const updatedErrors = new Map(prev.validationErrors);\r\n\r\n      let doSomething = false;\r\n      const pathArray = path.split(\".\");\r\n      Array.from(updatedErrors.keys()).forEach((key) => {\r\n        const keyArray = key.split(\".\");\r\n        if (keyArray.length >= pathArray.length) {\r\n          let match = true;\r\n          for (let i = 0; i < pathArray.length; i++) {\r\n            if (keyArray[i] !== pathArray[i]) {\r\n              match = false;\r\n              break;\r\n            }\r\n          }\r\n\r\n          if (match) {\r\n            doSomething = true;\r\n            updatedErrors.delete(key);\r\n          }\r\n        }\r\n      });\r\n\r\n      return doSomething ? { validationErrors: updatedErrors } : prev;\r\n    });\r\n  },\r\n  getValidationErrors: (path: string) => {\r\n    const errors: string[] = [];\r\n    const valErrors = get().validationErrors;\r\n    const pathArray = path.split(\".\");\r\n\r\n    // Helper to check if an index matches either a wildcard or is in an array of indices\r\n    const isIndexMatch = (pathSegment: string, keySegment: string) => {\r\n      if (pathSegment === \"[*]\") return true;\r\n      if (Array.isArray(pathSegment)) {\r\n        return pathSegment.includes(parseInt(keySegment));\r\n      }\r\n      return pathSegment === keySegment;\r\n    };\r\n\r\n    Array.from(valErrors.keys()).forEach((key) => {\r\n      const keyArray = key.split(\".\");\r\n      if (keyArray.length >= pathArray.length) {\r\n        let match = true;\r\n        for (let i = 0; i < pathArray.length; i++) {\r\n          const pathSegment = pathArray[i];\r\n          const keySegment = keyArray[i]!;\r\n\r\n          // If current path segment is a number or [*], we need special handling\r\n          if (pathSegment === \"[*]\" || Array.isArray(pathSegment)) {\r\n            // Key segment should be a number if we're using [*] or array indices\r\n            const keyIndex = parseInt(keySegment);\r\n            if (isNaN(keyIndex)) {\r\n              match = false;\r\n              break;\r\n            }\r\n\r\n            if (!isIndexMatch(pathSegment, keySegment)) {\r\n              match = false;\r\n              break;\r\n            }\r\n          } else if (pathSegment !== keySegment) {\r\n            match = false;\r\n            break;\r\n          }\r\n        }\r\n\r\n        if (match) {\r\n          const errorMessages = valErrors.get(key);\r\n          if (errorMessages) {\r\n            errors.push(...errorMessages);\r\n          }\r\n        }\r\n      }\r\n    });\r\n\r\n    return errors;\r\n  },\r\n  getInitialOptions: (key) => {\r\n    return get().initialStateOptions[key];\r\n  },\r\n  getNestedState: (key: string, path: string[]) => {\r\n    const rootState = get().cogsStateStore[key];\r\n\r\n    const getValueWithAsterisk = (obj: any, pathArray: string[]): any => {\r\n      if (pathArray.length === 0) return obj;\r\n\r\n      const currentPath = pathArray[0];\r\n      const remainingPath = pathArray.slice(1);\r\n\r\n      if (currentPath === \"[*]\") {\r\n        if (!Array.isArray(obj)) {\r\n          console.warn(\"Asterisk notation used on non-array value\");\r\n          return undefined;\r\n        }\r\n\r\n        if (remainingPath.length === 0) return obj;\r\n\r\n        // Get result for each array item\r\n        const results = obj.map((item) =>\r\n          getValueWithAsterisk(item, remainingPath)\r\n        );\r\n\r\n        // If the next path segment exists and returns arrays, flatten them\r\n        if (Array.isArray(results[0])) {\r\n          return results.flat();\r\n        }\r\n\r\n        return results;\r\n      }\r\n\r\n      const value = obj[currentPath as keyof typeof obj];\r\n      if (value === undefined) return undefined;\r\n\r\n      return getValueWithAsterisk(value, remainingPath);\r\n    };\r\n\r\n    // This will still get the value but we need to make it reactive only to specific paths\r\n    return getValueWithAsterisk(rootState, path);\r\n  },\r\n  setInitialStateOptions: (key, value) => {\r\n    set((prev) => ({\r\n      initialStateOptions: {\r\n        ...prev.initialStateOptions,\r\n        [key]: value,\r\n      },\r\n    }));\r\n  },\r\n  updateInitialStateGlobal: (key, newState) => {\r\n    set((prev) => ({\r\n      initialStateGlobal: {\r\n        ...prev.initialStateGlobal,\r\n        [key]: newState,\r\n      },\r\n    }));\r\n  },\r\n  getUpdaterState: (key) => {\r\n    return get().updaterState[key];\r\n  },\r\n  setUpdaterState: (key, newUpdater) => {\r\n    const current = get().updaterState;\r\n\r\n    if (!key || !newUpdater) return;\r\n\r\n    set({ updaterState: { ...(current ?? {}), [key]: newUpdater } });\r\n  },\r\n  getKeyState: <StateKey extends StateKeys>(key: StateKey) => {\r\n    return get().cogsStateStore[key];\r\n  },\r\n\r\n  setState: <StateKey extends StateKeys>(key: StateKey, value: StateValue) => {\r\n    set((prev) => {\r\n      return {\r\n        cogsStateStore: {\r\n          ...prev.cogsStateStore,\r\n          [key]:\r\n            typeof value === \"function\"\r\n              ? value(prev.cogsStateStore[key])\r\n              : value,\r\n        },\r\n      };\r\n    });\r\n  },\r\n  setInitialStates: <StateKey extends StateKeys>(initialState: StateValue) => {\r\n    set((prev) => ({\r\n      cogsStateStore: {\r\n        ...prev.cogsStateStore,\r\n        ...initialState,\r\n      },\r\n    }));\r\n  },\r\n  setCreatedState: (initialState: StateValue) => {\r\n    set((prev) => ({\r\n      iniitialCreatedState: {\r\n        ...prev.cogsStateStore,\r\n        ...initialState,\r\n      },\r\n    }));\r\n  },\r\n\r\n  syncInfoStore: new Map<string, SyncInfo>(),\r\n  setSyncInfo: (key: string, syncInfo: SyncInfo) =>\r\n    set((state) => {\r\n      const newMap = new Map(state.syncInfoStore);\r\n      newMap.set(key, syncInfo);\r\n      return { ...state, syncInfoStore: newMap };\r\n    }),\r\n  getSyncInfo: (key: string) => get().syncInfoStore.get(key) || null,\r\n}));\r\n"],"names":["formRefStore","create","set","get","id","ref","state","newRefs","stateKey","allRefs","stateKeyPrefix","filteredRefs","getGlobalStore","key","path","shadow","current","segment","initialState","createShadowStructure","obj","_","i","k","newValue","newShadow","pathCopy","lastSegment","arrayPath","newItem","item","index","callback","newSubs","subsForKey","metadata","hasChanged","oldHeight","newHeight","subscribers","parentPath","stateMap","newMap","newOuterMap","listener","record","rest","signalId","elementInfo","instanceId","elements","el","newState","prev","value","updater","currentUpdates","newUpdates","message","updatedErrors","existingMessages","doSomething","pathArray","keyArray","match","errors","valErrors","isIndexMatch","pathSegment","keySegment","keyIndex","errorMessages","rootState","getValueWithAsterisk","currentPath","remainingPath","results","newUpdater","syncInfo"],"mappings":"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"}