{"version":3,"file":"store.js","sources":["../src/store.ts"],"sourcesContent":["import { create } from 'zustand';\r\nimport { ulid } from 'ulid';\r\nimport type {\r\n  OptionsType,\r\n  ReactivityType,\r\n  SyncInfo,\r\n  UpdateTypeDetail,\r\n} from './CogsState.js';\r\n\r\nimport { startTransition, type ReactNode } from 'react';\r\n\r\nexport type FreshValuesObject = {\r\n  pathsToValues?: string[];\r\n  prevValue?: any;\r\n  newValue?: any;\r\n  timeStamp: number;\r\n};\r\n\r\ntype StateValue = any;\r\n\r\nexport type TrieNode = {\r\n  subscribers: Set<string>;\r\n  children: Map<string, TrieNode>;\r\n};\r\n\r\nexport type FormRefStoreState = {\r\n  formRefs: Map<string, React.RefObject<any>>;\r\n  registerFormRef: (id: string, ref: React.RefObject<any>) => void;\r\n  getFormRef: (id: string) => React.RefObject<any> | undefined;\r\n  removeFormRef: (id: string) => void;\r\n  // New method to get all refs for a stateKey\r\n  getFormRefsByStateKey: (\r\n    stateKey: string\r\n  ) => Map<string, React.RefObject<any>>;\r\n};\r\n\r\nexport const formRefStore = create<FormRefStoreState>((set, get) => ({\r\n  formRefs: new Map(),\r\n\r\n  registerFormRef: (id, ref) =>\r\n    set((state) => {\r\n      const newRefs = new Map(state.formRefs);\r\n      newRefs.set(id, ref);\r\n      return { formRefs: newRefs };\r\n    }),\r\n\r\n  getFormRef: (id) => get().formRefs.get(id),\r\n\r\n  removeFormRef: (id) =>\r\n    set((state) => {\r\n      const newRefs = new Map(state.formRefs);\r\n      newRefs.delete(id);\r\n      return { formRefs: newRefs };\r\n    }),\r\n\r\n  // Get all refs that start with the stateKey prefix\r\n  getFormRefsByStateKey: (stateKey) => {\r\n    const allRefs = get().formRefs;\r\n    const stateKeyPrefix = stateKey + '.';\r\n    const filteredRefs = new Map();\r\n\r\n    allRefs.forEach((ref, id) => {\r\n      if (id.startsWith(stateKeyPrefix) || id === stateKey) {\r\n        filteredRefs.set(id, ref);\r\n      }\r\n    });\r\n\r\n    return filteredRefs;\r\n  },\r\n}));\r\nexport type ComponentsType = {\r\n  components?: Map<\r\n    string,\r\n    {\r\n      forceUpdate: () => void;\r\n      paths: Set<string>;\r\n      deps?: any[];\r\n      prevDeps?: any[];\r\n      depsFunction?: (state: any) => any[] | true;\r\n      reactiveType: ReactivityType[] | ReactivityType;\r\n    }\r\n  >;\r\n};\r\n\r\nexport type ValidationStatus =\r\n  | 'NOT_VALIDATED' // Never run\r\n  | 'VALIDATING' // Currently running\r\n  | 'VALID' // Passed\r\n  | 'INVALID'; // Failed\r\n\r\nexport type ValidationError = {\r\n  source: 'client' | 'sync_engine' | 'api';\r\n  message: string;\r\n  severity: 'warning' | 'error'; // warning = gentle, error = blocking\r\n  code?: string; // Optional error code\r\n};\r\n\r\nexport type ValidationState = {\r\n  status: ValidationStatus;\r\n  errors: ValidationError[];\r\n  lastValidated?: number;\r\n  validatedValue?: any; // Value when last validated\r\n};\r\nexport type ShadowMetadata = {\r\n  id?: string;\r\n\r\n  stateSource?: 'default' | 'server' | 'localStorage';\r\n  lastServerSync?: number;\r\n  isDirty?: boolean;\r\n  baseServerState?: any;\r\n\r\n  arrayKeys?: string[];\r\n\r\n  fields?: Record<string, any>;\r\n  virtualizer?: {\r\n    itemHeight?: number;\r\n    domRef?: HTMLElement | null;\r\n  };\r\n  syncInfo?: { status: string };\r\n  validation?: ValidationState;\r\n  features?: {\r\n    syncEnabled: boolean;\r\n    validationEnabled: boolean;\r\n    localStorageEnabled: boolean;\r\n  };\r\n  lastUpdated?: number;\r\n  value?: any;\r\n\r\n  signals?: Array<{\r\n    instanceId: string;\r\n    parentId: string;\r\n    position: number;\r\n    effect?: string;\r\n  }>;\r\n  mapWrappers?: Array<{\r\n    instanceId: string;\r\n    path: string[];\r\n    componentId: string;\r\n    meta?: any;\r\n    mapFn: (\r\n      setter: any,\r\n      index: number,\r\n\r\n      arraySetter: any\r\n    ) => ReactNode;\r\n    containerRef: HTMLDivElement | null;\r\n    rebuildStateShape: any;\r\n  }>;\r\n  transformCaches?: Map<\r\n    string,\r\n    {\r\n      validIds: string[];\r\n      computedAt: number;\r\n      transforms: Array<{ type: 'filter' | 'sort'; fn: Function }>;\r\n    }\r\n  >;\r\n  pathComponents?: Set<string>;\r\n  streams?: Map<\r\n    string,\r\n    {\r\n      buffer: any[];\r\n      flushTimer: NodeJS.Timeout | null;\r\n    }\r\n  >;\r\n} & ComponentsType;\r\n\r\nexport type CogsEvent =\r\n  | { type: 'INSERT'; path: string; itemKey: string; index: number }\r\n  | { type: 'REMOVE'; path: string; itemKey: string }\r\n  | { type: 'UPDATE'; path: string; newValue: any }\r\n  | { type: 'ITEMHEIGHT'; itemKey: string; height: number }\r\n  | { type: 'RELOAD'; path: string };\r\n\r\ntype ShadowValueNEW = {\r\n  value: any;\r\n  // Metadata that can exist on any value\r\n  signals?: Array<{\r\n    instanceId: string;\r\n    parentId: string;\r\n    position: number;\r\n    effect?: string;\r\n  }>;\r\n  validation?: ValidationState;\r\n  virtualizer?: {\r\n    itemHeight?: number;\r\n    domRef?: HTMLElement | null;\r\n  };\r\n  pathComponents?: Set<string>;\r\n};\r\n\r\ntype ShadowObjectNEW = {\r\n  [key: string]: ShadowValueNEW | ShadowObjectNEW | ShadowArrayNEW;\r\n};\r\n\r\ntype ShadowArrayNEW = {\r\n  [key: `id:${string}`]: ShadowValueNEW | ShadowObjectNEW | ShadowArrayNEW;\r\n  // Array-specific metadata\r\n  arrayKeys: string[];\r\n  mapWrappers?: Array<{\r\n    instanceId: string;\r\n    path: string[];\r\n    componentId: string;\r\n    meta?: any;\r\n    mapFn: (setter: any, index: number, arraySetter: any) => ReactNode;\r\n    containerRef: HTMLDivElement | null;\r\n    rebuildStateShape: any;\r\n  }>;\r\n  transformCaches?: Map<\r\n    string,\r\n    {\r\n      validIds: string[];\r\n      computedAt: number;\r\n      transforms: Array<{ type: 'filter' | 'sort'; fn: Function }>;\r\n    }\r\n  >;\r\n};\r\n\r\nexport type CogsGlobalState = {\r\n  // NEW shadow store\r\n  shadowStateStore: Map<string, ShadowMetadata>;\r\n  setTransformCache: (\r\n    key: string,\r\n    path: string[],\r\n    cacheKey: string,\r\n    cacheData: any\r\n  ) => void;\r\n  // NEW functions\r\n  initializeShadowState: (key: string, initialState: any) => void;\r\n  getShadowMetadata: (\r\n    key: string,\r\n    path: string[]\r\n  ) => ShadowMetadata | undefined;\r\n  setShadowMetadata: (key: string, path: string[], metadata: any) => void;\r\n  getShadowValue: (\r\n    key: string,\r\n    path: string[],\r\n    validArrayIds?: string[],\r\n    log?: boolean\r\n  ) => any;\r\n  updateShadowAtPath: (key: string, path: string[], newValue: any) => void;\r\n  insertShadowArrayElement: (\r\n    key: string,\r\n    arrayPath: string[],\r\n    newItem: any,\r\n    index?: number\r\n  ) => void;\r\n  removeShadowArrayElement: (key: string, itemPath: string[]) => void;\r\n  registerComponent: (\r\n    stateKey: string,\r\n    componentId: string,\r\n    registration: any\r\n  ) => void;\r\n  unregisterComponent: (stateKey: string, componentId: string) => void;\r\n  addPathComponent: (\r\n    stateKey: string,\r\n    dependencyPath: string[],\r\n    fullComponentId: string\r\n  ) => void;\r\n\r\n  markAsDirty: (\r\n    key: string,\r\n    path: string[],\r\n    options: { bubble: boolean }\r\n  ) => void;\r\n  // These method signatures stay the same\r\n\r\n  pathSubscribers: Map<string, Set<(newValue: any) => void>>;\r\n  subscribeToPath: (\r\n    path: string,\r\n    callback: (newValue: any) => void\r\n  ) => () => void;\r\n  notifyPathSubscribers: (updatedPath: string, newValue: any) => void;\r\n\r\n  selectedIndicesMap: Map<string, string>; // stateKey -> (parentPath -> selectedIndex)\r\n  getSelectedIndex: (stateKey: string, validArrayIds?: string[]) => number;\r\n  setSelectedIndex: (key: string, itemKey: string) => void;\r\n  clearSelectedIndex: ({ arrayKey }: { arrayKey: string }) => void;\r\n  clearSelectedIndexesForState: (stateKey: string) => void;\r\n\r\n  // --- Core State and Updaters ---\r\n\r\n  initialStateOptions: { [key: string]: OptionsType };\r\n\r\n  initialStateGlobal: { [key: string]: StateValue };\r\n\r\n  updateInitialStateGlobal: (key: string, newState: StateValue) => void;\r\n\r\n  getInitialOptions: (key: string) => OptionsType | undefined;\r\n  setInitialStateOptions: (key: string, value: OptionsType) => void;\r\n\r\n  serverStateUpdates: Map<\r\n    string,\r\n    {\r\n      data: any;\r\n      status: 'loading' | 'success' | 'error';\r\n      timestamp: number;\r\n    }\r\n  >;\r\n\r\n  setServerStateUpdate: (key: string, serverState: any) => void;\r\n\r\n  stateLog: Map<string, Map<string, UpdateTypeDetail>>;\r\n  syncInfoStore: Map<string, SyncInfo>;\r\n  addStateLog: (updates: UpdateTypeDetail[]) => void;\r\n\r\n  setSyncInfo: (key: string, syncInfo: SyncInfo) => void;\r\n  getSyncInfo: (key: string) => SyncInfo | null;\r\n};\r\n\r\n// ✅ CHANGE 1: Add `arrayKeys` to the list of recognized metadata keys.\r\nexport const METADATA_KEYS = new Set([\r\n  'arrayKeys',\r\n  'components',\r\n  'signals',\r\n  'mapWrappers',\r\n  'pathComponents',\r\n  'validation',\r\n  'features',\r\n  'virtualizer',\r\n  'transformCaches',\r\n  'lastServerSync',\r\n  'stateSource',\r\n  'baseServerState',\r\n  'isDirty',\r\n]);\r\n\r\n/**\r\n * The single source of truth for converting a regular JS value/object\r\n * into the shadow state tree format.\r\n */\r\n// ✅ CHANGE 2: `buildShadowNode` now correctly handles all arrays.\r\nexport function buildShadowNode(value: any): any {\r\n  // Primitives and null are wrapped.\r\n  if (value === null || typeof value !== 'object') {\r\n    return { value };\r\n  }\r\n\r\n  // Arrays are converted to an object with id-keyed children and an `arrayKeys` metadata property.\r\n  if (Array.isArray(value)) {\r\n    const arrayNode: any = { arrayKeys: [] }; // Initialize with arrayKeys\r\n    const idKeys: string[] = [];\r\n    value.forEach((item) => {\r\n      const itemId = `id:${ulid()}`;\r\n      arrayNode[itemId] = buildShadowNode(item); // Recurse for each item\r\n      idKeys.push(itemId);\r\n    });\r\n    arrayNode.arrayKeys = idKeys; // Set the final ordered keys\r\n    return arrayNode;\r\n  }\r\n\r\n  // Plain objects are recursively processed.\r\n  if (value.constructor === Object) {\r\n    const objectNode: any = {};\r\n    for (const key in value) {\r\n      if (Object.prototype.hasOwnProperty.call(value, key)) {\r\n        objectNode[key] = buildShadowNode(value[key]); // Recurse for each property\r\n      }\r\n    }\r\n    return objectNode;\r\n  }\r\n\r\n  // Fallback for other object types (Date, etc.) - treat them as primitives.\r\n  return { value };\r\n}\r\nexport const getGlobalStore = create<CogsGlobalState>((set, get) => ({\r\n  // Add to CogsGlobalState in store.ts\r\n\r\n  shadowStateStore: new Map<string, ShadowMetadata>(),\r\n\r\n  setTransformCache: (\r\n    key: string,\r\n    path: string[],\r\n    cacheKey: string,\r\n    cacheData: any\r\n  ) => {\r\n    const fullKey = [key, ...path].join('.');\r\n    const newShadowStore = new Map(get().shadowStateStore);\r\n    const existing = newShadowStore.get(fullKey) || {};\r\n\r\n    // Initialize transformCaches if it doesn't exist\r\n    if (!existing.transformCaches) {\r\n      existing.transformCaches = new Map();\r\n    }\r\n\r\n    // Update just the specific cache entry\r\n    existing.transformCaches.set(cacheKey, cacheData);\r\n\r\n    // Update shadow store WITHOUT notifying path subscribers\r\n    newShadowStore.set(fullKey, existing);\r\n    set({ shadowStateStore: newShadowStore });\r\n\r\n    // Don't call notifyPathSubscribers here - cache updates shouldn't trigger renders\r\n  },\r\n  initializeShadowState: (key: string, initialState: any) => {\r\n    set((state) => {\r\n      const newShadowStoreNEW = new Map(state.shadowStateStore);\r\n      const existingRoot =\r\n        newShadowStoreNEW.get(key) || newShadowStoreNEW.get(`[${key}`);\r\n      let preservedMetadata: any = {};\r\n      if (existingRoot) {\r\n        const {\r\n          components,\r\n          features,\r\n          lastServerSync,\r\n          stateSource,\r\n          baseServerState,\r\n        } = existingRoot as any;\r\n        if (components) preservedMetadata.components = components;\r\n        if (features) preservedMetadata.features = features;\r\n        if (lastServerSync) preservedMetadata.lastServerSync = lastServerSync;\r\n        if (stateSource) preservedMetadata.stateSource = stateSource;\r\n        if (baseServerState)\r\n          preservedMetadata.baseServerState = baseServerState;\r\n      }\r\n      newShadowStoreNEW.delete(key);\r\n      newShadowStoreNEW.delete(`[${key}`);\r\n\r\n      const newRoot = buildShadowNode(initialState);\r\n      Object.assign(newRoot, preservedMetadata);\r\n\r\n      const storageKey = Array.isArray(initialState) ? `[${key}` : key;\r\n      newShadowStoreNEW.set(storageKey, newRoot);\r\n      console.log('sssssssssssssssssssssssssssss', newShadowStoreNEW);\r\n      return { shadowStateStore: newShadowStoreNEW };\r\n    });\r\n  },\r\n  getShadowMetadata: (key: string, path: string[]) => {\r\n    const store = get().shadowStateStore;\r\n    let current: any = store.get(key) || store.get(`[${key}`);\r\n\r\n    if (!current) return undefined;\r\n    if (path.length === 0) return current;\r\n\r\n    // Correctly traverses the nested object property by property.\r\n    for (const segment of path) {\r\n      if (typeof current !== 'object' || current === null) return undefined;\r\n      current = current[segment];\r\n      if (current === undefined) return undefined;\r\n    }\r\n    return current;\r\n  },\r\n  setShadowMetadata: (key: string, path: string[], metadata: any) => {\r\n    set((state) => {\r\n      const newStore = new Map(state.shadowStateStore);\r\n      const rootKey = newStore.has(`[${key}`) ? `[${key}` : key;\r\n      let root = newStore.get(rootKey);\r\n\r\n      if (!root) {\r\n        root = {};\r\n        newStore.set(rootKey, root);\r\n      }\r\n\r\n      const clonedRoot: any = { ...root };\r\n      newStore.set(rootKey, clonedRoot);\r\n\r\n      if (path.length === 0) {\r\n        Object.assign(clonedRoot, metadata);\r\n      } else {\r\n        let current = clonedRoot;\r\n        const parentPath = path.slice(0, -1);\r\n\r\n        for (const segment of parentPath) {\r\n          const nextNode = current[segment] || {};\r\n          current[segment] = { ...nextNode }; // Clone for immutability\r\n          current = current[segment];\r\n        }\r\n\r\n        const lastSegment = path[path.length - 1]!;\r\n        const existingNode = current[lastSegment] || {};\r\n        current[lastSegment] = { ...existingNode, ...metadata }; // Merge metadata\r\n      }\r\n\r\n      return { shadowStateStore: newStore };\r\n    });\r\n  },\r\n\r\n  getShadowValue: (\r\n    key: string,\r\n    path: string[],\r\n    validArrayIds?: string[],\r\n    log?: boolean\r\n  ) => {\r\n    const node = get().getShadowMetadata(key, path);\r\n\r\n    if (node === null || node === undefined) return undefined;\r\n    if (log) {\r\n      console.log('getShadowValue', key, path, node);\r\n    }\r\n    const nodeKeys = Object.keys(node);\r\n\r\n    const isPrimitiveWrapper =\r\n      Object.prototype.hasOwnProperty.call(node, 'value') &&\r\n      nodeKeys.every((k) => k === 'value' || METADATA_KEYS.has(k));\r\n    if (log) {\r\n      console.log('isPrimitiveWrapper', isPrimitiveWrapper);\r\n    }\r\n    if (isPrimitiveWrapper) return node.value;\r\n\r\n    // A node is an array if it has the `arrayKeys` metadata property.\r\n    const isArrayNode = Object.prototype.hasOwnProperty.call(node, 'arrayKeys');\r\n    if (log) {\r\n      console.log('isArrayNode', isArrayNode);\r\n    }\r\n    if (isArrayNode) {\r\n      // Use the ordered list from `validArrayIds` (for filtered views) or the node's own `arrayKeys`.\r\n      const keysToIterate =\r\n        validArrayIds !== undefined && validArrayIds.length > 0\r\n          ? validArrayIds\r\n          : (node as any).arrayKeys;\r\n\r\n      if (log) {\r\n        console.log('keysToIterate', keysToIterate);\r\n      }\r\n      return keysToIterate.map((itemKey: string) =>\r\n        get().getShadowValue(key, [...path, itemKey])\r\n      );\r\n    }\r\n\r\n    const result: any = {};\r\n    for (const propKey of nodeKeys) {\r\n      if (!METADATA_KEYS.has(propKey) && !propKey.startsWith('id:')) {\r\n        result[propKey] = get().getShadowValue(key, [...path, propKey]);\r\n      }\r\n    }\r\n    return result;\r\n  },\r\n\r\n  updateShadowAtPath: (key: string, path: string[], newValue: any) => {\r\n    set((state) => {\r\n      const newStore = new Map(state.shadowStateStore);\r\n      const rootKey = newStore.has(`[${key}`) ? `[${key}` : key;\r\n      let root = newStore.get(rootKey);\r\n\r\n      if (!root) return state;\r\n\r\n      const clonedRoot: any = { ...root };\r\n      newStore.set(rootKey, clonedRoot);\r\n\r\n      if (path.length === 0) {\r\n        const newRootStructure = buildShadowNode(newValue);\r\n        for (const metaKey in clonedRoot) {\r\n          if (METADATA_KEYS.has(metaKey)) {\r\n            newRootStructure[metaKey] = clonedRoot[metaKey];\r\n          }\r\n        }\r\n        newStore.set(rootKey, newRootStructure);\r\n      } else {\r\n        let current = clonedRoot;\r\n        const parentPath = path.slice(0, -1);\r\n        for (const segment of parentPath) {\r\n          current[segment] = { ...current[segment] };\r\n          current = current[segment];\r\n        }\r\n\r\n        const lastSegment = path[path.length - 1]!;\r\n        const existingNode = current[lastSegment] || {};\r\n        const newNodeStructure = buildShadowNode(newValue);\r\n        // This merge is critical: it preserves metadata (like pathComponents) during an update.\r\n        current[lastSegment] = { ...existingNode, ...newNodeStructure };\r\n      }\r\n\r\n      get().notifyPathSubscribers([key, ...path].join('.'), {\r\n        type: 'UPDATE',\r\n        newValue,\r\n      });\r\n      return { shadowStateStore: newStore };\r\n    });\r\n  },\r\n\r\n  insertShadowArrayElement: (\r\n    key: string,\r\n    arrayPath: string[],\r\n    newItem: any,\r\n    index?: number\r\n  ) => {\r\n    set((state) => {\r\n      // Get the array node. We need a mutable reference for this transaction.\r\n      const arrayNode = get().getShadowMetadata(key, arrayPath);\r\n      if (!arrayNode) {\r\n        console.error(\r\n          `Array not found at path: ${[key, ...arrayPath].join('.')}`\r\n        );\r\n        return state;\r\n      }\r\n      const newItemId = `id:${ulid()}`;\r\n      // Add the new item's data to the node\r\n      arrayNode[newItemId as keyof typeof arrayNode] = buildShadowNode(newItem);\r\n\r\n      // Update the `arrayKeys` metadata to include the new item ID in the correct position\r\n      const currentKeys = (arrayNode.arrayKeys as string[]) || [];\r\n      const newKeys = [...currentKeys];\r\n      if (index !== undefined && index >= 0 && index <= newKeys.length) {\r\n        newKeys.splice(index, 0, newItemId);\r\n      } else {\r\n        newKeys.push(newItemId);\r\n      }\r\n      arrayNode.arrayKeys = newKeys;\r\n      get().setShadowMetadata(key, arrayPath, arrayNode);\r\n      const arrayKey = [key, ...arrayPath].join('.');\r\n      get().notifyPathSubscribers(arrayKey, {\r\n        type: 'INSERT',\r\n        path: arrayKey,\r\n        itemKey: `${arrayKey}.${newItemId}`,\r\n        index: index ?? newKeys.length - 1,\r\n      });\r\n\r\n      // `setShadowMetadata` handles the state update, so we return an empty object.\r\n      return {};\r\n    });\r\n  },\r\n\r\n  // ✅ CHANGE 5: `removeShadowArrayElement` now updates the `arrayKeys` metadata.\r\n  removeShadowArrayElement: (key: string, itemPath: string[]) => {\r\n    set((state) => {\r\n      if (itemPath.length === 0) {\r\n        console.error('Cannot remove root');\r\n        return state;\r\n      }\r\n\r\n      const arrayPath = itemPath.slice(0, -1);\r\n      const itemId = itemPath[itemPath.length - 1];\r\n\r\n      if (!itemId?.startsWith('id:')) {\r\n        console.error('Invalid item ID for removal:', itemId);\r\n        return state;\r\n      }\r\n\r\n      const arrayNode = get().getShadowMetadata(key, arrayPath);\r\n\r\n      if (!arrayNode) {\r\n        console.error(\r\n          `Array not found at path: ${[key, ...arrayPath].join('.')}`\r\n        );\r\n        return state;\r\n      }\r\n\r\n      // Delete the item's data from the node\r\n      delete arrayNode[itemId as keyof typeof arrayNode];\r\n\r\n      // Also remove the item's ID from the `arrayKeys` metadata\r\n      if (Array.isArray(arrayNode.arrayKeys)) {\r\n        arrayNode.arrayKeys = arrayNode.arrayKeys.filter((k) => k !== itemId);\r\n      }\r\n\r\n      // Persist the modified array node back to the store\r\n      get().setShadowMetadata(key, arrayPath, arrayNode);\r\n\r\n      const arrayKey = [key, ...arrayPath].join('.');\r\n      get().notifyPathSubscribers(arrayKey, {\r\n        type: 'REMOVE',\r\n        path: arrayKey,\r\n        itemKey: `${arrayKey}.${itemId}`,\r\n      });\r\n\r\n      // `setShadowMetadata` handles the state update\r\n      return {};\r\n    });\r\n  },\r\n  addPathComponent: (stateKey, dependencyPath, fullComponentId) => {\r\n    const node = get().getShadowMetadata(stateKey, dependencyPath) || {};\r\n\r\n    const newPathComponents = new Set(node.pathComponents);\r\n    newPathComponents.add(fullComponentId);\r\n    get().setShadowMetadata(stateKey, dependencyPath, {\r\n      pathComponents: newPathComponents,\r\n    });\r\n\r\n    // --- Part 2: Update the component's own list of paths it subscribes to ---\r\n    const rootNode = get().getShadowMetadata(stateKey, []);\r\n    if (rootNode?.components) {\r\n      const component = rootNode.components.get(fullComponentId);\r\n      if (component) {\r\n        const fullPathKey = [stateKey, ...dependencyPath].join('.');\r\n        const newPaths = new Set(component.paths);\r\n        newPaths.add(fullPathKey);\r\n        const newComponentRegistration = { ...component, paths: newPaths };\r\n        const newComponentsMap = new Map(rootNode.components);\r\n        newComponentsMap.set(fullComponentId, newComponentRegistration);\r\n        get().setShadowMetadata(stateKey, [], {\r\n          components: newComponentsMap,\r\n        });\r\n      }\r\n    }\r\n  },\r\n  registerComponent: (stateKey, fullComponentId, registration) => {\r\n    // Get metadata from the NEW store.\r\n    const rootMeta = get().getShadowMetadata(stateKey, []);\r\n    const components = new Map(rootMeta?.components);\r\n\r\n    components.set(fullComponentId, registration);\r\n\r\n    // Set the updated components map back onto the root node of the NEW store.\r\n    get().setShadowMetadata(stateKey, [], { components });\r\n  },\r\n  // Replace the old unregisterComponent with this corrected version\r\n  unregisterComponent: (stateKey, fullComponentId) => {\r\n    // Get metadata from the NEW store.\r\n    const rootMeta = get().getShadowMetadata(stateKey, []);\r\n\r\n    if (!rootMeta?.components) {\r\n      return; // Nothing to do\r\n    }\r\n\r\n    const components = new Map(rootMeta.components);\r\n    const wasDeleted = components.delete(fullComponentId);\r\n\r\n    // Only update state if something was actually deleted\r\n    if (wasDeleted) {\r\n      // Set the updated components map back onto the root node of the NEW store.\r\n      get().setShadowMetadata(stateKey, [], { components });\r\n    }\r\n  },\r\n\r\n  markAsDirty: (key: string, path: string[], options = { bubble: true }) => {\r\n    set((state) => {\r\n      // 1. Setup: Get the new store, find the root, and clone it to begin the update.\r\n      const newShadowStoreNEW = new Map(state.shadowStateStore);\r\n      const rootKey = newShadowStoreNEW.has(`[${key}`) ? `[${key}` : key;\r\n      const root = newShadowStoreNEW.get(rootKey);\r\n\r\n      // Abort if the root state object doesn't exist.\r\n      if (!root) {\r\n        console.error(`State with key \"${key}\" not found for markAsDirty.`);\r\n        return state;\r\n      }\r\n\r\n      const clonedRoot: any = { ...root };\r\n      newShadowStoreNEW.set(rootKey, clonedRoot);\r\n\r\n      // 2. This helper function translates your original `setDirty` logic.\r\n      //    It operates on the single `clonedRoot` object.\r\n      //    It returns 'true' if the node was already dirty, to stop the bubble.\r\n      const setDirtyOnNode = (pathToMark: string[]): boolean => {\r\n        // A. First, just navigate to the node to check its status without modifying anything.\r\n        let nodeToCheck = clonedRoot;\r\n        for (const segment of pathToMark) {\r\n          if (!nodeToCheck[segment]) {\r\n            // Path doesn't exist, so we can't mark it. Stop the process.\r\n            return true;\r\n          }\r\n          nodeToCheck = nodeToCheck[segment];\r\n        }\r\n\r\n        // B. If it's already dirty, we don't need to do anything else. Signal to stop bubbling.\r\n        if (nodeToCheck.isDirty === true) {\r\n          return true;\r\n        }\r\n\r\n        // C. If it's NOT dirty, we now traverse again, this time cloning each\r\n        //    node on the path to ensure an immutable update.\r\n        let mutator = clonedRoot;\r\n        for (const segment of pathToMark) {\r\n          mutator[segment] = { ...mutator[segment] }; // This is the crucial clone.\r\n          mutator = mutator[segment];\r\n        }\r\n\r\n        // D. Set the flag on the final, cloned node.\r\n        mutator.isDirty = true;\r\n        return false; // Signal that the state was changed.\r\n      };\r\n\r\n      // 3. Execute the logic, identical to your original function's structure.\r\n\r\n      // Mark the target path first.\r\n      setDirtyOnNode(path);\r\n\r\n      // Bubble up the change if requested.\r\n      if (options.bubble) {\r\n        let parentPath = [...path];\r\n        while (parentPath.length > 0) {\r\n          parentPath.pop();\r\n          const wasParentAlreadyDirty = setDirtyOnNode(parentPath);\r\n          // If the parent was already dirty, all of its ancestors are also dirty,\r\n          // so we can stop bubbling.\r\n          if (wasParentAlreadyDirty) {\r\n            break;\r\n          }\r\n        }\r\n      }\r\n\r\n      // 4. Return the new state object containing the fully modified root.\r\n      return { shadowStateStore: newShadowStoreNEW };\r\n    });\r\n  },\r\n  serverStateUpdates: new Map(),\r\n  setServerStateUpdate: (key, serverState) => {\r\n    set((state) => {\r\n      const newMap = new Map(state.serverStateUpdates);\r\n      newMap.set(key, serverState);\r\n      return { serverStateUpdates: newMap };\r\n    });\r\n\r\n    // Notify all subscribers for this key\r\n\r\n    get().notifyPathSubscribers(key, {\r\n      type: 'SERVER_STATE_UPDATE',\r\n      serverState,\r\n    });\r\n  },\r\n\r\n  getShadowNode: (key: string) => get().shadowStateStore.get(key),\r\n  pathSubscribers: new Map<string, Set<(newValue: any) => void>>(),\r\n\r\n  subscribeToPath: (path, callback) => {\r\n    const subscribers = get().pathSubscribers;\r\n    const subsForPath = subscribers.get(path) || new Set();\r\n    subsForPath.add(callback);\r\n    subscribers.set(path, subsForPath);\r\n\r\n    return () => {\r\n      const currentSubs = get().pathSubscribers.get(path);\r\n      if (currentSubs) {\r\n        currentSubs.delete(callback);\r\n        if (currentSubs.size === 0) {\r\n          get().pathSubscribers.delete(path);\r\n        }\r\n      }\r\n    };\r\n  },\r\n\r\n  notifyPathSubscribers: (updatedPath, newValue) => {\r\n    const subscribers = get().pathSubscribers;\r\n    const subs = subscribers.get(updatedPath);\r\n\r\n    if (subs) {\r\n      subs.forEach((callback) => callback(newValue));\r\n    }\r\n  },\r\n\r\n  selectedIndicesMap: new Map<string, string>(),\r\n  getSelectedIndex: (arrayKey: string, validIds?: string[]): number => {\r\n    const itemKey = get().selectedIndicesMap.get(arrayKey);\r\n\r\n    if (!itemKey) return -1;\r\n\r\n    // Use validIds if provided (for filtered views), otherwise use all arrayKeys\r\n    const arrayKeys =\r\n      validIds ||\r\n      getGlobalStore.getState().getShadowMetadata(arrayKey, [])?.arrayKeys;\r\n\r\n    if (!arrayKeys) return -1;\r\n\r\n    return arrayKeys.indexOf(itemKey);\r\n  },\r\n\r\n  setSelectedIndex: (arrayKey: string, itemKey: string | undefined) => {\r\n    set((state) => {\r\n      const newMap = state.selectedIndicesMap;\r\n\r\n      if (itemKey === undefined) {\r\n        newMap.delete(arrayKey);\r\n      } else {\r\n        if (newMap.has(arrayKey)) {\r\n          get().notifyPathSubscribers(newMap.get(arrayKey)!, {\r\n            type: 'THIS_UNSELECTED',\r\n          });\r\n        }\r\n        newMap.set(arrayKey, itemKey);\r\n\r\n        get().notifyPathSubscribers(itemKey, {\r\n          type: 'THIS_SELECTED',\r\n        });\r\n      }\r\n      get().notifyPathSubscribers(arrayKey, {\r\n        type: 'GET_SELECTED',\r\n      });\r\n      return {\r\n        ...state,\r\n        selectedIndicesMap: newMap,\r\n      };\r\n    });\r\n  },\r\n  clearSelectedIndex: ({ arrayKey }: { arrayKey: string }): void => {\r\n    set((state) => {\r\n      const newMap = state.selectedIndicesMap;\r\n      const acutalKey = newMap.get(arrayKey);\r\n      if (acutalKey) {\r\n        get().notifyPathSubscribers(acutalKey, {\r\n          type: 'CLEAR_SELECTION',\r\n        });\r\n      }\r\n\r\n      newMap.delete(arrayKey);\r\n      get().notifyPathSubscribers(arrayKey, {\r\n        type: 'CLEAR_SELECTION',\r\n      });\r\n      return {\r\n        ...state,\r\n        selectedIndicesMap: newMap,\r\n      };\r\n    });\r\n  },\r\n  clearSelectedIndexesForState: (stateKey: string) => {\r\n    set((state) => {\r\n      const newOuterMap = new Map(state.selectedIndicesMap);\r\n      const changed = newOuterMap.delete(stateKey);\r\n      if (changed) {\r\n        return { selectedIndicesMap: newOuterMap };\r\n      } else {\r\n        return {};\r\n      }\r\n    });\r\n  },\r\n\r\n  initialStateOptions: {},\r\n\r\n  stateTimeline: {},\r\n  cogsStateStore: {},\r\n  stateLog: new Map(),\r\n\r\n  initialStateGlobal: {},\r\n\r\n  validationErrors: new Map(),\r\n  addStateLog: (updates) => {\r\n    if (!updates || updates.length === 0) {\r\n      return;\r\n    }\r\n    set((state) => {\r\n      const newLog = new Map(state.stateLog);\r\n\r\n      // Group all updates by their stateKey\r\n      const logsGroupedByKey = new Map<string, UpdateTypeDetail[]>();\r\n      for (const update of updates) {\r\n        if (!logsGroupedByKey.has(update.stateKey)) {\r\n          logsGroupedByKey.set(update.stateKey, []);\r\n        }\r\n        logsGroupedByKey.get(update.stateKey)!.push(update);\r\n      }\r\n\r\n      // Process each group efficiently\r\n      for (const [key, batchOfUpdates] of logsGroupedByKey.entries()) {\r\n        // Copy the map for this key only ONCE\r\n        const newStateLogForKey = new Map(newLog.get(key));\r\n\r\n        // Apply all updates for this key in a fast loop\r\n        for (const update of batchOfUpdates) {\r\n          const uniquePathKey = JSON.stringify(update.path);\r\n          newStateLogForKey.set(uniquePathKey, { ...update });\r\n        }\r\n\r\n        newLog.set(key, newStateLogForKey);\r\n      }\r\n\r\n      return { stateLog: newLog };\r\n    });\r\n  },\r\n\r\n  getInitialOptions: (key) => {\r\n    return get().initialStateOptions[key];\r\n  },\r\n\r\n  setInitialStateOptions: (key, value) => {\r\n    set((prev) => ({\r\n      initialStateOptions: {\r\n        ...prev.initialStateOptions,\r\n        [key]: value,\r\n      },\r\n    }));\r\n  },\r\n  updateInitialStateGlobal: (key, newState) => {\r\n    set((prev) => ({\r\n      initialStateGlobal: {\r\n        ...prev.initialStateGlobal,\r\n        [key]: newState,\r\n      },\r\n    }));\r\n  },\r\n\r\n  syncInfoStore: new Map<string, SyncInfo>(),\r\n  setSyncInfo: (key: string, syncInfo: SyncInfo) =>\r\n    set((state) => {\r\n      const newMap = new Map(state.syncInfoStore);\r\n      newMap.set(key, syncInfo);\r\n      return { ...state, syncInfoStore: newMap };\r\n    }),\r\n  getSyncInfo: (key: string) => get().syncInfoStore.get(key) || null,\r\n}));\r\n"],"names":["formRefStore","create","set","get","id","ref","state","newRefs","stateKey","allRefs","stateKeyPrefix","filteredRefs","METADATA_KEYS","buildShadowNode","value","arrayNode","idKeys","item","itemId","ulid","objectNode","key","getGlobalStore","path","cacheKey","cacheData","fullKey","newShadowStore","existing","initialState","newShadowStoreNEW","existingRoot","preservedMetadata","components","features","lastServerSync","stateSource","baseServerState","newRoot","storageKey","store","current","segment","metadata","newStore","rootKey","root","clonedRoot","parentPath","nextNode","lastSegment","existingNode","validArrayIds","log","node","nodeKeys","isPrimitiveWrapper","k","isArrayNode","keysToIterate","itemKey","result","propKey","newValue","newRootStructure","metaKey","newNodeStructure","arrayPath","newItem","index","newItemId","newKeys","arrayKey","itemPath","dependencyPath","fullComponentId","newPathComponents","rootNode","component","fullPathKey","newPaths","newComponentRegistration","newComponentsMap","registration","rootMeta","options","setDirtyOnNode","pathToMark","nodeToCheck","mutator","serverState","newMap","callback","subscribers","subsForPath","currentSubs","updatedPath","subs","validIds","arrayKeys","acutalKey","newOuterMap","updates","newLog","logsGroupedByKey","update","batchOfUpdates","newStateLogForKey","uniquePathKey","prev","newState","syncInfo"],"mappings":"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"}