{"version":3,"file":"store.js","sources":["../src/store.ts"],"sourcesContent":["import { create } from 'zustand';\r\nimport { ulid } from 'ulid';\r\nimport type {\r\n  OptionsType,\r\n  ReactivityType,\r\n  SyncInfo,\r\n  UpdateTypeDetail,\r\n} from './CogsState.js';\r\n\r\nimport { startTransition, type ReactNode } from 'react';\r\n\r\nexport type FreshValuesObject = {\r\n  pathsToValues?: string[];\r\n  prevValue?: any;\r\n  newValue?: any;\r\n  timeStamp: number;\r\n};\r\n\r\ntype StateValue = any;\r\n\r\nexport type TrieNode = {\r\n  subscribers: Set<string>;\r\n  children: Map<string, TrieNode>;\r\n};\r\n\r\nexport type FormRefStoreState = {\r\n  formRefs: Map<string, React.RefObject<any>>;\r\n  registerFormRef: (id: string, ref: React.RefObject<any>) => void;\r\n  getFormRef: (id: string) => React.RefObject<any> | undefined;\r\n  removeFormRef: (id: string) => void;\r\n  // New method to get all refs for a stateKey\r\n  getFormRefsByStateKey: (\r\n    stateKey: string\r\n  ) => Map<string, React.RefObject<any>>;\r\n};\r\n\r\nexport const formRefStore = create<FormRefStoreState>((set, get) => ({\r\n  formRefs: new Map(),\r\n\r\n  registerFormRef: (id, ref) =>\r\n    set((state) => {\r\n      const newRefs = new Map(state.formRefs);\r\n      newRefs.set(id, ref);\r\n      return { formRefs: newRefs };\r\n    }),\r\n\r\n  getFormRef: (id) => get().formRefs.get(id),\r\n\r\n  removeFormRef: (id) =>\r\n    set((state) => {\r\n      const newRefs = new Map(state.formRefs);\r\n      newRefs.delete(id);\r\n      return { formRefs: newRefs };\r\n    }),\r\n\r\n  // Get all refs that start with the stateKey prefix\r\n  getFormRefsByStateKey: (stateKey) => {\r\n    const allRefs = get().formRefs;\r\n    const stateKeyPrefix = stateKey + '.';\r\n    const filteredRefs = new Map();\r\n\r\n    allRefs.forEach((ref, id) => {\r\n      if (id.startsWith(stateKeyPrefix) || id === stateKey) {\r\n        filteredRefs.set(id, ref);\r\n      }\r\n    });\r\n\r\n    return filteredRefs;\r\n  },\r\n}));\r\nexport type ComponentsType = {\r\n  components?: Map<\r\n    string,\r\n    {\r\n      forceUpdate: () => void;\r\n      paths: Set<string>;\r\n      deps?: any[];\r\n      prevDeps?: any[];\r\n      depsFunction?: (state: any) => any[] | true;\r\n      reactiveType: ReactivityType[] | ReactivityType;\r\n    }\r\n  >;\r\n};\r\n\r\nexport type ValidationStatus =\r\n  | 'NOT_VALIDATED' // Never run\r\n  | 'VALIDATING' // Currently running\r\n  | 'VALID' // Passed\r\n  | 'INVALID'; // Failed\r\n\r\nexport type ValidationError = {\r\n  source: 'client' | 'sync_engine' | 'api';\r\n  message: string;\r\n  severity: 'warning' | 'error'; // warning = gentle, error = blocking\r\n  code?: string; // Optional error code\r\n};\r\n\r\nexport type ValidationState = {\r\n  status: ValidationStatus;\r\n  errors: ValidationError[];\r\n  lastValidated?: number;\r\n  validatedValue?: any; // Value when last validated\r\n};\r\n\r\n// This is the new definition for the metadata object\r\nexport type ShadowMetadata = {\r\n  id?: string;\r\n  stateSource?: 'default' | 'server' | 'localStorage';\r\n  lastServerSync?: number;\r\n  isDirty?: boolean;\r\n  baseServerState?: any;\r\n  arrayKeys?: string[];\r\n  fields?: Record<string, any>;\r\n  virtualizer?: {\r\n    itemHeight?: number;\r\n    domRef?: HTMLElement | null;\r\n  };\r\n  syncInfo?: { status: string };\r\n  validation?: ValidationState;\r\n  features?: {\r\n    syncEnabled: boolean;\r\n    validationEnabled: boolean;\r\n    localStorageEnabled: boolean;\r\n  };\r\n  lastUpdated?: number;\r\n  signals?: Array<{\r\n    instanceId: string;\r\n    parentId: string;\r\n    position: number;\r\n    effect?: string;\r\n  }>;\r\n  mapWrappers?: Array<{\r\n    instanceId: string;\r\n    path: string[];\r\n    componentId: string;\r\n    meta?: any;\r\n    mapFn: (setter: any, index: number, arraySetter: any) => ReactNode;\r\n    containerRef: HTMLDivElement | null;\r\n    rebuildStateShape: any;\r\n  }>;\r\n  transformCaches?: Map<\r\n    string,\r\n    {\r\n      validIds: string[];\r\n      computedAt: number;\r\n      transforms: Array<{ type: 'filter' | 'sort'; fn: Function }>;\r\n    }\r\n  >;\r\n  pathComponents?: Set<string>;\r\n  streams?: Map<\r\n    string,\r\n    {\r\n      buffer: any[];\r\n      flushTimer: NodeJS.Timeout | null;\r\n    }\r\n  >;\r\n} & ComponentsType;\r\n\r\n// The shadow node itself can have a value and the metadata object.\r\ntype ShadowNode = {\r\n  value?: any;\r\n  _meta?: ShadowMetadata;\r\n  [key: string]: any; // For nested data properties\r\n};\r\n\r\nexport type CogsGlobalState = {\r\n  // NEW shadow store\r\n  shadowStateStore: Map<string, ShadowNode>; // Changed ShadowMetadata to ShadowNode\r\n  setTransformCache: (\r\n    key: string,\r\n    path: string[],\r\n    cacheKey: string,\r\n    cacheData: any\r\n  ) => void;\r\n  // NEW functions\r\n  initializeShadowState: (key: string, initialState: any) => void;\r\n\r\n  // REFACTORED: getShadowNode gets the whole object (data + _meta)\r\n  getShadowNode: (key: string, path: string[]) => ShadowNode | undefined;\r\n  // REFACTORED: getShadowMetadata now returns just the _meta field\r\n  getShadowMetadata: (\r\n    key: string,\r\n    path: string[]\r\n  ) => ShadowMetadata | undefined;\r\n\r\n  setShadowMetadata: (key: string, path: string[], metadata: any) => void;\r\n  getShadowValue: (\r\n    key: string,\r\n    path: string[],\r\n    validArrayIds?: string[],\r\n    log?: boolean\r\n  ) => any;\r\n  updateShadowAtPath: (key: string, path: string[], newValue: any) => void;\r\n  insertShadowArrayElement: (\r\n    key: string,\r\n    arrayPath: string[],\r\n    newItem: any,\r\n    index?: number\r\n  ) => void;\r\n  removeShadowArrayElement: (key: string, itemPath: string[]) => void;\r\n  registerComponent: (\r\n    stateKey: string,\r\n    componentId: string,\r\n    registration: any\r\n  ) => void;\r\n  unregisterComponent: (stateKey: string, componentId: string) => void;\r\n  addPathComponent: (\r\n    stateKey: string,\r\n    dependencyPath: string[],\r\n    fullComponentId: string\r\n  ) => void;\r\n\r\n  markAsDirty: (\r\n    key: string,\r\n    path: string[],\r\n    options: { bubble: boolean }\r\n  ) => void;\r\n  // These method signatures stay the same\r\n\r\n  pathSubscribers: Map<string, Set<(newValue: any) => void>>;\r\n  subscribeToPath: (\r\n    path: string,\r\n    callback: (newValue: any) => void\r\n  ) => () => void;\r\n  notifyPathSubscribers: (updatedPath: string, newValue: any) => void;\r\n\r\n  selectedIndicesMap: Map<string, string>; // stateKey -> (parentPath -> selectedIndex)\r\n  getSelectedIndex: (stateKey: string, validArrayIds?: string[]) => number;\r\n  setSelectedIndex: (key: string, itemKey: string) => void;\r\n  clearSelectedIndex: ({ arrayKey }: { arrayKey: string }) => void;\r\n  clearSelectedIndexesForState: (stateKey: string) => void;\r\n\r\n  // --- Core State and Updaters ---\r\n\r\n  initialStateOptions: { [key: string]: OptionsType };\r\n\r\n  initialStateGlobal: { [key: string]: StateValue };\r\n\r\n  updateInitialStateGlobal: (key: string, newState: StateValue) => void;\r\n\r\n  getInitialOptions: (key: string) => OptionsType | undefined;\r\n  setInitialStateOptions: (key: string, value: OptionsType) => void;\r\n\r\n  serverStateUpdates: Map<\r\n    string,\r\n    {\r\n      data: any;\r\n      status: 'loading' | 'success' | 'error';\r\n      timestamp: number;\r\n    }\r\n  >;\r\n\r\n  setServerStateUpdate: (key: string, serverState: any) => void;\r\n\r\n  stateLog: Map<string, Map<string, UpdateTypeDetail>>;\r\n  syncInfoStore: Map<string, SyncInfo>;\r\n  addStateLog: (updates: UpdateTypeDetail[]) => void;\r\n\r\n  setSyncInfo: (key: string, syncInfo: SyncInfo) => void;\r\n  getSyncInfo: (key: string) => SyncInfo | null;\r\n};\r\n\r\n// ✅ CHANGE 1: `METADATA_KEYS` now only contains `_meta` and `value`.\r\n// The other keys are now properties of the `ShadowMetadata` type.\r\nexport const METADATA_KEYS = new Set(['_meta', 'value']);\r\n\r\n/**\r\n * The single source of truth for converting a regular JS value/object\r\n * into the shadow state tree format with the new `_meta` structure.\r\n */\r\n// ✅ CHANGE 2: `buildShadowNode` now creates the `_meta` field.\r\nexport function buildShadowNode(value: any): ShadowNode {\r\n  // Primitives and null are wrapped.\r\n  if (value === null || typeof value !== 'object') {\r\n    return { value };\r\n  }\r\n\r\n  // Arrays are converted to an object with id-keyed children and metadata in `_meta`.\r\n  if (Array.isArray(value)) {\r\n    const arrayNode: ShadowNode = { _meta: { arrayKeys: [] } }; // Initialize with _meta and arrayKeys\r\n    const idKeys: string[] = [];\r\n    value.forEach((item) => {\r\n      const itemId = `id:${ulid()}`;\r\n      arrayNode[itemId] = buildShadowNode(item); // Recurse for each item\r\n      idKeys.push(itemId);\r\n    });\r\n    arrayNode._meta!.arrayKeys = idKeys; // Set the final ordered keys\r\n    return arrayNode;\r\n  }\r\n\r\n  // Plain objects are recursively processed.\r\n  if (value.constructor === Object) {\r\n    const objectNode: ShadowNode = { _meta: {} }; // Initialize with an empty meta object\r\n    for (const key in value) {\r\n      if (Object.prototype.hasOwnProperty.call(value, key)) {\r\n        objectNode[key] = buildShadowNode(value[key]); // Recurse for each property\r\n      }\r\n    }\r\n    return objectNode;\r\n  }\r\n\r\n  // Fallback for other object types (Date, etc.) - treat them as primitives.\r\n  return { value };\r\n}\r\n\r\nexport const getGlobalStore = create<CogsGlobalState>((set, get) => ({\r\n  shadowStateStore: new Map<string, ShadowNode>(),\r\n\r\n  setTransformCache: (\r\n    key: string,\r\n    path: string[],\r\n    cacheKey: string,\r\n    cacheData: any\r\n  ) => {\r\n    // This function now uses setShadowMetadata which correctly places the data.\r\n    const metadata = get().getShadowMetadata(key, path) || {};\r\n    if (!metadata.transformCaches) {\r\n      metadata.transformCaches = new Map();\r\n    }\r\n    metadata.transformCaches.set(cacheKey, cacheData);\r\n    get().setShadowMetadata(key, path, {\r\n      transformCaches: metadata.transformCaches,\r\n    });\r\n  },\r\n\r\n  initializeShadowState: (key: string, initialState: any) => {\r\n    set((state) => {\r\n      const newShadowStore = new Map(state.shadowStateStore);\r\n      const existingRoot =\r\n        newShadowStore.get(key) || newShadowStore.get(`[${key}`);\r\n      let preservedMetadata: Partial<ShadowMetadata> = {};\r\n\r\n      if (existingRoot?._meta) {\r\n        const {\r\n          components,\r\n          features,\r\n          lastServerSync,\r\n          stateSource,\r\n          baseServerState,\r\n        } = existingRoot._meta;\r\n        if (components) preservedMetadata.components = components;\r\n        if (features) preservedMetadata.features = features;\r\n        if (lastServerSync) preservedMetadata.lastServerSync = lastServerSync;\r\n        if (stateSource) preservedMetadata.stateSource = stateSource;\r\n        if (baseServerState)\r\n          preservedMetadata.baseServerState = baseServerState;\r\n      }\r\n\r\n      newShadowStore.delete(key);\r\n      newShadowStore.delete(`[${key}`);\r\n\r\n      const newRoot = buildShadowNode(initialState);\r\n      // Ensure _meta exists before assigning to it\r\n      if (!newRoot._meta) newRoot._meta = {};\r\n      Object.assign(newRoot._meta, preservedMetadata);\r\n\r\n      const storageKey = Array.isArray(initialState) ? `[${key}` : key;\r\n      newShadowStore.set(storageKey, newRoot);\r\n\r\n      return { shadowStateStore: newShadowStore };\r\n    });\r\n  },\r\n\r\n  // ✅ NEW HELPER: Gets the entire node (data and metadata).\r\n  getShadowNode: (key: string, path: string[]): ShadowNode | undefined => {\r\n    const store = get().shadowStateStore;\r\n    let current: any = store.get(key) || store.get(`[${key}`);\r\n\r\n    if (!current) return undefined;\r\n    if (path.length === 0) return current;\r\n\r\n    for (const segment of path) {\r\n      if (typeof current !== 'object' || current === null) return undefined;\r\n      current = current[segment];\r\n      if (current === undefined) return undefined;\r\n    }\r\n    return current;\r\n  },\r\n\r\n  // ✅ REFACTORED: Returns only the `_meta` part of a node.\r\n  getShadowMetadata: (\r\n    key: string,\r\n    path: string[]\r\n  ): ShadowMetadata | undefined => {\r\n    const node = get().getShadowNode(key, path);\r\n    return node?._meta;\r\n  },\r\n\r\n  // ✅ REFACTORED: Sets data within the `_meta` object.\r\n  setShadowMetadata: (\r\n    key: string,\r\n    path: string[],\r\n    newMetadata: Partial<ShadowMetadata>\r\n  ) => {\r\n    set((state) => {\r\n      const newStore = new Map(state.shadowStateStore);\r\n      const rootKey = newStore.has(`[${key}`) ? `[${key}` : key;\r\n      let root = newStore.get(rootKey);\r\n\r\n      if (!root) {\r\n        root = {};\r\n        newStore.set(rootKey, root);\r\n      }\r\n\r\n      const clonedRoot: any = { ...root };\r\n      newStore.set(rootKey, clonedRoot);\r\n\r\n      let current = clonedRoot;\r\n      for (const segment of path) {\r\n        const nextNode = current[segment] || {};\r\n        current[segment] = { ...nextNode }; // Clone for immutability\r\n        current = current[segment];\r\n      }\r\n\r\n      // Ensure _meta object exists and merge the new metadata into it\r\n      current._meta = { ...(current._meta || {}), ...newMetadata };\r\n\r\n      return { shadowStateStore: newStore };\r\n    });\r\n  },\r\n  getShadowValue: (\r\n    key: string,\r\n    path: string[],\r\n    validArrayIds?: string[],\r\n    log?: boolean\r\n  ) => {\r\n    const node = get().getShadowNode(key, path);\r\n\r\n    if (node === null || node === undefined) return undefined;\r\n\r\n    const nodeKeys = Object.keys(node);\r\n\r\n    // ✅ FIX: A node is a primitive wrapper ONLY if its keys are 'value' and/or '_meta'.\r\n    // This prevents objects in your data that happen to have a \"value\" property from being\r\n    // incorrectly treated as wrappers.\r\n    const isPrimitiveWrapper =\r\n      Object.prototype.hasOwnProperty.call(node, 'value') &&\r\n      nodeKeys.every((k) => k === 'value' || k === '_meta');\r\n\r\n    if (isPrimitiveWrapper) {\r\n      return node.value;\r\n    }\r\n\r\n    // Array Check (This part is correct)\r\n    const isArrayNode =\r\n      node._meta &&\r\n      Object.prototype.hasOwnProperty.call(node._meta, 'arrayKeys');\r\n    if (isArrayNode) {\r\n      const keysToIterate =\r\n        validArrayIds !== undefined && validArrayIds.length > 0\r\n          ? validArrayIds\r\n          : node._meta!.arrayKeys!;\r\n\r\n      return keysToIterate.map((itemKey: string) =>\r\n        get().getShadowValue(key, [...path, itemKey])\r\n      );\r\n    }\r\n\r\n    // Object Reconstruction (This part is also correct)\r\n    const result: any = {};\r\n    for (const propKey of nodeKeys) {\r\n      // We correctly ignore metadata and array item keys here.\r\n      if (propKey !== '_meta' && !propKey.startsWith('id:')) {\r\n        result[propKey] = get().getShadowValue(key, [...path, propKey]);\r\n      }\r\n    }\r\n    return result;\r\n  },\r\n\r\n  // ✅ REFACTORED: Correctly preserves `_meta` on updates.\r\n  updateShadowAtPath: (key, path, newValue) => {\r\n    set((state) => {\r\n      const newStore = new Map(state.shadowStateStore);\r\n      const rootKey = newStore.has(`[${key}`) ? `[${key}` : key;\r\n      let root = newStore.get(rootKey);\r\n\r\n      if (!root) return state;\r\n\r\n      const clonedRoot: any = { ...root };\r\n      newStore.set(rootKey, clonedRoot);\r\n\r\n      if (path.length === 0) {\r\n        const newRootStructure = buildShadowNode(newValue);\r\n        // Preserve the top-level metadata\r\n        if (clonedRoot._meta) {\r\n          newRootStructure._meta = {\r\n            ...(newRootStructure._meta || {}),\r\n            ...clonedRoot._meta,\r\n          };\r\n        }\r\n        newStore.set(rootKey, newRootStructure);\r\n      } else {\r\n        let current = clonedRoot;\r\n        const parentPath = path.slice(0, -1);\r\n        for (const segment of parentPath) {\r\n          current[segment] = { ...current[segment] };\r\n          current = current[segment];\r\n        }\r\n\r\n        const lastSegment = path[path.length - 1]!;\r\n        const existingNode = current[lastSegment] || {};\r\n        const newNodeStructure = buildShadowNode(newValue);\r\n\r\n        // This merge is critical: it preserves existing metadata during an update.\r\n        if (existingNode._meta) {\r\n          newNodeStructure._meta = {\r\n            ...(newNodeStructure._meta || {}),\r\n            ...existingNode._meta,\r\n          };\r\n        }\r\n        current[lastSegment] = newNodeStructure;\r\n      }\r\n\r\n      get().notifyPathSubscribers([key, ...path].join('.'), {\r\n        type: 'UPDATE',\r\n        newValue,\r\n      });\r\n      return { shadowStateStore: newStore };\r\n    });\r\n  },\r\n\r\n  // ✅ REFACTORED: Works with `_meta.arrayKeys`.\r\n  insertShadowArrayElement: (key, arrayPath, newItem, index) => {\r\n    const arrayNode = get().getShadowNode(key, arrayPath);\r\n    if (!arrayNode?._meta?.arrayKeys) {\r\n      console.error(\r\n        `Array not found at path: ${[key, ...arrayPath].join('.')}`\r\n      );\r\n      return;\r\n    }\r\n\r\n    const newItemId = `id:${ulid()}`;\r\n    const newItemNode = buildShadowNode(newItem);\r\n\r\n    // Update the `arrayKeys` in the metadata\r\n    const currentKeys = arrayNode._meta.arrayKeys;\r\n    const newKeys = [...currentKeys];\r\n    if (index !== undefined && index >= 0 && index <= newKeys.length) {\r\n      newKeys.splice(index, 0, newItemId);\r\n    } else {\r\n      newKeys.push(newItemId);\r\n    }\r\n\r\n    // Update transform caches if they exist\r\n    if (arrayNode._meta.transformCaches) {\r\n      arrayNode._meta.transformCaches.forEach((cache) => {\r\n        if (cache.validIds && Array.isArray(cache.validIds)) {\r\n          const matchesFilters = cache.transforms.every((transform) =>\r\n            transform.type === 'filter' ? transform.fn(newItem) : true\r\n          );\r\n          if (matchesFilters) {\r\n            cache.validIds = [...cache.validIds];\r\n            if (index !== undefined) {\r\n              cache.validIds.splice(index, 0, newItemId);\r\n            } else {\r\n              cache.validIds.push(newItemId);\r\n            }\r\n          }\r\n        }\r\n      });\r\n    }\r\n\r\n    // Directly set the new item and updated metadata on the node before setting state\r\n    arrayNode[newItemId] = newItemNode;\r\n    arrayNode._meta.arrayKeys = newKeys;\r\n\r\n    get().setShadowMetadata(key, arrayPath, { arrayKeys: newKeys });\r\n\r\n    // Trigger notifications\r\n    const arrayKey = [key, ...arrayPath].join('.');\r\n    get().notifyPathSubscribers(arrayKey, {\r\n      type: 'INSERT',\r\n      path: arrayKey,\r\n      itemKey: `${arrayKey}.${newItemId}`,\r\n      index: index ?? newKeys.length - 1,\r\n    });\r\n  },\r\n\r\n  // ✅ REFACTORED: Works with `_meta.arrayKeys`.\r\n  removeShadowArrayElement: (key, itemPath) => {\r\n    if (itemPath.length === 0) return;\r\n\r\n    const arrayPath = itemPath.slice(0, -1);\r\n    const itemId = itemPath[itemPath.length - 1];\r\n    if (!itemId?.startsWith('id:')) return;\r\n\r\n    const arrayNode = get().getShadowNode(key, arrayPath);\r\n    if (!arrayNode?._meta?.arrayKeys) return;\r\n\r\n    // Filter the item's ID from the `arrayKeys` metadata\r\n    const newKeys = arrayNode._meta.arrayKeys.filter((k) => k !== itemId);\r\n\r\n    // Delete the item's data from the node\r\n    delete arrayNode[itemId];\r\n\r\n    // Persist the modified array node back to the store\r\n    get().setShadowMetadata(key, arrayPath, { arrayKeys: newKeys });\r\n\r\n    const arrayKey = [key, ...arrayPath].join('.');\r\n    get().notifyPathSubscribers(arrayKey, {\r\n      type: 'REMOVE',\r\n      path: arrayKey,\r\n      itemKey: `${arrayKey}.${itemId}`,\r\n    });\r\n  },\r\n\r\n  // The rest of the functions are updated to use the new helpers (`getShadowMetadata`, `setShadowMetadata`)\r\n  // which abstracts away the `_meta` implementation detail.\r\n\r\n  addPathComponent: (stateKey, dependencyPath, fullComponentId) => {\r\n    const metadata = get().getShadowMetadata(stateKey, dependencyPath) || {};\r\n    const newPathComponents = new Set(metadata.pathComponents);\r\n    newPathComponents.add(fullComponentId);\r\n    get().setShadowMetadata(stateKey, dependencyPath, {\r\n      pathComponents: newPathComponents,\r\n    });\r\n\r\n    const rootMeta = get().getShadowMetadata(stateKey, []);\r\n    if (rootMeta?.components) {\r\n      const component = rootMeta.components.get(fullComponentId);\r\n      if (component) {\r\n        const fullPathKey = [stateKey, ...dependencyPath].join('.');\r\n        const newPaths = new Set(component.paths);\r\n        newPaths.add(fullPathKey);\r\n        const newComponentRegistration = { ...component, paths: newPaths };\r\n        const newComponentsMap = new Map(rootMeta.components);\r\n        newComponentsMap.set(fullComponentId, newComponentRegistration);\r\n        get().setShadowMetadata(stateKey, [], { components: newComponentsMap });\r\n      }\r\n    }\r\n  },\r\n\r\n  registerComponent: (stateKey, fullComponentId, registration) => {\r\n    const rootMeta = get().getShadowMetadata(stateKey, []) || {};\r\n    const components = new Map(rootMeta.components);\r\n    components.set(fullComponentId, registration);\r\n    get().setShadowMetadata(stateKey, [], { components });\r\n  },\r\n\r\n  unregisterComponent: (stateKey, fullComponentId) => {\r\n    const rootMeta = get().getShadowMetadata(stateKey, []);\r\n    if (!rootMeta?.components) return;\r\n    const components = new Map(rootMeta.components);\r\n    if (components.delete(fullComponentId)) {\r\n      get().setShadowMetadata(stateKey, [], { components });\r\n    }\r\n  },\r\n\r\n  // ✅ REFACTORED: `markAsDirty` now correctly writes to `_meta.isDirty`.\r\n  markAsDirty: (key, path, options = { bubble: true }) => {\r\n    const setDirtyOnPath = (pathToMark: string[]) => {\r\n      const node = get().getShadowNode(key, pathToMark);\r\n      if (node?._meta?.isDirty) {\r\n        return true; // Already dirty, stop bubbling\r\n      }\r\n      get().setShadowMetadata(key, pathToMark, { isDirty: true });\r\n      return false; // Was not dirty before\r\n    };\r\n\r\n    setDirtyOnPath(path);\r\n\r\n    if (options.bubble) {\r\n      let parentPath = [...path];\r\n      while (parentPath.length > 0) {\r\n        parentPath.pop();\r\n        if (setDirtyOnPath(parentPath)) {\r\n          break; // Stop if parent was already dirty\r\n        }\r\n      }\r\n    }\r\n  },\r\n\r\n  serverStateUpdates: new Map(),\r\n  setServerStateUpdate: (key, serverState) => {\r\n    set((state) => ({\r\n      serverStateUpdates: new Map(state.serverStateUpdates).set(\r\n        key,\r\n        serverState\r\n      ),\r\n    }));\r\n    get().notifyPathSubscribers(key, {\r\n      type: 'SERVER_STATE_UPDATE',\r\n      serverState,\r\n    });\r\n  },\r\n\r\n  pathSubscribers: new Map<string, Set<(newValue: any) => void>>(),\r\n  subscribeToPath: (path, callback) => {\r\n    const subscribers = get().pathSubscribers;\r\n    const subsForPath = subscribers.get(path) || new Set();\r\n    subsForPath.add(callback);\r\n    subscribers.set(path, subsForPath);\r\n\r\n    return () => {\r\n      const currentSubs = get().pathSubscribers.get(path);\r\n      if (currentSubs) {\r\n        currentSubs.delete(callback);\r\n        if (currentSubs.size === 0) {\r\n          get().pathSubscribers.delete(path);\r\n        }\r\n      }\r\n    };\r\n  },\r\n  notifyPathSubscribers: (updatedPath, newValue) => {\r\n    const subscribers = get().pathSubscribers;\r\n    const subs = subscribers.get(updatedPath);\r\n    if (subs) {\r\n      subs.forEach((callback) => callback(newValue));\r\n    }\r\n  },\r\n\r\n  selectedIndicesMap: new Map<string, string>(),\r\n  getSelectedIndex: (arrayKey, validIds) => {\r\n    const itemKey = get().selectedIndicesMap.get(arrayKey);\r\n    if (!itemKey) return -1;\r\n\r\n    const arrayMeta = get().getShadowMetadata(\r\n      arrayKey.split('.')[0]!,\r\n      arrayKey.split('.').slice(1)\r\n    );\r\n    const arrayKeys = validIds || arrayMeta?.arrayKeys;\r\n\r\n    return arrayKeys ? arrayKeys.indexOf(itemKey) : -1;\r\n  },\r\n\r\n  setSelectedIndex: (arrayKey, itemKey) => {\r\n    set((state) => {\r\n      const newMap = new Map(state.selectedIndicesMap);\r\n      const oldSelection = newMap.get(arrayKey);\r\n      if (oldSelection) {\r\n        get().notifyPathSubscribers(oldSelection, { type: 'THIS_UNSELECTED' });\r\n      }\r\n\r\n      if (itemKey === undefined) {\r\n        newMap.delete(arrayKey);\r\n      } else {\r\n        newMap.set(arrayKey, itemKey);\r\n        get().notifyPathSubscribers(itemKey, { type: 'THIS_SELECTED' });\r\n      }\r\n\r\n      get().notifyPathSubscribers(arrayKey, { type: 'GET_SELECTED' });\r\n      return { selectedIndicesMap: newMap };\r\n    });\r\n  },\r\n\r\n  clearSelectedIndex: ({ arrayKey }) => {\r\n    set((state) => {\r\n      const newMap = new Map(state.selectedIndicesMap);\r\n      const actualKey = newMap.get(arrayKey);\r\n      if (actualKey) {\r\n        get().notifyPathSubscribers(actualKey, { type: 'CLEAR_SELECTION' });\r\n      }\r\n      newMap.delete(arrayKey);\r\n      get().notifyPathSubscribers(arrayKey, { type: 'CLEAR_SELECTION' });\r\n      return { selectedIndicesMap: newMap };\r\n    });\r\n  },\r\n\r\n  clearSelectedIndexesForState: (stateKey) => {\r\n    set((state) => {\r\n      const newMap = new Map(state.selectedIndicesMap);\r\n      let changed = false;\r\n      for (const key of newMap.keys()) {\r\n        if (key === stateKey || key.startsWith(stateKey + '.')) {\r\n          newMap.delete(key);\r\n          changed = true;\r\n        }\r\n      }\r\n      return changed ? { selectedIndicesMap: newMap } : {};\r\n    });\r\n  },\r\n\r\n  initialStateOptions: {},\r\n  stateLog: new Map(),\r\n  initialStateGlobal: {},\r\n\r\n  addStateLog: (updates) => {\r\n    if (!updates || updates.length === 0) return;\r\n    set((state) => {\r\n      const newLog = new Map(state.stateLog);\r\n      const logsGroupedByKey = new Map<string, UpdateTypeDetail[]>();\r\n      for (const update of updates) {\r\n        const group = logsGroupedByKey.get(update.stateKey) || [];\r\n        group.push(update);\r\n        logsGroupedByKey.set(update.stateKey, group);\r\n      }\r\n      for (const [key, batchOfUpdates] of logsGroupedByKey.entries()) {\r\n        const newStateLogForKey = new Map(newLog.get(key));\r\n        for (const update of batchOfUpdates) {\r\n          newStateLogForKey.set(JSON.stringify(update.path), { ...update });\r\n        }\r\n        newLog.set(key, newStateLogForKey);\r\n      }\r\n      return { stateLog: newLog };\r\n    });\r\n  },\r\n\r\n  getInitialOptions: (key) => get().initialStateOptions[key],\r\n  setInitialStateOptions: (key, value) => {\r\n    set((prev) => ({\r\n      initialStateOptions: { ...prev.initialStateOptions, [key]: value },\r\n    }));\r\n  },\r\n  updateInitialStateGlobal: (key, newState) => {\r\n    set((prev) => ({\r\n      initialStateGlobal: { ...prev.initialStateGlobal, [key]: newState },\r\n    }));\r\n  },\r\n\r\n  syncInfoStore: new Map<string, SyncInfo>(),\r\n  setSyncInfo: (key, syncInfo) =>\r\n    set((state) => {\r\n      const newMap = new Map(state.syncInfoStore);\r\n      newMap.set(key, syncInfo);\r\n      return { syncInfoStore: newMap };\r\n    }),\r\n  getSyncInfo: (key) => get().syncInfoStore.get(key) || null,\r\n}));\r\n"],"names":["formRefStore","create","set","get","id","ref","state","newRefs","stateKey","allRefs","stateKeyPrefix","filteredRefs","METADATA_KEYS","buildShadowNode","value","arrayNode","idKeys","item","itemId","ulid","objectNode","key","getGlobalStore","path","cacheKey","cacheData","metadata","initialState","newShadowStore","existingRoot","preservedMetadata","components","features","lastServerSync","stateSource","baseServerState","newRoot","storageKey","store","current","segment","newMetadata","newStore","rootKey","root","clonedRoot","nextNode","validArrayIds","log","node","nodeKeys","k","itemKey","result","propKey","newValue","newRootStructure","parentPath","lastSegment","existingNode","newNodeStructure","arrayPath","newItem","index","newItemId","newItemNode","newKeys","cache","transform","arrayKey","itemPath","dependencyPath","fullComponentId","newPathComponents","rootMeta","component","fullPathKey","newPaths","newComponentRegistration","newComponentsMap","registration","options","setDirtyOnPath","pathToMark","serverState","callback","subscribers","subsForPath","currentSubs","updatedPath","subs","validIds","arrayMeta","arrayKeys","newMap","oldSelection","actualKey","changed","updates","newLog","logsGroupedByKey","update","group","batchOfUpdates","newStateLogForKey","prev","newState","syncInfo"],"mappings":"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"}