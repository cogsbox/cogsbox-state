{"version":3,"file":"store.js","sources":["../src/store.ts"],"sourcesContent":["import { create } from 'zustand';\r\nimport { ulid } from 'ulid';\r\nimport type {\r\n  OptionsType,\r\n  ReactivityType,\r\n  SyncInfo,\r\n  UpdateTypeDetail,\r\n} from './CogsState.js';\r\n\r\nimport { startTransition, type ReactNode } from 'react';\r\n\r\nexport type FreshValuesObject = {\r\n  pathsToValues?: string[];\r\n  prevValue?: any;\r\n  newValue?: any;\r\n  timeStamp: number;\r\n};\r\n\r\ntype StateValue = any;\r\n\r\nexport type TrieNode = {\r\n  subscribers: Set<string>;\r\n  children: Map<string, TrieNode>;\r\n};\r\n\r\nexport type FormRefStoreState = {\r\n  formRefs: Map<string, React.RefObject<any>>;\r\n  registerFormRef: (id: string, ref: React.RefObject<any>) => void;\r\n  getFormRef: (id: string) => React.RefObject<any> | undefined;\r\n  removeFormRef: (id: string) => void;\r\n  // New method to get all refs for a stateKey\r\n  getFormRefsByStateKey: (\r\n    stateKey: string\r\n  ) => Map<string, React.RefObject<any>>;\r\n};\r\n\r\nexport const formRefStore = create<FormRefStoreState>((set, get) => ({\r\n  formRefs: new Map(),\r\n\r\n  registerFormRef: (id, ref) =>\r\n    set((state) => {\r\n      const newRefs = new Map(state.formRefs);\r\n      newRefs.set(id, ref);\r\n      return { formRefs: newRefs };\r\n    }),\r\n\r\n  getFormRef: (id) => get().formRefs.get(id),\r\n\r\n  removeFormRef: (id) =>\r\n    set((state) => {\r\n      const newRefs = new Map(state.formRefs);\r\n      newRefs.delete(id);\r\n      return { formRefs: newRefs };\r\n    }),\r\n\r\n  // Get all refs that start with the stateKey prefix\r\n  getFormRefsByStateKey: (stateKey) => {\r\n    const allRefs = get().formRefs;\r\n    const stateKeyPrefix = stateKey + '.';\r\n    const filteredRefs = new Map();\r\n\r\n    allRefs.forEach((ref, id) => {\r\n      if (id.startsWith(stateKeyPrefix) || id === stateKey) {\r\n        filteredRefs.set(id, ref);\r\n      }\r\n    });\r\n\r\n    return filteredRefs;\r\n  },\r\n}));\r\nexport type ComponentsType = {\r\n  components?: Map<\r\n    string,\r\n    {\r\n      forceUpdate: () => void;\r\n      paths: Set<string>;\r\n      deps?: any[];\r\n      prevDeps?: any[];\r\n      depsFunction?: (state: any) => any[] | true;\r\n      reactiveType: ReactivityType[] | ReactivityType;\r\n    }\r\n  >;\r\n};\r\n\r\nexport type ValidationStatus =\r\n  | 'NOT_VALIDATED' // Never run\r\n  | 'VALIDATING' // Currently running\r\n  | 'VALID' // Passed\r\n  | 'INVALID'; // Failed\r\n\r\nexport type ValidationError = {\r\n  source: 'client' | 'sync_engine' | 'api';\r\n  message: string;\r\n  severity: 'warning' | 'error'; // warning = gentle, error = blocking\r\n  code?: string; // Optional error code\r\n};\r\n\r\nexport type ValidationState = {\r\n  status: ValidationStatus;\r\n  errors: ValidationError[];\r\n  lastValidated?: number;\r\n  validatedValue?: any; // Value when last validated\r\n};\r\n\r\n// This is the new definition for the metadata object\r\nexport type ShadowMetadata = {\r\n  id?: string;\r\n  stateSource?: 'default' | 'server' | 'localStorage';\r\n  lastServerSync?: number;\r\n  isDirty?: boolean;\r\n  baseServerState?: any;\r\n  arrayKeys?: string[];\r\n  fields?: Record<string, any>;\r\n  virtualizer?: {\r\n    itemHeight?: number;\r\n    domRef?: HTMLElement | null;\r\n  };\r\n  syncInfo?: { status: string };\r\n  validation?: ValidationState;\r\n  features?: {\r\n    syncEnabled: boolean;\r\n    validationEnabled: boolean;\r\n    localStorageEnabled: boolean;\r\n  };\r\n  lastUpdated?: number;\r\n  signals?: Array<{\r\n    instanceId: string;\r\n    parentId: string;\r\n    position: number;\r\n    effect?: string;\r\n  }>;\r\n  mapWrappers?: Array<{\r\n    instanceId: string;\r\n    path: string[];\r\n    componentId: string;\r\n    meta?: any;\r\n    mapFn: (setter: any, index: number, arraySetter: any) => ReactNode;\r\n    containerRef: HTMLDivElement | null;\r\n    rebuildStateShape: any;\r\n  }>;\r\n  transformCaches?: Map<\r\n    string,\r\n    {\r\n      validIds: string[];\r\n      computedAt: number;\r\n      transforms: Array<{ type: 'filter' | 'sort'; fn: Function }>;\r\n    }\r\n  >;\r\n  pathComponents?: Set<string>;\r\n  streams?: Map<\r\n    string,\r\n    {\r\n      buffer: any[];\r\n      flushTimer: NodeJS.Timeout | null;\r\n    }\r\n  >;\r\n} & ComponentsType;\r\n\r\n// The shadow node itself can have a value and the metadata object.\r\ntype ShadowNode = {\r\n  value?: any;\r\n  _meta?: ShadowMetadata;\r\n  [key: string]: any; // For nested data properties\r\n};\r\n\r\nexport type CogsGlobalState = {\r\n  // NEW shadow store\r\n  shadowStateStore: Map<string, ShadowNode>; // Changed ShadowMetadata to ShadowNode\r\n  setTransformCache: (\r\n    key: string,\r\n    path: string[],\r\n    cacheKey: string,\r\n    cacheData: any\r\n  ) => void;\r\n  // NEW functions\r\n  initializeShadowState: (key: string, initialState: any) => void;\r\n\r\n  // REFACTORED: getShadowNode gets the whole object (data + _meta)\r\n  getShadowNode: (key: string, path: string[]) => ShadowNode | undefined;\r\n  // REFACTORED: getShadowMetadata now returns just the _meta field\r\n  getShadowMetadata: (\r\n    key: string,\r\n    path: string[]\r\n  ) => ShadowMetadata | undefined;\r\n\r\n  setShadowMetadata: (key: string, path: string[], metadata: any) => void;\r\n  getShadowValue: (\r\n    key: string,\r\n    path: string[],\r\n    validArrayIds?: string[],\r\n    log?: boolean\r\n  ) => any;\r\n  updateShadowAtPath: (key: string, path: string[], newValue: any) => void;\r\n  insertManyShadowArrayElements: (\r\n    key: string,\r\n    arrayPath: string[],\r\n    newItems: any[],\r\n    index?: number\r\n  ) => void;\r\n  addItemsToArrayNode: (\r\n    key: string,\r\n    arrayPath: string[],\r\n    newItems: any,\r\n    newKeys: string[]\r\n  ) => void;\r\n  insertShadowArrayElement: (\r\n    key: string,\r\n    arrayPath: string[],\r\n    newItem: any,\r\n    index?: number\r\n  ) => void;\r\n  removeShadowArrayElement: (key: string, itemPath: string[]) => void;\r\n  registerComponent: (\r\n    stateKey: string,\r\n    componentId: string,\r\n    registration: any\r\n  ) => void;\r\n  unregisterComponent: (stateKey: string, componentId: string) => void;\r\n  addPathComponent: (\r\n    stateKey: string,\r\n    dependencyPath: string[],\r\n    fullComponentId: string\r\n  ) => void;\r\n\r\n  markAsDirty: (\r\n    key: string,\r\n    path: string[],\r\n    options: { bubble: boolean }\r\n  ) => void;\r\n  // These method signatures stay the same\r\n\r\n  pathSubscribers: Map<string, Set<(newValue: any) => void>>;\r\n  subscribeToPath: (\r\n    path: string,\r\n    callback: (newValue: any) => void\r\n  ) => () => void;\r\n  notifyPathSubscribers: (updatedPath: string, newValue: any) => void;\r\n\r\n  selectedIndicesMap: Map<string, string>; // stateKey -> (parentPath -> selectedIndex)\r\n  getSelectedIndex: (stateKey: string, validArrayIds?: string[]) => number;\r\n  setSelectedIndex: (key: string, itemKey: string) => void;\r\n  clearSelectedIndex: ({ arrayKey }: { arrayKey: string }) => void;\r\n  clearSelectedIndexesForState: (stateKey: string) => void;\r\n\r\n  // --- Core State and Updaters ---\r\n\r\n  initialStateOptions: { [key: string]: OptionsType };\r\n\r\n  initialStateGlobal: { [key: string]: StateValue };\r\n\r\n  updateInitialStateGlobal: (key: string, newState: StateValue) => void;\r\n\r\n  getInitialOptions: (key: string) => OptionsType | undefined;\r\n  setInitialStateOptions: (key: string, value: OptionsType) => void;\r\n\r\n  serverStateUpdates: Map<\r\n    string,\r\n    {\r\n      data: any;\r\n      status: 'loading' | 'success' | 'error';\r\n      timestamp: number;\r\n    }\r\n  >;\r\n\r\n  setServerStateUpdate: (key: string, serverState: any) => void;\r\n\r\n  stateLog: Map<string, Map<string, UpdateTypeDetail>>;\r\n  syncInfoStore: Map<string, SyncInfo>;\r\n  addStateLog: (updates: UpdateTypeDetail[]) => void;\r\n\r\n  setSyncInfo: (key: string, syncInfo: SyncInfo) => void;\r\n  getSyncInfo: (key: string) => SyncInfo | null;\r\n};\r\n\r\n// ✅ CHANGE 1: `METADATA_KEYS` now only contains `_meta` and `value`.\r\n// The other keys are now properties of the `ShadowMetadata` type.\r\nexport const METADATA_KEYS = new Set(['_meta', 'value']);\r\n\r\n/**\r\n * The single source of truth for converting a regular JS value/object\r\n * into the shadow state tree format with the new `_meta` structure.\r\n */\r\n// ✅ CHANGE 2: `buildShadowNode` now creates the `_meta` field.\r\nexport function buildShadowNode(value: any): ShadowNode {\r\n  // Primitives and null are wrapped.\r\n  if (value === null || typeof value !== 'object') {\r\n    return { value };\r\n  }\r\n\r\n  // Arrays are converted to an object with id-keyed children and metadata in `_meta`.\r\n  if (Array.isArray(value)) {\r\n    const arrayNode: ShadowNode = { _meta: { arrayKeys: [] } }; // Initialize with _meta and arrayKeys\r\n    const idKeys: string[] = [];\r\n\r\n    value.forEach((item) => {\r\n      const itemId = `id:${ulid()}`;\r\n      arrayNode[itemId] = buildShadowNode(item); // Recurse for each item\r\n      idKeys.push(itemId);\r\n    });\r\n\r\n    arrayNode._meta!.arrayKeys = idKeys; // Set the final ordered keys\r\n    return arrayNode;\r\n  }\r\n\r\n  // Plain objects are recursively processed.\r\n  if (value.constructor === Object) {\r\n    const objectNode: ShadowNode = { _meta: {} }; // Initialize with an empty meta object\r\n    for (const key in value) {\r\n      if (Object.prototype.hasOwnProperty.call(value, key)) {\r\n        objectNode[key] = buildShadowNode(value[key]); // Recurse for each property\r\n      }\r\n    }\r\n    return objectNode;\r\n  }\r\n\r\n  // Fallback for other object types (Date, etc.) - treat them as primitives.\r\n  return { value };\r\n}\r\n\r\nexport const getGlobalStore = create<CogsGlobalState>((set, get) => ({\r\n  shadowStateStore: new Map<string, ShadowNode>(),\r\n\r\n  setTransformCache: (\r\n    key: string,\r\n    path: string[],\r\n    cacheKey: string,\r\n    cacheData: any\r\n  ) => {\r\n    // This function now uses setShadowMetadata which correctly places the data.\r\n    const metadata = get().getShadowMetadata(key, path) || {};\r\n    if (!metadata.transformCaches) {\r\n      metadata.transformCaches = new Map();\r\n    }\r\n    metadata.transformCaches.set(cacheKey, cacheData);\r\n    get().setShadowMetadata(key, path, {\r\n      transformCaches: metadata.transformCaches,\r\n    });\r\n  },\r\n\r\n  initializeShadowState: (key: string, initialState: any) => {\r\n    set((state) => {\r\n      const newShadowStore = new Map(state.shadowStateStore);\r\n      const existingRoot =\r\n        newShadowStore.get(key) || newShadowStore.get(`[${key}`);\r\n      let preservedMetadata: Partial<ShadowMetadata> = {};\r\n\r\n      if (existingRoot?._meta) {\r\n        const {\r\n          components,\r\n          features,\r\n          lastServerSync,\r\n          stateSource,\r\n          baseServerState,\r\n        } = existingRoot._meta;\r\n        if (components) preservedMetadata.components = components;\r\n        if (features) preservedMetadata.features = features;\r\n        if (lastServerSync) preservedMetadata.lastServerSync = lastServerSync;\r\n        if (stateSource) preservedMetadata.stateSource = stateSource;\r\n        if (baseServerState)\r\n          preservedMetadata.baseServerState = baseServerState;\r\n      }\r\n\r\n      newShadowStore.delete(key);\r\n      newShadowStore.delete(`[${key}`);\r\n\r\n      const newRoot = buildShadowNode(initialState);\r\n      // Ensure _meta exists before assigning to it\r\n      if (!newRoot._meta) newRoot._meta = {};\r\n      Object.assign(newRoot._meta, preservedMetadata);\r\n\r\n      const storageKey = Array.isArray(initialState) ? `[${key}` : key;\r\n      newShadowStore.set(storageKey, newRoot);\r\n\r\n      return { shadowStateStore: newShadowStore };\r\n    });\r\n  },\r\n\r\n  // ✅ NEW HELPER: Gets the entire node (data and metadata).\r\n  getShadowNode: (key: string, path: string[]): ShadowNode | undefined => {\r\n    const store = get().shadowStateStore;\r\n    let current: any = store.get(key) || store.get(`[${key}`);\r\n\r\n    if (!current) return undefined;\r\n    if (path.length === 0) return current;\r\n\r\n    for (const segment of path) {\r\n      if (typeof current !== 'object' || current === null) return undefined;\r\n      current = current[segment];\r\n      if (current === undefined) return undefined;\r\n    }\r\n    return current;\r\n  },\r\n\r\n  // ✅ REFACTORED: Returns only the `_meta` part of a node.\r\n  getShadowMetadata: (\r\n    key: string,\r\n    path: string[]\r\n  ): ShadowMetadata | undefined => {\r\n    const node = get().getShadowNode(key, path);\r\n    return node?._meta;\r\n  },\r\n\r\n  // ✅ REFACTORED: Sets data within the `_meta` object.\r\n  setShadowMetadata: (\r\n    key: string,\r\n    path: string[],\r\n    newMetadata: Partial<ShadowMetadata>\r\n  ) => {\r\n    set((state) => {\r\n      const newStore = new Map(state.shadowStateStore);\r\n      const rootKey = newStore.has(`[${key}`) ? `[${key}` : key;\r\n      let root = newStore.get(rootKey);\r\n\r\n      if (!root) {\r\n        root = {};\r\n        newStore.set(rootKey, root);\r\n      }\r\n\r\n      const clonedRoot: any = { ...root };\r\n      newStore.set(rootKey, clonedRoot);\r\n\r\n      let current = clonedRoot;\r\n      for (const segment of path) {\r\n        const nextNode = current[segment] || {};\r\n        current[segment] = { ...nextNode }; // Clone for immutability\r\n        current = current[segment];\r\n      }\r\n\r\n      // Ensure _meta object exists and merge the new metadata into it\r\n      current._meta = { ...(current._meta || {}), ...newMetadata };\r\n\r\n      return { shadowStateStore: newStore };\r\n    });\r\n  },\r\n  getShadowValue: (\r\n    key: string,\r\n    path: string[],\r\n    validArrayIds?: string[],\r\n    log?: boolean\r\n  ) => {\r\n    const node = get().getShadowNode(key, path);\r\n\r\n    if (node === null || node === undefined) return undefined;\r\n\r\n    const nodeKeys = Object.keys(node);\r\n\r\n    // ✅ FIX: A node is a primitive wrapper ONLY if its keys are 'value' and/or '_meta'.\r\n    // This prevents objects in your data that happen to have a \"value\" property from being\r\n    // incorrectly treated as wrappers.\r\n    const isPrimitiveWrapper =\r\n      Object.prototype.hasOwnProperty.call(node, 'value') &&\r\n      nodeKeys.every((k) => k === 'value' || k === '_meta');\r\n\r\n    if (isPrimitiveWrapper) {\r\n      return node.value;\r\n    }\r\n\r\n    // Array Check (This part is correct)\r\n    const isArrayNode =\r\n      node._meta &&\r\n      Object.prototype.hasOwnProperty.call(node._meta, 'arrayKeys');\r\n    if (isArrayNode) {\r\n      const keysToIterate =\r\n        validArrayIds !== undefined && validArrayIds.length > 0\r\n          ? validArrayIds\r\n          : node._meta!.arrayKeys!;\r\n\r\n      return keysToIterate.map((itemKey: string) =>\r\n        get().getShadowValue(key, [...path, itemKey])\r\n      );\r\n    }\r\n\r\n    // Object Reconstruction (This part is also correct)\r\n    const result: any = {};\r\n    for (const propKey of nodeKeys) {\r\n      // We correctly ignore metadata and array item keys here.\r\n      if (propKey !== '_meta' && !propKey.startsWith('id:')) {\r\n        result[propKey] = get().getShadowValue(key, [...path, propKey]);\r\n      }\r\n    }\r\n    return result;\r\n  },\r\n\r\n  // ✅ REFACTORED: Correctly preserves `_meta` on updates.\r\n  updateShadowAtPath: (key, path, newValue) => {\r\n    set((state) => {\r\n      const newStore = new Map(state.shadowStateStore);\r\n      const rootKey = newStore.has(`[${key}`) ? `[${key}` : key;\r\n      let root = newStore.get(rootKey);\r\n\r\n      if (!root) return state;\r\n\r\n      const clonedRoot: any = { ...root };\r\n      newStore.set(rootKey, clonedRoot);\r\n\r\n      if (path.length === 0) {\r\n        const newRootStructure = buildShadowNode(newValue);\r\n        // Preserve the top-level metadata\r\n        if (clonedRoot._meta) {\r\n          newRootStructure._meta = {\r\n            ...(newRootStructure._meta || {}),\r\n            ...clonedRoot._meta,\r\n          };\r\n        }\r\n        newStore.set(rootKey, newRootStructure);\r\n      } else {\r\n        let current = clonedRoot;\r\n        const parentPath = path.slice(0, -1);\r\n        for (const segment of parentPath) {\r\n          current[segment] = { ...current[segment] };\r\n          current = current[segment];\r\n        }\r\n\r\n        const lastSegment = path[path.length - 1]!;\r\n        const existingNode = current[lastSegment] || {};\r\n        const newNodeStructure = buildShadowNode(newValue);\r\n\r\n        // This merge is critical: it preserves existing metadata during an update.\r\n        if (existingNode._meta) {\r\n          newNodeStructure._meta = {\r\n            ...(newNodeStructure._meta || {}),\r\n            ...existingNode._meta,\r\n          };\r\n        }\r\n        current[lastSegment] = newNodeStructure;\r\n      }\r\n\r\n      get().notifyPathSubscribers([key, ...path].join('.'), {\r\n        type: 'UPDATE',\r\n        newValue,\r\n      });\r\n      return { shadowStateStore: newStore };\r\n    });\r\n  },\r\n  addItemsToArrayNode: (key, arrayPath, newItems, newKeys) => {\r\n    set((state) => {\r\n      const newStore = new Map(state.shadowStateStore);\r\n      const rootKey = newStore.has(`[${key}`) ? `[${key}` : key;\r\n      let root = newStore.get(rootKey);\r\n      if (!root) {\r\n        console.error('Root not found for state key:', key);\r\n        return state;\r\n      }\r\n\r\n      const clonedRoot = { ...root };\r\n      newStore.set(rootKey, clonedRoot);\r\n\r\n      let current = clonedRoot;\r\n      for (const segment of arrayPath) {\r\n        const nextNode = current[segment] || {};\r\n        // Clone each node in the path for immutability\r\n        current[segment] = { ...nextNode };\r\n        current = current[segment];\r\n      }\r\n\r\n      // Atomically:\r\n      // 1. Add the new item data to the node\r\n      Object.assign(current, newItems);\r\n\r\n      // 2. Update the metadata with the new keys\r\n      current._meta = { ...(current._meta || {}), arrayKeys: newKeys };\r\n\r\n      return { shadowStateStore: newStore };\r\n    });\r\n  },\r\n  // ✅ REFACTORED: Works with `_meta.arrayKeys`.\r\n\r\n  insertShadowArrayElement: (key, arrayPath, newItem, index) => {\r\n    const arrayNode = get().getShadowNode(key, arrayPath);\r\n    if (!arrayNode?._meta?.arrayKeys) {\r\n      console.error(\r\n        `Array not found at path: ${[key, ...arrayPath].join('.')}`\r\n      );\r\n      return;\r\n    }\r\n\r\n    const newItemId = `id:${ulid()}`;\r\n    const itemsToAdd = { [newItemId]: buildShadowNode(newItem) };\r\n\r\n    const currentKeys = arrayNode._meta.arrayKeys;\r\n    const newKeys = [...currentKeys];\r\n    const insertionPoint =\r\n      index !== undefined && index >= 0 && index <= newKeys.length\r\n        ? index\r\n        : newKeys.length;\r\n    newKeys.splice(insertionPoint, 0, newItemId);\r\n\r\n    // Use the same transactional helper for a single item\r\n    get().addItemsToArrayNode(key, arrayPath, itemsToAdd, newKeys);\r\n\r\n    // Trigger notification\r\n    const arrayKey = [key, ...arrayPath].join('.');\r\n    get().notifyPathSubscribers(arrayKey, {\r\n      type: 'INSERT',\r\n      path: arrayKey,\r\n      itemKey: `${arrayKey}.${newItemId}`,\r\n      index: insertionPoint,\r\n    });\r\n  },\r\n  insertManyShadowArrayElements: (key, arrayPath, newItems, index) => {\r\n    if (!newItems || newItems.length === 0) {\r\n      return;\r\n    }\r\n\r\n    const arrayNode = get().getShadowNode(key, arrayPath);\r\n    if (!arrayNode?._meta?.arrayKeys) {\r\n      console.error(\r\n        `Array not found at path: ${[key, ...arrayPath].join('.')}`\r\n      );\r\n      return;\r\n    }\r\n\r\n    const itemsToAdd: Record<string, any> = {};\r\n    const newIds: string[] = [];\r\n\r\n    newItems.forEach((item) => {\r\n      const newItemId = `id:${ulid()}`;\r\n      newIds.push(newItemId);\r\n      itemsToAdd[newItemId] = buildShadowNode(item);\r\n    });\r\n\r\n    const currentKeys = arrayNode._meta.arrayKeys;\r\n    const finalKeys = [...currentKeys];\r\n    const insertionPoint =\r\n      index !== undefined && index >= 0 && index <= finalKeys.length\r\n        ? index\r\n        : finalKeys.length;\r\n    finalKeys.splice(insertionPoint, 0, ...newIds);\r\n\r\n    // Call the new transactional update function\r\n    get().addItemsToArrayNode(key, arrayPath, itemsToAdd, finalKeys);\r\n\r\n    // Notify subscribers with a single, more efficient event\r\n    const arrayKey = [key, ...arrayPath].join('.');\r\n    get().notifyPathSubscribers(arrayKey, {\r\n      type: 'INSERT_MANY',\r\n      path: arrayKey,\r\n      count: newItems.length,\r\n      index: insertionPoint,\r\n    });\r\n  },\r\n  // ✅ REFACTORED: Works with `_meta.arrayKeys`.\r\n  removeShadowArrayElement: (key, itemPath) => {\r\n    if (itemPath.length === 0) return;\r\n\r\n    const arrayPath = itemPath.slice(0, -1);\r\n    const itemId = itemPath[itemPath.length - 1];\r\n    if (!itemId?.startsWith('id:')) return;\r\n\r\n    const arrayNode = get().getShadowNode(key, arrayPath);\r\n    if (!arrayNode?._meta?.arrayKeys) return;\r\n\r\n    // Filter the item's ID from the `arrayKeys` metadata\r\n    const newKeys = arrayNode._meta.arrayKeys.filter((k) => k !== itemId);\r\n\r\n    // Delete the item's data from the node\r\n    delete arrayNode[itemId];\r\n\r\n    // Persist the modified array node back to the store\r\n    get().setShadowMetadata(key, arrayPath, { arrayKeys: newKeys });\r\n\r\n    const arrayKey = [key, ...arrayPath].join('.');\r\n    get().notifyPathSubscribers(arrayKey, {\r\n      type: 'REMOVE',\r\n      path: arrayKey,\r\n      itemKey: `${arrayKey}.${itemId}`,\r\n    });\r\n  },\r\n\r\n  // The rest of the functions are updated to use the new helpers (`getShadowMetadata`, `setShadowMetadata`)\r\n  // which abstracts away the `_meta` implementation detail.\r\n\r\n  addPathComponent: (stateKey, dependencyPath, fullComponentId) => {\r\n    const metadata = get().getShadowMetadata(stateKey, dependencyPath) || {};\r\n    const newPathComponents = new Set(metadata.pathComponents);\r\n    newPathComponents.add(fullComponentId);\r\n    get().setShadowMetadata(stateKey, dependencyPath, {\r\n      pathComponents: newPathComponents,\r\n    });\r\n\r\n    const rootMeta = get().getShadowMetadata(stateKey, []);\r\n    if (rootMeta?.components) {\r\n      const component = rootMeta.components.get(fullComponentId);\r\n      if (component) {\r\n        const fullPathKey = [stateKey, ...dependencyPath].join('.');\r\n        const newPaths = new Set(component.paths);\r\n        newPaths.add(fullPathKey);\r\n        const newComponentRegistration = { ...component, paths: newPaths };\r\n        const newComponentsMap = new Map(rootMeta.components);\r\n        newComponentsMap.set(fullComponentId, newComponentRegistration);\r\n        get().setShadowMetadata(stateKey, [], { components: newComponentsMap });\r\n      }\r\n    }\r\n  },\r\n\r\n  registerComponent: (stateKey, fullComponentId, registration) => {\r\n    const rootMeta = get().getShadowMetadata(stateKey, []) || {};\r\n    const components = new Map(rootMeta.components);\r\n    components.set(fullComponentId, registration);\r\n    get().setShadowMetadata(stateKey, [], { components });\r\n  },\r\n\r\n  unregisterComponent: (stateKey, fullComponentId) => {\r\n    const rootMeta = get().getShadowMetadata(stateKey, []);\r\n    if (!rootMeta?.components) return;\r\n    const components = new Map(rootMeta.components);\r\n    if (components.delete(fullComponentId)) {\r\n      get().setShadowMetadata(stateKey, [], { components });\r\n    }\r\n  },\r\n\r\n  // ✅ REFACTORED: `markAsDirty` now correctly writes to `_meta.isDirty`.\r\n  markAsDirty: (key, path, options = { bubble: true }) => {\r\n    const setDirtyOnPath = (pathToMark: string[]) => {\r\n      const node = get().getShadowNode(key, pathToMark);\r\n      if (node?._meta?.isDirty) {\r\n        return true; // Already dirty, stop bubbling\r\n      }\r\n      get().setShadowMetadata(key, pathToMark, { isDirty: true });\r\n      return false; // Was not dirty before\r\n    };\r\n\r\n    setDirtyOnPath(path);\r\n\r\n    if (options.bubble) {\r\n      let parentPath = [...path];\r\n      while (parentPath.length > 0) {\r\n        parentPath.pop();\r\n        if (setDirtyOnPath(parentPath)) {\r\n          break; // Stop if parent was already dirty\r\n        }\r\n      }\r\n    }\r\n  },\r\n\r\n  serverStateUpdates: new Map(),\r\n  setServerStateUpdate: (key, serverState) => {\r\n    set((state) => ({\r\n      serverStateUpdates: new Map(state.serverStateUpdates).set(\r\n        key,\r\n        serverState\r\n      ),\r\n    }));\r\n    get().notifyPathSubscribers(key, {\r\n      type: 'SERVER_STATE_UPDATE',\r\n      serverState,\r\n    });\r\n  },\r\n\r\n  pathSubscribers: new Map<string, Set<(newValue: any) => void>>(),\r\n  subscribeToPath: (path, callback) => {\r\n    const subscribers = get().pathSubscribers;\r\n    const subsForPath = subscribers.get(path) || new Set();\r\n    subsForPath.add(callback);\r\n    subscribers.set(path, subsForPath);\r\n\r\n    return () => {\r\n      const currentSubs = get().pathSubscribers.get(path);\r\n      if (currentSubs) {\r\n        currentSubs.delete(callback);\r\n        if (currentSubs.size === 0) {\r\n          get().pathSubscribers.delete(path);\r\n        }\r\n      }\r\n    };\r\n  },\r\n  notifyPathSubscribers: (updatedPath, newValue) => {\r\n    const subscribers = get().pathSubscribers;\r\n    const subs = subscribers.get(updatedPath);\r\n    if (subs) {\r\n      subs.forEach((callback) => callback(newValue));\r\n    }\r\n  },\r\n\r\n  selectedIndicesMap: new Map<string, string>(),\r\n  getSelectedIndex: (arrayKey, validIds) => {\r\n    const itemKey = get().selectedIndicesMap.get(arrayKey);\r\n    if (!itemKey) return -1;\r\n\r\n    const arrayMeta = get().getShadowMetadata(\r\n      arrayKey.split('.')[0]!,\r\n      arrayKey.split('.').slice(1)\r\n    );\r\n    const arrayKeys = validIds || arrayMeta?.arrayKeys;\r\n\r\n    return arrayKeys ? arrayKeys.indexOf(itemKey) : -1;\r\n  },\r\n\r\n  setSelectedIndex: (arrayKey, itemKey) => {\r\n    set((state) => {\r\n      const newMap = new Map(state.selectedIndicesMap);\r\n      const oldSelection = newMap.get(arrayKey);\r\n      if (oldSelection) {\r\n        get().notifyPathSubscribers(oldSelection, { type: 'THIS_UNSELECTED' });\r\n      }\r\n\r\n      if (itemKey === undefined) {\r\n        newMap.delete(arrayKey);\r\n      } else {\r\n        newMap.set(arrayKey, itemKey);\r\n        get().notifyPathSubscribers(itemKey, { type: 'THIS_SELECTED' });\r\n      }\r\n\r\n      get().notifyPathSubscribers(arrayKey, { type: 'GET_SELECTED' });\r\n      return { selectedIndicesMap: newMap };\r\n    });\r\n  },\r\n\r\n  clearSelectedIndex: ({ arrayKey }) => {\r\n    set((state) => {\r\n      const newMap = new Map(state.selectedIndicesMap);\r\n      const actualKey = newMap.get(arrayKey);\r\n      if (actualKey) {\r\n        get().notifyPathSubscribers(actualKey, { type: 'CLEAR_SELECTION' });\r\n      }\r\n      newMap.delete(arrayKey);\r\n      get().notifyPathSubscribers(arrayKey, { type: 'CLEAR_SELECTION' });\r\n      return { selectedIndicesMap: newMap };\r\n    });\r\n  },\r\n\r\n  clearSelectedIndexesForState: (stateKey) => {\r\n    set((state) => {\r\n      const newMap = new Map(state.selectedIndicesMap);\r\n      let changed = false;\r\n      for (const key of newMap.keys()) {\r\n        if (key === stateKey || key.startsWith(stateKey + '.')) {\r\n          newMap.delete(key);\r\n          changed = true;\r\n        }\r\n      }\r\n      return changed ? { selectedIndicesMap: newMap } : {};\r\n    });\r\n  },\r\n\r\n  initialStateOptions: {},\r\n  stateLog: new Map(),\r\n  initialStateGlobal: {},\r\n\r\n  addStateLog: (updates) => {\r\n    if (!updates || updates.length === 0) return;\r\n    set((state) => {\r\n      const newLog = new Map(state.stateLog);\r\n      const logsGroupedByKey = new Map<string, UpdateTypeDetail[]>();\r\n      for (const update of updates) {\r\n        const group = logsGroupedByKey.get(update.stateKey) || [];\r\n        group.push(update);\r\n        logsGroupedByKey.set(update.stateKey, group);\r\n      }\r\n      for (const [key, batchOfUpdates] of logsGroupedByKey.entries()) {\r\n        const newStateLogForKey = new Map(newLog.get(key));\r\n        for (const update of batchOfUpdates) {\r\n          newStateLogForKey.set(JSON.stringify(update.path), { ...update });\r\n        }\r\n        newLog.set(key, newStateLogForKey);\r\n      }\r\n      return { stateLog: newLog };\r\n    });\r\n  },\r\n\r\n  getInitialOptions: (key) => get().initialStateOptions[key],\r\n  setInitialStateOptions: (key, value) => {\r\n    set((prev) => ({\r\n      initialStateOptions: { ...prev.initialStateOptions, [key]: value },\r\n    }));\r\n  },\r\n  updateInitialStateGlobal: (key, newState) => {\r\n    set((prev) => ({\r\n      initialStateGlobal: { ...prev.initialStateGlobal, [key]: newState },\r\n    }));\r\n  },\r\n\r\n  syncInfoStore: new Map<string, SyncInfo>(),\r\n  setSyncInfo: (key, syncInfo) =>\r\n    set((state) => {\r\n      const newMap = new Map(state.syncInfoStore);\r\n      newMap.set(key, syncInfo);\r\n      return { syncInfoStore: newMap };\r\n    }),\r\n  getSyncInfo: (key) => get().syncInfoStore.get(key) || null,\r\n}));\r\n"],"names":["formRefStore","create","set","get","id","ref","state","newRefs","stateKey","allRefs","stateKeyPrefix","filteredRefs","METADATA_KEYS","buildShadowNode","value","arrayNode","idKeys","item","itemId","ulid","objectNode","key","getGlobalStore","path","cacheKey","cacheData","metadata","initialState","newShadowStore","existingRoot","preservedMetadata","components","features","lastServerSync","stateSource","baseServerState","newRoot","storageKey","store","current","segment","newMetadata","newStore","rootKey","root","clonedRoot","nextNode","validArrayIds","log","node","nodeKeys","k","itemKey","result","propKey","newValue","newRootStructure","parentPath","lastSegment","existingNode","newNodeStructure","arrayPath","newItems","newKeys","newItem","index","newItemId","itemsToAdd","insertionPoint","arrayKey","newIds","finalKeys","itemPath","dependencyPath","fullComponentId","newPathComponents","rootMeta","component","fullPathKey","newPaths","newComponentRegistration","newComponentsMap","registration","options","setDirtyOnPath","pathToMark","serverState","callback","subscribers","subsForPath","currentSubs","updatedPath","subs","validIds","arrayMeta","arrayKeys","newMap","oldSelection","actualKey","changed","updates","newLog","logsGroupedByKey","update","group","batchOfUpdates","newStateLogForKey","prev","newState","syncInfo"],"mappings":"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"}