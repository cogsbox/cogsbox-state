{"version":3,"file":"store.js","sources":["../src/store.ts"],"sourcesContent":["import { create } from 'zustand';\r\nimport { ulid } from 'ulid';\r\nimport type {\r\n  OptionsType,\r\n  ReactivityType,\r\n  SyncInfo,\r\n  UpdateTypeDetail,\r\n} from './CogsState.js';\r\n\r\nimport { type ReactNode } from 'react';\r\n\r\nexport type FreshValuesObject = {\r\n  pathsToValues?: string[];\r\n  prevValue?: any;\r\n  newValue?: any;\r\n  timeStamp: number;\r\n};\r\n\r\ntype StateValue = any;\r\n\r\nexport type TrieNode = {\r\n  subscribers: Set<string>;\r\n  children: Map<string, TrieNode>;\r\n};\r\n\r\nexport type FormRefStoreState = {\r\n  formRefs: Map<string, React.RefObject<any>>;\r\n  registerFormRef: (id: string, ref: React.RefObject<any>) => void;\r\n  getFormRef: (id: string) => React.RefObject<any> | undefined;\r\n  removeFormRef: (id: string) => void;\r\n  getFormRefsByStateKey: (\r\n    stateKey: string\r\n  ) => Map<string, React.RefObject<any>>;\r\n};\r\n\r\nexport const formRefStore = create<FormRefStoreState>((set, get) => ({\r\n  formRefs: new Map(),\r\n\r\n  registerFormRef: (id, ref) =>\r\n    set((state) => {\r\n      const newRefs = new Map(state.formRefs);\r\n      newRefs.set(id, ref);\r\n      return { formRefs: newRefs };\r\n    }),\r\n\r\n  getFormRef: (id) => get().formRefs.get(id),\r\n\r\n  removeFormRef: (id) =>\r\n    set((state) => {\r\n      const newRefs = new Map(state.formRefs);\r\n      newRefs.delete(id);\r\n      return { formRefs: newRefs };\r\n    }),\r\n\r\n  getFormRefsByStateKey: (stateKey) => {\r\n    const allRefs = get().formRefs;\r\n    const stateKeyPrefix = stateKey + '.';\r\n    const filteredRefs = new Map();\r\n\r\n    allRefs.forEach((ref, id) => {\r\n      if (id.startsWith(stateKeyPrefix) || id === stateKey) {\r\n        filteredRefs.set(id, ref);\r\n      }\r\n    });\r\n\r\n    return filteredRefs;\r\n  },\r\n}));\r\nexport type ComponentsType = {\r\n  components?: Map<\r\n    string,\r\n    {\r\n      forceUpdate: () => void;\r\n      paths: Set<string>;\r\n      deps?: any[];\r\n      prevDeps?: any[];\r\n      depsFunction?: (state: any) => any[] | true;\r\n      reactiveType: ReactivityType[] | ReactivityType;\r\n    }\r\n  >;\r\n};\r\n\r\nexport type ValidationStatus =\r\n  | 'NOT_VALIDATED'\r\n  | 'VALIDATING'\r\n  | 'VALID'\r\n  | 'INVALID';\r\nexport type ValidationSeverity = 'warning' | 'error' | undefined;\r\nexport type ValidationError = {\r\n  source: 'client' | 'sync_engine' | 'api';\r\n  message: string;\r\n  severity: ValidationSeverity;\r\n  code?: string;\r\n};\r\n\r\nexport type ValidationState = {\r\n  status: ValidationStatus;\r\n  errors: ValidationError[];\r\n  lastValidated?: number;\r\n  validatedValue?: any;\r\n};\r\n\r\nexport type ShadowMetadata = {\r\n  id?: string;\r\n  stateSource?: 'default' | 'server' | 'localStorage';\r\n  lastServerSync?: number;\r\n  isDirty?: boolean;\r\n  baseServerState?: any;\r\n  arrayKeys?: string[];\r\n  fields?: Record<string, any>;\r\n  virtualizer?: {\r\n    itemHeight?: number;\r\n    domRef?: HTMLElement | null;\r\n  };\r\n  syncInfo?: { status: string };\r\n  validation?: ValidationState;\r\n  features?: {\r\n    syncEnabled: boolean;\r\n    validationEnabled: boolean;\r\n    localStorageEnabled: boolean;\r\n  };\r\n  lastUpdated?: number;\r\n  signals?: Array<{\r\n    instanceId: string;\r\n    parentId: string;\r\n    position: number;\r\n    effect?: string;\r\n  }>;\r\n  mapWrappers?: Array<{\r\n    instanceId: string;\r\n    path: string[];\r\n    componentId: string;\r\n    meta?: any;\r\n    mapFn: (setter: any, index: number, arraySetter: any) => ReactNode;\r\n    containerRef: HTMLDivElement | null;\r\n    rebuildStateShape: any;\r\n  }>;\r\n  transformCaches?: Map<\r\n    string,\r\n    {\r\n      validIds: string[];\r\n      computedAt: number;\r\n      transforms: Array<{ type: 'filter' | 'sort'; fn: Function }>;\r\n    }\r\n  >;\r\n  pathComponents?: Set<string>;\r\n  streams?: Map<\r\n    string,\r\n    {\r\n      buffer: any[];\r\n      flushTimer: NodeJS.Timeout | null;\r\n    }\r\n  >;\r\n} & ComponentsType;\r\n\r\ntype ShadowNode = {\r\n  value?: any;\r\n  _meta?: ShadowMetadata;\r\n  [key: string]: any;\r\n};\r\n\r\nexport type CogsGlobalState = {\r\n  setTransformCache: (\r\n    key: string,\r\n    path: string[],\r\n    cacheKey: string,\r\n    cacheData: any\r\n  ) => void;\r\n  initializeShadowState: (key: string, initialState: any) => void;\r\n  getShadowNode: (key: string, path: string[]) => ShadowNode | undefined;\r\n  getShadowMetadata: (\r\n    key: string,\r\n    path: string[]\r\n  ) => ShadowMetadata | undefined;\r\n\r\n  setShadowMetadata: (key: string, path: string[], metadata: any) => void;\r\n  getShadowValue: (\r\n    key: string,\r\n    path: string[],\r\n    validArrayIds?: string[],\r\n    log?: boolean\r\n  ) => any;\r\n  updateShadowAtPath: (key: string, path: string[], newValue: any) => void;\r\n  insertManyShadowArrayElements: (\r\n    key: string,\r\n    arrayPath: string[],\r\n    newItems: any[],\r\n    index?: number\r\n  ) => void;\r\n  addItemsToArrayNode: (\r\n    key: string,\r\n    arrayPath: string[],\r\n    newItems: any,\r\n    newKeys: string[]\r\n  ) => void;\r\n  insertShadowArrayElement: (\r\n    key: string,\r\n    arrayPath: string[],\r\n    newItem: any,\r\n    index?: number\r\n  ) => void;\r\n  removeShadowArrayElement: (key: string, itemPath: string[]) => void;\r\n  registerComponent: (\r\n    stateKey: string,\r\n    componentId: string,\r\n    registration: any\r\n  ) => void;\r\n  unregisterComponent: (stateKey: string, componentId: string) => void;\r\n  addPathComponent: (\r\n    stateKey: string,\r\n    dependencyPath: string[],\r\n    fullComponentId: string\r\n  ) => void;\r\n  markAsDirty: (\r\n    key: string,\r\n    path: string[],\r\n    options: { bubble: boolean }\r\n  ) => void;\r\n\r\n  pathSubscribers: Map<string, Set<(newValue: any) => void>>;\r\n  subscribeToPath: (\r\n    path: string,\r\n    callback: (newValue: any) => void\r\n  ) => () => void;\r\n  notifyPathSubscribers: (updatedPath: string, newValue: any) => void;\r\n\r\n  selectedIndicesMap: Map<string, string>; // stateKey -> (parentPath -> selectedIndex)\r\n  getSelectedIndex: (stateKey: string, validArrayIds?: string[]) => number;\r\n  setSelectedIndex: (key: string, itemKey: string) => void;\r\n  clearSelectedIndex: ({ arrayKey }: { arrayKey: string }) => void;\r\n  clearSelectedIndexesForState: (stateKey: string) => void;\r\n\r\n  initialStateOptions: { [key: string]: OptionsType };\r\n  initialStateGlobal: { [key: string]: StateValue };\r\n  updateInitialStateGlobal: (key: string, newState: StateValue) => void;\r\n\r\n  getInitialOptions: (key: string) => OptionsType | undefined;\r\n  setInitialStateOptions: (key: string, value: OptionsType) => void;\r\n\r\n  serverStateUpdates: Map<\r\n    string,\r\n    {\r\n      data: any;\r\n      status: 'loading' | 'success' | 'error';\r\n      timestamp: number;\r\n    }\r\n  >;\r\n\r\n  setServerStateUpdate: (key: string, serverState: any) => void;\r\n\r\n  stateLog: Map<string, Map<string, UpdateTypeDetail>>;\r\n  syncInfoStore: Map<string, SyncInfo>;\r\n  addStateLog: (updates: UpdateTypeDetail[]) => void;\r\n\r\n  setSyncInfo: (key: string, syncInfo: SyncInfo) => void;\r\n  getSyncInfo: (key: string) => SyncInfo | null;\r\n};\r\n\r\nexport function buildShadowNode(value: any): ShadowNode {\r\n  if (value === null || typeof value !== 'object') {\r\n    return { value };\r\n  }\r\n\r\n  if (Array.isArray(value)) {\r\n    const arrayNode: ShadowNode = { _meta: { arrayKeys: [] } };\r\n    const idKeys: string[] = [];\r\n\r\n    value.forEach((item) => {\r\n      const itemId = `id:${ulid()}`;\r\n      arrayNode[itemId] = buildShadowNode(item);\r\n      idKeys.push(itemId);\r\n    });\r\n\r\n    arrayNode._meta!.arrayKeys = idKeys;\r\n    return arrayNode;\r\n  }\r\n\r\n  if (value.constructor === Object) {\r\n    const objectNode: ShadowNode = { _meta: {} };\r\n    for (const key in value) {\r\n      if (Object.prototype.hasOwnProperty.call(value, key)) {\r\n        objectNode[key] = buildShadowNode(value[key]);\r\n      }\r\n    }\r\n    return objectNode;\r\n  }\r\n\r\n  return { value };\r\n}\r\n// store.ts - Replace the shadow store methods with mutable versions\r\n// store.ts - Replace the shadow store methods with mutable versions\r\n\r\n// Module-level mutable store\r\nconst shadowStateStore = new Map<string, ShadowNode>();\r\n\r\nexport const getGlobalStore = create<CogsGlobalState>((set, get) => ({\r\n  // Remove shadowStateStore from Zustand state\r\n\r\n  setTransformCache: (\r\n    key: string,\r\n    path: string[],\r\n    cacheKey: string,\r\n    cacheData: any\r\n  ) => {\r\n    const metadata = get().getShadowMetadata(key, path) || {};\r\n    if (!metadata.transformCaches) {\r\n      metadata.transformCaches = new Map();\r\n    }\r\n    metadata.transformCaches.set(cacheKey, cacheData);\r\n    get().setShadowMetadata(key, path, {\r\n      transformCaches: metadata.transformCaches,\r\n    });\r\n  },\r\n\r\n  initializeShadowState: (key: string, initialState: any) => {\r\n    const existingRoot =\r\n      shadowStateStore.get(key) || shadowStateStore.get(`[${key}`);\r\n    let preservedMetadata: Partial<ShadowMetadata> = {};\r\n\r\n    if (existingRoot?._meta) {\r\n      const {\r\n        components,\r\n        features,\r\n        lastServerSync,\r\n        stateSource,\r\n        baseServerState,\r\n      } = existingRoot._meta;\r\n      if (components) preservedMetadata.components = components;\r\n      if (features) preservedMetadata.features = features;\r\n      if (lastServerSync) preservedMetadata.lastServerSync = lastServerSync;\r\n      if (stateSource) preservedMetadata.stateSource = stateSource;\r\n      if (baseServerState) preservedMetadata.baseServerState = baseServerState;\r\n    }\r\n\r\n    shadowStateStore.delete(key);\r\n    shadowStateStore.delete(`[${key}`);\r\n\r\n    const newRoot = buildShadowNode(initialState);\r\n    if (!newRoot._meta) newRoot._meta = {};\r\n    Object.assign(newRoot._meta, preservedMetadata);\r\n\r\n    const storageKey = Array.isArray(initialState) ? `[${key}` : key;\r\n    shadowStateStore.set(storageKey, newRoot);\r\n  },\r\n\r\n  getShadowNode: (key: string, path: string[]): ShadowNode | undefined => {\r\n    let current: any =\r\n      shadowStateStore.get(key) || shadowStateStore.get(`[${key}`);\r\n    if (!current) return undefined;\r\n    if (path.length === 0) return current;\r\n\r\n    for (const segment of path) {\r\n      if (typeof current !== 'object' || current === null) return undefined;\r\n      current = current[segment];\r\n      if (current === undefined) return undefined;\r\n    }\r\n    return current;\r\n  },\r\n\r\n  getShadowMetadata: (\r\n    key: string,\r\n    path: string[]\r\n  ): ShadowMetadata | undefined => {\r\n    const node = get().getShadowNode(key, path);\r\n    return node?._meta;\r\n  },\r\n\r\n  setShadowMetadata: (\r\n    key: string,\r\n    path: string[],\r\n    newMetadata: Partial<ShadowMetadata>\r\n  ) => {\r\n    // Direct mutation - no cloning!\r\n    const rootKey = shadowStateStore.has(`[${key}`) ? `[${key}` : key;\r\n    let root = shadowStateStore.get(rootKey);\r\n\r\n    if (!root) {\r\n      root = { _meta: newMetadata };\r\n      shadowStateStore.set(rootKey, root);\r\n      return;\r\n    }\r\n\r\n    // Navigate to target without cloning\r\n    let current = root;\r\n    for (const segment of path) {\r\n      if (!current[segment]) {\r\n        current[segment] = {};\r\n      }\r\n      current = current[segment];\r\n    }\r\n\r\n    // Mutate metadata directly\r\n    if (!current._meta) {\r\n      current._meta = {};\r\n    }\r\n    Object.assign(current._meta, newMetadata);\r\n  },\r\n\r\n  getShadowValue: (\r\n    key: string,\r\n    path: string[],\r\n    validArrayIds?: string[],\r\n    log?: boolean\r\n  ) => {\r\n    const node = get().getShadowNode(key, path);\r\n\r\n    if (node === null || node === undefined) return undefined;\r\n\r\n    const nodeKeys = Object.keys(node);\r\n\r\n    const isPrimitiveWrapper =\r\n      Object.prototype.hasOwnProperty.call(node, 'value') &&\r\n      nodeKeys.every((k) => k === 'value' || k === '_meta');\r\n\r\n    if (isPrimitiveWrapper) {\r\n      return node.value;\r\n    }\r\n\r\n    const isArrayNode =\r\n      node._meta &&\r\n      Object.prototype.hasOwnProperty.call(node._meta, 'arrayKeys');\r\n    if (isArrayNode) {\r\n      const keysToIterate =\r\n        validArrayIds !== undefined && validArrayIds.length > 0\r\n          ? validArrayIds\r\n          : node._meta!.arrayKeys!;\r\n\r\n      return keysToIterate.map((itemKey: string) =>\r\n        get().getShadowValue(key, [...path, itemKey])\r\n      );\r\n    }\r\n\r\n    const result: any = {};\r\n    for (const propKey of nodeKeys) {\r\n      if (propKey !== '_meta' && !propKey.startsWith('id:')) {\r\n        result[propKey] = get().getShadowValue(key, [...path, propKey]);\r\n      }\r\n    }\r\n    return result;\r\n  },\r\n\r\n  updateShadowAtPath: (key, path, newValue) => {\r\n    // NO MORE set() wrapper - direct mutation!\r\n    const rootKey = shadowStateStore.has(`[${key}`) ? `[${key}` : key;\r\n    let root = shadowStateStore.get(rootKey);\r\n    if (!root) return;\r\n\r\n    // Navigate to parent without cloning\r\n    let parentNode = root;\r\n    for (let i = 0; i < path.length - 1; i++) {\r\n      if (!parentNode[path[i]!]) {\r\n        parentNode[path[i]!] = {};\r\n      }\r\n      parentNode = parentNode[path[i]!];\r\n    }\r\n\r\n    const targetNode =\r\n      path.length === 0 ? parentNode : parentNode[path[path.length - 1]!];\r\n\r\n    if (!targetNode) {\r\n      parentNode[path[path.length - 1]!] = buildShadowNode(newValue);\r\n      get().notifyPathSubscribers([key, ...path].join('.'), {\r\n        type: 'UPDATE',\r\n        newValue,\r\n      });\r\n      return;\r\n    }\r\n\r\n    function intelligentMerge(nodeToUpdate: any, plainValue: any) {\r\n      if (\r\n        typeof plainValue !== 'object' ||\r\n        plainValue === null ||\r\n        Array.isArray(plainValue)\r\n      ) {\r\n        const oldMeta = nodeToUpdate._meta;\r\n        // Clear existing properties\r\n        for (const key in nodeToUpdate) {\r\n          if (key !== '_meta') delete nodeToUpdate[key];\r\n        }\r\n        const newNode = buildShadowNode(plainValue);\r\n        Object.assign(nodeToUpdate, newNode);\r\n        if (oldMeta) {\r\n          nodeToUpdate._meta = { ...oldMeta, ...(nodeToUpdate._meta || {}) };\r\n        }\r\n        return;\r\n      }\r\n\r\n      const plainValueKeys = new Set(Object.keys(plainValue));\r\n\r\n      for (const propKey of plainValueKeys) {\r\n        const childValue = plainValue[propKey];\r\n        if (nodeToUpdate[propKey]) {\r\n          intelligentMerge(nodeToUpdate[propKey], childValue);\r\n        } else {\r\n          nodeToUpdate[propKey] = buildShadowNode(childValue);\r\n        }\r\n      }\r\n\r\n      for (const nodeKey in nodeToUpdate) {\r\n        if (\r\n          nodeKey === '_meta' ||\r\n          !Object.prototype.hasOwnProperty.call(nodeToUpdate, nodeKey)\r\n        )\r\n          continue;\r\n\r\n        if (!plainValueKeys.has(nodeKey)) {\r\n          delete nodeToUpdate[nodeKey];\r\n        }\r\n      }\r\n    }\r\n\r\n    intelligentMerge(targetNode, newValue);\r\n\r\n    get().notifyPathSubscribers([key, ...path].join('.'), {\r\n      type: 'UPDATE',\r\n      newValue,\r\n    });\r\n  },\r\n\r\n  addItemsToArrayNode: (key, arrayPath, newItems, newKeys) => {\r\n    // Direct mutation - no cloning!\r\n    const rootKey = shadowStateStore.has(`[${key}`) ? `[${key}` : key;\r\n    let root = shadowStateStore.get(rootKey);\r\n    if (!root) {\r\n      console.error('Root not found for state key:', key);\r\n      return;\r\n    }\r\n\r\n    // Navigate without cloning\r\n    let current = root;\r\n    for (const segment of arrayPath) {\r\n      if (!current[segment]) {\r\n        current[segment] = {};\r\n      }\r\n      current = current[segment];\r\n    }\r\n\r\n    // Mutate directly\r\n    Object.assign(current, newItems);\r\n    if (!current._meta) current._meta = {};\r\n    current._meta.arrayKeys = newKeys; // Direct assignment!\r\n  },\r\n\r\n  insertShadowArrayElement: (key, arrayPath, newItem, index) => {\r\n    const arrayNode = get().getShadowNode(key, arrayPath);\r\n    if (!arrayNode?._meta?.arrayKeys) {\r\n      console.error(\r\n        `Array not found at path: ${[key, ...arrayPath].join('.')}`\r\n      );\r\n      return;\r\n    }\r\n\r\n    const newItemId = `id:${ulid()}`;\r\n    const itemsToAdd = { [newItemId]: buildShadowNode(newItem) };\r\n\r\n    // Mutate the array directly\r\n    const currentKeys = arrayNode._meta.arrayKeys;\r\n    const insertionPoint =\r\n      index !== undefined && index >= 0 && index <= currentKeys.length\r\n        ? index\r\n        : currentKeys.length;\r\n\r\n    if (insertionPoint >= currentKeys.length) {\r\n      currentKeys.push(newItemId); // O(1)\r\n    } else {\r\n      currentKeys.splice(insertionPoint, 0, newItemId); // O(n) only for middle\r\n    }\r\n\r\n    // Pass the mutated array\r\n    get().addItemsToArrayNode(key, arrayPath, itemsToAdd, currentKeys);\r\n\r\n    const arrayKey = [key, ...arrayPath].join('.');\r\n    get().notifyPathSubscribers(arrayKey, {\r\n      type: 'INSERT',\r\n      path: arrayKey,\r\n      itemKey: `${arrayKey}.${newItemId}`,\r\n      index: insertionPoint,\r\n    });\r\n  },\r\n\r\n  insertManyShadowArrayElements: (key, arrayPath, newItems, index) => {\r\n    if (!newItems || newItems.length === 0) {\r\n      return;\r\n    }\r\n\r\n    const arrayNode = get().getShadowNode(key, arrayPath);\r\n    if (!arrayNode?._meta?.arrayKeys) {\r\n      console.error(\r\n        `Array not found at path: ${[key, ...arrayPath].join('.')}`\r\n      );\r\n      return;\r\n    }\r\n\r\n    const itemsToAdd: Record<string, any> = {};\r\n    const newIds: string[] = [];\r\n\r\n    newItems.forEach((item) => {\r\n      const newItemId = `id:${ulid()}`;\r\n      newIds.push(newItemId);\r\n      itemsToAdd[newItemId] = buildShadowNode(item);\r\n    });\r\n\r\n    // Mutate directly\r\n    const currentKeys = arrayNode._meta.arrayKeys;\r\n    const insertionPoint =\r\n      index !== undefined && index >= 0 && index <= currentKeys.length\r\n        ? index\r\n        : currentKeys.length;\r\n\r\n    if (insertionPoint >= currentKeys.length) {\r\n      currentKeys.push(...newIds); // O(k) where k is items being added\r\n    } else {\r\n      currentKeys.splice(insertionPoint, 0, ...newIds); // O(n + k)\r\n    }\r\n\r\n    get().addItemsToArrayNode(key, arrayPath, itemsToAdd, currentKeys);\r\n\r\n    const arrayKey = [key, ...arrayPath].join('.');\r\n    get().notifyPathSubscribers(arrayKey, {\r\n      type: 'INSERT_MANY',\r\n      path: arrayKey,\r\n      count: newItems.length,\r\n      index: insertionPoint,\r\n    });\r\n  },\r\n\r\n  removeShadowArrayElement: (key, itemPath) => {\r\n    if (itemPath.length === 0) return;\r\n\r\n    const arrayPath = itemPath.slice(0, -1);\r\n    const itemId = itemPath[itemPath.length - 1];\r\n    if (!itemId?.startsWith('id:')) return;\r\n\r\n    const arrayNode = get().getShadowNode(key, arrayPath);\r\n    if (!arrayNode?._meta?.arrayKeys) return;\r\n\r\n    // Mutate directly\r\n    const currentKeys = arrayNode._meta.arrayKeys;\r\n    const indexToRemove = currentKeys.indexOf(itemId);\r\n\r\n    if (indexToRemove === -1) return;\r\n\r\n    // O(1) for removing from end\r\n    if (indexToRemove === currentKeys.length - 1) {\r\n      currentKeys.pop();\r\n    }\r\n    // O(n) for removing from beginning or middle\r\n    else if (indexToRemove === 0) {\r\n      currentKeys.shift();\r\n    } else {\r\n      currentKeys.splice(indexToRemove, 1);\r\n    }\r\n\r\n    // Delete the actual item\r\n    delete arrayNode[itemId];\r\n\r\n    // No need to update metadata - already mutated!\r\n\r\n    const arrayKey = [key, ...arrayPath].join('.');\r\n    get().notifyPathSubscribers(arrayKey, {\r\n      type: 'REMOVE',\r\n      path: arrayKey,\r\n      itemKey: `${arrayKey}.${itemId}`,\r\n    });\r\n  },\r\n\r\n  registerComponent: (stateKey, fullComponentId, registration) => {\r\n    const rootMeta = get().getShadowMetadata(stateKey, []) || {};\r\n    const components = new Map(rootMeta.components);\r\n    components.set(fullComponentId, registration);\r\n    get().setShadowMetadata(stateKey, [], { components });\r\n  },\r\n\r\n  unregisterComponent: (stateKey, fullComponentId) => {\r\n    const rootMeta = get().getShadowMetadata(stateKey, []);\r\n    if (!rootMeta?.components) return;\r\n    const components = new Map(rootMeta.components);\r\n    if (components.delete(fullComponentId)) {\r\n      get().setShadowMetadata(stateKey, [], { components });\r\n    }\r\n  },\r\n\r\n  addPathComponent: (stateKey, dependencyPath, fullComponentId) => {\r\n    const metadata = get().getShadowMetadata(stateKey, dependencyPath) || {};\r\n    const newPathComponents = new Set(metadata.pathComponents);\r\n    newPathComponents.add(fullComponentId);\r\n    get().setShadowMetadata(stateKey, dependencyPath, {\r\n      pathComponents: newPathComponents,\r\n    });\r\n\r\n    const rootMeta = get().getShadowMetadata(stateKey, []);\r\n    if (rootMeta?.components) {\r\n      const component = rootMeta.components.get(fullComponentId);\r\n      if (component) {\r\n        const fullPathKey = [stateKey, ...dependencyPath].join('.');\r\n        const newPaths = new Set(component.paths);\r\n        newPaths.add(fullPathKey);\r\n        const newComponentRegistration = { ...component, paths: newPaths };\r\n        const newComponentsMap = new Map(rootMeta.components);\r\n        newComponentsMap.set(fullComponentId, newComponentRegistration);\r\n        get().setShadowMetadata(stateKey, [], { components: newComponentsMap });\r\n      }\r\n    }\r\n  },\r\n\r\n  markAsDirty: (key, path, options = { bubble: true }) => {\r\n    const setDirtyOnPath = (pathToMark: string[]) => {\r\n      const node = get().getShadowNode(key, pathToMark);\r\n      if (node?._meta?.isDirty) {\r\n        return true;\r\n      }\r\n      get().setShadowMetadata(key, pathToMark, { isDirty: true });\r\n      return false;\r\n    };\r\n\r\n    setDirtyOnPath(path);\r\n\r\n    if (options.bubble) {\r\n      let parentPath = [...path];\r\n      while (parentPath.length > 0) {\r\n        parentPath.pop();\r\n        if (setDirtyOnPath(parentPath)) {\r\n          break;\r\n        }\r\n      }\r\n    }\r\n  },\r\n\r\n  // Keep these in Zustand as they need React reactivity\r\n  serverStateUpdates: new Map(),\r\n  setServerStateUpdate: (key, serverState) => {\r\n    set((state) => ({\r\n      serverStateUpdates: new Map(state.serverStateUpdates).set(\r\n        key,\r\n        serverState\r\n      ),\r\n    }));\r\n    get().notifyPathSubscribers(key, {\r\n      type: 'SERVER_STATE_UPDATE',\r\n      serverState,\r\n    });\r\n  },\r\n\r\n  pathSubscribers: new Map<string, Set<(newValue: any) => void>>(),\r\n  subscribeToPath: (path, callback) => {\r\n    const subscribers = get().pathSubscribers;\r\n    const subsForPath = subscribers.get(path) || new Set();\r\n    subsForPath.add(callback);\r\n    subscribers.set(path, subsForPath);\r\n\r\n    return () => {\r\n      const currentSubs = get().pathSubscribers.get(path);\r\n      if (currentSubs) {\r\n        currentSubs.delete(callback);\r\n        if (currentSubs.size === 0) {\r\n          get().pathSubscribers.delete(path);\r\n        }\r\n      }\r\n    };\r\n  },\r\n\r\n  notifyPathSubscribers: (updatedPath, newValue) => {\r\n    const subscribers = get().pathSubscribers;\r\n    const subs = subscribers.get(updatedPath);\r\n    if (subs) {\r\n      subs.forEach((callback) => callback(newValue));\r\n    }\r\n  },\r\n\r\n  selectedIndicesMap: new Map<string, string>(),\r\n  getSelectedIndex: (arrayKey, validIds) => {\r\n    const itemKey = get().selectedIndicesMap.get(arrayKey);\r\n    if (!itemKey) return -1;\r\n\r\n    const arrayMeta = get().getShadowMetadata(\r\n      arrayKey.split('.')[0]!,\r\n      arrayKey.split('.').slice(1)\r\n    );\r\n    const arrayKeys = validIds || arrayMeta?.arrayKeys;\r\n\r\n    return arrayKeys ? arrayKeys.indexOf(itemKey) : -1;\r\n  },\r\n\r\n  setSelectedIndex: (arrayKey: string, itemKey: string | undefined) => {\r\n    set((state) => {\r\n      const newMap = new Map(state.selectedIndicesMap);\r\n\r\n      if (itemKey === undefined) {\r\n        newMap.delete(arrayKey);\r\n      } else {\r\n        if (newMap.has(arrayKey)) {\r\n          get().notifyPathSubscribers(newMap.get(arrayKey)!, {\r\n            type: 'THIS_UNSELECTED',\r\n          });\r\n        }\r\n        newMap.set(arrayKey, itemKey);\r\n        get().notifyPathSubscribers(itemKey, { type: 'THIS_SELECTED' });\r\n      }\r\n\r\n      get().notifyPathSubscribers(arrayKey, { type: 'GET_SELECTED' });\r\n\r\n      return {\r\n        ...state,\r\n        selectedIndicesMap: newMap,\r\n      };\r\n    });\r\n  },\r\n\r\n  clearSelectedIndex: ({ arrayKey }: { arrayKey: string }): void => {\r\n    set((state) => {\r\n      const newMap = new Map(state.selectedIndicesMap);\r\n      const actualKey = newMap.get(arrayKey);\r\n      if (actualKey) {\r\n        get().notifyPathSubscribers(actualKey, {\r\n          type: 'CLEAR_SELECTION',\r\n        });\r\n      }\r\n\r\n      newMap.delete(arrayKey);\r\n      get().notifyPathSubscribers(arrayKey, {\r\n        type: 'CLEAR_SELECTION',\r\n      });\r\n      return {\r\n        ...state,\r\n        selectedIndicesMap: newMap,\r\n      };\r\n    });\r\n  },\r\n\r\n  clearSelectedIndexesForState: (stateKey) => {\r\n    set((state) => {\r\n      const newMap = new Map(state.selectedIndicesMap);\r\n      let changed = false;\r\n      for (const key of newMap.keys()) {\r\n        if (key === stateKey || key.startsWith(stateKey + '.')) {\r\n          newMap.delete(key);\r\n          changed = true;\r\n        }\r\n      }\r\n      return changed ? { selectedIndicesMap: newMap } : {};\r\n    });\r\n  },\r\n\r\n  initialStateOptions: {},\r\n  stateLog: new Map(),\r\n  initialStateGlobal: {},\r\n\r\n  addStateLog: (updates) => {\r\n    if (!updates || updates.length === 0) return;\r\n    set((state) => {\r\n      const newLog = new Map(state.stateLog);\r\n      const logsGroupedByKey = new Map<string, UpdateTypeDetail[]>();\r\n      for (const update of updates) {\r\n        const group = logsGroupedByKey.get(update.stateKey) || [];\r\n        group.push(update);\r\n        logsGroupedByKey.set(update.stateKey, group);\r\n      }\r\n      for (const [key, batchOfUpdates] of logsGroupedByKey.entries()) {\r\n        const newStateLogForKey = new Map(newLog.get(key));\r\n        for (const update of batchOfUpdates) {\r\n          newStateLogForKey.set(JSON.stringify(update.path), { ...update });\r\n        }\r\n        newLog.set(key, newStateLogForKey);\r\n      }\r\n      return { stateLog: newLog };\r\n    });\r\n  },\r\n\r\n  getInitialOptions: (key) => get().initialStateOptions[key],\r\n  setInitialStateOptions: (key, value) => {\r\n    set((prev) => ({\r\n      initialStateOptions: { ...prev.initialStateOptions, [key]: value },\r\n    }));\r\n  },\r\n\r\n  updateInitialStateGlobal: (key, newState) => {\r\n    set((prev) => ({\r\n      initialStateGlobal: { ...prev.initialStateGlobal, [key]: newState },\r\n    }));\r\n  },\r\n\r\n  syncInfoStore: new Map<string, SyncInfo>(),\r\n  setSyncInfo: (key, syncInfo) =>\r\n    set((state) => {\r\n      const newMap = new Map(state.syncInfoStore);\r\n      newMap.set(key, syncInfo);\r\n      return { syncInfoStore: newMap };\r\n    }),\r\n  getSyncInfo: (key) => get().syncInfoStore.get(key) || null,\r\n}));\r\n"],"names":["formRefStore","create","set","get","id","ref","state","newRefs","stateKey","allRefs","stateKeyPrefix","filteredRefs","buildShadowNode","value","arrayNode","idKeys","item","itemId","ulid","objectNode","key","shadowStateStore","getGlobalStore","path","cacheKey","cacheData","metadata","initialState","existingRoot","preservedMetadata","components","features","lastServerSync","stateSource","baseServerState","newRoot","storageKey","current","segment","newMetadata","rootKey","root","validArrayIds","log","node","nodeKeys","k","itemKey","result","propKey","newValue","parentNode","i","targetNode","intelligentMerge","nodeToUpdate","plainValue","oldMeta","newNode","plainValueKeys","childValue","nodeKey","arrayPath","newItems","newKeys","newItem","index","newItemId","itemsToAdd","currentKeys","insertionPoint","arrayKey","newIds","itemPath","indexToRemove","fullComponentId","registration","rootMeta","dependencyPath","newPathComponents","component","fullPathKey","newPaths","newComponentRegistration","newComponentsMap","options","setDirtyOnPath","pathToMark","parentPath","serverState","callback","subscribers","subsForPath","currentSubs","updatedPath","subs","validIds","arrayMeta","arrayKeys","newMap","actualKey","changed","updates","newLog","logsGroupedByKey","update","group","batchOfUpdates","newStateLogForKey","prev","newState","syncInfo"],"mappings":"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"}