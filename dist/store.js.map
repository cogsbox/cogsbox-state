{"version":3,"file":"store.js","sources":["../src/store.ts"],"sourcesContent":["import { create } from 'zustand';\r\nimport { ulid } from 'ulid';\r\nimport type {\r\n  OptionsType,\r\n  ReactivityType,\r\n  StateKeys,\r\n  SyncInfo,\r\n  UpdateTypeDetail,\r\n} from './CogsState.js';\r\n\r\nimport { startTransition, type ReactNode } from 'react';\r\n\r\ntype StateUpdater<StateValue> =\r\n  | StateValue\r\n  | ((prevValue: StateValue) => StateValue);\r\n\r\nexport type FreshValuesObject = {\r\n  pathsToValues?: string[];\r\n  prevValue?: any;\r\n  newValue?: any;\r\n  timeStamp: number;\r\n};\r\n\r\ntype SyncLogType = {\r\n  timeStamp: number;\r\n};\r\ntype StateValue = any;\r\n\r\nexport type TrieNode = {\r\n  subscribers: Set<string>;\r\n  children: Map<string, TrieNode>;\r\n};\r\n\r\nexport type FormRefStoreState = {\r\n  formRefs: Map<string, React.RefObject<any>>;\r\n  registerFormRef: (id: string, ref: React.RefObject<any>) => void;\r\n  getFormRef: (id: string) => React.RefObject<any> | undefined;\r\n  removeFormRef: (id: string) => void;\r\n  // New method to get all refs for a stateKey\r\n  getFormRefsByStateKey: (\r\n    stateKey: string\r\n  ) => Map<string, React.RefObject<any>>;\r\n};\r\n\r\nexport const formRefStore = create<FormRefStoreState>((set, get) => ({\r\n  formRefs: new Map(),\r\n\r\n  registerFormRef: (id, ref) =>\r\n    set((state) => {\r\n      const newRefs = new Map(state.formRefs);\r\n      newRefs.set(id, ref);\r\n      return { formRefs: newRefs };\r\n    }),\r\n\r\n  getFormRef: (id) => get().formRefs.get(id),\r\n\r\n  removeFormRef: (id) =>\r\n    set((state) => {\r\n      const newRefs = new Map(state.formRefs);\r\n      newRefs.delete(id);\r\n      return { formRefs: newRefs };\r\n    }),\r\n\r\n  // Get all refs that start with the stateKey prefix\r\n  getFormRefsByStateKey: (stateKey) => {\r\n    const allRefs = get().formRefs;\r\n    const stateKeyPrefix = stateKey + '.';\r\n    const filteredRefs = new Map();\r\n\r\n    allRefs.forEach((ref, id) => {\r\n      if (id.startsWith(stateKeyPrefix) || id === stateKey) {\r\n        filteredRefs.set(id, ref);\r\n      }\r\n    });\r\n\r\n    return filteredRefs;\r\n  },\r\n}));\r\nexport type ComponentsType = {\r\n  components?: Map<\r\n    string,\r\n    {\r\n      forceUpdate: () => void;\r\n      paths: Set<string>;\r\n      deps?: any[];\r\n      prevDeps?: any[];\r\n      depsFunction?: (state: any) => any[] | true;\r\n      reactiveType: ReactivityType[] | ReactivityType;\r\n    }\r\n  >;\r\n};\r\nexport type ShadowMetadata = {\r\n  id?: string;\r\n\r\n  stateSource?: 'default' | 'server' | 'localStorage';\r\n  lastServerSync?: number;\r\n  isDirty?: boolean;\r\n  baseServerState?: any;\r\n\r\n  arrayKeys?: string[];\r\n\r\n  fields?: Record<string, any>;\r\n  virtualizer?: {\r\n    itemHeight?: number;\r\n    domRef?: HTMLElement | null;\r\n  };\r\n  syncInfo?: { status: string };\r\n  validation?: ValidationState;\r\n  lastUpdated?: number;\r\n  value?: any;\r\n  classSignals?: Array<{\r\n    id: string;\r\n    effect: string;\r\n    lastClasses: string;\r\n    deps: any[];\r\n  }>;\r\n  signals?: Array<{\r\n    instanceId: string;\r\n    parentId: string;\r\n    position: number;\r\n    effect?: string;\r\n  }>;\r\n  mapWrappers?: Array<{\r\n    instanceId: string;\r\n    path: string[];\r\n    componentId: string;\r\n    meta?: any;\r\n    mapFn: (\r\n      setter: any,\r\n      index: number,\r\n\r\n      arraySetter: any\r\n    ) => ReactNode;\r\n    containerRef: HTMLDivElement | null;\r\n    rebuildStateShape: any;\r\n  }>;\r\n  transformCaches?: Map<\r\n    string,\r\n    {\r\n      validIds: string[];\r\n      computedAt: number;\r\n      transforms: Array<{ type: 'filter' | 'sort'; fn: Function }>;\r\n    }\r\n  >;\r\n  pathComponents?: Set<string>;\r\n  streams?: Map<\r\n    string,\r\n    {\r\n      buffer: any[];\r\n      flushTimer: NodeJS.Timeout | null;\r\n    }\r\n  >;\r\n} & ComponentsType;\r\n\r\nexport type ValidationStatus =\r\n  | 'PRISTINE' // Untouched, matches initial state.\r\n  | 'DIRTY' // Changed, but no validation run yet.\r\n  | 'VALID_LIVE' // Valid while typing.\r\n  | 'INVALID_LIVE' // Gentle error during typing.\r\n  | 'VALIDATION_FAILED' // Hard error on blur/submit.\r\n  | 'VALID_PENDING_SYNC' // Passed validation, ready for sync.\r\n  | 'SYNCING' // Actively being sent to the server.\r\n  | 'SYNCED' // Server confirmed success.\r\n  | 'SYNC_FAILED'; // Server rejected the data.\r\n\r\nexport type ValidationState = {\r\n  status: ValidationStatus;\r\n  message?: string;\r\n  lastValidated?: number;\r\n  validatedValue?: any;\r\n};\r\nexport type CogsEvent =\r\n  | { type: 'INSERT'; path: string; itemKey: string; index: number }\r\n  | { type: 'REMOVE'; path: string; itemKey: string }\r\n  | { type: 'UPDATE'; path: string; newValue: any }\r\n  | { type: 'ITEMHEIGHT'; itemKey: string; height: number }\r\n  | { type: 'RELOAD'; path: string };\r\nexport type CogsGlobalState = {\r\n  updateQueue: Set<() => void>;\r\n  isFlushScheduled: boolean;\r\n\r\n  flushUpdates: () => void;\r\n\r\n  // --- Shadow State and Subscription System ---\r\n  registerComponent: (\r\n    stateKey: string,\r\n    componentId: string,\r\n    registration: any\r\n  ) => void;\r\n  unregisterComponent: (stateKey: string, componentId: string) => void;\r\n  addPathComponent: (\r\n    stateKey: string,\r\n    dependencyPath: string[],\r\n    fullComponentId: string\r\n  ) => void;\r\n  shadowStateStore: Map<string, ShadowMetadata>;\r\n\r\n  markAsDirty: (\r\n    key: string,\r\n    path: string[],\r\n    options: { bubble: boolean }\r\n  ) => void;\r\n  // These method signatures stay the same\r\n  initializeShadowState: (key: string, initialState: any) => void;\r\n  updateShadowAtPath: (key: string, path: string[], newValue: any) => void;\r\n  insertShadowArrayElement: (\r\n    key: string,\r\n    arrayPath: string[],\r\n    newItem: any\r\n  ) => void;\r\n  removeShadowArrayElement: (key: string, arrayPath: string[]) => void;\r\n  getShadowValue: (\r\n    key: string,\r\n\r\n    validArrayIds?: string[]\r\n  ) => any;\r\n\r\n  getShadowMetadata: (\r\n    key: string,\r\n    path: string[]\r\n  ) => ShadowMetadata | undefined;\r\n  setShadowMetadata: (\r\n    key: string,\r\n    path: string[],\r\n    metadata: Omit<ShadowMetadata, 'id'>\r\n  ) => void;\r\n  setTransformCache: (\r\n    key: string,\r\n    path: string[],\r\n    cacheKey: string,\r\n    cacheData: any\r\n  ) => void;\r\n\r\n  pathSubscribers: Map<string, Set<(newValue: any) => void>>;\r\n  subscribeToPath: (\r\n    path: string,\r\n    callback: (newValue: any) => void\r\n  ) => () => void;\r\n  notifyPathSubscribers: (updatedPath: string, newValue: any) => void;\r\n\r\n  selectedIndicesMap: Map<string, string>; // stateKey -> (parentPath -> selectedIndex)\r\n  getSelectedIndex: (stateKey: string, validArrayIds?: string[]) => number;\r\n  setSelectedIndex: (key: string, itemKey: string) => void;\r\n  clearSelectedIndex: ({ arrayKey }: { arrayKey: string }) => void;\r\n  clearSelectedIndexesForState: (stateKey: string) => void;\r\n\r\n  // --- Core State and Updaters ---\r\n\r\n  initialStateOptions: { [key: string]: OptionsType };\r\n\r\n  initialStateGlobal: { [key: string]: StateValue };\r\n\r\n  updateInitialStateGlobal: (key: string, newState: StateValue) => void;\r\n\r\n  getInitialOptions: (key: string) => OptionsType | undefined;\r\n  setInitialStateOptions: (key: string, value: OptionsType) => void;\r\n\r\n  serverStateUpdates: Map<\r\n    string,\r\n    {\r\n      data: any;\r\n      status: 'loading' | 'success' | 'error';\r\n      timestamp: number;\r\n    }\r\n  >;\r\n\r\n  setServerStateUpdate: (key: string, serverState: any) => void;\r\n\r\n  stateLog: Map<string, Map<string, UpdateTypeDetail>>;\r\n  syncInfoStore: Map<string, SyncInfo>;\r\n  addStateLog: (key: string, update: UpdateTypeDetail) => void;\r\n\r\n  setSyncInfo: (key: string, syncInfo: SyncInfo) => void;\r\n  getSyncInfo: (key: string) => SyncInfo | null;\r\n};\r\nconst isSimpleObject = (value: any): boolean => {\r\n  // Most common cases first\r\n  if (value === null || typeof value !== 'object') return false;\r\n\r\n  // Arrays are simple objects\r\n  if (Array.isArray(value)) return true;\r\n\r\n  // Plain objects second most common\r\n  if (value.constructor === Object) return true;\r\n\r\n  // Everything else is not simple\r\n  return false;\r\n};\r\nexport const getGlobalStore = create<CogsGlobalState>((set, get) => ({\r\n  updateQueue: new Set<() => void>(),\r\n  // A flag to ensure we only schedule the flush once per event-loop tick.\r\n  isFlushScheduled: false,\r\n\r\n  // This function is called by queueMicrotask to execute all queued updates.\r\n  flushUpdates: () => {\r\n    const { updateQueue } = get();\r\n\r\n    if (updateQueue.size > 0) {\r\n      startTransition(() => {\r\n        updateQueue.forEach((updateFn) => updateFn());\r\n      });\r\n    }\r\n\r\n    // Clear the queue and reset the flag for the next event loop tick.\r\n    set({ updateQueue: new Set(), isFlushScheduled: false });\r\n  },\r\n  addPathComponent: (stateKey, dependencyPath, fullComponentId) => {\r\n    set((state) => {\r\n      const newShadowStore = new Map(state.shadowStateStore);\r\n      const dependencyKey = [stateKey, ...dependencyPath].join('.');\r\n\r\n      // --- Part 1: Update the path's own metadata ---\r\n      const pathMeta = newShadowStore.get(dependencyKey) || {};\r\n      // Create a *new* Set to ensure immutability\r\n      const pathComponents = new Set(pathMeta.pathComponents);\r\n      pathComponents.add(fullComponentId);\r\n      // Update the metadata for the specific path\r\n      newShadowStore.set(dependencyKey, { ...pathMeta, pathComponents });\r\n\r\n      // --- Part 2: Update the component's own list of paths ---\r\n      const rootMeta = newShadowStore.get(stateKey) || {};\r\n      const component = rootMeta.components?.get(fullComponentId);\r\n\r\n      // If the component exists, update its `paths` set immutably\r\n      if (component) {\r\n        const newPaths = new Set(component.paths);\r\n        newPaths.add(dependencyKey);\r\n\r\n        const newComponentRegistration = { ...component, paths: newPaths };\r\n        const newComponentsMap = new Map(rootMeta.components);\r\n        newComponentsMap.set(fullComponentId, newComponentRegistration);\r\n\r\n        // Update the root metadata with the new components map\r\n        newShadowStore.set(stateKey, {\r\n          ...rootMeta,\r\n          components: newComponentsMap,\r\n        });\r\n      }\r\n\r\n      // Return the final, updated state\r\n      return { shadowStateStore: newShadowStore };\r\n    });\r\n  },\r\n  registerComponent: (stateKey, fullComponentId, registration) => {\r\n    set((state) => {\r\n      const newShadowStore = new Map(state.shadowStateStore);\r\n      const rootMeta = newShadowStore.get(stateKey) || {};\r\n      const components = new Map(rootMeta.components);\r\n      components.set(fullComponentId, registration);\r\n      newShadowStore.set(stateKey, { ...rootMeta, components });\r\n      return { shadowStateStore: newShadowStore };\r\n    });\r\n  },\r\n\r\n  unregisterComponent: (stateKey, fullComponentId) => {\r\n    set((state) => {\r\n      const newShadowStore = new Map(state.shadowStateStore);\r\n      const rootMeta = newShadowStore.get(stateKey);\r\n      if (!rootMeta?.components) {\r\n        return state; // Return original state, no change needed\r\n      }\r\n\r\n      const components = new Map(rootMeta.components);\r\n      const wasDeleted = components.delete(fullComponentId);\r\n\r\n      // Only update state if something was actually deleted\r\n      if (wasDeleted) {\r\n        newShadowStore.set(stateKey, { ...rootMeta, components });\r\n        return { shadowStateStore: newShadowStore };\r\n      }\r\n\r\n      return state; // Nothing changed\r\n    });\r\n  },\r\n  markAsDirty: (key: string, path: string[], options = { bubble: true }) => {\r\n    const { shadowStateStore } = get();\r\n    const updates = new Map<string, ShadowMetadata>();\r\n\r\n    const setDirty = (currentPath: string[]) => {\r\n      const fullKey = [key, ...currentPath].join('.');\r\n      const meta = shadowStateStore.get(fullKey) || {};\r\n\r\n      // If already dirty, no need to update\r\n      if (meta.isDirty === true) {\r\n        return true; // Return true to indicate parent is dirty\r\n      }\r\n\r\n      updates.set(fullKey, { ...meta, isDirty: true });\r\n      return false; // Not previously dirty\r\n    };\r\n\r\n    // Mark the target path\r\n    setDirty(path);\r\n\r\n    // Bubble up if requested\r\n    if (options.bubble) {\r\n      let parentPath = [...path];\r\n      while (parentPath.length > 0) {\r\n        parentPath.pop();\r\n        const wasDirty = setDirty(parentPath);\r\n        if (wasDirty) {\r\n          break; // Stop bubbling if parent was already dirty\r\n        }\r\n      }\r\n    }\r\n\r\n    // Apply all updates at once\r\n    if (updates.size > 0) {\r\n      set((state) => {\r\n        updates.forEach((meta, key) => {\r\n          state.shadowStateStore.set(key, meta);\r\n        });\r\n        return state;\r\n      });\r\n    }\r\n  },\r\n  serverStateUpdates: new Map(),\r\n  setServerStateUpdate: (key, serverState) => {\r\n    set((state) => {\r\n      const newMap = new Map(state.serverStateUpdates);\r\n      newMap.set(key, serverState);\r\n      return { serverStateUpdates: newMap };\r\n    });\r\n\r\n    // Notify all subscribers for this key\r\n    get().notifyPathSubscribers(key, {\r\n      type: 'SERVER_STATE_UPDATE',\r\n      serverState,\r\n    });\r\n  },\r\n  shadowStateStore: new Map(),\r\n  getShadowNode: (key: string) => get().shadowStateStore.get(key),\r\n  pathSubscribers: new Map<string, Set<(newValue: any) => void>>(),\r\n\r\n  subscribeToPath: (path, callback) => {\r\n    const subscribers = get().pathSubscribers;\r\n    const subsForPath = subscribers.get(path) || new Set();\r\n    subsForPath.add(callback);\r\n    subscribers.set(path, subsForPath);\r\n\r\n    return () => {\r\n      const currentSubs = get().pathSubscribers.get(path);\r\n      if (currentSubs) {\r\n        currentSubs.delete(callback);\r\n        if (currentSubs.size === 0) {\r\n          get().pathSubscribers.delete(path);\r\n        }\r\n      }\r\n    };\r\n  },\r\n\r\n  notifyPathSubscribers: (updatedPath, newValue) => {\r\n    const subscribers = get().pathSubscribers;\r\n    const subs = subscribers.get(updatedPath);\r\n\r\n    if (subs) {\r\n      subs.forEach((callback) => callback(newValue));\r\n    }\r\n  },\r\n\r\n  initializeShadowState: (key: string, initialState: any) => {\r\n    set((state) => {\r\n      // 1. Make a copy of the current store to modify it\r\n      const newShadowStore = new Map(state.shadowStateStore);\r\n      console.log('initializeShadowState');\r\n      // 2. PRESERVE the existing components map before doing anything else\r\n      const existingRootMeta = newShadowStore.get(key);\r\n      const preservedComponents = existingRootMeta?.components;\r\n\r\n      // 3. Wipe all old shadow entries for this state key\r\n      const prefixToDelete = key + '.';\r\n      for (const k of Array.from(newShadowStore.keys())) {\r\n        if (k === key || k.startsWith(prefixToDelete)) {\r\n          newShadowStore.delete(k);\r\n        }\r\n      }\r\n\r\n      // 4. Run your original logic to rebuild the state tree from scratch\r\n      const processValue = (value: any, path: string[]) => {\r\n        const nodeKey = [key, ...path].join('.');\r\n\r\n        if (Array.isArray(value)) {\r\n          const childIds: string[] = [];\r\n          value.forEach(() => {\r\n            const itemId = `id:${ulid()}`;\r\n            childIds.push(nodeKey + '.' + itemId);\r\n          });\r\n          newShadowStore.set(nodeKey, { arrayKeys: childIds });\r\n          value.forEach((item, index) => {\r\n            const itemId = childIds[index]!.split('.').pop();\r\n            processValue(item, [...path!, itemId!]);\r\n          });\r\n        } else if (isSimpleObject(value)) {\r\n          const fields = Object.fromEntries(\r\n            Object.keys(value).map((k) => [k, nodeKey + '.' + k])\r\n          );\r\n          newShadowStore.set(nodeKey, { fields });\r\n          Object.keys(value).forEach((k) => {\r\n            processValue(value[k], [...path, k]);\r\n          });\r\n        } else {\r\n          newShadowStore.set(nodeKey, { value });\r\n        }\r\n      };\r\n      processValue(initialState, []);\r\n\r\n      // 5. RESTORE the preserved components map onto the new root metadata\r\n      if (preservedComponents) {\r\n        const newRootMeta = newShadowStore.get(key) || {};\r\n        newShadowStore.set(key, {\r\n          ...newRootMeta,\r\n          components: preservedComponents,\r\n        });\r\n      }\r\n\r\n      // 6. Return the completely updated state\r\n      return { shadowStateStore: newShadowStore };\r\n    });\r\n  },\r\n\r\n  getShadowValue: (fullKey: string, validArrayIds?: string[]) => {\r\n    const memo = new Map<string, any>();\r\n    const reconstruct = (keyToBuild: string, ids?: string[]): any => {\r\n      if (memo.has(keyToBuild)) {\r\n        return memo.get(keyToBuild);\r\n      }\r\n\r\n      const shadowMeta = get().shadowStateStore.get(keyToBuild);\r\n      if (!shadowMeta) {\r\n        return undefined;\r\n      }\r\n\r\n      if (shadowMeta.value !== undefined) {\r\n        return shadowMeta.value;\r\n      }\r\n\r\n      let result: any; // The value we are about to build.\r\n\r\n      if (shadowMeta.arrayKeys) {\r\n        const keys = ids ?? shadowMeta.arrayKeys;\r\n        result = [];\r\n        memo.set(keyToBuild, result);\r\n        keys.forEach((itemKey) => {\r\n          result.push(reconstruct(itemKey));\r\n        });\r\n      } else if (shadowMeta.fields) {\r\n        result = {};\r\n        memo.set(keyToBuild, result);\r\n        Object.entries(shadowMeta.fields).forEach(([key, fieldPath]) => {\r\n          result[key] = reconstruct(fieldPath as string);\r\n        });\r\n      } else {\r\n        result = undefined;\r\n      }\r\n\r\n      // Return the final, fully populated result.\r\n      return result;\r\n    };\r\n\r\n    // Start the process by calling the inner function on the root key.\r\n    return reconstruct(fullKey, validArrayIds);\r\n  },\r\n  getShadowMetadata: (key: string, path: string[]) => {\r\n    const fullKey = [key, ...path].join('.');\r\n\r\n    return get().shadowStateStore.get(fullKey);\r\n  },\r\n\r\n  setShadowMetadata: (key, path, metadata) => {\r\n    const fullKey = [key, ...path].join('.');\r\n    const existingMeta = get().shadowStateStore.get(fullKey);\r\n\r\n    // --- THIS IS THE TRAP ---\r\n    // If the existing metadata HAS a components map, but the NEW metadata DOES NOT,\r\n    // it means we are about to wipe it out. This is the bug.\r\n    if (existingMeta?.components && !metadata.components) {\r\n      console.group(\r\n        '%cðŸš¨ RACE CONDITION DETECTED! ðŸš¨',\r\n        'color: red; font-size: 18px; font-weight: bold;'\r\n      );\r\n      console.error(\r\n        `An overwrite is about to happen on stateKey: \"${key}\" at path: [${path.join(', ')}]`\r\n      );\r\n      console.log(\r\n        'The EXISTING metadata had a components map:',\r\n        existingMeta.components\r\n      );\r\n      console.log(\r\n        'The NEW metadata is trying to save WITHOUT a components map:',\r\n        metadata\r\n      );\r\n      console.log(\r\n        '%cStack trace to the function that caused this overwrite:',\r\n        'font-weight: bold;'\r\n      );\r\n      console.trace(); // This prints the call stack, leading you to the bad code.\r\n      console.groupEnd();\r\n    }\r\n    // --- END OF TRAP ---\r\n\r\n    const newShadowStore = new Map(get().shadowStateStore);\r\n    const finalMeta = { ...(existingMeta || {}), ...metadata };\r\n    newShadowStore.set(fullKey, finalMeta);\r\n    set({ shadowStateStore: newShadowStore });\r\n  },\r\n  setTransformCache: (\r\n    key: string,\r\n    path: string[],\r\n    cacheKey: string,\r\n    cacheData: any\r\n  ) => {\r\n    const fullKey = [key, ...path].join('.');\r\n    const newShadowStore = new Map(get().shadowStateStore);\r\n    const existing = newShadowStore.get(fullKey) || {};\r\n\r\n    // Initialize transformCaches if it doesn't exist\r\n    if (!existing.transformCaches) {\r\n      existing.transformCaches = new Map();\r\n    }\r\n\r\n    // Update just the specific cache entry\r\n    existing.transformCaches.set(cacheKey, cacheData);\r\n\r\n    // Update shadow store WITHOUT notifying path subscribers\r\n    newShadowStore.set(fullKey, existing);\r\n    set({ shadowStateStore: newShadowStore });\r\n\r\n    // Don't call notifyPathSubscribers here - cache updates shouldn't trigger renders\r\n  },\r\n  insertShadowArrayElement: (\r\n    key: string,\r\n    arrayPath: string[],\r\n    newItem: any\r\n  ) => {\r\n    const newShadowStore = new Map(get().shadowStateStore);\r\n    const arrayKey = [key, ...arrayPath].join('.');\r\n    const parentMeta = newShadowStore.get(arrayKey);\r\n\r\n    if (!parentMeta || !parentMeta.arrayKeys) return;\r\n\r\n    const newItemId = `id:${ulid()}`;\r\n    const fullItemKey = arrayKey + '.' + newItemId;\r\n\r\n    // Just add to the end (or at a specific index if provided)\r\n    const newArrayKeys = [...parentMeta.arrayKeys];\r\n    newArrayKeys.push(fullItemKey); // Or use splice if you have an index\r\n    newShadowStore.set(arrayKey, { ...parentMeta, arrayKeys: newArrayKeys });\r\n\r\n    // Process the new item - but use the correct logic\r\n    const processNewItem = (value: any, path: string[]) => {\r\n      const nodeKey = [key, ...path].join('.');\r\n\r\n      if (Array.isArray(value)) {\r\n        // Handle arrays...\r\n      } else if (typeof value === 'object' && value !== null) {\r\n        // Create fields mapping\r\n        const fields = Object.fromEntries(\r\n          Object.keys(value).map((k) => [k, nodeKey + '.' + k])\r\n        );\r\n        newShadowStore.set(nodeKey, { fields });\r\n\r\n        // Process each field\r\n        Object.entries(value).forEach(([k, v]) => {\r\n          processNewItem(v, [...path, k]);\r\n        });\r\n      } else {\r\n        // Primitive value\r\n        newShadowStore.set(nodeKey, { value });\r\n      }\r\n    };\r\n\r\n    processNewItem(newItem, [...arrayPath, newItemId]);\r\n    set({ shadowStateStore: newShadowStore });\r\n\r\n    get().notifyPathSubscribers(arrayKey, {\r\n      type: 'INSERT',\r\n      path: arrayKey,\r\n      itemKey: fullItemKey,\r\n    });\r\n  },\r\n  removeShadowArrayElement: (key: string, itemPath: string[]) => {\r\n    const newShadowStore = new Map(get().shadowStateStore);\r\n\r\n    // Get the full item key (e.g., \"stateKey.products.id:xxx\")\r\n    const itemKey = [key, ...itemPath].join('.');\r\n\r\n    // Extract parent path and item ID\r\n    const parentPath = itemPath.slice(0, -1);\r\n    const parentKey = [key, ...parentPath].join('.');\r\n\r\n    // Get parent metadata\r\n    const parentMeta = newShadowStore.get(parentKey);\r\n\r\n    if (parentMeta && parentMeta.arrayKeys) {\r\n      // Find the index of the item to remove\r\n      const indexToRemove = parentMeta.arrayKeys.findIndex(\r\n        (arrayItemKey) => arrayItemKey === itemKey\r\n      );\r\n\r\n      if (indexToRemove !== -1) {\r\n        // Create new array keys with the item removed\r\n        const newArrayKeys = parentMeta.arrayKeys.filter(\r\n          (arrayItemKey) => arrayItemKey !== itemKey\r\n        );\r\n\r\n        // Update parent with new array keys\r\n        newShadowStore.set(parentKey, {\r\n          ...parentMeta,\r\n          arrayKeys: newArrayKeys,\r\n        });\r\n\r\n        // Delete all data associated with the removed item\r\n        const prefixToDelete = itemKey + '.';\r\n        for (const k of Array.from(newShadowStore.keys())) {\r\n          if (k === itemKey || k.startsWith(prefixToDelete)) {\r\n            newShadowStore.delete(k);\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    set({ shadowStateStore: newShadowStore });\r\n\r\n    get().notifyPathSubscribers(parentKey, {\r\n      type: 'REMOVE',\r\n      path: parentKey,\r\n      itemKey: itemKey, // The exact ID of the removed item\r\n    });\r\n  },\r\n\r\n  updateShadowAtPath: (key, path, newValue) => {\r\n    const fullKey = [key, ...path].join('.');\r\n\r\n    // Optimization: Only update if value actually changed\r\n    const existingMeta = get().shadowStateStore.get(fullKey);\r\n    if (existingMeta?.value === newValue && !isSimpleObject(newValue)) {\r\n      return; // Skip update for unchanged primitives\r\n    }\r\n\r\n    // CHANGE: Don't clone the entire Map, just update in place\r\n    set((state) => {\r\n      const store = state.shadowStateStore;\r\n\r\n      if (!isSimpleObject(newValue)) {\r\n        const meta = store.get(fullKey) || {};\r\n        store.set(fullKey, { ...meta, value: newValue });\r\n      } else {\r\n        // Handle objects by iterating\r\n        const processObject = (currentPath: string[], objectToSet: any) => {\r\n          const currentFullKey = [key, ...currentPath].join('.');\r\n          const meta = store.get(currentFullKey);\r\n\r\n          if (meta && meta.fields) {\r\n            for (const fieldKey in objectToSet) {\r\n              if (Object.prototype.hasOwnProperty.call(objectToSet, fieldKey)) {\r\n                const childValue = objectToSet[fieldKey];\r\n                const childFullPath = meta.fields[fieldKey];\r\n\r\n                if (childFullPath) {\r\n                  if (isSimpleObject(childValue)) {\r\n                    processObject(\r\n                      childFullPath.split('.').slice(1),\r\n                      childValue\r\n                    );\r\n                  } else {\r\n                    const existingChildMeta = store.get(childFullPath) || {};\r\n                    store.set(childFullPath, {\r\n                      ...existingChildMeta,\r\n                      value: childValue,\r\n                    });\r\n                  }\r\n                }\r\n              }\r\n            }\r\n          }\r\n        };\r\n\r\n        processObject(path, newValue);\r\n      }\r\n\r\n      // Only notify after all changes are made\r\n      get().notifyPathSubscribers(fullKey, { type: 'UPDATE', newValue });\r\n\r\n      // Return same reference if using Zustand's immer middleware\r\n      return state;\r\n    });\r\n  },\r\n  selectedIndicesMap: new Map<string, string>(),\r\n  getSelectedIndex: (arrayKey: string, validIds?: string[]): number => {\r\n    const itemKey = get().selectedIndicesMap.get(arrayKey);\r\n\r\n    if (!itemKey) return -1;\r\n\r\n    // Use validIds if provided (for filtered views), otherwise use all arrayKeys\r\n    const arrayKeys =\r\n      validIds ||\r\n      getGlobalStore.getState().getShadowMetadata(arrayKey, [])?.arrayKeys;\r\n\r\n    if (!arrayKeys) return -1;\r\n\r\n    return arrayKeys.indexOf(itemKey);\r\n  },\r\n\r\n  setSelectedIndex: (arrayKey: string, itemKey: string | undefined) => {\r\n    set((state) => {\r\n      const newMap = state.selectedIndicesMap;\r\n\r\n      if (itemKey === undefined) {\r\n        newMap.delete(arrayKey);\r\n      } else {\r\n        if (newMap.has(arrayKey)) {\r\n          get().notifyPathSubscribers(newMap.get(arrayKey)!, {\r\n            type: 'THIS_UNSELECTED',\r\n          });\r\n        }\r\n        newMap.set(arrayKey, itemKey);\r\n\r\n        get().notifyPathSubscribers(itemKey, {\r\n          type: 'THIS_SELECTED',\r\n        });\r\n      }\r\n      get().notifyPathSubscribers(arrayKey, {\r\n        type: 'GET_SELECTED',\r\n      });\r\n      return {\r\n        ...state,\r\n        selectedIndicesMap: newMap,\r\n      };\r\n    });\r\n  },\r\n  clearSelectedIndex: ({ arrayKey }: { arrayKey: string }): void => {\r\n    set((state) => {\r\n      const newMap = state.selectedIndicesMap;\r\n      const acutalKey = newMap.get(arrayKey);\r\n      if (acutalKey) {\r\n        get().notifyPathSubscribers(acutalKey, {\r\n          type: 'CLEAR_SELECTION',\r\n        });\r\n      }\r\n\r\n      newMap.delete(arrayKey);\r\n      get().notifyPathSubscribers(arrayKey, {\r\n        type: 'CLEAR_SELECTION',\r\n      });\r\n      return {\r\n        ...state,\r\n        selectedIndicesMap: newMap,\r\n      };\r\n    });\r\n  },\r\n  clearSelectedIndexesForState: (stateKey: string) => {\r\n    set((state) => {\r\n      const newOuterMap = new Map(state.selectedIndicesMap);\r\n      const changed = newOuterMap.delete(stateKey);\r\n      if (changed) {\r\n        return { selectedIndicesMap: newOuterMap };\r\n      } else {\r\n        return {};\r\n      }\r\n    });\r\n  },\r\n\r\n  initialStateOptions: {},\r\n\r\n  stateTimeline: {},\r\n  cogsStateStore: {},\r\n  stateLog: new Map(),\r\n\r\n  initialStateGlobal: {},\r\n\r\n  validationErrors: new Map(),\r\n  addStateLog: (key, update) => {\r\n    set((state) => {\r\n      const newLog = new Map(state.stateLog);\r\n      const stateLogForKey = new Map(newLog.get(key));\r\n      const uniquePathKey = JSON.stringify(update.path);\r\n\r\n      const existing = stateLogForKey.get(uniquePathKey);\r\n      if (existing) {\r\n        // If an update for this path already exists, just modify it. (Fast)\r\n        existing.newValue = update.newValue;\r\n        existing.timeStamp = update.timeStamp;\r\n      } else {\r\n        // Otherwise, add the new update. (Fast)\r\n        stateLogForKey.set(uniquePathKey, { ...update });\r\n      }\r\n\r\n      newLog.set(key, stateLogForKey);\r\n      return { stateLog: newLog };\r\n    });\r\n  },\r\n\r\n  getInitialOptions: (key) => {\r\n    return get().initialStateOptions[key];\r\n  },\r\n\r\n  setInitialStateOptions: (key, value) => {\r\n    set((prev) => ({\r\n      initialStateOptions: {\r\n        ...prev.initialStateOptions,\r\n        [key]: value,\r\n      },\r\n    }));\r\n  },\r\n  updateInitialStateGlobal: (key, newState) => {\r\n    set((prev) => ({\r\n      initialStateGlobal: {\r\n        ...prev.initialStateGlobal,\r\n        [key]: newState,\r\n      },\r\n    }));\r\n  },\r\n\r\n  syncInfoStore: new Map<string, SyncInfo>(),\r\n  setSyncInfo: (key: string, syncInfo: SyncInfo) =>\r\n    set((state) => {\r\n      const newMap = new Map(state.syncInfoStore);\r\n      newMap.set(key, syncInfo);\r\n      return { ...state, syncInfoStore: newMap };\r\n    }),\r\n  getSyncInfo: (key: string) => get().syncInfoStore.get(key) || null,\r\n}));\r\n"],"names":["formRefStore","create","set","get","id","ref","state","newRefs","stateKey","allRefs","stateKeyPrefix","filteredRefs","isSimpleObject","value","getGlobalStore","updateQueue","startTransition","updateFn","dependencyPath","fullComponentId","newShadowStore","dependencyKey","pathMeta","pathComponents","rootMeta","component","newPaths","newComponentRegistration","newComponentsMap","registration","components","key","path","options","shadowStateStore","updates","setDirty","currentPath","fullKey","meta","parentPath","serverState","newMap","callback","subscribers","subsForPath","currentSubs","updatedPath","newValue","subs","initialState","preservedComponents","prefixToDelete","k","processValue","nodeKey","childIds","itemId","ulid","item","index","fields","newRootMeta","validArrayIds","memo","reconstruct","keyToBuild","ids","shadowMeta","result","keys","itemKey","fieldPath","metadata","existingMeta","finalMeta","cacheKey","cacheData","existing","arrayPath","newItem","arrayKey","parentMeta","newItemId","fullItemKey","newArrayKeys","processNewItem","v","itemPath","parentKey","arrayItemKey","store","processObject","objectToSet","currentFullKey","fieldKey","childValue","childFullPath","existingChildMeta","validIds","arrayKeys","acutalKey","newOuterMap","update","newLog","stateLogForKey","uniquePathKey","prev","newState","syncInfo"],"mappings":";;;AA4CO,MAAMA,IAAeC,EAA0B,CAACC,GAAKC,OAAS;AAAA,EACnE,8BAAc,IAAA;AAAA,EAEd,iBAAiB,CAACC,GAAIC,MACpBH,EAAI,CAACI,MAAU;AACb,UAAMC,IAAU,IAAI,IAAID,EAAM,QAAQ;AACtC,WAAAC,EAAQ,IAAIH,GAAIC,CAAG,GACZ,EAAE,UAAUE,EAAA;AAAA,EACrB,CAAC;AAAA,EAEH,YAAY,CAACH,MAAOD,IAAM,SAAS,IAAIC,CAAE;AAAA,EAEzC,eAAe,CAACA,MACdF,EAAI,CAACI,MAAU;AACb,UAAMC,IAAU,IAAI,IAAID,EAAM,QAAQ;AACtC,WAAAC,EAAQ,OAAOH,CAAE,GACV,EAAE,UAAUG,EAAA;AAAA,EACrB,CAAC;AAAA;AAAA,EAGH,uBAAuB,CAACC,MAAa;AACnC,UAAMC,IAAUN,IAAM,UAChBO,IAAiBF,IAAW,KAC5BG,wBAAmB,IAAA;AAEzB,WAAAF,EAAQ,QAAQ,CAACJ,GAAKD,MAAO;AAC3B,OAAIA,EAAG,WAAWM,CAAc,KAAKN,MAAOI,MAC1CG,EAAa,IAAIP,GAAIC,CAAG;AAAA,IAE5B,CAAC,GAEMM;AAAA,EACT;AACF,EAAE,GAsMIC,IAAiB,CAACC,MAElBA,MAAU,QAAQ,OAAOA,KAAU,WAAiB,KAGpD,SAAM,QAAQA,CAAK,KAGnBA,EAAM,gBAAgB,SAKfC,IAAiBb,EAAwB,CAACC,GAAKC,OAAS;AAAA,EACnE,iCAAiB,IAAA;AAAA;AAAA,EAEjB,kBAAkB;AAAA;AAAA,EAGlB,cAAc,MAAM;AAClB,UAAM,EAAE,aAAAY,EAAA,IAAgBZ,EAAA;AAExB,IAAIY,EAAY,OAAO,KACrBC,EAAgB,MAAM;AACpB,MAAAD,EAAY,QAAQ,CAACE,MAAaA,EAAA,CAAU;AAAA,IAC9C,CAAC,GAIHf,EAAI,EAAE,aAAa,oBAAI,OAAO,kBAAkB,IAAO;AAAA,EACzD;AAAA,EACA,kBAAkB,CAACM,GAAUU,GAAgBC,MAAoB;AAC/D,IAAAjB,EAAI,CAACI,MAAU;AACb,YAAMc,IAAiB,IAAI,IAAId,EAAM,gBAAgB,GAC/Ce,IAAgB,CAACb,GAAU,GAAGU,CAAc,EAAE,KAAK,GAAG,GAGtDI,IAAWF,EAAe,IAAIC,CAAa,KAAK,CAAA,GAEhDE,IAAiB,IAAI,IAAID,EAAS,cAAc;AACtD,MAAAC,EAAe,IAAIJ,CAAe,GAElCC,EAAe,IAAIC,GAAe,EAAE,GAAGC,GAAU,gBAAAC,GAAgB;AAGjE,YAAMC,IAAWJ,EAAe,IAAIZ,CAAQ,KAAK,CAAA,GAC3CiB,IAAYD,EAAS,YAAY,IAAIL,CAAe;AAG1D,UAAIM,GAAW;AACb,cAAMC,IAAW,IAAI,IAAID,EAAU,KAAK;AACxC,QAAAC,EAAS,IAAIL,CAAa;AAE1B,cAAMM,IAA2B,EAAE,GAAGF,GAAW,OAAOC,EAAA,GAClDE,IAAmB,IAAI,IAAIJ,EAAS,UAAU;AACpD,QAAAI,EAAiB,IAAIT,GAAiBQ,CAAwB,GAG9DP,EAAe,IAAIZ,GAAU;AAAA,UAC3B,GAAGgB;AAAA,UACH,YAAYI;AAAA,QAAA,CACb;AAAA,MACH;AAGA,aAAO,EAAE,kBAAkBR,EAAA;AAAA,IAC7B,CAAC;AAAA,EACH;AAAA,EACA,mBAAmB,CAACZ,GAAUW,GAAiBU,MAAiB;AAC9D,IAAA3B,EAAI,CAACI,MAAU;AACb,YAAMc,IAAiB,IAAI,IAAId,EAAM,gBAAgB,GAC/CkB,IAAWJ,EAAe,IAAIZ,CAAQ,KAAK,CAAA,GAC3CsB,IAAa,IAAI,IAAIN,EAAS,UAAU;AAC9C,aAAAM,EAAW,IAAIX,GAAiBU,CAAY,GAC5CT,EAAe,IAAIZ,GAAU,EAAE,GAAGgB,GAAU,YAAAM,GAAY,GACjD,EAAE,kBAAkBV,EAAA;AAAA,IAC7B,CAAC;AAAA,EACH;AAAA,EAEA,qBAAqB,CAACZ,GAAUW,MAAoB;AAClD,IAAAjB,EAAI,CAACI,MAAU;AACb,YAAMc,IAAiB,IAAI,IAAId,EAAM,gBAAgB,GAC/CkB,IAAWJ,EAAe,IAAIZ,CAAQ;AAC5C,UAAI,CAACgB,GAAU;AACb,eAAOlB;AAGT,YAAMwB,IAAa,IAAI,IAAIN,EAAS,UAAU;AAI9C,aAHmBM,EAAW,OAAOX,CAAe,KAIlDC,EAAe,IAAIZ,GAAU,EAAE,GAAGgB,GAAU,YAAAM,GAAY,GACjD,EAAE,kBAAkBV,EAAA,KAGtBd;AAAA,IACT,CAAC;AAAA,EACH;AAAA,EACA,aAAa,CAACyB,GAAaC,GAAgBC,IAAU,EAAE,QAAQ,SAAW;AACxE,UAAM,EAAE,kBAAAC,EAAA,IAAqB/B,EAAA,GACvBgC,wBAAc,IAAA,GAEdC,IAAW,CAACC,MAA0B;AAC1C,YAAMC,IAAU,CAACP,GAAK,GAAGM,CAAW,EAAE,KAAK,GAAG,GACxCE,IAAOL,EAAiB,IAAII,CAAO,KAAK,CAAA;AAG9C,aAAIC,EAAK,YAAY,KACZ,MAGTJ,EAAQ,IAAIG,GAAS,EAAE,GAAGC,GAAM,SAAS,IAAM,GACxC;AAAA,IACT;AAMA,QAHAH,EAASJ,CAAI,GAGTC,EAAQ,QAAQ;AAClB,UAAIO,IAAa,CAAC,GAAGR,CAAI;AACzB,aAAOQ,EAAW,SAAS,MACzBA,EAAW,IAAA,GACM,CAAAJ,EAASI,CAAU;AACpC;AAAA,IAIJ;AAGA,IAAIL,EAAQ,OAAO,KACjBjC,EAAI,CAACI,OACH6B,EAAQ,QAAQ,CAACI,GAAMR,MAAQ;AAC7B,MAAAzB,EAAM,iBAAiB,IAAIyB,GAAKQ,CAAI;AAAA,IACtC,CAAC,GACMjC,EACR;AAAA,EAEL;AAAA,EACA,wCAAwB,IAAA;AAAA,EACxB,sBAAsB,CAACyB,GAAKU,MAAgB;AAC1C,IAAAvC,EAAI,CAACI,MAAU;AACb,YAAMoC,IAAS,IAAI,IAAIpC,EAAM,kBAAkB;AAC/C,aAAAoC,EAAO,IAAIX,GAAKU,CAAW,GACpB,EAAE,oBAAoBC,EAAA;AAAA,IAC/B,CAAC,GAGDvC,EAAA,EAAM,sBAAsB4B,GAAK;AAAA,MAC/B,MAAM;AAAA,MACN,aAAAU;AAAA,IAAA,CACD;AAAA,EACH;AAAA,EACA,sCAAsB,IAAA;AAAA,EACtB,eAAe,CAACV,MAAgB5B,IAAM,iBAAiB,IAAI4B,CAAG;AAAA,EAC9D,qCAAqB,IAAA;AAAA,EAErB,iBAAiB,CAACC,GAAMW,MAAa;AACnC,UAAMC,IAAczC,IAAM,iBACpB0C,IAAcD,EAAY,IAAIZ,CAAI,yBAAS,IAAA;AACjD,WAAAa,EAAY,IAAIF,CAAQ,GACxBC,EAAY,IAAIZ,GAAMa,CAAW,GAE1B,MAAM;AACX,YAAMC,IAAc3C,EAAA,EAAM,gBAAgB,IAAI6B,CAAI;AAClD,MAAIc,MACFA,EAAY,OAAOH,CAAQ,GACvBG,EAAY,SAAS,KACvB3C,IAAM,gBAAgB,OAAO6B,CAAI;AAAA,IAGvC;AAAA,EACF;AAAA,EAEA,uBAAuB,CAACe,GAAaC,MAAa;AAEhD,UAAMC,IADc9C,IAAM,gBACD,IAAI4C,CAAW;AAExC,IAAIE,KACFA,EAAK,QAAQ,CAACN,MAAaA,EAASK,CAAQ,CAAC;AAAA,EAEjD;AAAA,EAEA,uBAAuB,CAACjB,GAAamB,MAAsB;AACzD,IAAAhD,EAAI,CAACI,MAAU;AAEb,YAAMc,IAAiB,IAAI,IAAId,EAAM,gBAAgB;AACrD,cAAQ,IAAI,uBAAuB;AAGnC,YAAM6C,IADmB/B,EAAe,IAAIW,CAAG,GACD,YAGxCqB,IAAiBrB,IAAM;AAC7B,iBAAWsB,KAAK,MAAM,KAAKjC,EAAe,KAAA,CAAM;AAC9C,SAAIiC,MAAMtB,KAAOsB,EAAE,WAAWD,CAAc,MAC1ChC,EAAe,OAAOiC,CAAC;AAK3B,YAAMC,IAAe,CAACzC,GAAYmB,MAAmB;AACnD,cAAMuB,IAAU,CAACxB,GAAK,GAAGC,CAAI,EAAE,KAAK,GAAG;AAEvC,YAAI,MAAM,QAAQnB,CAAK,GAAG;AACxB,gBAAM2C,IAAqB,CAAA;AAC3B,UAAA3C,EAAM,QAAQ,MAAM;AAClB,kBAAM4C,IAAS,MAAMC,EAAA,CAAM;AAC3B,YAAAF,EAAS,KAAKD,IAAU,MAAME,CAAM;AAAA,UACtC,CAAC,GACDrC,EAAe,IAAImC,GAAS,EAAE,WAAWC,GAAU,GACnD3C,EAAM,QAAQ,CAAC8C,GAAMC,MAAU;AAC7B,kBAAMH,IAASD,EAASI,CAAK,EAAG,MAAM,GAAG,EAAE,IAAA;AAC3C,YAAAN,EAAaK,GAAM,CAAC,GAAG3B,GAAOyB,CAAO,CAAC;AAAA,UACxC,CAAC;AAAA,QACH,WAAW7C,EAAeC,CAAK,GAAG;AAChC,gBAAMgD,IAAS,OAAO;AAAA,YACpB,OAAO,KAAKhD,CAAK,EAAE,IAAI,CAACwC,MAAM,CAACA,GAAGE,IAAU,MAAMF,CAAC,CAAC;AAAA,UAAA;AAEtD,UAAAjC,EAAe,IAAImC,GAAS,EAAE,QAAAM,EAAA,CAAQ,GACtC,OAAO,KAAKhD,CAAK,EAAE,QAAQ,CAACwC,MAAM;AAChC,YAAAC,EAAazC,EAAMwC,CAAC,GAAG,CAAC,GAAGrB,GAAMqB,CAAC,CAAC;AAAA,UACrC,CAAC;AAAA,QACH;AACE,UAAAjC,EAAe,IAAImC,GAAS,EAAE,OAAA1C,EAAA,CAAO;AAAA,MAEzC;AAIA,UAHAyC,EAAaJ,GAAc,EAAE,GAGzBC,GAAqB;AACvB,cAAMW,IAAc1C,EAAe,IAAIW,CAAG,KAAK,CAAA;AAC/C,QAAAX,EAAe,IAAIW,GAAK;AAAA,UACtB,GAAG+B;AAAA,UACH,YAAYX;AAAA,QAAA,CACb;AAAA,MACH;AAGA,aAAO,EAAE,kBAAkB/B,EAAA;AAAA,IAC7B,CAAC;AAAA,EACH;AAAA,EAEA,gBAAgB,CAACkB,GAAiByB,MAA6B;AAC7D,UAAMC,wBAAW,IAAA,GACXC,IAAc,CAACC,GAAoBC,MAAwB;AAC/D,UAAIH,EAAK,IAAIE,CAAU;AACrB,eAAOF,EAAK,IAAIE,CAAU;AAG5B,YAAME,IAAajE,EAAA,EAAM,iBAAiB,IAAI+D,CAAU;AACxD,UAAI,CAACE;AACH;AAGF,UAAIA,EAAW,UAAU;AACvB,eAAOA,EAAW;AAGpB,UAAIC;AAEJ,UAAID,EAAW,WAAW;AACxB,cAAME,IAAOH,KAAOC,EAAW;AAC/B,QAAAC,IAAS,CAAA,GACTL,EAAK,IAAIE,GAAYG,CAAM,GAC3BC,EAAK,QAAQ,CAACC,MAAY;AACxB,UAAAF,EAAO,KAAKJ,EAAYM,CAAO,CAAC;AAAA,QAClC,CAAC;AAAA,MACH,MAAA,CAAWH,EAAW,UACpBC,IAAS,CAAA,GACTL,EAAK,IAAIE,GAAYG,CAAM,GAC3B,OAAO,QAAQD,EAAW,MAAM,EAAE,QAAQ,CAAC,CAACrC,GAAKyC,CAAS,MAAM;AAC9D,QAAAH,EAAOtC,CAAG,IAAIkC,EAAYO,CAAmB;AAAA,MAC/C,CAAC,KAEDH,IAAS;AAIX,aAAOA;AAAA,IACT;AAGA,WAAOJ,EAAY3B,GAASyB,CAAa;AAAA,EAC3C;AAAA,EACA,mBAAmB,CAAChC,GAAaC,MAAmB;AAClD,UAAMM,IAAU,CAACP,GAAK,GAAGC,CAAI,EAAE,KAAK,GAAG;AAEvC,WAAO7B,EAAA,EAAM,iBAAiB,IAAImC,CAAO;AAAA,EAC3C;AAAA,EAEA,mBAAmB,CAACP,GAAKC,GAAMyC,MAAa;AAC1C,UAAMnC,IAAU,CAACP,GAAK,GAAGC,CAAI,EAAE,KAAK,GAAG,GACjC0C,IAAevE,EAAA,EAAM,iBAAiB,IAAImC,CAAO;AAKvD,IAAIoC,GAAc,cAAc,CAACD,EAAS,eACxC,QAAQ;AAAA,MACN;AAAA,MACA;AAAA,IAAA,GAEF,QAAQ;AAAA,MACN,iDAAiD1C,CAAG,eAAeC,EAAK,KAAK,IAAI,CAAC;AAAA,IAAA,GAEpF,QAAQ;AAAA,MACN;AAAA,MACA0C,EAAa;AAAA,IAAA,GAEf,QAAQ;AAAA,MACN;AAAA,MACAD;AAAA,IAAA,GAEF,QAAQ;AAAA,MACN;AAAA,MACA;AAAA,IAAA,GAEF,QAAQ,MAAA,GACR,QAAQ,SAAA;AAIV,UAAMrD,IAAiB,IAAI,IAAIjB,EAAA,EAAM,gBAAgB,GAC/CwE,IAAY,EAAE,GAAID,KAAgB,CAAA,GAAK,GAAGD,EAAA;AAChD,IAAArD,EAAe,IAAIkB,GAASqC,CAAS,GACrCzE,EAAI,EAAE,kBAAkBkB,GAAgB;AAAA,EAC1C;AAAA,EACA,mBAAmB,CACjBW,GACAC,GACA4C,GACAC,MACG;AACH,UAAMvC,IAAU,CAACP,GAAK,GAAGC,CAAI,EAAE,KAAK,GAAG,GACjCZ,IAAiB,IAAI,IAAIjB,EAAA,EAAM,gBAAgB,GAC/C2E,IAAW1D,EAAe,IAAIkB,CAAO,KAAK,CAAA;AAGhD,IAAKwC,EAAS,oBACZA,EAAS,sCAAsB,IAAA,IAIjCA,EAAS,gBAAgB,IAAIF,GAAUC,CAAS,GAGhDzD,EAAe,IAAIkB,GAASwC,CAAQ,GACpC5E,EAAI,EAAE,kBAAkBkB,GAAgB;AAAA,EAG1C;AAAA,EACA,0BAA0B,CACxBW,GACAgD,GACAC,MACG;AACH,UAAM5D,IAAiB,IAAI,IAAIjB,EAAA,EAAM,gBAAgB,GAC/C8E,IAAW,CAAClD,GAAK,GAAGgD,CAAS,EAAE,KAAK,GAAG,GACvCG,IAAa9D,EAAe,IAAI6D,CAAQ;AAE9C,QAAI,CAACC,KAAc,CAACA,EAAW,UAAW;AAE1C,UAAMC,IAAY,MAAMzB,EAAA,CAAM,IACxB0B,IAAcH,IAAW,MAAME,GAG/BE,IAAe,CAAC,GAAGH,EAAW,SAAS;AAC7C,IAAAG,EAAa,KAAKD,CAAW,GAC7BhE,EAAe,IAAI6D,GAAU,EAAE,GAAGC,GAAY,WAAWG,GAAc;AAGvE,UAAMC,IAAiB,CAACzE,GAAYmB,MAAmB;AACrD,YAAMuB,IAAU,CAACxB,GAAK,GAAGC,CAAI,EAAE,KAAK,GAAG;AAEvC,UAAI,OAAM,QAAQnB,CAAK,EAEvB,KAAW,OAAOA,KAAU,YAAYA,MAAU,MAAM;AAEtD,cAAMgD,IAAS,OAAO;AAAA,UACpB,OAAO,KAAKhD,CAAK,EAAE,IAAI,CAACwC,MAAM,CAACA,GAAGE,IAAU,MAAMF,CAAC,CAAC;AAAA,QAAA;AAEtD,QAAAjC,EAAe,IAAImC,GAAS,EAAE,QAAAM,EAAA,CAAQ,GAGtC,OAAO,QAAQhD,CAAK,EAAE,QAAQ,CAAC,CAACwC,GAAGkC,CAAC,MAAM;AACxC,UAAAD,EAAeC,GAAG,CAAC,GAAGvD,GAAMqB,CAAC,CAAC;AAAA,QAChC,CAAC;AAAA,MACH;AAEE,QAAAjC,EAAe,IAAImC,GAAS,EAAE,OAAA1C,EAAA,CAAO;AAAA,IAEzC;AAEA,IAAAyE,EAAeN,GAAS,CAAC,GAAGD,GAAWI,CAAS,CAAC,GACjDjF,EAAI,EAAE,kBAAkBkB,GAAgB,GAExCjB,EAAA,EAAM,sBAAsB8E,GAAU;AAAA,MACpC,MAAM;AAAA,MACN,MAAMA;AAAA,MACN,SAASG;AAAA,IAAA,CACV;AAAA,EACH;AAAA,EACA,0BAA0B,CAACrD,GAAayD,MAAuB;AAC7D,UAAMpE,IAAiB,IAAI,IAAIjB,EAAA,EAAM,gBAAgB,GAG/CoE,IAAU,CAACxC,GAAK,GAAGyD,CAAQ,EAAE,KAAK,GAAG,GAGrChD,IAAagD,EAAS,MAAM,GAAG,EAAE,GACjCC,IAAY,CAAC1D,GAAK,GAAGS,CAAU,EAAE,KAAK,GAAG,GAGzC0C,IAAa9D,EAAe,IAAIqE,CAAS;AAE/C,QAAIP,KAAcA,EAAW,aAELA,EAAW,UAAU;AAAA,MACzC,CAACQ,MAAiBA,MAAiBnB;AAAA,IAAA,MAGf,IAAI;AAExB,YAAMc,IAAeH,EAAW,UAAU;AAAA,QACxC,CAACQ,MAAiBA,MAAiBnB;AAAA,MAAA;AAIrC,MAAAnD,EAAe,IAAIqE,GAAW;AAAA,QAC5B,GAAGP;AAAA,QACH,WAAWG;AAAA,MAAA,CACZ;AAGD,YAAMjC,IAAiBmB,IAAU;AACjC,iBAAWlB,KAAK,MAAM,KAAKjC,EAAe,KAAA,CAAM;AAC9C,SAAIiC,MAAMkB,KAAWlB,EAAE,WAAWD,CAAc,MAC9ChC,EAAe,OAAOiC,CAAC;AAAA,IAG7B;AAGF,IAAAnD,EAAI,EAAE,kBAAkBkB,GAAgB,GAExCjB,EAAA,EAAM,sBAAsBsF,GAAW;AAAA,MACrC,MAAM;AAAA,MACN,MAAMA;AAAA,MACN,SAAAlB;AAAA;AAAA,IAAA,CACD;AAAA,EACH;AAAA,EAEA,oBAAoB,CAACxC,GAAKC,GAAMgB,MAAa;AAC3C,UAAMV,IAAU,CAACP,GAAK,GAAGC,CAAI,EAAE,KAAK,GAAG;AAIvC,IADqB7B,EAAA,EAAM,iBAAiB,IAAImC,CAAO,GACrC,UAAUU,KAAY,CAACpC,EAAeoC,CAAQ,KAKhE9C,EAAI,CAACI,MAAU;AACb,YAAMqF,IAAQrF,EAAM;AAEpB,UAAKM,EAAeoC,CAAQ,GAGrB;AAEL,cAAM4C,IAAgB,CAACvD,GAAuBwD,MAAqB;AACjE,gBAAMC,IAAiB,CAAC/D,GAAK,GAAGM,CAAW,EAAE,KAAK,GAAG,GAC/CE,IAAOoD,EAAM,IAAIG,CAAc;AAErC,cAAIvD,KAAQA,EAAK;AACf,uBAAWwD,KAAYF;AACrB,kBAAI,OAAO,UAAU,eAAe,KAAKA,GAAaE,CAAQ,GAAG;AAC/D,sBAAMC,IAAaH,EAAYE,CAAQ,GACjCE,IAAgB1D,EAAK,OAAOwD,CAAQ;AAE1C,oBAAIE;AACF,sBAAIrF,EAAeoF,CAAU;AAC3B,oBAAAJ;AAAA,sBACEK,EAAc,MAAM,GAAG,EAAE,MAAM,CAAC;AAAA,sBAChCD;AAAA,oBAAA;AAAA,uBAEG;AACL,0BAAME,IAAoBP,EAAM,IAAIM,CAAa,KAAK,CAAA;AACtD,oBAAAN,EAAM,IAAIM,GAAe;AAAA,sBACvB,GAAGC;AAAA,sBACH,OAAOF;AAAA,oBAAA,CACR;AAAA,kBACH;AAAA,cAEJ;AAAA;AAAA,QAGN;AAEA,QAAAJ,EAAc5D,GAAMgB,CAAQ;AAAA,MAC9B,OAnC+B;AAC7B,cAAMT,IAAOoD,EAAM,IAAIrD,CAAO,KAAK,CAAA;AACnC,QAAAqD,EAAM,IAAIrD,GAAS,EAAE,GAAGC,GAAM,OAAOS,GAAU;AAAA,MACjD;AAmCA,aAAA7C,EAAA,EAAM,sBAAsBmC,GAAS,EAAE,MAAM,UAAU,UAAAU,GAAU,GAG1D1C;AAAA,IACT,CAAC;AAAA,EACH;AAAA,EACA,wCAAwB,IAAA;AAAA,EACxB,kBAAkB,CAAC2E,GAAkBkB,MAAgC;AACnE,UAAM5B,IAAUpE,EAAA,EAAM,mBAAmB,IAAI8E,CAAQ;AAErD,QAAI,CAACV,EAAS,QAAO;AAGrB,UAAM6B,IACJD,KACArF,EAAe,SAAA,EAAW,kBAAkBmE,GAAU,CAAA,CAAE,GAAG;AAE7D,WAAKmB,IAEEA,EAAU,QAAQ7B,CAAO,IAFT;AAAA,EAGzB;AAAA,EAEA,kBAAkB,CAACU,GAAkBV,MAAgC;AACnE,IAAArE,EAAI,CAACI,MAAU;AACb,YAAMoC,IAASpC,EAAM;AAErB,aAAIiE,MAAY,SACd7B,EAAO,OAAOuC,CAAQ,KAElBvC,EAAO,IAAIuC,CAAQ,KACrB9E,EAAA,EAAM,sBAAsBuC,EAAO,IAAIuC,CAAQ,GAAI;AAAA,QACjD,MAAM;AAAA,MAAA,CACP,GAEHvC,EAAO,IAAIuC,GAAUV,CAAO,GAE5BpE,EAAA,EAAM,sBAAsBoE,GAAS;AAAA,QACnC,MAAM;AAAA,MAAA,CACP,IAEHpE,EAAA,EAAM,sBAAsB8E,GAAU;AAAA,QACpC,MAAM;AAAA,MAAA,CACP,GACM;AAAA,QACL,GAAG3E;AAAA,QACH,oBAAoBoC;AAAA,MAAA;AAAA,IAExB,CAAC;AAAA,EACH;AAAA,EACA,oBAAoB,CAAC,EAAE,UAAAuC,QAA2C;AAChE,IAAA/E,EAAI,CAACI,MAAU;AACb,YAAMoC,IAASpC,EAAM,oBACf+F,IAAY3D,EAAO,IAAIuC,CAAQ;AACrC,aAAIoB,KACFlG,EAAA,EAAM,sBAAsBkG,GAAW;AAAA,QACrC,MAAM;AAAA,MAAA,CACP,GAGH3D,EAAO,OAAOuC,CAAQ,GACtB9E,EAAA,EAAM,sBAAsB8E,GAAU;AAAA,QACpC,MAAM;AAAA,MAAA,CACP,GACM;AAAA,QACL,GAAG3E;AAAA,QACH,oBAAoBoC;AAAA,MAAA;AAAA,IAExB,CAAC;AAAA,EACH;AAAA,EACA,8BAA8B,CAAClC,MAAqB;AAClD,IAAAN,EAAI,CAACI,MAAU;AACb,YAAMgG,IAAc,IAAI,IAAIhG,EAAM,kBAAkB;AAEpD,aADgBgG,EAAY,OAAO9F,CAAQ,IAElC,EAAE,oBAAoB8F,EAAA,IAEtB,CAAA;AAAA,IAEX,CAAC;AAAA,EACH;AAAA,EAEA,qBAAqB,CAAA;AAAA,EAErB,eAAe,CAAA;AAAA,EACf,gBAAgB,CAAA;AAAA,EAChB,8BAAc,IAAA;AAAA,EAEd,oBAAoB,CAAA;AAAA,EAEpB,sCAAsB,IAAA;AAAA,EACtB,aAAa,CAACvE,GAAKwE,MAAW;AAC5B,IAAArG,EAAI,CAACI,MAAU;AACb,YAAMkG,IAAS,IAAI,IAAIlG,EAAM,QAAQ,GAC/BmG,IAAiB,IAAI,IAAID,EAAO,IAAIzE,CAAG,CAAC,GACxC2E,IAAgB,KAAK,UAAUH,EAAO,IAAI,GAE1CzB,IAAW2B,EAAe,IAAIC,CAAa;AACjD,aAAI5B,KAEFA,EAAS,WAAWyB,EAAO,UAC3BzB,EAAS,YAAYyB,EAAO,aAG5BE,EAAe,IAAIC,GAAe,EAAE,GAAGH,GAAQ,GAGjDC,EAAO,IAAIzE,GAAK0E,CAAc,GACvB,EAAE,UAAUD,EAAA;AAAA,IACrB,CAAC;AAAA,EACH;AAAA,EAEA,mBAAmB,CAACzE,MACX5B,EAAA,EAAM,oBAAoB4B,CAAG;AAAA,EAGtC,wBAAwB,CAACA,GAAKlB,MAAU;AACtC,IAAAX,EAAI,CAACyG,OAAU;AAAA,MACb,qBAAqB;AAAA,QACnB,GAAGA,EAAK;AAAA,QACR,CAAC5E,CAAG,GAAGlB;AAAA,MAAA;AAAA,IACT,EACA;AAAA,EACJ;AAAA,EACA,0BAA0B,CAACkB,GAAK6E,MAAa;AAC3C,IAAA1G,EAAI,CAACyG,OAAU;AAAA,MACb,oBAAoB;AAAA,QAClB,GAAGA,EAAK;AAAA,QACR,CAAC5E,CAAG,GAAG6E;AAAA,MAAA;AAAA,IACT,EACA;AAAA,EACJ;AAAA,EAEA,mCAAmB,IAAA;AAAA,EACnB,aAAa,CAAC7E,GAAa8E,MACzB3G,EAAI,CAACI,MAAU;AACb,UAAMoC,IAAS,IAAI,IAAIpC,EAAM,aAAa;AAC1C,WAAAoC,EAAO,IAAIX,GAAK8E,CAAQ,GACjB,EAAE,GAAGvG,GAAO,eAAeoC,EAAA;AAAA,EACpC,CAAC;AAAA,EACH,aAAa,CAACX,MAAgB5B,EAAA,EAAM,cAAc,IAAI4B,CAAG,KAAK;AAChE,EAAE;"}