{"version":3,"file":"store.js","sources":["../src/store.ts"],"sourcesContent":["import { create } from 'zustand';\r\n\r\nimport type {\r\n  OptionsType,\r\n  ReactivityType,\r\n  SyncInfo,\r\n  UpdateTypeDetail,\r\n} from './CogsState.js';\r\n\r\nexport type FreshValuesObject = {\r\n  pathsToValues?: string[];\r\n  prevValue?: any;\r\n  newValue?: any;\r\n  timeStamp: number;\r\n};\r\n\r\ntype StateValue = any;\r\nexport type FormEventType = {\r\n  type: 'focus' | 'blur' | 'input';\r\n  value?: any;\r\n  path: string[];\r\n};\r\nexport type TrieNode = {\r\n  subscribers: Set<string>;\r\n  children: Map<string, TrieNode>;\r\n};\r\n\r\nexport type ComponentsType = {\r\n  components?: Map<\r\n    string,\r\n    {\r\n      forceUpdate: () => void;\r\n      paths: Set<string>;\r\n      deps?: any[];\r\n      prevDeps?: any[];\r\n      depsFunction?: (state: any) => any[] | true;\r\n      reactiveType: ReactivityType[] | ReactivityType;\r\n    }\r\n  >;\r\n};\r\n\r\nexport type ValidationStatus =\r\n  | 'NOT_VALIDATED'\r\n  | 'VALIDATING'\r\n  | 'VALID'\r\n  | 'INVALID';\r\nexport type ValidationSeverity = 'warning' | 'error' | undefined;\r\nexport type ValidationError = {\r\n  source: 'client' | 'sync_engine' | 'api';\r\n  message: string;\r\n  severity: ValidationSeverity;\r\n  code?: string;\r\n};\r\n\r\nexport type ValidationState = {\r\n  status: ValidationStatus;\r\n  errors: ValidationError[];\r\n  lastValidated?: number;\r\n  validatedValue?: any;\r\n};\r\nexport type TypeInfo = {\r\n  type:\r\n    | 'string'\r\n    | 'number'\r\n    | 'boolean'\r\n    | 'array'\r\n    | 'object'\r\n    | 'date'\r\n    | 'unknown';\r\n  schema: any; // Store the actual Zod schema object\r\n  source: 'sync' | 'zod4' | 'zod3' | 'runtime' | 'default';\r\n  default: any;\r\n  nullable?: boolean;\r\n  optional?: boolean;\r\n};\r\n\r\nexport type UIState = {\r\n  isFocused?: boolean;\r\n  isTouched?: boolean;\r\n  isHovered?: boolean;\r\n};\r\n\r\n// Update ShadowMetadata to include typeInfo\r\nexport type ShadowMetadata = {\r\n  value?: any;\r\n\r\n  id?: string;\r\n  typeInfo?: TypeInfo;\r\n  stateSource?: 'default' | 'server' | 'localStorage';\r\n  lastServerSync?: number;\r\n  isDirty?: boolean;\r\n  baseServerState?: any;\r\n  arrayKeys?: string[];\r\n  fields?: Record<string, any>;\r\n  virtualizer?: {\r\n    itemHeight?: number;\r\n    domRef?: HTMLElement | null;\r\n  };\r\n  syncInfo?: { status: string };\r\n  validation?: ValidationState;\r\n  features?: {\r\n    localStorageEnabled: boolean;\r\n  };\r\n  signals?: Array<{\r\n    instanceId: string;\r\n    parentId: string;\r\n    position: number;\r\n    effect?: string;\r\n  }>;\r\n  transformCaches?: Map<\r\n    string,\r\n    {\r\n      validIds: string[];\r\n      computedAt: number;\r\n      transforms: Array<{ type: 'filter' | 'sort'; fn: Function }>;\r\n    }\r\n  >;\r\n  pathComponents?: Set<string>;\r\n\r\n  streams?: Map<\r\n    string,\r\n    {\r\n      buffer: any[];\r\n      flushTimer: NodeJS.Timeout | null;\r\n    }\r\n  >;\r\n  pluginMetaData?: Map<string, Record<string, any>>;\r\n  formRef?: React.RefObject<any>;\r\n  focusedElement?: { path: string[]; ref: React.RefObject<any> } | null;\r\n} & ComponentsType;\r\n\r\ntype ShadowNode = {\r\n  _meta?: ShadowMetadata;\r\n  [key: string]: any;\r\n};\r\n\r\nexport type CogsGlobalState = {\r\n  getPluginMetaDataMap: (\r\n    key: string,\r\n    path: string[]\r\n  ) => Map<string, Record<string, any>> | undefined;\r\n  setPluginMetaData: (\r\n    key: string,\r\n    path: string[],\r\n    pluginName: string,\r\n    data: Record<string, any>\r\n  ) => void;\r\n  removePluginMetaData: (\r\n    key: string,\r\n    path: string[],\r\n    pluginName: string\r\n  ) => void;\r\n  setTransformCache: (\r\n    key: string,\r\n    path: string[],\r\n    cacheKey: string,\r\n    cacheData: any\r\n  ) => void;\r\n  initializeAndMergeShadowState: (key: string, initialState: any) => void;\r\n  initializeShadowState: (key: string, initialState: any) => void;\r\n  getShadowNode: (key: string, path: string[]) => ShadowNode | undefined;\r\n  getShadowMetadata: (\r\n    key: string,\r\n    path: string[]\r\n  ) => ShadowMetadata | undefined;\r\n\r\n  setShadowMetadata: (key: string, path: string[], metadata: any) => void;\r\n  getShadowValue: (\r\n    key: string,\r\n    path: string[],\r\n    validArrayIds?: string[],\r\n    log?: boolean\r\n  ) => any;\r\n  updateShadowAtPath: (key: string, path: string[], newValue: any) => void;\r\n  insertManyShadowArrayElements: (\r\n    key: string,\r\n    arrayPath: string[],\r\n    newItems: any[],\r\n    index?: number\r\n  ) => void;\r\n  addItemsToArrayNode: (\r\n    key: string,\r\n    arrayPath: string[],\r\n    newItems: any\r\n  ) => void;\r\n  insertShadowArrayElement: (\r\n    key: string,\r\n    arrayPath: string[],\r\n    newItem: any,\r\n    index?: number,\r\n    itemId?: string\r\n  ) => string;\r\n  removeShadowArrayElement: (key: string, itemPath: string[]) => void;\r\n  registerComponent: (\r\n    stateKey: string,\r\n    componentId: string,\r\n    registration: any\r\n  ) => void;\r\n  unregisterComponent: (stateKey: string, componentId: string) => void;\r\n  addPathComponent: (\r\n    stateKey: string,\r\n    dependencyPath: string[],\r\n    fullComponentId: string\r\n  ) => void;\r\n  markAsDirty: (\r\n    key: string,\r\n    path: string[],\r\n    options: { bubble: boolean }\r\n  ) => void;\r\n\r\n  pathSubscribers: Map<string, Set<(newValue: any) => void>>;\r\n  subscribeToPath: (\r\n    path: string,\r\n    callback: (newValue: any) => void\r\n  ) => () => void;\r\n  notifyPathSubscribers: (updatedPath: string, newValue: any) => void;\r\n\r\n  selectedIndicesMap: Map<string, string>; // stateKey -> (parentPath -> selectedIndex)\r\n  getSelectedIndex: (stateKey: string, validArrayIds?: string[]) => number;\r\n  setSelectedIndex: (key: string, itemKey: string) => void;\r\n  clearSelectedIndex: ({ arrayKey }: { arrayKey: string }) => void;\r\n  clearSelectedIndexesForState: (stateKey: string) => void;\r\n\r\n  initialStateOptions: { [key: string]: OptionsType };\r\n  initialStateGlobal: { [key: string]: StateValue };\r\n  updateInitialStateGlobal: (key: string, newState: StateValue) => void;\r\n\r\n  getInitialOptions: (key: string) => OptionsType | undefined;\r\n  setInitialStateOptions: (key: string, value: OptionsType) => void;\r\n\r\n  serverStateUpdates: Map<\r\n    string,\r\n    {\r\n      data: any;\r\n      status: 'loading' | 'success' | 'error';\r\n      timestamp: number;\r\n    }\r\n  >;\r\n\r\n  setServerStateUpdate: (key: string, serverState: any) => void;\r\n\r\n  stateLog: Map<string, Map<string, UpdateTypeDetail>>;\r\n  syncInfoStore: Map<string, SyncInfo>;\r\n  addStateLog: (updates: UpdateTypeDetail[]) => void;\r\n\r\n  setSyncInfo: (key: string, syncInfo: SyncInfo) => void;\r\n  getSyncInfo: (key: string) => SyncInfo | null;\r\n};\r\nfunction getTypeFromZodSchema(\r\n  schema: any,\r\n  source: 'zod4' | 'zod3' | 'sync' = 'zod4'\r\n): TypeInfo | null {\r\n  if (!schema) return null;\r\n\r\n  let current = schema;\r\n  let isNullable = false;\r\n  let isOptional = false;\r\n  let defaultValue: any = undefined;\r\n  let hasDefault = false;\r\n\r\n  // This loop will now correctly navigate through any wrappers AND unions.\r\n  for (let i = 0; i < 20; i++) {\r\n    // Added a safety break for complex schemas\r\n    const def = current?.def || current?._def;\r\n    if (!def) break;\r\n\r\n    const typeIdentifier = def.typeName || def.type || current._type;\r\n\r\n    // --- START: THE CRITICAL FIX FOR ZodUnion ---\r\n    if (typeIdentifier === 'ZodUnion' || typeIdentifier === 'union') {\r\n      if (def.options && def.options.length > 0) {\r\n        current = def.options[0]; // Proceed by analyzing the FIRST option of the union\r\n        continue; // Restart the loop with the new schema\r\n      } else {\r\n        break; // Union with no options, cannot determine type\r\n      }\r\n    }\r\n    // --- END: THE CRITICAL FIX ---\r\n\r\n    if (typeIdentifier === 'ZodOptional' || typeIdentifier === 'optional') {\r\n      isOptional = true;\r\n    } else if (\r\n      typeIdentifier === 'ZodNullable' ||\r\n      typeIdentifier === 'nullable'\r\n    ) {\r\n      isNullable = true;\r\n    } else if (\r\n      typeIdentifier === 'ZodDefault' ||\r\n      typeIdentifier === 'default'\r\n    ) {\r\n      hasDefault = true;\r\n      defaultValue =\r\n        typeof def.defaultValue === 'function'\r\n          ? def.defaultValue()\r\n          : def.defaultValue;\r\n    } else if (\r\n      typeIdentifier !== 'ZodEffects' &&\r\n      typeIdentifier !== 'effects'\r\n    ) {\r\n      // This is not a wrapper we need to unwrap further, so we can exit the loop.\r\n      break;\r\n    }\r\n\r\n    const nextSchema = def.innerType || def.schema || current._inner;\r\n    if (!nextSchema || nextSchema === current) {\r\n      break; // Reached the end or a recursive schema\r\n    }\r\n    current = nextSchema;\r\n  }\r\n\r\n  const baseSchema = current;\r\n  const baseDef = baseSchema?.def || baseSchema?._def;\r\n  const baseType = baseDef?.typeName || baseDef?.type || baseSchema?._type;\r\n\r\n  if (baseType === 'ZodNumber' || baseType === 'number') {\r\n    return {\r\n      type: 'number',\r\n      schema: schema,\r\n      source,\r\n      default: hasDefault ? defaultValue : 0,\r\n      nullable: isNullable,\r\n      optional: isOptional,\r\n    };\r\n  }\r\n  if (baseType === 'ZodString' || baseType === 'string') {\r\n    return {\r\n      type: 'string',\r\n      schema: schema,\r\n      source,\r\n      default: hasDefault ? defaultValue : '',\r\n      nullable: isNullable,\r\n      optional: isOptional,\r\n    };\r\n  }\r\n  if (baseType === 'ZodBoolean' || baseType === 'boolean') {\r\n    return {\r\n      type: 'boolean',\r\n      schema: schema,\r\n      source,\r\n      default: hasDefault ? defaultValue : false,\r\n      nullable: isNullable,\r\n      optional: isOptional,\r\n    };\r\n  }\r\n  if (baseType === 'ZodArray' || baseType === 'array') {\r\n    return {\r\n      type: 'array',\r\n      schema: schema,\r\n      source,\r\n      default: hasDefault ? defaultValue : [],\r\n      nullable: isNullable,\r\n      optional: isOptional,\r\n    };\r\n  }\r\n  if (baseType === 'ZodObject' || baseType === 'object') {\r\n    return {\r\n      type: 'object',\r\n      schema: schema,\r\n      source,\r\n      default: hasDefault ? defaultValue : {},\r\n      nullable: isNullable,\r\n      optional: isOptional,\r\n    };\r\n  }\r\n  if (baseType === 'ZodDate' || baseType === 'date') {\r\n    return {\r\n      type: 'date',\r\n      schema: schema,\r\n      source,\r\n      default: hasDefault ? defaultValue : new Date(),\r\n      nullable: isNullable,\r\n      optional: isOptional,\r\n    };\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\n// Helper to get type info from runtime value\r\nfunction getTypeFromValue(value: any): TypeInfo {\r\n  if (value === null) {\r\n    return {\r\n      type: 'unknown',\r\n      schema: null,\r\n      source: 'default',\r\n      default: null,\r\n      nullable: true,\r\n    };\r\n  }\r\n\r\n  if (value === undefined) {\r\n    return {\r\n      type: 'unknown',\r\n      schema: null,\r\n      source: 'default',\r\n      default: undefined,\r\n      optional: true,\r\n    };\r\n  }\r\n\r\n  const valueType = typeof value;\r\n\r\n  if (valueType === 'number') {\r\n    return { type: 'number', schema: null, source: 'runtime', default: value };\r\n  } else if (valueType === 'string') {\r\n    return { type: 'string', schema: null, source: 'runtime', default: value };\r\n  } else if (valueType === 'boolean') {\r\n    return { type: 'boolean', schema: null, source: 'runtime', default: value };\r\n  } else if (Array.isArray(value)) {\r\n    return { type: 'array', schema: null, source: 'runtime', default: [] };\r\n  } else if (value instanceof Date) {\r\n    return { type: 'date', schema: null, source: 'runtime', default: value };\r\n  } else if (valueType === 'object') {\r\n    return { type: 'object', schema: null, source: 'runtime', default: {} };\r\n  }\r\n\r\n  return { type: 'unknown', schema: null, source: 'runtime', default: value };\r\n}\r\ntype BuildContext = {\r\n  stateKey: string;\r\n  path: string[];\r\n  schemas: {\r\n    sync?: any;\r\n    zodV4?: any;\r\n    zodV3?: any;\r\n  };\r\n};\r\n\r\nexport function buildShadowNode(\r\n  stateKey: string,\r\n  value: any,\r\n  context?: BuildContext\r\n): ShadowNode {\r\n  // Handle null/undefined/primitives (This part is already correct)\r\n  if (value === null || value === undefined || typeof value !== 'object') {\r\n    const node: ShadowNode = { _meta: { value } };\r\n    node._meta!.typeInfo = getTypeInfoForPath(value, context);\r\n    return node;\r\n  }\r\n\r\n  // Handle arrays\r\n  if (Array.isArray(value)) {\r\n    // 1. Create the node for the array.\r\n    const node: ShadowNode = { _meta: { arrayKeys: [] } };\r\n\r\n    // 2. Get the type info for the array itself ONCE, right at the start.\r\n    node._meta!.typeInfo = getTypeInfoForPath(value, context);\r\n\r\n    // 3. THEN, recursively process the children.\r\n    value.forEach((item, index) => {\r\n      const itemId = generateId(stateKey);\r\n      const itemContext = context\r\n        ? {\r\n            ...context,\r\n            path: [...context.path, index.toString()],\r\n          }\r\n        : undefined;\r\n\r\n      node[itemId] = buildShadowNode(stateKey, item, itemContext);\r\n      node._meta!.arrayKeys!.push(itemId);\r\n    });\r\n\r\n    return node;\r\n  }\r\n\r\n  // Handle objects\r\n  if (value.constructor === Object) {\r\n    // 1. Create the node for the object.\r\n    const node: ShadowNode = { _meta: {} };\r\n\r\n    // 2. Get the type info for the object itself ONCE, right at the start.\r\n    node._meta!.typeInfo = getTypeInfoForPath(value, context);\r\n\r\n    // 3. THEN, recursively process the children.\r\n    for (const key in value) {\r\n      if (Object.prototype.hasOwnProperty.call(value, key)) {\r\n        const propContext = context\r\n          ? {\r\n              ...context,\r\n              path: [...context.path, key],\r\n            }\r\n          : undefined;\r\n\r\n        node[key] = buildShadowNode(stateKey, value[key], propContext);\r\n      }\r\n    }\r\n\r\n    return node;\r\n  }\r\n\r\n  // Fallback for other object types (Date, class instances, etc.)\r\n  return {\r\n    _meta: {\r\n      value: value,\r\n      typeInfo: getTypeFromValue(value),\r\n    },\r\n  };\r\n}\r\n\r\n// Helper function to get type info (extracted for clarity)\r\nfunction getTypeInfoForPath(value: any, context?: BuildContext): TypeInfo {\r\n  if (context) {\r\n    // Try to get schema-based type info\r\n    let typeInfo: TypeInfo | null = null;\r\n\r\n    if (context.schemas.zodV4) {\r\n      const schema =\r\n        context.path.length === 0\r\n          ? context.schemas.zodV4\r\n          : getSchemaAtPath(context.schemas.zodV4, context.path);\r\n      if (schema) {\r\n        typeInfo = getTypeFromZodSchema(schema, 'zod4');\r\n      }\r\n    }\r\n\r\n    if (!typeInfo && context.schemas.zodV3) {\r\n      const schema =\r\n        context.path.length === 0\r\n          ? context.schemas.zodV3\r\n          : getSchemaAtPath(context.schemas.zodV3, context.path);\r\n      if (schema) {\r\n        typeInfo = getTypeFromZodSchema(schema, 'zod3');\r\n      }\r\n    }\r\n\r\n    if (!typeInfo && context.schemas.sync?.[context.stateKey]) {\r\n      typeInfo = getTypeFromValue(value);\r\n      typeInfo.source = 'sync';\r\n    }\r\n\r\n    if (typeInfo) return typeInfo;\r\n  }\r\n\r\n  return getTypeFromValue(value);\r\n}\r\n\r\nexport function updateShadowTypeInfo(\r\n  stateKey: string,\r\n  rootSchema: any,\r\n  source: 'zod4' | 'zod3'\r\n) {\r\n  const rootNode =\r\n    shadowStateStore.get(stateKey) || shadowStateStore.get(`[${stateKey}`);\r\n  if (!rootNode) return;\r\n\r\n  function updateNodeTypeInfo(node: any, path: string[]) {\r\n    if (!node || typeof node !== 'object') return;\r\n    const fieldSchema = getSchemaAtPath(rootSchema, path);\r\n\r\n    if (fieldSchema) {\r\n      const typeInfo = getTypeFromZodSchema(fieldSchema, source);\r\n      if (typeInfo) {\r\n        if (!node._meta) node._meta = {};\r\n        node._meta.typeInfo = {\r\n          ...typeInfo,\r\n          schema: fieldSchema,\r\n        };\r\n      }\r\n    }\r\n\r\n    // Recursively update children\r\n    if (node._meta?.arrayKeys) {\r\n      node._meta.arrayKeys.forEach((itemKey: string) => {\r\n        if (node[itemKey]) {\r\n          updateNodeTypeInfo(node[itemKey], [...path, '0']); // Use index 0 for array item schema\r\n        }\r\n      });\r\n    } else if (!node._meta?.hasOwnProperty('value')) {\r\n      // It's an object - update each property\r\n      Object.keys(node).forEach((key) => {\r\n        if (key !== '_meta') {\r\n          updateNodeTypeInfo(node[key], [...path, key]);\r\n        }\r\n      });\r\n    }\r\n  }\r\n\r\n  updateNodeTypeInfo(rootNode, []);\r\n}\r\n\r\n/**\r\n * Reliably unwraps a Zod schema to its core type, handling modifiers\r\n * from both Zod v3 and modern Zod.\r\n */\r\nfunction unwrapSchema(schema: any): any {\r\n  let current = schema;\r\n  while (current) {\r\n    // Version-agnostic way to get the definition object\r\n    const def = current.def || current._def;\r\n\r\n    // VITAL FIX: Check for `def.type` (like in your log), `def.typeName` (modern Zod), and `_type` (zod v3)\r\n    const typeIdentifier = def?.typeName || def?.type || current._type;\r\n\r\n    if (\r\n      typeIdentifier === 'ZodOptional' ||\r\n      typeIdentifier === 'optional' ||\r\n      typeIdentifier === 'ZodNullable' ||\r\n      typeIdentifier === 'nullable' ||\r\n      typeIdentifier === 'ZodDefault' ||\r\n      typeIdentifier === 'default' ||\r\n      typeIdentifier === 'ZodEffects' ||\r\n      typeIdentifier === 'effects'\r\n    ) {\r\n      // Get the inner schema, supporting multiple internal structures\r\n      current =\r\n        def.innerType || def.schema || current._inner || current.unwrap?.();\r\n    } else {\r\n      break; // Reached the base schema\r\n    }\r\n  }\r\n  return current;\r\n}\r\n\r\n/**\r\n * Helper function to get a nested schema at a specific path,\r\n * correctly handling both Zod v3 and modern Zod internals.\r\n */\r\nfunction getSchemaAtPath(schema: any, path: string[]): any {\r\n  if (!schema) return null;\r\n  if (path.length === 0) return schema;\r\n\r\n  let currentSchema = schema;\r\n\r\n  for (const segment of path) {\r\n    const containerSchema = unwrapSchema(currentSchema);\r\n    if (!containerSchema) return null;\r\n\r\n    const def = containerSchema.def || containerSchema._def;\r\n\r\n    // VITAL FIX: Check for `def.type` as you discovered.\r\n    const typeIdentifier = def?.typeName || def?.type || containerSchema._type;\r\n\r\n    if (typeIdentifier === 'ZodObject' || typeIdentifier === 'object') {\r\n      // VITAL FIX: Check for `shape` inside `def` first, then on the schema itself.\r\n      const shape =\r\n        def?.shape || containerSchema.shape || containerSchema._shape;\r\n      currentSchema = shape?.[segment];\r\n    } else if (typeIdentifier === 'ZodArray' || typeIdentifier === 'array') {\r\n      // For arrays, the next schema is always the element's schema.\r\n      currentSchema = containerSchema.element || def?.type;\r\n    } else {\r\n      return null; // Not a container, cannot traverse deeper.\r\n    }\r\n\r\n    if (!currentSchema) {\r\n      return null; // Path segment does not exist in the schema.\r\n    }\r\n  }\r\n\r\n  return currentSchema;\r\n}\r\nexport const shadowStateStore = new Map<string, ShadowNode>();\r\nlet globalCounter = 0;\r\nconst instanceId = Date.now().toString(36);\r\n\r\nexport function generateId(stateKey: string): string {\r\n  const prefix = 'local';\r\n\r\n  return `id:${prefix}_${instanceId}_${(globalCounter++).toString(36)}`;\r\n}\r\nexport const getGlobalStore = create<CogsGlobalState>((set, get) => ({\r\n  getPluginMetaDataMap: (\r\n    key: string,\r\n    path: string[]\r\n  ): Map<string, Record<string, any>> | undefined => {\r\n    const metadata = get().getShadowMetadata(key, path);\r\n    return metadata?.pluginMetaData;\r\n  },\r\n\r\n  setPluginMetaData: (\r\n    key: string,\r\n    path: string[], // ADD THIS PARAMETER\r\n    pluginName: string,\r\n    data: Record<string, any>\r\n  ) => {\r\n    const metadata = get().getShadowMetadata(key, path) || {}; // Use the path!\r\n    const pluginMetaData = new Map(metadata.pluginMetaData || []);\r\n    const existingData = pluginMetaData.get(pluginName) || {};\r\n    pluginMetaData.set(pluginName, { ...existingData, ...data });\r\n    get().setShadowMetadata(key, path, { ...metadata, pluginMetaData });\r\n    get().notifyPathSubscribers([key, ...path].join('.'), {\r\n      type: 'METADATA_UPDATE',\r\n    });\r\n  },\r\n  removePluginMetaData: (key: string, path: string[], pluginName: string) => {\r\n    const metadata = get().getShadowMetadata(key, path);\r\n    if (!metadata?.pluginMetaData) return;\r\n    const pluginMetaData = new Map(metadata.pluginMetaData);\r\n    pluginMetaData.delete(pluginName);\r\n    get().setShadowMetadata(key, path, { ...metadata, pluginMetaData });\r\n  },\r\n\r\n  setTransformCache: (\r\n    key: string,\r\n    path: string[],\r\n    cacheKey: string,\r\n    cacheData: any\r\n  ) => {\r\n    const metadata = get().getShadowMetadata(key, path) || {};\r\n    if (!metadata.transformCaches) {\r\n      metadata.transformCaches = new Map();\r\n    }\r\n    metadata.transformCaches.set(cacheKey, cacheData);\r\n    get().setShadowMetadata(key, path, {\r\n      transformCaches: metadata.transformCaches,\r\n    });\r\n  },\r\n  // Replace your entire `initializeAndMergeShadowState` function with this one.\r\n\r\n  initializeAndMergeShadowState: (key: string, shadowState: any) => {\r\n    const isArrayState = shadowState?._meta?.arrayKeys !== undefined;\r\n    const storageKey = isArrayState ? `[${key}` : key;\r\n\r\n    const existingRoot =\r\n      shadowStateStore.get(storageKey) ||\r\n      shadowStateStore.get(key) ||\r\n      shadowStateStore.get(`[${key}`);\r\n\r\n    // --- THIS LOGIC IS RESTORED ---\r\n    // This is vital for preserving component registrations and other top-level\r\n    // metadata across a full merge/replace, which is why removing it was a mistake.\r\n    let preservedMetadata: Partial<ShadowMetadata> = {};\r\n    if (existingRoot?._meta) {\r\n      const {\r\n        components,\r\n        features,\r\n        lastServerSync,\r\n        stateSource,\r\n        baseServerState,\r\n        pathComponents,\r\n        signals,\r\n        validation,\r\n      } = existingRoot._meta;\r\n\r\n      if (components) preservedMetadata.components = components;\r\n      if (features) preservedMetadata.features = features;\r\n      if (lastServerSync) preservedMetadata.lastServerSync = lastServerSync;\r\n      if (stateSource) preservedMetadata.stateSource = stateSource;\r\n      if (baseServerState) preservedMetadata.baseServerState = baseServerState;\r\n      if (pathComponents) preservedMetadata.pathComponents = pathComponents;\r\n      if (signals) preservedMetadata.signals = signals;\r\n      if (validation) preservedMetadata.validation = validation;\r\n    }\r\n    function deepMergeShadowNodes(target: ShadowNode, source: ShadowNode) {\r\n      // --- START: CORRECTED, MORE ROBUST METADATA MERGE ---\r\n      if (source._meta || target._meta) {\r\n        const existingMeta = target._meta || {};\r\n        const sourceMeta = source._meta || {};\r\n\r\n        // Combine metadata, letting the source overwrite simple, top-level properties.\r\n        const newMeta = { ...existingMeta, ...sourceMeta };\r\n\r\n        // CRITICAL FIX: Now, explicitly check and preserve the complex, valuable\r\n        // objects from the existing state if the incoming source state doesn't have\r\n        // an equally good or better version.\r\n\r\n        // 1. Preserve rich TypeInfo (with a schema) over a simple runtime one.\r\n        if (existingMeta.typeInfo?.schema && !sourceMeta.typeInfo?.schema) {\r\n          newMeta.typeInfo = existingMeta.typeInfo;\r\n        }\r\n\r\n        // 2. Preserve the existing validation state, which is computed and stored on the target.\r\n        // A source built from a plain object will never have this.\r\n        if (existingMeta.validation && !sourceMeta.validation) {\r\n          newMeta.validation = existingMeta.validation;\r\n        }\r\n\r\n        // 3. Preserve component registrations, which only exist on the live target state.\r\n        if (existingMeta.components) {\r\n          newMeta.components = existingMeta.components;\r\n        }\r\n\r\n        target._meta = newMeta;\r\n      }\r\n      // --- END: CORRECTED METADATA MERGE ---\r\n\r\n      // 2. Handle the node's data (primitive, array, or object).\r\n      if (source._meta?.hasOwnProperty('value')) {\r\n        // Source is a primitive. Clear any old child properties from target.\r\n        for (const key in target) {\r\n          if (key !== '_meta') delete target[key];\r\n        }\r\n        return; // Done with this branch\r\n      }\r\n\r\n      // Synchronize the data structure based on the source.\r\n      const sourceKeys = new Set(\r\n        Object.keys(source).filter((k) => k !== '_meta')\r\n      );\r\n      const targetKeys = new Set(\r\n        Object.keys(target).filter((k) => k !== '_meta')\r\n      );\r\n\r\n      // Delete keys that are in the target but no longer in the source.\r\n      for (const key of targetKeys) {\r\n        if (!sourceKeys.has(key)) {\r\n          delete target[key];\r\n        }\r\n      }\r\n\r\n      // Recursively merge or add keys from the source.\r\n      for (const key of sourceKeys) {\r\n        const sourceValue = source[key];\r\n        const targetValue = target[key];\r\n        if (\r\n          targetValue &&\r\n          typeof targetValue === 'object' &&\r\n          sourceValue &&\r\n          typeof sourceValue === 'object'\r\n        ) {\r\n          deepMergeShadowNodes(targetValue, sourceValue); // Recurse for objects\r\n        } else {\r\n          target[key] = sourceValue; // Add new or replace primitive/node\r\n        }\r\n      }\r\n    }\r\n    // --- THIS IS YOUR ORIGINAL, CORRECT MAIN LOGIC ---\r\n    if (existingRoot) {\r\n      // Merge the new shadow state into the existing one\r\n      deepMergeShadowNodes(existingRoot, shadowState);\r\n      // Restore preserved metadata\r\n      if (!existingRoot._meta) existingRoot._meta = {};\r\n      Object.assign(existingRoot._meta, preservedMetadata);\r\n      shadowStateStore.set(storageKey, existingRoot);\r\n    } else {\r\n      // The logic for when no state exists yet\r\n      if (preservedMetadata && Object.keys(preservedMetadata).length > 0) {\r\n        if (!shadowState._meta) shadowState._meta = {};\r\n        Object.assign(shadowState._meta, preservedMetadata);\r\n      }\r\n      shadowStateStore.set(storageKey, shadowState);\r\n    }\r\n\r\n    // As your logs show, this part works. It runs AFTER the merge to apply schemas.\r\n    const options = get().getInitialOptions(key);\r\n    const hasSchema =\r\n      options?.validation?.zodSchemaV4 || options?.validation?.zodSchemaV3;\r\n    if (hasSchema) {\r\n      if (options.validation?.zodSchemaV4) {\r\n        updateShadowTypeInfo(key, options.validation.zodSchemaV4, 'zod4');\r\n      } else if (options.validation?.zodSchemaV3) {\r\n        updateShadowTypeInfo(key, options.validation.zodSchemaV3, 'zod3');\r\n      }\r\n    }\r\n\r\n    // Cleanup logic is restored\r\n    if (storageKey === key) {\r\n      shadowStateStore.delete(`[${key}`);\r\n    } else {\r\n      shadowStateStore.delete(key);\r\n    }\r\n  },\r\n  initializeShadowState: (key: string, initialState: any) => {\r\n    const existingRoot =\r\n      shadowStateStore.get(key) || shadowStateStore.get(`[${key}`);\r\n    let preservedMetadata: Partial<ShadowMetadata> = {};\r\n\r\n    if (existingRoot?._meta) {\r\n      const {\r\n        components,\r\n        features,\r\n        lastServerSync,\r\n        stateSource,\r\n        baseServerState,\r\n      } = existingRoot._meta;\r\n      if (components) preservedMetadata.components = components;\r\n      if (features) preservedMetadata.features = features;\r\n      if (lastServerSync) preservedMetadata.lastServerSync = lastServerSync;\r\n      if (stateSource) preservedMetadata.stateSource = stateSource;\r\n      if (baseServerState) preservedMetadata.baseServerState = baseServerState;\r\n    }\r\n\r\n    shadowStateStore.delete(key);\r\n    shadowStateStore.delete(`[${key}`);\r\n\r\n    // Get all available schemas for this state\r\n    const options = get().getInitialOptions(key);\r\n    const syncSchemas = get().getInitialOptions('__syncSchemas');\r\n\r\n    const context: BuildContext = {\r\n      stateKey: key,\r\n      path: [],\r\n      schemas: {\r\n        sync: syncSchemas,\r\n        zodV4: options?.validation?.zodSchemaV4,\r\n        zodV3: options?.validation?.zodSchemaV3,\r\n      },\r\n    };\r\n\r\n    // Build with context so type info is stored\r\n    const newRoot = buildShadowNode(key, initialState, context);\r\n\r\n    if (!newRoot._meta) newRoot._meta = {};\r\n    Object.assign(newRoot._meta, preservedMetadata);\r\n\r\n    const storageKey = Array.isArray(initialState) ? `[${key}` : key;\r\n    shadowStateStore.set(storageKey, newRoot);\r\n  },\r\n  getShadowNode: (key: string, path: string[]): ShadowNode | undefined => {\r\n    let current: any =\r\n      shadowStateStore.get(key) || shadowStateStore.get(`[${key}`);\r\n    if (!current) return undefined;\r\n    if (path.length === 0) return current;\r\n\r\n    for (const segment of path) {\r\n      if (typeof current !== 'object' || current === null) return undefined;\r\n      current = current[segment];\r\n      if (current === undefined) return undefined;\r\n    }\r\n    return current;\r\n  },\r\n\r\n  getShadowMetadata: (\r\n    key: string,\r\n    path: string[]\r\n  ): ShadowMetadata | undefined => {\r\n    const node = get().getShadowNode(key, path);\r\n    return node?._meta;\r\n  },\r\n\r\n  setShadowMetadata: (\r\n    key: string,\r\n    path: string[],\r\n    newMetadata: Partial<ShadowMetadata>\r\n  ) => {\r\n    // Direct mutation - no cloning!\r\n    const rootKey = shadowStateStore.has(`[${key}`) ? `[${key}` : key;\r\n    let root = shadowStateStore.get(rootKey);\r\n\r\n    if (!root) {\r\n      root = { _meta: newMetadata };\r\n      shadowStateStore.set(rootKey, root);\r\n      return;\r\n    }\r\n\r\n    // Navigate to target without cloning\r\n    let current = root;\r\n    for (const segment of path) {\r\n      if (!current[segment]) {\r\n        current[segment] = {};\r\n      }\r\n      current = current[segment];\r\n    }\r\n\r\n    // Mutate metadata directly\r\n    if (!current._meta) {\r\n      current._meta = {};\r\n    }\r\n\r\n    Object.assign(current._meta, newMetadata);\r\n  },\r\n  getShadowValue: (key: string, path: string[], validArrayIds?: string[]) => {\r\n    const startNode = get().getShadowNode(key, path);\r\n\r\n    // If the path is invalid or leads nowhere, return undefined immediately.\r\n    if (!startNode) {\r\n      return undefined;\r\n    }\r\n\r\n    // --- High-Performance Iterative Materializer ---\r\n\r\n    // A single root object to hold the final, materialized result.\r\n    const rootResult: any = {};\r\n\r\n    // Stack to manage the traversal without recursion.\r\n    // Each item is [shadowNode, parentObjectInResult, keyToSetOnParent]\r\n    const stack: [ShadowNode, any, string | number][] = [\r\n      [startNode, rootResult, 'final'],\r\n    ];\r\n\r\n    while (stack.length > 0) {\r\n      const [currentNode, parentResult, resultKey] = stack.pop()!;\r\n\r\n      // 1. Handle primitive values\r\n      if (currentNode._meta?.hasOwnProperty('value')) {\r\n        parentResult[resultKey] = currentNode._meta.value;\r\n        continue; // Done with this branch\r\n      }\r\n\r\n      // 2. Handle arrays\r\n      if (currentNode._meta?.arrayKeys) {\r\n        const keysToIterate = validArrayIds || currentNode._meta.arrayKeys;\r\n        const newArray: any[] = [];\r\n        parentResult[resultKey] = newArray;\r\n\r\n        // Push children onto the stack in reverse order to process them from 0 to N\r\n        for (let i = keysToIterate.length - 1; i >= 0; i--) {\r\n          const itemKey = keysToIterate[i]!;\r\n          if (currentNode[itemKey]) {\r\n            // The child's result will be placed at index `i` in `newArray`\r\n            stack.push([currentNode[itemKey], newArray, i]);\r\n          }\r\n        }\r\n        continue; // Done with this branch\r\n      }\r\n\r\n      // 3. Handle objects\r\n      const newObject: any = {};\r\n      parentResult[resultKey] = newObject;\r\n\r\n      const objectKeys = Object.keys(currentNode);\r\n      // Push children onto the stack (order doesn't matter for objects)\r\n      for (const propKey of objectKeys) {\r\n        if (propKey !== '_meta') {\r\n          // The child's result will be set as a property on `newObject`\r\n          stack.push([currentNode[propKey], newObject, propKey]);\r\n        }\r\n      }\r\n    }\r\n\r\n    return rootResult.final;\r\n  },\r\n  updateShadowAtPath: (key, path, newValue) => {\r\n    const rootKey = shadowStateStore.has(`[${key}`) ? `[${key}` : key;\r\n    let root = shadowStateStore.get(rootKey);\r\n    if (!root) return;\r\n\r\n    let parentNode = root;\r\n    for (let i = 0; i < path.length - 1; i++) {\r\n      if (!parentNode[path[i]!]) {\r\n        parentNode[path[i]!] = {};\r\n      }\r\n      parentNode = parentNode[path[i]!];\r\n    }\r\n    const targetNode =\r\n      path.length === 0 ? parentNode : parentNode[path[path.length - 1]!];\r\n\r\n    // This function is now defined inside to close over 'key' and 'path' for context\r\n    function intelligentMerge(\r\n      nodeToUpdate: any,\r\n      plainValue: any,\r\n      currentPath: string[]\r\n    ) {\r\n      // 1. Handle primitives (but NOT arrays)\r\n      if (\r\n        typeof plainValue !== 'object' ||\r\n        plainValue === null ||\r\n        plainValue instanceof Date\r\n      ) {\r\n        const oldMeta = nodeToUpdate._meta || {};\r\n        // Clear all child properties\r\n        for (const prop in nodeToUpdate) {\r\n          if (prop !== '_meta') delete nodeToUpdate[prop];\r\n        }\r\n        // Set the new primitive value, preserving metadata\r\n        nodeToUpdate._meta = { ...oldMeta, value: plainValue };\r\n        return;\r\n      }\r\n\r\n      // 2. Handle Arrays INTELLIGENTLY\r\n      if (Array.isArray(plainValue)) {\r\n        // Ensure the target is a shadow array node\r\n        if (!nodeToUpdate._meta) nodeToUpdate._meta = {};\r\n        if (!nodeToUpdate._meta.arrayKeys) nodeToUpdate._meta.arrayKeys = [];\r\n\r\n        const existingKeys = nodeToUpdate._meta.arrayKeys;\r\n        const newValues = plainValue;\r\n\r\n        const updatedKeys: string[] = [];\r\n\r\n        // Merge existing items and add new items\r\n        for (let i = 0; i < newValues.length; i++) {\r\n          const newItemValue = newValues[i]!;\r\n          if (i < existingKeys.length) {\r\n            // Merge into existing item, preserving its key and metadata\r\n            const existingKey = existingKeys[i]!;\r\n            intelligentMerge(nodeToUpdate[existingKey], newItemValue, [\r\n              ...currentPath,\r\n              existingKey,\r\n            ]);\r\n            updatedKeys.push(existingKey);\r\n          } else {\r\n            // Add a new item\r\n            const newItemId = generateId(key);\r\n            const options = get().getInitialOptions(key);\r\n            // Build the new node WITH proper context to get schema info\r\n            const itemContext: BuildContext = {\r\n              stateKey: key,\r\n              path: [...currentPath, '0'], // Use '0' for array element schema lookup\r\n              schemas: {\r\n                zodV4: options?.validation?.zodSchemaV4,\r\n                zodV3: options?.validation?.zodSchemaV3,\r\n              },\r\n            };\r\n            nodeToUpdate[newItemId] = buildShadowNode(\r\n              key,\r\n              newItemValue,\r\n              itemContext\r\n            );\r\n            updatedKeys.push(newItemId);\r\n          }\r\n        }\r\n\r\n        // Remove deleted items\r\n        if (existingKeys.length > newValues.length) {\r\n          const keysToDelete = existingKeys.slice(newValues.length);\r\n          keysToDelete.forEach((keyToDelete: string) => {\r\n            delete nodeToUpdate[keyToDelete];\r\n          });\r\n        }\r\n\r\n        // Update the keys array to reflect the new state\r\n        nodeToUpdate._meta.arrayKeys = updatedKeys;\r\n        return;\r\n      }\r\n\r\n      // 3. Handle Objects\r\n      const plainValueKeys = new Set(Object.keys(plainValue));\r\n      if (nodeToUpdate._meta?.hasOwnProperty('value')) {\r\n        // transitioning from primitive to object, clear the value\r\n        delete nodeToUpdate._meta.value;\r\n      }\r\n\r\n      for (const propKey of plainValueKeys) {\r\n        const childValue = plainValue[propKey];\r\n        if (nodeToUpdate[propKey]) {\r\n          intelligentMerge(nodeToUpdate[propKey], childValue, [\r\n            ...currentPath,\r\n            propKey,\r\n          ]);\r\n        } else {\r\n          const options = get().getInitialOptions(key);\r\n          const itemContext: BuildContext = {\r\n            stateKey: key,\r\n            path: [...currentPath, propKey],\r\n            schemas: {\r\n              zodV4: options?.validation?.zodSchemaV4,\r\n              zodV3: options?.validation?.zodSchemaV3,\r\n            },\r\n          };\r\n          nodeToUpdate[propKey] = buildShadowNode(key, childValue, itemContext);\r\n        }\r\n      }\r\n\r\n      // Delete keys that no longer exist\r\n      for (const nodeKey in nodeToUpdate) {\r\n        if (\r\n          nodeKey === '_meta' ||\r\n          !Object.prototype.hasOwnProperty.call(nodeToUpdate, nodeKey)\r\n        )\r\n          continue;\r\n        if (!plainValueKeys.has(nodeKey)) {\r\n          delete nodeToUpdate[nodeKey];\r\n        }\r\n      }\r\n    }\r\n\r\n    if (!targetNode) {\r\n      parentNode[path[path.length - 1]!] = buildShadowNode(key, newValue); // Build fresh if no target\r\n    } else {\r\n      intelligentMerge(targetNode, newValue, path); // Use the new intelligent merge\r\n    }\r\n\r\n    get().notifyPathSubscribers([key, ...path].join('.'), {\r\n      type: 'UPDATE',\r\n      newValue,\r\n    });\r\n  },\r\n  addItemsToArrayNode: (key, arrayPath, newItems) => {\r\n    const rootKey = shadowStateStore.has(`[${key}`) ? `[${key}` : key;\r\n    let root = shadowStateStore.get(rootKey);\r\n    if (!root) {\r\n      console.error('Root not found for state key:', key);\r\n      return;\r\n    }\r\n\r\n    let current = root;\r\n    for (const segment of arrayPath) {\r\n      if (!current[segment]) {\r\n        current[segment] = {};\r\n      }\r\n      current = current[segment];\r\n    }\r\n\r\n    Object.assign(current, newItems);\r\n  },\r\n  insertShadowArrayElement: (key, arrayPath, newItem, index, itemId) => {\r\n    const arrayNode = get().getShadowNode(key, arrayPath);\r\n    if (!arrayNode?._meta?.arrayKeys) {\r\n      throw new Error(\r\n        `Array not found at path: ${[key, ...arrayPath].join('.')}`\r\n      );\r\n    }\r\n    console.log('OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO');\r\n    const newItemId = itemId || `${generateId(key)}`;\r\n\r\n    // BUILD AND ADD the node directly - no need for addItemsToArrayNode\r\n    arrayNode[newItemId] = buildShadowNode(key, newItem);\r\n\r\n    // Mutate the array directly\r\n    const currentKeys = arrayNode._meta.arrayKeys;\r\n    const insertionPoint =\r\n      index !== undefined && index >= 0 && index <= currentKeys.length\r\n        ? index\r\n        : currentKeys.length;\r\n\r\n    if (insertionPoint >= currentKeys.length) {\r\n      currentKeys.push(newItemId);\r\n    } else {\r\n      currentKeys.splice(insertionPoint, 0, newItemId);\r\n    }\r\n\r\n    // Skip addItemsToArrayNode entirely - we already did everything it does!\r\n\r\n    const arrayKey = [key, ...arrayPath].join('.');\r\n    get().notifyPathSubscribers(arrayKey, {\r\n      type: 'INSERT',\r\n      path: arrayKey,\r\n      itemKey: `${arrayKey}.${newItemId}`,\r\n      index: insertionPoint,\r\n    });\r\n\r\n    return newItemId;\r\n  },\r\n\r\n  insertManyShadowArrayElements: (key, arrayPath, newItems, index) => {\r\n    if (!newItems || newItems.length === 0) {\r\n      return;\r\n    }\r\n\r\n    const arrayNode = get().getShadowNode(key, arrayPath);\r\n    if (!arrayNode?._meta?.arrayKeys) {\r\n      console.error(\r\n        `Array not found at path: ${[key, ...arrayPath].join('.')}`\r\n      );\r\n      return;\r\n    }\r\n\r\n    const newIds: string[] = [];\r\n\r\n    // Build and add items directly\r\n    newItems.forEach((item) => {\r\n      const newItemId = `${generateId(key)}`;\r\n      newIds.push(newItemId);\r\n      arrayNode[newItemId] = buildShadowNode(key, item); // ADD DIRECTLY!\r\n    });\r\n\r\n    // Mutate the keys array\r\n    const currentKeys = arrayNode._meta.arrayKeys;\r\n    const insertionPoint =\r\n      index !== undefined && index >= 0 && index <= currentKeys.length\r\n        ? index\r\n        : currentKeys.length;\r\n\r\n    if (insertionPoint >= currentKeys.length) {\r\n      currentKeys.push(...newIds);\r\n    } else {\r\n      currentKeys.splice(insertionPoint, 0, ...newIds);\r\n    }\r\n\r\n    // NO addItemsToArrayNode call needed!\r\n\r\n    const arrayKey = [key, ...arrayPath].join('.');\r\n    get().notifyPathSubscribers(arrayKey, {\r\n      type: 'INSERT_MANY',\r\n      path: arrayKey,\r\n      count: newItems.length,\r\n      index: insertionPoint,\r\n    });\r\n  },\r\n\r\n  removeShadowArrayElement: (key, itemPath) => {\r\n    if (itemPath.length === 0) return;\r\n\r\n    const arrayPath = itemPath.slice(0, -1);\r\n    const itemId = itemPath[itemPath.length - 1];\r\n    if (!itemId?.startsWith('id:')) return;\r\n\r\n    const arrayNode = get().getShadowNode(key, arrayPath);\r\n    if (!arrayNode?._meta?.arrayKeys) return;\r\n\r\n    // Mutate directly\r\n    const currentKeys = arrayNode._meta.arrayKeys;\r\n    const indexToRemove = currentKeys.indexOf(itemId);\r\n\r\n    if (indexToRemove === -1) return;\r\n\r\n    // O(1) for removing from end\r\n    if (indexToRemove === currentKeys.length - 1) {\r\n      currentKeys.pop();\r\n    }\r\n    // O(n) for removing from beginning or middle\r\n    else if (indexToRemove === 0) {\r\n      currentKeys.shift();\r\n    } else {\r\n      currentKeys.splice(indexToRemove, 1);\r\n    }\r\n\r\n    // Delete the actual item\r\n    delete arrayNode[itemId];\r\n\r\n    // No need to update metadata - already mutated!\r\n\r\n    const arrayKey = [key, ...arrayPath].join('.');\r\n    get().notifyPathSubscribers(arrayKey, {\r\n      type: 'REMOVE',\r\n      path: arrayKey,\r\n      itemKey: `${arrayKey}.${itemId}`,\r\n    });\r\n  },\r\n\r\n  registerComponent: (stateKey, fullComponentId, registration) => {\r\n    const rootMeta = get().getShadowMetadata(stateKey, []) || {};\r\n    const components = new Map(rootMeta.components);\r\n    components.set(fullComponentId, registration);\r\n    get().setShadowMetadata(stateKey, [], { components });\r\n  },\r\n\r\n  unregisterComponent: (stateKey, fullComponentId) => {\r\n    const rootMeta = get().getShadowMetadata(stateKey, []);\r\n    if (!rootMeta?.components) return;\r\n    const components = new Map(rootMeta.components);\r\n    if (components.delete(fullComponentId)) {\r\n      get().setShadowMetadata(stateKey, [], { components });\r\n    }\r\n  },\r\n\r\n  addPathComponent: (stateKey, dependencyPath, fullComponentId) => {\r\n    const metadata = get().getShadowMetadata(stateKey, dependencyPath) || {};\r\n    const newPathComponents = new Set(metadata.pathComponents);\r\n    newPathComponents.add(fullComponentId);\r\n    get().setShadowMetadata(stateKey, dependencyPath, {\r\n      pathComponents: newPathComponents,\r\n    });\r\n\r\n    const rootMeta = get().getShadowMetadata(stateKey, []);\r\n    if (rootMeta?.components) {\r\n      const component = rootMeta.components.get(fullComponentId);\r\n      if (component) {\r\n        const fullPathKey = [stateKey, ...dependencyPath].join('.');\r\n        const newPaths = new Set(component.paths);\r\n        newPaths.add(fullPathKey);\r\n        const newComponentRegistration = { ...component, paths: newPaths };\r\n        const newComponentsMap = new Map(rootMeta.components);\r\n        newComponentsMap.set(fullComponentId, newComponentRegistration);\r\n        get().setShadowMetadata(stateKey, [], { components: newComponentsMap });\r\n      }\r\n    }\r\n  },\r\n\r\n  markAsDirty: (key, path, options = { bubble: true }) => {\r\n    // Start at the root node once.\r\n    let rootNode = get().getShadowNode(key, []);\r\n    if (!rootNode) return;\r\n\r\n    // Navigate to the target node once.\r\n    let currentNode = rootNode;\r\n    for (const segment of path) {\r\n      currentNode = currentNode[segment];\r\n      if (!currentNode) return; // Path doesn't exist, nothing to mark.\r\n    }\r\n\r\n    // Mark the target node as dirty.\r\n    if (!currentNode._meta) currentNode._meta = {};\r\n    currentNode._meta.isDirty = true;\r\n\r\n    // If bubbling is disabled, we are done.\r\n    if (!options.bubble) return;\r\n\r\n    // Efficiently bubble up using the path segments.\r\n    let parentNode = rootNode;\r\n    for (let i = 0; i < path.length; i++) {\r\n      // The current node in the loop is the parent of the next one.\r\n      if (parentNode._meta?.isDirty) {\r\n        // Optimization: If a parent is already dirty, all of its ancestors are too.\r\n        // We can stop bubbling immediately.\r\n        return;\r\n      }\r\n      if (!parentNode._meta) parentNode._meta = {};\r\n      parentNode._meta.isDirty = true;\r\n      parentNode = parentNode[path[i]!];\r\n    }\r\n  },\r\n\r\n  // Keep these in Zustand as they need React reactivity\r\n  serverStateUpdates: new Map(),\r\n  setServerStateUpdate: (key, serverState) => {\r\n    set((state) => ({\r\n      serverStateUpdates: new Map(state.serverStateUpdates).set(\r\n        key,\r\n        serverState\r\n      ),\r\n    }));\r\n    get().notifyPathSubscribers(key, {\r\n      type: 'SERVER_STATE_UPDATE',\r\n      serverState,\r\n    });\r\n  },\r\n\r\n  pathSubscribers: new Map<string, Set<(newValue: any) => void>>(),\r\n  subscribeToPath: (path, callback) => {\r\n    const subscribers = get().pathSubscribers;\r\n    const subsForPath = subscribers.get(path) || new Set();\r\n    subsForPath.add(callback);\r\n    subscribers.set(path, subsForPath);\r\n\r\n    return () => {\r\n      const currentSubs = get().pathSubscribers.get(path);\r\n      if (currentSubs) {\r\n        currentSubs.delete(callback);\r\n        if (currentSubs.size === 0) {\r\n          get().pathSubscribers.delete(path);\r\n        }\r\n      }\r\n    };\r\n  },\r\n\r\n  notifyPathSubscribers: (updatedPath, newValue) => {\r\n    const subscribers = get().pathSubscribers;\r\n    const subs = subscribers.get(updatedPath);\r\n    if (subs) {\r\n      subs.forEach((callback) => callback(newValue));\r\n    }\r\n  },\r\n\r\n  selectedIndicesMap: new Map<string, string>(),\r\n  getSelectedIndex: (arrayKey, validIds) => {\r\n    const itemKey = get().selectedIndicesMap.get(arrayKey);\r\n    if (!itemKey) return -1;\r\n\r\n    const arrayMeta = get().getShadowMetadata(\r\n      arrayKey.split('.')[0]!,\r\n      arrayKey.split('.').slice(1)\r\n    );\r\n    const arrayKeys = validIds || arrayMeta?.arrayKeys;\r\n\r\n    return arrayKeys ? arrayKeys.indexOf(itemKey) : -1;\r\n  },\r\n\r\n  setSelectedIndex: (arrayKey: string, itemKey: string | undefined) => {\r\n    set((state) => {\r\n      const newMap = new Map(state.selectedIndicesMap);\r\n\r\n      if (itemKey === undefined) {\r\n        newMap.delete(arrayKey);\r\n      } else {\r\n        if (newMap.has(arrayKey)) {\r\n          get().notifyPathSubscribers(newMap.get(arrayKey)!, {\r\n            type: 'THIS_UNSELECTED',\r\n          });\r\n        }\r\n        newMap.set(arrayKey, itemKey);\r\n        get().notifyPathSubscribers(itemKey, { type: 'THIS_SELECTED' });\r\n      }\r\n\r\n      get().notifyPathSubscribers(arrayKey, { type: 'GET_SELECTED' });\r\n\r\n      return {\r\n        ...state,\r\n        selectedIndicesMap: newMap,\r\n      };\r\n    });\r\n  },\r\n\r\n  clearSelectedIndex: ({ arrayKey }: { arrayKey: string }): void => {\r\n    set((state) => {\r\n      const newMap = new Map(state.selectedIndicesMap);\r\n      const actualKey = newMap.get(arrayKey);\r\n      if (actualKey) {\r\n        get().notifyPathSubscribers(actualKey, {\r\n          type: 'CLEAR_SELECTION',\r\n        });\r\n      }\r\n\r\n      newMap.delete(arrayKey);\r\n      get().notifyPathSubscribers(arrayKey, {\r\n        type: 'CLEAR_SELECTION',\r\n      });\r\n      return {\r\n        ...state,\r\n        selectedIndicesMap: newMap,\r\n      };\r\n    });\r\n  },\r\n\r\n  clearSelectedIndexesForState: (stateKey) => {\r\n    set((state) => {\r\n      const newMap = new Map(state.selectedIndicesMap);\r\n      let changed = false;\r\n      for (const key of newMap.keys()) {\r\n        if (key === stateKey || key.startsWith(stateKey + '.')) {\r\n          newMap.delete(key);\r\n          changed = true;\r\n        }\r\n      }\r\n      return changed ? { selectedIndicesMap: newMap } : {};\r\n    });\r\n  },\r\n\r\n  initialStateOptions: {},\r\n  stateLog: new Map(),\r\n  initialStateGlobal: {},\r\n\r\n  addStateLog: (updates) => {\r\n    if (!updates || updates.length === 0) return;\r\n    set((state) => {\r\n      const newLog = new Map(state.stateLog);\r\n      const logsGroupedByKey = new Map<string, UpdateTypeDetail[]>();\r\n      for (const update of updates) {\r\n        const group = logsGroupedByKey.get(update.stateKey) || [];\r\n        group.push(update);\r\n        logsGroupedByKey.set(update.stateKey, group);\r\n      }\r\n      for (const [key, batchOfUpdates] of logsGroupedByKey.entries()) {\r\n        const newStateLogForKey = new Map(newLog.get(key));\r\n        for (const update of batchOfUpdates) {\r\n          newStateLogForKey.set(JSON.stringify(update.path), { ...update });\r\n        }\r\n        newLog.set(key, newStateLogForKey);\r\n      }\r\n      return { stateLog: newLog };\r\n    });\r\n  },\r\n\r\n  getInitialOptions: (key) => get().initialStateOptions[key],\r\n  setInitialStateOptions: (key, value) => {\r\n    set((prev) => ({\r\n      initialStateOptions: { ...prev.initialStateOptions, [key]: value },\r\n    }));\r\n  },\r\n\r\n  updateInitialStateGlobal: (key, newState) => {\r\n    set((prev) => ({\r\n      initialStateGlobal: { ...prev.initialStateGlobal, [key]: newState },\r\n    }));\r\n  },\r\n\r\n  syncInfoStore: new Map<string, SyncInfo>(),\r\n  setSyncInfo: (key, syncInfo) =>\r\n    set((state) => {\r\n      const newMap = new Map(state.syncInfoStore);\r\n      newMap.set(key, syncInfo);\r\n      return { syncInfoStore: newMap };\r\n    }),\r\n  getSyncInfo: (key) => get().syncInfoStore.get(key) || null,\r\n}));\r\n"],"names":["getTypeFromZodSchema","schema","source","current","isNullable","isOptional","defaultValue","hasDefault","i","def","typeIdentifier","nextSchema","baseSchema","baseDef","baseType","getTypeFromValue","value","valueType","buildShadowNode","stateKey","context","node","getTypeInfoForPath","item","index","itemId","generateId","itemContext","key","propContext","typeInfo","getSchemaAtPath","updateShadowTypeInfo","rootSchema","rootNode","shadowStateStore","updateNodeTypeInfo","path","fieldSchema","itemKey","unwrapSchema","currentSchema","segment","containerSchema","globalCounter","instanceId","getGlobalStore","create","set","get","pluginName","data","metadata","pluginMetaData","existingData","cacheKey","cacheData","shadowState","storageKey","existingRoot","preservedMetadata","components","features","lastServerSync","stateSource","baseServerState","pathComponents","signals","validation","deepMergeShadowNodes","target","existingMeta","sourceMeta","newMeta","sourceKeys","k","targetKeys","sourceValue","targetValue","options","initialState","syncSchemas","newRoot","newMetadata","rootKey","root","validArrayIds","startNode","rootResult","stack","currentNode","parentResult","resultKey","keysToIterate","newArray","newObject","objectKeys","propKey","newValue","parentNode","targetNode","intelligentMerge","nodeToUpdate","plainValue","currentPath","oldMeta","prop","existingKeys","newValues","updatedKeys","newItemValue","existingKey","newItemId","keyToDelete","plainValueKeys","childValue","nodeKey","arrayPath","newItems","newItem","arrayNode","currentKeys","insertionPoint","arrayKey","newIds","itemPath","indexToRemove","fullComponentId","registration","rootMeta","dependencyPath","newPathComponents","component","fullPathKey","newPaths","newComponentRegistration","newComponentsMap","serverState","state","callback","subscribers","subsForPath","currentSubs","updatedPath","subs","validIds","arrayMeta","arrayKeys","newMap","actualKey","changed","updates","newLog","logsGroupedByKey","update","group","batchOfUpdates","newStateLogForKey","prev","newState","syncInfo"],"mappings":"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"}