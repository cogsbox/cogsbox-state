{"version":3,"file":"store.js","sources":["../src/store.ts"],"sourcesContent":["import { create } from 'zustand';\r\nimport { ulid } from 'ulid';\r\nimport type {\r\n  OptionsType,\r\n  ReactivityType,\r\n  SyncInfo,\r\n  UpdateTypeDetail,\r\n} from './CogsState.js';\r\n\r\nimport { type ReactNode } from 'react';\r\n\r\nexport type FreshValuesObject = {\r\n  pathsToValues?: string[];\r\n  prevValue?: any;\r\n  newValue?: any;\r\n  timeStamp: number;\r\n};\r\n\r\ntype StateValue = any;\r\n\r\nexport type TrieNode = {\r\n  subscribers: Set<string>;\r\n  children: Map<string, TrieNode>;\r\n};\r\n\r\nexport type FormRefStoreState = {\r\n  formRefs: Map<string, React.RefObject<any>>;\r\n  registerFormRef: (id: string, ref: React.RefObject<any>) => void;\r\n  getFormRef: (id: string) => React.RefObject<any> | undefined;\r\n  removeFormRef: (id: string) => void;\r\n  getFormRefsByStateKey: (\r\n    stateKey: string\r\n  ) => Map<string, React.RefObject<any>>;\r\n};\r\n\r\nexport const formRefStore = create<FormRefStoreState>((set, get) => ({\r\n  formRefs: new Map(),\r\n\r\n  registerFormRef: (id, ref) =>\r\n    set((state) => {\r\n      const newRefs = new Map(state.formRefs);\r\n      newRefs.set(id, ref);\r\n      return { formRefs: newRefs };\r\n    }),\r\n\r\n  getFormRef: (id) => get().formRefs.get(id),\r\n\r\n  removeFormRef: (id) =>\r\n    set((state) => {\r\n      const newRefs = new Map(state.formRefs);\r\n      newRefs.delete(id);\r\n      return { formRefs: newRefs };\r\n    }),\r\n\r\n  getFormRefsByStateKey: (stateKey) => {\r\n    const allRefs = get().formRefs;\r\n    const stateKeyPrefix = stateKey + '.';\r\n    const filteredRefs = new Map();\r\n\r\n    allRefs.forEach((ref, id) => {\r\n      if (id.startsWith(stateKeyPrefix) || id === stateKey) {\r\n        filteredRefs.set(id, ref);\r\n      }\r\n    });\r\n\r\n    return filteredRefs;\r\n  },\r\n}));\r\nexport type ComponentsType = {\r\n  components?: Map<\r\n    string,\r\n    {\r\n      forceUpdate: () => void;\r\n      paths: Set<string>;\r\n      deps?: any[];\r\n      prevDeps?: any[];\r\n      depsFunction?: (state: any) => any[] | true;\r\n      reactiveType: ReactivityType[] | ReactivityType;\r\n    }\r\n  >;\r\n};\r\n\r\nexport type ValidationStatus =\r\n  | 'NOT_VALIDATED'\r\n  | 'VALIDATING'\r\n  | 'VALID'\r\n  | 'INVALID';\r\n\r\nexport type ValidationError = {\r\n  source: 'client' | 'sync_engine' | 'api';\r\n  message: string;\r\n  severity: 'warning' | 'error';\r\n  code?: string;\r\n};\r\n\r\nexport type ValidationState = {\r\n  status: ValidationStatus;\r\n  errors: ValidationError[];\r\n  lastValidated?: number;\r\n  validatedValue?: any;\r\n};\r\n\r\nexport type ShadowMetadata = {\r\n  id?: string;\r\n  stateSource?: 'default' | 'server' | 'localStorage';\r\n  lastServerSync?: number;\r\n  isDirty?: boolean;\r\n  baseServerState?: any;\r\n  arrayKeys?: string[];\r\n  fields?: Record<string, any>;\r\n  virtualizer?: {\r\n    itemHeight?: number;\r\n    domRef?: HTMLElement | null;\r\n  };\r\n  syncInfo?: { status: string };\r\n  validation?: ValidationState;\r\n  features?: {\r\n    syncEnabled: boolean;\r\n    validationEnabled: boolean;\r\n    localStorageEnabled: boolean;\r\n  };\r\n  lastUpdated?: number;\r\n  signals?: Array<{\r\n    instanceId: string;\r\n    parentId: string;\r\n    position: number;\r\n    effect?: string;\r\n  }>;\r\n  mapWrappers?: Array<{\r\n    instanceId: string;\r\n    path: string[];\r\n    componentId: string;\r\n    meta?: any;\r\n    mapFn: (setter: any, index: number, arraySetter: any) => ReactNode;\r\n    containerRef: HTMLDivElement | null;\r\n    rebuildStateShape: any;\r\n  }>;\r\n  transformCaches?: Map<\r\n    string,\r\n    {\r\n      validIds: string[];\r\n      computedAt: number;\r\n      transforms: Array<{ type: 'filter' | 'sort'; fn: Function }>;\r\n    }\r\n  >;\r\n  pathComponents?: Set<string>;\r\n  streams?: Map<\r\n    string,\r\n    {\r\n      buffer: any[];\r\n      flushTimer: NodeJS.Timeout | null;\r\n    }\r\n  >;\r\n} & ComponentsType;\r\n\r\ntype ShadowNode = {\r\n  value?: any;\r\n  _meta?: ShadowMetadata;\r\n  [key: string]: any;\r\n};\r\n\r\nexport type CogsGlobalState = {\r\n  // NEW shadow store\r\n  shadowStateStore: Map<string, ShadowNode>;\r\n  setTransformCache: (\r\n    key: string,\r\n    path: string[],\r\n    cacheKey: string,\r\n    cacheData: any\r\n  ) => void;\r\n  initializeShadowState: (key: string, initialState: any) => void;\r\n  getShadowNode: (key: string, path: string[]) => ShadowNode | undefined;\r\n  getShadowMetadata: (\r\n    key: string,\r\n    path: string[]\r\n  ) => ShadowMetadata | undefined;\r\n\r\n  setShadowMetadata: (key: string, path: string[], metadata: any) => void;\r\n  getShadowValue: (\r\n    key: string,\r\n    path: string[],\r\n    validArrayIds?: string[],\r\n    log?: boolean\r\n  ) => any;\r\n  updateShadowAtPath: (key: string, path: string[], newValue: any) => void;\r\n  insertManyShadowArrayElements: (\r\n    key: string,\r\n    arrayPath: string[],\r\n    newItems: any[],\r\n    index?: number\r\n  ) => void;\r\n  addItemsToArrayNode: (\r\n    key: string,\r\n    arrayPath: string[],\r\n    newItems: any,\r\n    newKeys: string[]\r\n  ) => void;\r\n  insertShadowArrayElement: (\r\n    key: string,\r\n    arrayPath: string[],\r\n    newItem: any,\r\n    index?: number\r\n  ) => void;\r\n  removeShadowArrayElement: (key: string, itemPath: string[]) => void;\r\n  registerComponent: (\r\n    stateKey: string,\r\n    componentId: string,\r\n    registration: any\r\n  ) => void;\r\n  unregisterComponent: (stateKey: string, componentId: string) => void;\r\n  addPathComponent: (\r\n    stateKey: string,\r\n    dependencyPath: string[],\r\n    fullComponentId: string\r\n  ) => void;\r\n  markAsDirty: (\r\n    key: string,\r\n    path: string[],\r\n    options: { bubble: boolean }\r\n  ) => void;\r\n\r\n  pathSubscribers: Map<string, Set<(newValue: any) => void>>;\r\n  subscribeToPath: (\r\n    path: string,\r\n    callback: (newValue: any) => void\r\n  ) => () => void;\r\n  notifyPathSubscribers: (updatedPath: string, newValue: any) => void;\r\n\r\n  selectedIndicesMap: Map<string, string>; // stateKey -> (parentPath -> selectedIndex)\r\n  getSelectedIndex: (stateKey: string, validArrayIds?: string[]) => number;\r\n  setSelectedIndex: (key: string, itemKey: string) => void;\r\n  clearSelectedIndex: ({ arrayKey }: { arrayKey: string }) => void;\r\n  clearSelectedIndexesForState: (stateKey: string) => void;\r\n\r\n  initialStateOptions: { [key: string]: OptionsType };\r\n  initialStateGlobal: { [key: string]: StateValue };\r\n  updateInitialStateGlobal: (key: string, newState: StateValue) => void;\r\n\r\n  getInitialOptions: (key: string) => OptionsType | undefined;\r\n  setInitialStateOptions: (key: string, value: OptionsType) => void;\r\n\r\n  serverStateUpdates: Map<\r\n    string,\r\n    {\r\n      data: any;\r\n      status: 'loading' | 'success' | 'error';\r\n      timestamp: number;\r\n    }\r\n  >;\r\n\r\n  setServerStateUpdate: (key: string, serverState: any) => void;\r\n\r\n  stateLog: Map<string, Map<string, UpdateTypeDetail>>;\r\n  syncInfoStore: Map<string, SyncInfo>;\r\n  addStateLog: (updates: UpdateTypeDetail[]) => void;\r\n\r\n  setSyncInfo: (key: string, syncInfo: SyncInfo) => void;\r\n  getSyncInfo: (key: string) => SyncInfo | null;\r\n};\r\n\r\nexport function buildShadowNode(value: any): ShadowNode {\r\n  if (value === null || typeof value !== 'object') {\r\n    return { value };\r\n  }\r\n\r\n  if (Array.isArray(value)) {\r\n    const arrayNode: ShadowNode = { _meta: { arrayKeys: [] } };\r\n    const idKeys: string[] = [];\r\n\r\n    value.forEach((item) => {\r\n      const itemId = `id:${ulid()}`;\r\n      arrayNode[itemId] = buildShadowNode(item);\r\n      idKeys.push(itemId);\r\n    });\r\n\r\n    arrayNode._meta!.arrayKeys = idKeys;\r\n    return arrayNode;\r\n  }\r\n\r\n  if (value.constructor === Object) {\r\n    const objectNode: ShadowNode = { _meta: {} };\r\n    for (const key in value) {\r\n      if (Object.prototype.hasOwnProperty.call(value, key)) {\r\n        objectNode[key] = buildShadowNode(value[key]);\r\n      }\r\n    }\r\n    return objectNode;\r\n  }\r\n\r\n  return { value };\r\n}\r\n\r\nexport const getGlobalStore = create<CogsGlobalState>((set, get) => ({\r\n  shadowStateStore: new Map<string, ShadowNode>(),\r\n\r\n  setTransformCache: (\r\n    key: string,\r\n    path: string[],\r\n    cacheKey: string,\r\n    cacheData: any\r\n  ) => {\r\n    const metadata = get().getShadowMetadata(key, path) || {};\r\n    if (!metadata.transformCaches) {\r\n      metadata.transformCaches = new Map();\r\n    }\r\n    metadata.transformCaches.set(cacheKey, cacheData);\r\n    get().setShadowMetadata(key, path, {\r\n      transformCaches: metadata.transformCaches,\r\n    });\r\n  },\r\n  initializeShadowState: (key: string, initialState: any) => {\r\n    set((state) => {\r\n      const newShadowStore = new Map(state.shadowStateStore);\r\n\r\n      // Get existing metadata more efficiently\r\n      const existingRoot =\r\n        newShadowStore.get(key) || newShadowStore.get(`[${key}`);\r\n\r\n      // Only preserve necessary metadata\r\n      let preservedMetadata: Partial<ShadowMetadata> | undefined;\r\n      if (existingRoot?._meta) {\r\n        const {\r\n          components,\r\n          features,\r\n          lastServerSync,\r\n          stateSource,\r\n          baseServerState,\r\n        } = existingRoot._meta;\r\n\r\n        // Only create object if we have something to preserve\r\n        if (\r\n          components ||\r\n          features ||\r\n          lastServerSync ||\r\n          stateSource ||\r\n          baseServerState\r\n        ) {\r\n          preservedMetadata = {};\r\n          if (components) preservedMetadata.components = components;\r\n          if (features) preservedMetadata.features = features;\r\n          if (lastServerSync) preservedMetadata.lastServerSync = lastServerSync;\r\n          if (stateSource) preservedMetadata.stateSource = stateSource;\r\n          if (baseServerState)\r\n            preservedMetadata.baseServerState = baseServerState;\r\n        }\r\n      }\r\n\r\n      // Clear old entries\r\n      newShadowStore.delete(key);\r\n      newShadowStore.delete(`[${key}`);\r\n\r\n      // Build new state\r\n      const newRoot = buildShadowNode(initialState);\r\n\r\n      // Only merge metadata if needed\r\n      if (preservedMetadata) {\r\n        if (!newRoot._meta) newRoot._meta = {};\r\n        Object.assign(newRoot._meta, preservedMetadata);\r\n      }\r\n\r\n      // Use correct key based on type\r\n      const storageKey = Array.isArray(initialState) ? `[${key}` : key;\r\n      newShadowStore.set(storageKey, newRoot);\r\n\r\n      return { shadowStateStore: newShadowStore };\r\n    });\r\n  },\r\n\r\n  getShadowNode: (key: string, path: string[]): ShadowNode | undefined => {\r\n    const store = get().shadowStateStore;\r\n\r\n    // Fast path for root access (common case)\r\n    if (path.length === 0) {\r\n      return store.get(key) || store.get(`[${key}`);\r\n    }\r\n\r\n    let current: any = store.get(key) || store.get(`[${key}`);\r\n    if (!current) return undefined;\r\n\r\n    // Use for loop instead of for...of for better performance\r\n    for (let i = 0; i < path.length; i++) {\r\n      if (typeof current !== 'object' || current === null) return undefined;\r\n      current = current[path[i]!];\r\n      if (current === undefined) return undefined;\r\n    }\r\n    return current;\r\n  },\r\n  getShadowMetadata: (\r\n    key: string,\r\n    path: string[]\r\n  ): ShadowMetadata | undefined => {\r\n    const node = get().getShadowNode(key, path);\r\n    return node?._meta;\r\n  },\r\n\r\n  setShadowMetadata: (\r\n    key: string,\r\n    path: string[],\r\n    newMetadata: Partial<ShadowMetadata>\r\n  ) => {\r\n    set((state) => {\r\n      const newStore = new Map(state.shadowStateStore);\r\n      const rootKey = newStore.has(`[${key}`) ? `[${key}` : key;\r\n      let root = newStore.get(rootKey);\r\n\r\n      if (!root) {\r\n        // Create root only if needed\r\n        root = { _meta: newMetadata };\r\n        newStore.set(rootKey, root);\r\n        return { shadowStateStore: newStore };\r\n      }\r\n\r\n      // Special case for root metadata (common)\r\n      if (path.length === 0) {\r\n        const clonedRoot = { ...root };\r\n        clonedRoot._meta = { ...(root._meta || {}), ...newMetadata };\r\n        newStore.set(rootKey, clonedRoot);\r\n        return { shadowStateStore: newStore };\r\n      }\r\n\r\n      // Clone path - optimized to only clone what changes\r\n      const clonedRoot: any = { ...root };\r\n      newStore.set(rootKey, clonedRoot);\r\n\r\n      let current = clonedRoot;\r\n      for (let i = 0; i < path.length; i++) {\r\n        const segment = path[i]!;\r\n        // Only clone if exists, create minimal object otherwise\r\n        if (current[segment]) {\r\n          current[segment] = { ...current[segment] };\r\n        } else {\r\n          current[segment] =\r\n            i === path.length - 1\r\n              ? { _meta: {} } // Last segment, prepare for metadata\r\n              : {}; // Intermediate segment\r\n        }\r\n        current = current[segment];\r\n      }\r\n\r\n      // Merge metadata efficiently\r\n      current._meta = current._meta\r\n        ? { ...current._meta, ...newMetadata }\r\n        : newMetadata;\r\n\r\n      return { shadowStateStore: newStore };\r\n    });\r\n  },\r\n  getShadowValue: (\r\n    key: string,\r\n    path: string[],\r\n    validArrayIds?: string[],\r\n    log?: boolean\r\n  ) => {\r\n    const node = get().getShadowNode(key, path);\r\n\r\n    if (node === null || node === undefined) return undefined;\r\n\r\n    const nodeKeys = Object.keys(node);\r\n\r\n    // Check if it's a primitive wrapper - must match original logic exactly\r\n    const isPrimitiveWrapper =\r\n      Object.prototype.hasOwnProperty.call(node, 'value') &&\r\n      nodeKeys.every((k) => k === 'value' || k === '_meta');\r\n\r\n    if (isPrimitiveWrapper) {\r\n      return node.value;\r\n    }\r\n\r\n    // Array check - more efficient with early check\r\n    const isArrayNode =\r\n      node._meta &&\r\n      Object.prototype.hasOwnProperty.call(node._meta, 'arrayKeys');\r\n\r\n    if (isArrayNode) {\r\n      const keysToIterate =\r\n        validArrayIds !== undefined && validArrayIds.length > 0\r\n          ? validArrayIds\r\n          : node._meta!.arrayKeys!;\r\n\r\n      // Pre-allocate array for better performance\r\n      const result = new Array(keysToIterate.length);\r\n      for (let i = 0; i < keysToIterate.length; i++) {\r\n        result[i] = get().getShadowValue(key, [...path, keysToIterate[i]!]);\r\n      }\r\n      return result;\r\n    }\r\n\r\n    // Object reconstruction - optimized with for...in\r\n    const result: any = {};\r\n    for (const propKey in node) {\r\n      if (\r\n        propKey !== '_meta' &&\r\n        !propKey.startsWith('id:') &&\r\n        Object.prototype.hasOwnProperty.call(node, propKey)\r\n      ) {\r\n        result[propKey] = get().getShadowValue(key, [...path, propKey]);\r\n      }\r\n    }\r\n    return result;\r\n  },\r\n\r\n  updateShadowAtPath: (key, path, newValue) => {\r\n    set((state) => {\r\n      const newStore = new Map(state.shadowStateStore);\r\n      const rootKey = newStore.has(`[${key}`) ? `[${key}` : key;\r\n      let root = newStore.get(rootKey);\r\n      if (!root) return state;\r\n\r\n      // Clone the root and navigate to target\r\n      const clonedRoot: any = { ...root };\r\n      newStore.set(rootKey, clonedRoot);\r\n\r\n      // For root-level updates (path.length === 0)\r\n      if (path.length === 0) {\r\n        const oldMeta = root._meta;\r\n        const newRoot = buildShadowNode(newValue);\r\n        if (oldMeta) {\r\n          newRoot._meta = { ...oldMeta, ...(newRoot._meta || {}) };\r\n        }\r\n        newStore.set(rootKey, newRoot);\r\n\r\n        get().notifyPathSubscribers(key, {\r\n          type: 'UPDATE',\r\n          newValue,\r\n        });\r\n        return { shadowStateStore: newStore };\r\n      }\r\n\r\n      // Navigate to parent of target, cloning only what we need\r\n      let current = clonedRoot;\r\n      const pathLength = path.length;\r\n\r\n      for (let i = 0; i < pathLength - 1; i++) {\r\n        const segment = path[i]!;\r\n        current[segment] = current[segment] ? { ...current[segment] } : {};\r\n        current = current[segment];\r\n      }\r\n\r\n      const lastSegment = path[pathLength - 1]!;\r\n      const targetNode = current[lastSegment];\r\n\r\n      // FAST PATH: Primitives, null, undefined, or arrays (no merge needed)\r\n      if (\r\n        newValue === null ||\r\n        newValue === undefined ||\r\n        typeof newValue !== 'object' ||\r\n        Array.isArray(newValue) ||\r\n        !targetNode ||\r\n        Array.isArray(targetNode._meta?.arrayKeys)\r\n      ) {\r\n        // Simple replacement - just preserve metadata\r\n        const oldMeta = targetNode?._meta;\r\n        const newNode = buildShadowNode(newValue);\r\n        if (oldMeta) {\r\n          if (newNode._meta) {\r\n            newNode._meta = { ...oldMeta, ...newNode._meta };\r\n          } else {\r\n            newNode._meta = oldMeta;\r\n          }\r\n        }\r\n        current[lastSegment] = newNode;\r\n      }\r\n      // MERGE PATH: Only for object-to-object updates\r\n      else {\r\n        const mergedNode = { ...targetNode };\r\n        current[lastSegment] = mergedNode;\r\n\r\n        // Preserve metadata\r\n        if (targetNode._meta) {\r\n          mergedNode._meta = targetNode._meta;\r\n        }\r\n\r\n        // Build a Set for O(1) lookups\r\n        const newKeysSet = new Set(Object.keys(newValue));\r\n\r\n        // Remove old keys not in newValue (single pass)\r\n        for (const key in mergedNode) {\r\n          if (key !== '_meta' && !newKeysSet.has(key)) {\r\n            delete mergedNode[key];\r\n          }\r\n        }\r\n\r\n        // Add/update new keys (single pass)\r\n        for (const key of newKeysSet) {\r\n          mergedNode[key] = buildShadowNode(newValue[key]);\r\n        }\r\n      }\r\n\r\n      get().notifyPathSubscribers([key, ...path].join('.'), {\r\n        type: 'UPDATE',\r\n        newValue,\r\n      });\r\n\r\n      return { shadowStateStore: newStore };\r\n    });\r\n  },\r\n  addItemsToArrayNode: (key, arrayPath, newItems, newKeys) => {\r\n    set((state) => {\r\n      const newStore = new Map(state.shadowStateStore);\r\n      const rootKey = newStore.has(`[${key}`) ? `[${key}` : key;\r\n      let root = newStore.get(rootKey);\r\n      if (!root) {\r\n        console.error('Root not found for state key:', key);\r\n        return state;\r\n      }\r\n\r\n      const clonedRoot = { ...root };\r\n      newStore.set(rootKey, clonedRoot);\r\n\r\n      let current = clonedRoot;\r\n      for (const segment of arrayPath) {\r\n        const nextNode = current[segment] || {};\r\n        current[segment] = { ...nextNode };\r\n        current = current[segment];\r\n      }\r\n\r\n      Object.assign(current, newItems);\r\n      current._meta = { ...(current._meta || {}), arrayKeys: newKeys };\r\n\r\n      return { shadowStateStore: newStore };\r\n    });\r\n  },\r\n\r\n  insertShadowArrayElement: (key, arrayPath, newItem, index) => {\r\n    const arrayNode = get().getShadowNode(key, arrayPath);\r\n    if (!arrayNode?._meta?.arrayKeys) {\r\n      console.error(\r\n        `Array not found at path: ${[key, ...arrayPath].join('.')}`\r\n      );\r\n      return;\r\n    }\r\n\r\n    const newItemId = `id:${ulid()}`;\r\n    const itemsToAdd = { [newItemId]: buildShadowNode(newItem) };\r\n\r\n    const currentKeys = arrayNode._meta.arrayKeys;\r\n    const newKeys = [...currentKeys];\r\n    const insertionPoint =\r\n      index !== undefined && index >= 0 && index <= newKeys.length\r\n        ? index\r\n        : newKeys.length;\r\n    newKeys.splice(insertionPoint, 0, newItemId);\r\n\r\n    get().addItemsToArrayNode(key, arrayPath, itemsToAdd, newKeys);\r\n\r\n    const arrayKey = [key, ...arrayPath].join('.');\r\n    get().notifyPathSubscribers(arrayKey, {\r\n      type: 'INSERT',\r\n      path: arrayKey,\r\n      itemKey: `${arrayKey}.${newItemId}`,\r\n      index: insertionPoint,\r\n    });\r\n  },\r\n  insertManyShadowArrayElements: (\r\n    key: string,\r\n    arrayPath: string[],\r\n    newItems: any[],\r\n    index?: number\r\n  ) => {\r\n    if (!newItems || newItems.length === 0) return;\r\n\r\n    const arrayNode = get().getShadowNode(key, arrayPath);\r\n    if (!arrayNode?._meta?.arrayKeys) {\r\n      console.error(\r\n        `Array not found at path: ${[key, ...arrayPath].join('.')}`\r\n      );\r\n      return;\r\n    }\r\n\r\n    // Pre-allocate objects for better performance\r\n    const itemsToAdd: Record<string, any> = Object.create(null);\r\n    const newIds = new Array(newItems.length);\r\n\r\n    // Generate all IDs and build nodes in one pass\r\n    for (let i = 0; i < newItems.length; i++) {\r\n      const newItemId = `id:${ulid()}`;\r\n      newIds[i] = newItemId;\r\n      itemsToAdd[newItemId] = buildShadowNode(newItems[i]);\r\n    }\r\n\r\n    // Efficient array concatenation\r\n    const currentKeys = arrayNode._meta.arrayKeys;\r\n    const insertionPoint =\r\n      index !== undefined && index >= 0 && index <= currentKeys.length\r\n        ? index\r\n        : currentKeys.length;\r\n\r\n    // Use spread operator for better performance with small arrays\r\n    // For large arrays, consider using concat\r\n    const finalKeys = [\r\n      ...currentKeys.slice(0, insertionPoint),\r\n      ...newIds,\r\n      ...currentKeys.slice(insertionPoint),\r\n    ];\r\n\r\n    get().addItemsToArrayNode(key, arrayPath, itemsToAdd, finalKeys);\r\n\r\n    // Single notification\r\n    const arrayKey = [key, ...arrayPath].join('.');\r\n    get().notifyPathSubscribers(arrayKey, {\r\n      type: 'INSERT_MANY',\r\n      path: arrayKey,\r\n      count: newItems.length,\r\n      index: insertionPoint,\r\n    });\r\n  },\r\n\r\n  removeShadowArrayElement: (key, itemPath) => {\r\n    if (itemPath.length === 0) return;\r\n\r\n    const arrayPath = itemPath.slice(0, -1);\r\n    const itemId = itemPath[itemPath.length - 1];\r\n    if (!itemId?.startsWith('id:')) return;\r\n\r\n    const arrayNode = get().getShadowNode(key, arrayPath);\r\n    if (!arrayNode?._meta?.arrayKeys) return;\r\n\r\n    const newKeys = arrayNode._meta.arrayKeys.filter((k) => k !== itemId);\r\n    delete arrayNode[itemId];\r\n\r\n    get().setShadowMetadata(key, arrayPath, { arrayKeys: newKeys });\r\n\r\n    const arrayKey = [key, ...arrayPath].join('.');\r\n    get().notifyPathSubscribers(arrayKey, {\r\n      type: 'REMOVE',\r\n      path: arrayKey,\r\n      itemKey: `${arrayKey}.${itemId}`,\r\n    });\r\n  },\r\n\r\n  addPathComponent: (\r\n    stateKey: string,\r\n    dependencyPath: string[],\r\n    fullComponentId: string\r\n  ) => {\r\n    const metadata = get().getShadowMetadata(stateKey, dependencyPath) || {};\r\n\r\n    // Only clone and update if component not already added\r\n    if (!metadata.pathComponents?.has(fullComponentId)) {\r\n      const newPathComponents = new Set(metadata.pathComponents);\r\n      newPathComponents.add(fullComponentId);\r\n\r\n      get().setShadowMetadata(stateKey, dependencyPath, {\r\n        pathComponents: newPathComponents,\r\n      });\r\n\r\n      // Update component's paths\r\n      const rootMeta = get().getShadowMetadata(stateKey, []);\r\n      if (rootMeta?.components) {\r\n        const component = rootMeta.components.get(fullComponentId);\r\n        if (\r\n          component &&\r\n          !component.paths.has([stateKey, ...dependencyPath].join('.'))\r\n        ) {\r\n          const newPaths = new Set(component.paths);\r\n          const fullPathKey = [stateKey, ...dependencyPath].join('.');\r\n          newPaths.add(fullPathKey);\r\n\r\n          const newComponentsMap = new Map(rootMeta.components);\r\n          newComponentsMap.set(fullComponentId, {\r\n            ...component,\r\n            paths: newPaths,\r\n          });\r\n          get().setShadowMetadata(stateKey, [], {\r\n            components: newComponentsMap,\r\n          });\r\n        }\r\n      }\r\n    }\r\n  },\r\n\r\n  registerComponent: (stateKey, fullComponentId, registration) => {\r\n    const rootMeta = get().getShadowMetadata(stateKey, []) || {};\r\n    const components = new Map(rootMeta.components);\r\n    components.set(fullComponentId, registration);\r\n    get().setShadowMetadata(stateKey, [], { components });\r\n  },\r\n\r\n  unregisterComponent: (stateKey, fullComponentId) => {\r\n    const rootMeta = get().getShadowMetadata(stateKey, []);\r\n    if (!rootMeta?.components) return;\r\n    const components = new Map(rootMeta.components);\r\n    if (components.delete(fullComponentId)) {\r\n      get().setShadowMetadata(stateKey, [], { components });\r\n    }\r\n  },\r\n\r\n  markAsDirty: (key, path, options = { bubble: true }) => {\r\n    const setDirtyOnPath = (pathToMark: string[]) => {\r\n      const node = get().getShadowNode(key, pathToMark);\r\n      if (node?._meta?.isDirty) {\r\n        return true;\r\n      }\r\n      get().setShadowMetadata(key, pathToMark, { isDirty: true });\r\n      return false;\r\n    };\r\n\r\n    setDirtyOnPath(path);\r\n\r\n    if (options.bubble) {\r\n      let parentPath = [...path];\r\n      while (parentPath.length > 0) {\r\n        parentPath.pop();\r\n        if (setDirtyOnPath(parentPath)) {\r\n          break;\r\n        }\r\n      }\r\n    }\r\n  },\r\n\r\n  serverStateUpdates: new Map(),\r\n  setServerStateUpdate: (key, serverState) => {\r\n    set((state) => ({\r\n      serverStateUpdates: new Map(state.serverStateUpdates).set(\r\n        key,\r\n        serverState\r\n      ),\r\n    }));\r\n    get().notifyPathSubscribers(key, {\r\n      type: 'SERVER_STATE_UPDATE',\r\n      serverState,\r\n    });\r\n  },\r\n\r\n  pathSubscribers: new Map<string, Set<(newValue: any) => void>>(),\r\n  subscribeToPath: (path, callback) => {\r\n    const subscribers = get().pathSubscribers;\r\n    const subsForPath = subscribers.get(path) || new Set();\r\n    subsForPath.add(callback);\r\n    subscribers.set(path, subsForPath);\r\n\r\n    return () => {\r\n      const currentSubs = get().pathSubscribers.get(path);\r\n      if (currentSubs) {\r\n        currentSubs.delete(callback);\r\n        if (currentSubs.size === 0) {\r\n          get().pathSubscribers.delete(path);\r\n        }\r\n      }\r\n    };\r\n  },\r\n  notifyPathSubscribers: (updatedPath, newValue) => {\r\n    const subscribers = get().pathSubscribers;\r\n    const subs = subscribers.get(updatedPath);\r\n    if (subs) {\r\n      subs.forEach((callback) => callback(newValue));\r\n    }\r\n  },\r\n  selectedIndicesMap: new Map<string, string>(),\r\n  getSelectedIndex: (arrayKey, validIds) => {\r\n    const itemKey = get().selectedIndicesMap.get(arrayKey);\r\n    if (!itemKey) return -1;\r\n\r\n    const arrayMeta = get().getShadowMetadata(\r\n      arrayKey.split('.')[0]!,\r\n      arrayKey.split('.').slice(1)\r\n    );\r\n    const arrayKeys = validIds || arrayMeta?.arrayKeys;\r\n\r\n    return arrayKeys ? arrayKeys.indexOf(itemKey) : -1;\r\n  },\r\n\r\n  setSelectedIndex: (arrayKey: string, itemKey: string | undefined) => {\r\n    set((state) => {\r\n      const newMap = new Map(state.selectedIndicesMap); // CREATE A NEW MAP!\r\n\r\n      if (itemKey === undefined) {\r\n        newMap.delete(arrayKey);\r\n      } else {\r\n        if (newMap.has(arrayKey)) {\r\n          get().notifyPathSubscribers(newMap.get(arrayKey)!, {\r\n            type: 'THIS_UNSELECTED',\r\n          });\r\n        }\r\n        newMap.set(arrayKey, itemKey);\r\n        get().notifyPathSubscribers(itemKey, { type: 'THIS_SELECTED' });\r\n      }\r\n\r\n      get().notifyPathSubscribers(arrayKey, { type: 'GET_SELECTED' });\r\n\r\n      return {\r\n        ...state,\r\n        selectedIndicesMap: newMap,\r\n      };\r\n    });\r\n  },\r\n\r\n  clearSelectedIndex: ({ arrayKey }: { arrayKey: string }): void => {\r\n    set((state) => {\r\n      const newMap = new Map(state.selectedIndicesMap); // CREATE A NEW MAP!\r\n      const actualKey = newMap.get(arrayKey);\r\n      if (actualKey) {\r\n        get().notifyPathSubscribers(actualKey, {\r\n          type: 'CLEAR_SELECTION',\r\n        });\r\n      }\r\n\r\n      newMap.delete(arrayKey);\r\n      get().notifyPathSubscribers(arrayKey, {\r\n        type: 'CLEAR_SELECTION',\r\n      });\r\n      return {\r\n        ...state,\r\n        selectedIndicesMap: newMap,\r\n      };\r\n    });\r\n  },\r\n  clearSelectedIndexesForState: (stateKey) => {\r\n    set((state) => {\r\n      const newMap = new Map(state.selectedIndicesMap);\r\n      let changed = false;\r\n      for (const key of newMap.keys()) {\r\n        if (key === stateKey || key.startsWith(stateKey + '.')) {\r\n          newMap.delete(key);\r\n          changed = true;\r\n        }\r\n      }\r\n      return changed ? { selectedIndicesMap: newMap } : {};\r\n    });\r\n  },\r\n\r\n  initialStateOptions: {},\r\n  stateLog: new Map(),\r\n  initialStateGlobal: {},\r\n\r\n  addStateLog: (updates) => {\r\n    if (!updates || updates.length === 0) return;\r\n    set((state) => {\r\n      const newLog = new Map(state.stateLog);\r\n      const logsGroupedByKey = new Map<string, UpdateTypeDetail[]>();\r\n      for (const update of updates) {\r\n        const group = logsGroupedByKey.get(update.stateKey) || [];\r\n        group.push(update);\r\n        logsGroupedByKey.set(update.stateKey, group);\r\n      }\r\n      for (const [key, batchOfUpdates] of logsGroupedByKey.entries()) {\r\n        const newStateLogForKey = new Map(newLog.get(key));\r\n        for (const update of batchOfUpdates) {\r\n          newStateLogForKey.set(JSON.stringify(update.path), { ...update });\r\n        }\r\n        newLog.set(key, newStateLogForKey);\r\n      }\r\n      return { stateLog: newLog };\r\n    });\r\n  },\r\n\r\n  getInitialOptions: (key) => get().initialStateOptions[key],\r\n  setInitialStateOptions: (key, value) => {\r\n    set((prev) => ({\r\n      initialStateOptions: { ...prev.initialStateOptions, [key]: value },\r\n    }));\r\n  },\r\n  updateInitialStateGlobal: (key, newState) => {\r\n    set((prev) => ({\r\n      initialStateGlobal: { ...prev.initialStateGlobal, [key]: newState },\r\n    }));\r\n  },\r\n\r\n  syncInfoStore: new Map<string, SyncInfo>(),\r\n  setSyncInfo: (key, syncInfo) =>\r\n    set((state) => {\r\n      const newMap = new Map(state.syncInfoStore);\r\n      newMap.set(key, syncInfo);\r\n      return { syncInfoStore: newMap };\r\n    }),\r\n  getSyncInfo: (key) => get().syncInfoStore.get(key) || null,\r\n}));\r\n"],"names":["formRefStore","create","set","get","id","ref","state","newRefs","stateKey","allRefs","stateKeyPrefix","filteredRefs","buildShadowNode","value","arrayNode","idKeys","item","itemId","ulid","objectNode","key","getGlobalStore","path","cacheKey","cacheData","metadata","initialState","newShadowStore","existingRoot","preservedMetadata","components","features","lastServerSync","stateSource","baseServerState","newRoot","storageKey","store","current","i","newMetadata","newStore","rootKey","root","clonedRoot","segment","validArrayIds","log","node","nodeKeys","k","keysToIterate","result","propKey","newValue","oldMeta","pathLength","lastSegment","targetNode","newNode","mergedNode","newKeysSet","arrayPath","newItems","newKeys","nextNode","newItem","index","newItemId","itemsToAdd","insertionPoint","arrayKey","newIds","currentKeys","finalKeys","itemPath","dependencyPath","fullComponentId","newPathComponents","rootMeta","component","newPaths","fullPathKey","newComponentsMap","registration","options","setDirtyOnPath","pathToMark","parentPath","serverState","callback","subscribers","subsForPath","currentSubs","updatedPath","subs","validIds","itemKey","arrayMeta","arrayKeys","newMap","actualKey","changed","updates","newLog","logsGroupedByKey","update","group","batchOfUpdates","newStateLogForKey","prev","newState","syncInfo"],"mappings":"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"}