{"version":3,"file":"Functions.jsx","sources":["../src/Functions.tsx"],"sourcesContent":["import {\r\n  notifyComponent,\r\n  type EffectiveSetState,\r\n  type FormElementParams,\r\n  type FormOptsType,\r\n  type UpdateArg,\r\n  type UpdateOpts,\r\n} from \"./CogsState\";\r\n\r\nimport { getNestedValue, isFunction, updateNestedProperty } from \"./utility\";\r\nimport { useEffect, useRef, useState } from \"react\";\r\nimport React from \"react\";\r\nimport { getGlobalStore, formRefStore } from \"./store\";\r\nimport { validateZodPathFunc } from \"./useValidateZodPath\";\r\n\r\nexport function updateFn<U>(\r\n  setState: EffectiveSetState<U>,\r\n  payload: UpdateArg<U>,\r\n  path: string[],\r\n  validationKey?: string\r\n): void {\r\n  setState(\r\n    (prevState) => {\r\n      if (isFunction<U>(payload)) {\r\n        const nestedValue = payload(getNestedValue(prevState, path));\r\n        let value = updateNestedProperty(path, prevState, nestedValue);\r\n        if (typeof value == \"string\") {\r\n          value = value.trim();\r\n        }\r\n        return value;\r\n      } else {\r\n        let value =\r\n          !path || path.length == 0\r\n            ? payload\r\n            : updateNestedProperty(path, prevState, payload);\r\n        if (typeof value == \"string\") {\r\n          value = value.trim();\r\n        }\r\n        return value;\r\n      }\r\n    },\r\n    path,\r\n    { updateType: \"update\" },\r\n    validationKey\r\n  );\r\n}\r\n\r\nexport function pushFunc<U>(\r\n  setState: EffectiveSetState<U>,\r\n  payload: UpdateArg<U>,\r\n  path: string[],\r\n  stateKey: string,\r\n  index?: number\r\n): void {\r\n  const array = getGlobalStore.getState().getNestedState(stateKey, path) as U[];\r\n  setState(\r\n    (prevState) => {\r\n      let arrayToUpdate =\r\n        !path || path.length == 0\r\n          ? prevState\r\n          : getNestedValue(prevState, [...path]);\r\n      let returnedArray = [...arrayToUpdate];\r\n\r\n      returnedArray.splice(\r\n        index || Number(index) == 0 ? index : arrayToUpdate.length,\r\n        0,\r\n        isFunction<U>(payload)\r\n          ? payload(index == -1 ? undefined : arrayToUpdate)\r\n          : payload\r\n      );\r\n      const value =\r\n        path.length == 0\r\n          ? returnedArray\r\n          : updateNestedProperty([...path], prevState, returnedArray);\r\n\r\n      return value as U;\r\n    },\r\n    [\r\n      ...path,\r\n      index || index === 0 ? index?.toString() : (array!.length - 1).toString(),\r\n    ],\r\n    {\r\n      updateType: \"insert\",\r\n    }\r\n  );\r\n}\r\n\r\nexport function cutFunc<U>(\r\n  setState: EffectiveSetState<U>,\r\n  path: string[],\r\n  stateKey: string,\r\n  index: number\r\n): void {\r\n  const array = getGlobalStore.getState().getNestedState(stateKey, path) as U[];\r\n  setState(\r\n    (prevState) => {\r\n      const arrayToUpdate = getNestedValue(prevState, [...path]);\r\n      if (index < 0 || index >= arrayToUpdate?.length) {\r\n        throw new Error(`Index ${index} does not exist in the array.`);\r\n      }\r\n      const indexToCut =\r\n        index || Number(index) == 0 ? index : arrayToUpdate.length - 1;\r\n\r\n      const updatedArray = [\r\n        ...arrayToUpdate.slice(0, indexToCut),\r\n        ...arrayToUpdate.slice(indexToCut + 1),\r\n      ] as U;\r\n\r\n      console.log(index);\r\n      return path.length == 0\r\n        ? updatedArray\r\n        : updateNestedProperty([...path], prevState, updatedArray);\r\n    },\r\n    [\r\n      ...path,\r\n      index || index === 0 ? index?.toString() : (array!.length - 1).toString(),\r\n    ],\r\n    { updateType: \"cut\" }\r\n  );\r\n}\r\n\r\nexport const useStoreSubscription = <T,>(\r\n  fullPath: string,\r\n  selector: (\r\n    store: ReturnType<typeof getGlobalStore.getState>,\r\n    path: string\r\n  ) => T,\r\n  compare: (a: T, b: T) => boolean = (a, b) =>\r\n    JSON.stringify(a) === JSON.stringify(b)\r\n) => {\r\n  const [value, setValue] = useState<T>(() =>\r\n    selector(getGlobalStore.getState(), fullPath)\r\n  );\r\n  const previousValueRef = useRef<T>(value);\r\n  const fullPathRef = useRef(fullPath);\r\n  useEffect(() => {\r\n    fullPathRef.current = fullPath; // Ensure latest fullPath is always used\r\n\r\n    setValue(selector(getGlobalStore.getState(), fullPath));\r\n\r\n    const callback = (store: any) => {\r\n      const newValue = selector(store, fullPathRef.current);\r\n\r\n      if (!compare(previousValueRef.current, newValue)) {\r\n        previousValueRef.current = newValue;\r\n        setValue(newValue);\r\n      }\r\n    };\r\n    const unsubscribe = getGlobalStore.subscribe(callback);\r\n    return () => {\r\n      unsubscribe();\r\n    };\r\n  }, [fullPath]);\r\n  return value;\r\n};\r\nexport const useGetValidationErrors = (\r\n  validationKey: string,\r\n  path: string[],\r\n  validIndices?: number[]\r\n) => {\r\n  // Construct the full path the same way as ValidationWrapper\r\n  const fullPath =\r\n    validationKey +\r\n    \".\" +\r\n    (path.length > 0 ? [path.join(\".\")] : []) +\r\n    (validIndices && validIndices.length > 0 ? \".\" + validIndices : \"\");\r\n\r\n  // Skip subscription if we have empty indices\r\n  if (validIndices?.length === 0) {\r\n    return [];\r\n  }\r\n\r\n  return useStoreSubscription(\r\n    fullPath,\r\n    (store, path) => store.getValidationErrors(path) || []\r\n  );\r\n};\r\n\r\nexport const useGetSyncInfo = (key: string, path: string[]) => {\r\n  const syncKey = `${key}:${path.join(\".\")}`;\r\n  return useStoreSubscription(syncKey, (store, path) =>\r\n    store.getSyncInfo(path)\r\n  );\r\n};\r\nexport const useGetKeyState = (key: string, path: string[]) => {\r\n  return useStoreSubscription(`${key}:${path.join(\".\")}`, (store, fullPath) =>\r\n    store.getNestedState(key, path)\r\n  );\r\n};\r\ninterface FormControlComponentProps<TStateObject> {\r\n  setState: EffectiveSetState<TStateObject>;\r\n\r\n  path: string[];\r\n  child: (obj: FormElementParams<TStateObject>) => JSX.Element;\r\n  formOpts?: FormOptsType;\r\n  stateKey: string;\r\n}\r\n\r\nexport const FormControlComponent = <TStateObject,>({\r\n  setState,\r\n  path,\r\n  child,\r\n  formOpts,\r\n  stateKey,\r\n}: FormControlComponentProps<TStateObject>) => {\r\n  const [_, forceUpdate] = useState({});\r\n  const { registerFormRef, getFormRef } = formRefStore.getState();\r\n  const refKey = stateKey + \".\" + path.join(\".\");\r\n\r\n  // Create a local ref\r\n  const localFormRef = useRef<HTMLInputElement>(null);\r\n\r\n  // Get existing ref from the store (if any)\r\n  const existingRef = getFormRef(refKey);\r\n  if (!existingRef) {\r\n    registerFormRef(stateKey + \".\" + path.join(\".\"), localFormRef);\r\n  }\r\n  // Use the existing ref if available, otherwise use the local one\r\n  const formRef = existingRef || localFormRef;\r\n\r\n  const {\r\n    getValidationErrors,\r\n    addValidationError,\r\n    getInitialOptions,\r\n    removeValidationError,\r\n  } = getGlobalStore.getState();\r\n  const stateValue = useGetKeyState(stateKey, path);\r\n  const [inputValue, setInputValue] = useState<any>(\r\n    getGlobalStore.getState().getNestedState(stateKey, path)\r\n  );\r\n\r\n  const initialOptions = getInitialOptions(stateKey);\r\n  if (!initialOptions?.validation?.key) {\r\n    throw new Error(\r\n      \"Validation key not found. You need to set it in the options for the createCogsState function\"\r\n    );\r\n  }\r\n  const validationKey = initialOptions.validation.key;\r\n  const validateOnBlur = initialOptions.validation.onBlur === true;\r\n  initialOptions;\r\n  useEffect(() => {\r\n    setInputValue(stateValue);\r\n  }, [stateKey, path.join(\".\"), stateValue]);\r\n\r\n  const timeoutRef = useRef<NodeJS.Timeout>();\r\n\r\n  // Standard updater function (unchanged)\r\n  let updater = (\r\n    payload: UpdateArg<TStateObject>,\r\n    opts?: UpdateOpts<TStateObject>\r\n  ) => {\r\n    setInputValue(payload);\r\n\r\n    if (timeoutRef.current) {\r\n      clearTimeout(timeoutRef.current);\r\n    }\r\n\r\n    timeoutRef.current = setTimeout(\r\n      () => {\r\n        console.log(typeof stateValue);\r\n        updateFn(setState, payload, path, validationKey);\r\n      },\r\n      formOpts?.debounceTime ?? (typeof stateValue == \"boolean\" ? 20 : 200)\r\n    );\r\n  };\r\n\r\n  // Handle blur event\r\n  const handleBlur = async () => {\r\n    if (!initialOptions.validation?.zodSchema) return;\r\n    removeValidationError(validationKey + \".\" + path.join(\".\"));\r\n    try {\r\n      // Get the current field value\r\n      const fieldValue = getGlobalStore\r\n        .getState()\r\n        .getNestedState(stateKey, path);\r\n\r\n      // Use your existing validateZodPathFunc\r\n      await validateZodPathFunc(\r\n        validationKey,\r\n        initialOptions.validation.zodSchema,\r\n        path,\r\n        fieldValue\r\n      );\r\n      console.log(\r\n        \"Validation\",\r\n        stateKey,\r\n        initialOptions.validation.zodSchema,\r\n        path,\r\n        fieldValue\r\n      );\r\n      forceUpdate({});\r\n    } catch (error) {\r\n      console.error(\"Validation error:\", error);\r\n    }\r\n  };\r\n\r\n  // Clear timeout on unmount\r\n  useEffect(() => {\r\n    return () => {\r\n      if (timeoutRef.current) {\r\n        clearTimeout(timeoutRef.current);\r\n      }\r\n    };\r\n  }, []);\r\n\r\n  const rawSyncStatus = useGetSyncInfo(stateKey, path);\r\n  const syncStatus = rawSyncStatus\r\n    ? {\r\n        ...rawSyncStatus,\r\n        date: new Date(rawSyncStatus.timeStamp),\r\n      }\r\n    : null;\r\n\r\n  const childElement = child({\r\n    get: () =>\r\n      inputValue || getGlobalStore.getState().getNestedState(stateKey, path),\r\n    set: updater,\r\n    syncStatus,\r\n    path: path,\r\n    validationErrors: () =>\r\n      getValidationErrors(validationKey + \".\" + path.join(\".\")),\r\n    addValidationError: (message?: string) => {\r\n      removeValidationError(validationKey + \".\" + path.join(\".\"));\r\n      addValidationError(validationKey + \".\" + path.join(\".\"), message ?? \"\");\r\n    },\r\n\r\n    inputProps: {\r\n      value:\r\n        inputValue ||\r\n        getGlobalStore.getState().getNestedState(stateKey, path) ||\r\n        \"\",\r\n      onChange: (e: any) => updater(e.target.value),\r\n      onBlur: handleBlur,\r\n      ref: formRef,\r\n    },\r\n  });\r\n\r\n  return (\r\n    <>\r\n      <ValidationWrapper\r\n        {...{\r\n          formOpts,\r\n          path,\r\n          validationKey,\r\n          stateKey,\r\n        }}\r\n      >\r\n        {childElement}\r\n      </ValidationWrapper>\r\n    </>\r\n  );\r\n};\r\nexport function ValidationWrapper({\r\n  formOpts,\r\n  path,\r\n  validationKey,\r\n  stateKey,\r\n  children,\r\n  validIndices,\r\n}: {\r\n  formOpts?: FormOptsType;\r\n  path: string[];\r\n  validationKey: string;\r\n  stateKey?: string;\r\n  children: React.ReactNode;\r\n  validIndices?: number[];\r\n}) {\r\n  const { getInitialOptions } = getGlobalStore.getState();\r\n\r\n  const validationErrors = useGetValidationErrors(\r\n    validationKey,\r\n    path,\r\n    validIndices\r\n  );\r\n\r\n  const thesMessages: string[] = [];\r\n\r\n  if (validationErrors) {\r\n    const newMessage = validationErrors!.join(\", \");\r\n    if (!thesMessages.includes(newMessage)) {\r\n      thesMessages.push(newMessage);\r\n    }\r\n  }\r\n  const thisStateOpts = getInitialOptions(stateKey!);\r\n  let fullMessageString = thisStateOpts?.validation?.onBlur\r\n    ? thesMessages?.length > 0\r\n      ? thesMessages?.join(\", \")\r\n      : formOpts?.validation?.message\r\n        ? formOpts?.validation?.message\r\n        : \"\"\r\n    : \"\";\r\n\r\n  return (\r\n    <>\r\n      {thisStateOpts?.formElements?.validation &&\r\n      !formOpts?.validation?.disable ? (\r\n        thisStateOpts.formElements!.validation!({\r\n          children: (\r\n            <React.Fragment key={path.toString()}>{children}</React.Fragment>\r\n          ),\r\n          active: fullMessageString != \"\" ? true : false,\r\n          message: formOpts?.validation?.hideMessage ? \"\" : fullMessageString,\r\n          path,\r\n\r\n          ...(formOpts?.key && { key: formOpts?.key }),\r\n        })\r\n      ) : (\r\n        <React.Fragment key={path.toString()}>{children}</React.Fragment>\r\n      )}\r\n    </>\r\n  );\r\n}\r\n"],"names":["updateFn","setState","payload","path","validationKey","prevState","isFunction","nestedValue","getNestedValue","value","updateNestedProperty","pushFunc","stateKey","index","array","getGlobalStore","arrayToUpdate","returnedArray","cutFunc","indexToCut","updatedArray","useStoreSubscription","fullPath","selector","compare","a","b","setValue","useState","previousValueRef","useRef","fullPathRef","useEffect","callback","store","newValue","unsubscribe","useGetValidationErrors","validIndices","useGetSyncInfo","key","syncKey","useGetKeyState","FormControlComponent","child","formOpts","_","forceUpdate","registerFormRef","getFormRef","formRefStore","refKey","localFormRef","existingRef","formRef","getValidationErrors","addValidationError","getInitialOptions","removeValidationError","stateValue","inputValue","setInputValue","initialOptions","timeoutRef","updater","opts","handleBlur","fieldValue","validateZodPathFunc","error","rawSyncStatus","syncStatus","childElement","message","e","jsx","Fragment","ValidationWrapper","children","validationErrors","thesMessages","newMessage","thisStateOpts","fullMessageString","React"],"mappings":"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"}