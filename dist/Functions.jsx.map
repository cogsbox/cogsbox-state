{"version":3,"file":"Functions.jsx","sources":["../src/Functions.tsx"],"sourcesContent":["import type {\r\n    EffectiveSetState,\r\n    FormElementParmas,\r\n    FormOptsType,\r\n    UpdateArg,\r\n    UpdateOpts,\r\n} from \"./CogsState\";\r\n\r\nimport { getNestedValue, isFunction, updateNestedProperty } from \"./utility\";\r\nimport { useEffect, useRef, useState } from \"react\";\r\nimport React from \"react\";\r\nimport { getGlobalStore } from \"./store\";\r\n\r\nexport function updateFn<U>(\r\n    setState: EffectiveSetState<U>,\r\n    payload: UpdateArg<U>,\r\n    path: string[],\r\n    validationKey?: string,\r\n): void {\r\n    setState(\r\n        (prevState) => {\r\n            if (isFunction<U>(payload)) {\r\n                const nestedValue = payload(getNestedValue(prevState, path));\r\n                let value = updateNestedProperty(path, prevState, nestedValue);\r\n                if (typeof value == \"string\") {\r\n                    value = value.trim();\r\n                }\r\n                return value;\r\n            } else {\r\n                let value =\r\n                    !path || path.length == 0\r\n                        ? payload\r\n                        : updateNestedProperty(path, prevState, payload);\r\n                if (typeof value == \"string\") {\r\n                    value = value.trim();\r\n                }\r\n                return value;\r\n            }\r\n        },\r\n        path,\r\n        { updateType: \"update\" },\r\n        validationKey,\r\n    );\r\n}\r\n\r\nexport function pushFunc<U>(\r\n    setState: EffectiveSetState<U>,\r\n    payload: UpdateArg<U>,\r\n    path: string[],\r\n    stateKey: string,\r\n    index?: number,\r\n): void {\r\n    const array = getGlobalStore\r\n        .getState()\r\n        .getNestedState(stateKey, path) as U[];\r\n    setState(\r\n        (prevState) => {\r\n            let arrayToUpdate =\r\n                !path || path.length == 0\r\n                    ? prevState\r\n                    : getNestedValue(prevState, [...path]);\r\n            let returnedArray = [...arrayToUpdate];\r\n\r\n            returnedArray.splice(\r\n                index || Number(index) == 0 ? index : arrayToUpdate.length,\r\n                0,\r\n                isFunction<U>(payload)\r\n                    ? payload(index == -1 ? undefined : arrayToUpdate)\r\n                    : payload,\r\n            );\r\n            const value =\r\n                path.length == 0\r\n                    ? returnedArray\r\n                    : updateNestedProperty([...path], prevState, returnedArray);\r\n\r\n            return value as U;\r\n        },\r\n        [\r\n            ...path,\r\n            index || index === 0\r\n                ? index?.toString()\r\n                : (array!.length - 1).toString(),\r\n        ],\r\n        {\r\n            updateType: \"insert\",\r\n        },\r\n    );\r\n}\r\n\r\nexport function cutFunc<U>(\r\n    setState: EffectiveSetState<U>,\r\n    path: string[],\r\n    stateKey: string,\r\n    index: number,\r\n): void {\r\n    const array = getGlobalStore\r\n        .getState()\r\n        .getNestedState(stateKey, path) as U[];\r\n    setState(\r\n        (prevState) => {\r\n            const arrayToUpdate = getNestedValue(prevState, [...path]);\r\n            if (index < 0 || index >= arrayToUpdate?.length) {\r\n                throw new Error(`Index ${index} does not exist in the array.`);\r\n            }\r\n            const indexToCut =\r\n                index || Number(index) == 0 ? index : arrayToUpdate.length - 1;\r\n\r\n            const updatedArray = [\r\n                ...arrayToUpdate.slice(0, indexToCut),\r\n                ...arrayToUpdate.slice(indexToCut + 1),\r\n            ] as U;\r\n\r\n            console.log(index);\r\n            return path.length == 0\r\n                ? updatedArray\r\n                : updateNestedProperty([...path], prevState, updatedArray);\r\n        },\r\n        [\r\n            ...path,\r\n            index || index === 0\r\n                ? index?.toString()\r\n                : (array!.length - 1).toString(),\r\n        ],\r\n        { updateType: \"cut\" },\r\n    );\r\n}\r\n\r\nexport const useStoreSubscription = <T,>(\r\n    fullPath: string,\r\n    selector: (\r\n        store: ReturnType<typeof getGlobalStore.getState>,\r\n        path: string,\r\n    ) => T,\r\n    compare: (a: T, b: T) => boolean = (a, b) =>\r\n        JSON.stringify(a) === JSON.stringify(b),\r\n) => {\r\n    const [value, setValue] = useState<T>(() =>\r\n        selector(getGlobalStore.getState(), fullPath),\r\n    );\r\n    const previousValueRef = useRef<T>(value);\r\n\r\n    useEffect(() => {\r\n        const unsubscribe = getGlobalStore.subscribe((store) => {\r\n            const newValue = selector(store, fullPath);\r\n            if (!compare(previousValueRef.current, newValue)) {\r\n                previousValueRef.current = newValue;\r\n                setValue(newValue);\r\n            }\r\n        });\r\n\r\n        return () => unsubscribe();\r\n    }, [fullPath]);\r\n\r\n    return value;\r\n};\r\nexport const useGetValidationErrors = (\r\n    validationKey: string,\r\n    path: string[],\r\n    validIndices?: number[],\r\n) => {\r\n    // Construct the full path the same way as ValidationWrapper\r\n    const fullPath =\r\n        validationKey +\r\n        \".\" +\r\n        (path.length > 0 ? [path.join(\".\")] : []) +\r\n        (validIndices && validIndices.length > 0 ? \".\" + validIndices : \"\");\r\n\r\n    // Skip subscription if we have empty indices\r\n    if (validIndices?.length === 0) {\r\n        return [];\r\n    }\r\n\r\n    return useStoreSubscription(\r\n        fullPath,\r\n        (store, path) => store.getValidationErrors(path) || [],\r\n    );\r\n};\r\n\r\nexport const useGetSyncInfo = (key: string, path: string[]) => {\r\n    const syncKey = `${key}:${path.join(\".\")}`;\r\n    return useStoreSubscription(syncKey, (store, path) =>\r\n        store.getSyncInfo(path),\r\n    );\r\n};\r\nexport const useGetKeyState = (key: string, path: string[]) => {\r\n    return useStoreSubscription(`${key}:${path.join(\".\")}`, (store, fullPath) =>\r\n        store.getNestedState(key, path),\r\n    );\r\n};\r\ninterface FormControlComponentProps<TStateObject> {\r\n    setState: EffectiveSetState<TStateObject>;\r\n\r\n    path: string[];\r\n    child: (obj: FormElementParmas<TStateObject>) => JSX.Element;\r\n    formOpts?: FormOptsType;\r\n    stateKey: string;\r\n}\r\nexport const FormControlComponent = <TStateObject,>({\r\n    setState,\r\n\r\n    path,\r\n    child,\r\n    formOpts,\r\n    stateKey,\r\n}: FormControlComponentProps<TStateObject>) => {\r\n    const { getValidationErrors, getInitialOptions } =\r\n        getGlobalStore.getState();\r\n    const stateValue = useGetKeyState(stateKey, path);\r\n    const [inputValue, setInputValue] = useState<any>(\r\n        getGlobalStore.getState().getNestedState(stateKey, path),\r\n    );\r\n\r\n    const initialOptions = getInitialOptions(stateKey);\r\n    if (!initialOptions?.validationKey) {\r\n        throw new Error(\r\n            \"Validation key not found. You need ot set it in the options for the createCogsState function\",\r\n        );\r\n    }\r\n    const validationKey = initialOptions.validationKey;\r\n    useEffect(() => {\r\n        setInputValue(stateValue);\r\n    }, [stateKey, path.join(\".\"), stateValue]);\r\n\r\n    const timeoutRef = useRef<NodeJS.Timeout>();\r\n\r\n    let updater = (\r\n        payload: UpdateArg<TStateObject>,\r\n        opts?: UpdateOpts<TStateObject>,\r\n    ) => {\r\n        setInputValue(payload);\r\n\r\n        if (timeoutRef.current) {\r\n            clearTimeout(timeoutRef.current);\r\n        }\r\n\r\n        timeoutRef.current = setTimeout(() => {\r\n            updateFn(setState, payload, path, validationKey);\r\n        }, formOpts?.debounceTime ?? 300);\r\n    };\r\n\r\n    // Clear timeout on unmount\r\n    useEffect(() => {\r\n        return () => {\r\n            if (timeoutRef.current) {\r\n                clearTimeout(timeoutRef.current);\r\n            }\r\n        };\r\n    }, []);\r\n\r\n    const rawSyncStatus = useGetSyncInfo(stateKey, path);\r\n    const syncStatus = rawSyncStatus\r\n        ? {\r\n              ...rawSyncStatus,\r\n              date: new Date(rawSyncStatus.timeStamp),\r\n          }\r\n        : null;\r\n    const childElement = child({\r\n        get: () =>\r\n            inputValue ||\r\n            getGlobalStore.getState().getNestedState(stateKey, path),\r\n        set: updater,\r\n        syncStatus,\r\n        path: path,\r\n        validationErrors: () =>\r\n            getValidationErrors(validationKey + \".\" + path.join(\".\")),\r\n\r\n        // Add default input props\r\n        inputProps: {\r\n            value:\r\n                inputValue ||\r\n                getGlobalStore.getState().getNestedState(stateKey, path) ||\r\n                \"\",\r\n            onChange: (e: any) => updater(e.target.value),\r\n        },\r\n    });\r\n\r\n    return (\r\n        <>\r\n            <ValidationWrapper\r\n                {...{\r\n                    formOpts,\r\n                    path,\r\n                    validationKey,\r\n                    stateKey,\r\n                }}\r\n            >\r\n                {childElement}\r\n            </ValidationWrapper>\r\n        </>\r\n    );\r\n};\r\n\r\nexport function ValidationWrapper({\r\n    formOpts,\r\n    path,\r\n    validationKey,\r\n    stateKey,\r\n    children,\r\n    validIndices,\r\n}: {\r\n    formOpts?: FormOptsType;\r\n    path: string[];\r\n    validationKey: string;\r\n    stateKey?: string;\r\n    children: React.ReactNode;\r\n    validIndices?: number[];\r\n}) {\r\n    const { getInitialOptions, getValidationErrors } =\r\n        getGlobalStore.getState();\r\n    const validationErrors = useGetValidationErrors(\r\n        validationKey,\r\n        path,\r\n        validIndices,\r\n    );\r\n    const thesMessages: string[] = [];\r\n\r\n    if (validationErrors) {\r\n        const newMessage = validationErrors!.join(\", \");\r\n        if (!thesMessages.includes(newMessage)) {\r\n            thesMessages.push(newMessage);\r\n        }\r\n    }\r\n    let fullMessageString =\r\n        thesMessages?.length > 0 ? thesMessages?.join(\", \") : \"\";\r\n\r\n    const thisStateOpts = getInitialOptions(stateKey!);\r\n\r\n    return (\r\n        <>\r\n            {thisStateOpts?.formElements?.validation &&\r\n            !formOpts?.validation?.disable ? (\r\n                thisStateOpts.formElements!.validation!({\r\n                    children: (\r\n                        <React.Fragment key={path.toString()}>\r\n                            {children}\r\n                        </React.Fragment>\r\n                    ),\r\n                    active: fullMessageString != \"\" ? true : false,\r\n                    message: formOpts?.validation?.message\r\n                        ? formOpts?.validation?.message\r\n                        : formOpts?.validation?.message == \"\"\r\n                          ? \"\"\r\n                          : fullMessageString,\r\n                    path,\r\n\r\n                    ...(formOpts?.key && { key: formOpts?.key }),\r\n                })\r\n            ) : (\r\n                <React.Fragment key={path.toString()}>\r\n                    {children}\r\n                </React.Fragment>\r\n            )}\r\n        </>\r\n    );\r\n}\r\n"],"names":["updateFn","setState","payload","path","validationKey","prevState","isFunction","nestedValue","getNestedValue","value","updateNestedProperty","pushFunc","stateKey","index","array","getGlobalStore","arrayToUpdate","returnedArray","cutFunc","indexToCut","updatedArray","useStoreSubscription","fullPath","selector","compare","a","b","setValue","useState","previousValueRef","useRef","useEffect","unsubscribe","store","newValue","useGetValidationErrors","validIndices","useGetSyncInfo","key","syncKey","useGetKeyState","FormControlComponent","child","formOpts","getValidationErrors","getInitialOptions","stateValue","inputValue","setInputValue","initialOptions","timeoutRef","updater","opts","rawSyncStatus","syncStatus","childElement","e","jsx","Fragment","ValidationWrapper","children","validationErrors","thesMessages","newMessage","fullMessageString","thisStateOpts","React"],"mappings":"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"}