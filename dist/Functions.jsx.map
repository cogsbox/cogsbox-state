{"version":3,"file":"Functions.jsx","sources":["../src/Functions.tsx"],"sourcesContent":["import { type FormOptsType } from './CogsState';\r\n\r\nimport { useEffect, useRef, useState } from 'react';\r\nimport React from 'react';\r\nimport { getGlobalStore } from './store';\r\n\r\nexport const useStoreSubscription = <T,>(\r\n  fullPath: string,\r\n  selector: (\r\n    store: ReturnType<typeof getGlobalStore.getState>,\r\n    path: string\r\n  ) => T,\r\n  compare: (a: T, b: T) => boolean = (a, b) =>\r\n    JSON.stringify(a) === JSON.stringify(b)\r\n) => {\r\n  const [value, setValue] = useState<T>(() =>\r\n    selector(getGlobalStore.getState(), fullPath)\r\n  );\r\n  const previousValueRef = useRef<T>(value);\r\n  const fullPathRef = useRef(fullPath);\r\n  useEffect(() => {\r\n    fullPathRef.current = fullPath; // Ensure latest fullPath is always used\r\n\r\n    setValue(selector(getGlobalStore.getState(), fullPath));\r\n\r\n    const callback = (store: any) => {\r\n      const newValue = selector(store, fullPathRef.current);\r\n\r\n      if (!compare(previousValueRef.current, newValue)) {\r\n        previousValueRef.current = newValue;\r\n        setValue(newValue);\r\n      }\r\n    };\r\n    const unsubscribe = getGlobalStore.subscribe(callback);\r\n    return () => {\r\n      unsubscribe();\r\n    };\r\n  }, [fullPath]);\r\n  return value;\r\n};\r\nexport const useGetValidationErrors = (\r\n  validationKey: string,\r\n  path: string[],\r\n  validIndices?: number[]\r\n) => {\r\n  const fullPath =\r\n    validationKey +\r\n    '.' +\r\n    (path.length > 0 ? [path.join('.')] : []) +\r\n    (validIndices && validIndices.length > 0 ? '.' + validIndices : '');\r\n\r\n  const returnresult = useStoreSubscription(\r\n    fullPath,\r\n    (store, path) => store.getValidationErrors(path) || []\r\n  );\r\n\r\n  return returnresult;\r\n};\r\n\r\n// Find FormControlComponent in your Functions.ts or equivalent file\r\n\r\n// export const FormControlComponent = <TStateObject,>({\r\n//   setState, // This is the real effectiveSetState from the hook\r\n//   path,\r\n//   child,\r\n//   formOpts,\r\n//   stateKey,\r\n//   rebuildStateShape,\r\n// }: FormControlComponentProps<TStateObject>) => {\r\n//   const { registerFormRef, getFormRef } = formRefStore.getState();\r\n//   const {\r\n//     getValidationErrors,\r\n//     addValidationError,\r\n//     getInitialOptions,\r\n//     removeValidationError,\r\n//   } = getGlobalStore.getState();\r\n//   const stateKeyPathKey = [stateKey, ...path].join('.');\r\n//   const [, forceUpdate] = useState<any>();\r\n//   getGlobalStore.getState().subscribeToPath(stateKeyPathKey, () => {\r\n//     forceUpdate({});\r\n//   });\r\n\r\n//   const refKey = stateKey + '.' + path.join('.');\r\n//   const localFormRef = useRef<HTMLInputElement>(null);\r\n//   const existingRef = getFormRef(refKey);\r\n//   if (!existingRef) {\r\n//     registerFormRef(refKey, localFormRef);\r\n//   }\r\n//   const formRef = existingRef || localFormRef;\r\n\r\n//   // --- START CHANGES ---\r\n\r\n//   const globalStateValue = getGlobalStore\r\n//     .getState()\r\n//     .getShadowValue(stateKeyPathKey);\r\n//   const [localValue, setLocalValue] = useState<any>(globalStateValue);\r\n//   const isCurrentlyDebouncing = useRef(false);\r\n//   const debounceTimeoutRef = useRef<NodeJS.Timeout | null>(null);\r\n\r\n//   // Effect to sync local state if global state changes externally\r\n//   useEffect(() => {\r\n//     // Only update local if not actively debouncing a local change\r\n//     if (!isCurrentlyDebouncing.current && globalStateValue !== localValue) {\r\n//       setLocalValue(globalStateValue);\r\n//     }\r\n//   }, [globalStateValue]); // Removed localValue dependency\r\n\r\n//   // Effect for cleanup\r\n//   useEffect(() => {\r\n//     return () => {\r\n//       if (debounceTimeoutRef.current) {\r\n//         clearTimeout(debounceTimeoutRef.current);\r\n//         debounceTimeoutRef.current = null; // Explicitly nullify\r\n//         isCurrentlyDebouncing.current = false;\r\n//       }\r\n//     };\r\n//   }, []);\r\n\r\n//   const debouncedUpdater = (payload: UpdateArg<TStateObject>) => {\r\n//     setLocalValue(payload); // Update local state immediately\r\n//     isCurrentlyDebouncing.current = true;\r\n\r\n//     if (payload === '') {\r\n//       if (debounceTimeoutRef.current) {\r\n//         clearTimeout(debounceTimeoutRef.current); // Clear pending timer\r\n//         debounceTimeoutRef.current = null;\r\n//       }\r\n\r\n//       setState(payload, path, { updateType: 'update' });\r\n//       isCurrentlyDebouncing.current = false; // No longer debouncing\r\n//       return; // Don't proceed to set another timeout\r\n//     }\r\n\r\n//     // If not empty, proceed with normal debouncing\r\n//     if (debounceTimeoutRef.current) {\r\n//       clearTimeout(debounceTimeoutRef.current);\r\n//     }\r\n\r\n//     debounceTimeoutRef.current = setTimeout(\r\n//       () => {\r\n//         isCurrentlyDebouncing.current = false;\r\n//         console.log('debouncedUpdater', payload);\r\n//         setState(payload, path, { updateType: 'update' });\r\n//       },\r\n//       formOpts?.debounceTime ??\r\n//         (typeof globalStateValue == 'boolean' ? 20 : 200)\r\n//     );\r\n//   };\r\n\r\n//   const initialOptions = getInitialOptions(stateKey);\r\n\r\n//   const validationKey = initialOptions?.validation?.key;\r\n//   const validateOnBlur = initialOptions?.validation?.onBlur === true;\r\n\r\n//   const handleBlur = async () => {\r\n//     // --- Ensure latest value is flushed if debouncing ---\r\n//     if (debounceTimeoutRef.current) {\r\n//       clearTimeout(debounceTimeoutRef.current); // Clear pending timer\r\n//       debounceTimeoutRef.current = null;\r\n//       isCurrentlyDebouncing.current = false;\r\n//       // Ensure the absolute latest local value is committed on blur\r\n//       setState(localValue, path, { updateType: 'update' });\r\n//     }\r\n//     // --- End modification ---\r\n\r\n//     if (!initialOptions?.validation?.zodSchema || !validateOnBlur) return;\r\n//     removeValidationError(validationKey + '.' + path.join('.'));\r\n//     try {\r\n//       // Use the potentially just flushed value\r\n//       if (!validationKey) return;\r\n//       const fieldValue = getGlobalStore\r\n//         .getState()\r\n//         .getShadowValue(stateKeyPathKey);\r\n//       await validateZodPathFunc(\r\n//         validationKey,\r\n//         initialOptions.validation.zodSchema,\r\n//         path,\r\n//         fieldValue\r\n//       );\r\n//       // forceUpdate might be needed if validation state update doesn't trigger render\r\n//       // Consider using useGetValidationErrors hook result directly for validation display\r\n//     } catch (error) {\r\n//       console.error('Validation error on blur:', error);\r\n//     }\r\n//   };\r\n\r\n//   const childElement = child({\r\n//     state: setter,\r\n//     // --- START CHANGES ---\r\n//     get: () => localValue, // Get should return the immediate local value\r\n//     set: debouncedUpdater, // Use the new debounced updater\r\n//     // --- END CHANGES ---\r\n\r\n//     path: path,\r\n//     validationErrors: () =>\r\n//       getValidationErrors(validationKey + '.' + path.join('.')),\r\n//     addValidationError: (message?: string) => {\r\n//       removeValidationError(validationKey + '.' + path.join('.'));\r\n//       addValidationError(validationKey + '.' + path.join('.'), message ?? '');\r\n//     },\r\n//     inputProps: {\r\n//       // --- START CHANGES ---\r\n//       value: localValue ?? '', // Input value is always the local state\r\n//       onChange: (e: any) => debouncedUpdater(e.target.value), // Use debounced updater\r\n//       // --- END CHANGES ---\r\n//       onBlur: handleBlur,\r\n//       ref: formRef,\r\n//     },\r\n//   });\r\n\r\n//   return (\r\n//     <>\r\n//       <ValidationWrapper {...{ formOpts, path, stateKey }}>\r\n//         {childElement}\r\n//       </ValidationWrapper>\r\n//     </>\r\n//   );\r\n// };\r\nexport type ValidationWrapperProps = {\r\n  formOpts?: FormOptsType;\r\n  path: string[];\r\n  stateKey: string;\r\n  children: React.ReactNode;\r\n  validIndices?: number[];\r\n};\r\nexport function ValidationWrapper({\r\n  formOpts,\r\n  path,\r\n\r\n  stateKey,\r\n  children,\r\n  validIndices,\r\n}: ValidationWrapperProps) {\r\n  const { getInitialOptions } = getGlobalStore.getState();\r\n  const thisStateOpts = getInitialOptions(stateKey!);\r\n  const validationKey = thisStateOpts?.validation?.key ?? stateKey!;\r\n  const validationErrors = useGetValidationErrors(\r\n    validationKey,\r\n    path,\r\n    validIndices\r\n  );\r\n  console.log(\r\n    'validationErrors ValidationWrapper',\r\n    stateKey,\r\n    validationKey,\r\n    path,\r\n    validationErrors\r\n  );\r\n  const thesMessages: string[] = [];\r\n\r\n  if (validationErrors) {\r\n    const newMessage = validationErrors!.join(', ');\r\n    if (!thesMessages.includes(newMessage)) {\r\n      thesMessages.push(newMessage);\r\n    }\r\n  }\r\n\r\n  return (\r\n    <>\r\n      {thisStateOpts?.formElements?.validation &&\r\n      !formOpts?.validation?.disable ? (\r\n        thisStateOpts.formElements!.validation!({\r\n          children: (\r\n            <React.Fragment key={path.toString()}>{children}</React.Fragment>\r\n          ),\r\n          active: validationErrors.length > 0 ? true : false,\r\n          message: formOpts?.validation?.hideMessage\r\n            ? ''\r\n            : formOpts?.validation?.message\r\n              ? formOpts?.validation?.message\r\n              : thesMessages.map((m) => m).join(', '),\r\n          path: path,\r\n        })\r\n      ) : (\r\n        <React.Fragment key={path.toString()}>{children}</React.Fragment>\r\n      )}\r\n    </>\r\n  );\r\n}\r\n"],"names":["useStoreSubscription","fullPath","selector","compare","a","b","value","setValue","useState","getGlobalStore","previousValueRef","useRef","fullPathRef","useEffect","callback","store","newValue","unsubscribe","useGetValidationErrors","validationKey","path","validIndices","ValidationWrapper","formOpts","stateKey","children","getInitialOptions","thisStateOpts","validationErrors","thesMessages","newMessage","jsx","Fragment","React","m"],"mappings":";;;AAMO,MAAMA,IAAuB,CAClCC,GACAC,GAIAC,IAAmC,CAACC,GAAGC,MACrC,KAAK,UAAUD,CAAC,MAAM,KAAK,UAAUC,CAAC,MACrC;AACH,QAAM,CAACC,GAAOC,CAAQ,IAAIC;AAAA,IAAY,MACpCN,EAASO,EAAe,SAAA,GAAYR,CAAQ;AAAA,EAAA,GAExCS,IAAmBC,EAAUL,CAAK,GAClCM,IAAcD,EAAOV,CAAQ;AACnC,SAAAY,EAAU,MAAM;AACd,IAAAD,EAAY,UAAUX,GAEtBM,EAASL,EAASO,EAAe,SAAA,GAAYR,CAAQ,CAAC;AAEtD,UAAMa,IAAW,CAACC,MAAe;AAC/B,YAAMC,IAAWd,EAASa,GAAOH,EAAY,OAAO;AAEpD,MAAKT,EAAQO,EAAiB,SAASM,CAAQ,MAC7CN,EAAiB,UAAUM,GAC3BT,EAASS,CAAQ;AAAA,IAErB,GACMC,IAAcR,EAAe,UAAUK,CAAQ;AACrD,WAAO,MAAM;AACX,MAAAG,EAAA;AAAA,IACF;AAAA,EACF,GAAG,CAAChB,CAAQ,CAAC,GACNK;AACT,GACaY,IAAyB,CACpCC,GACAC,GACAC,MACG;AACH,QAAMpB,IACJkB,IACA,OACCC,EAAK,SAAS,IAAI,CAACA,EAAK,KAAK,GAAG,CAAC,IAAI,CAAA,MACrCC,KAAgBA,EAAa,SAAS,IAAI,MAAMA,IAAe;AAOlE,SALqBrB;AAAA,IACnBC;AAAA,IACA,CAACc,GAAOK,MAASL,EAAM,oBAAoBK,CAAI,KAAK,CAAA;AAAA,EAAC;AAIzD;AAwKO,SAASE,EAAkB;AAAA,EAChC,UAAAC;AAAA,EACA,MAAAH;AAAA,EAEA,UAAAI;AAAA,EACA,UAAAC;AAAA,EACA,cAAAJ;AACF,GAA2B;AACzB,QAAM,EAAE,mBAAAK,EAAA,IAAsBjB,EAAe,SAAA,GACvCkB,IAAgBD,EAAkBF,CAAS,GAC3CL,IAAgBQ,GAAe,YAAY,OAAOH,GAClDI,IAAmBV;AAAA,IACvBC;AAAA,IACAC;AAAA,IACAC;AAAA,EAAA;AAEF,UAAQ;AAAA,IACN;AAAA,IACAG;AAAA,IACAL;AAAA,IACAC;AAAA,IACAQ;AAAA,EAAA;AAEF,QAAMC,IAAyB,CAAA;AAE/B,MAAID,GAAkB;AACpB,UAAME,IAAaF,EAAkB,KAAK,IAAI;AAC9C,IAAKC,EAAa,SAASC,CAAU,KACnCD,EAAa,KAAKC,CAAU;AAAA,EAEhC;AAEA,SACE,gBAAAC,EAAAC,GAAA,EACG,UAAAL,GAAe,cAAc,cAC9B,CAACJ,GAAU,YAAY,UACrBI,EAAc,aAAc,WAAY;AAAA,IACtC,4BACGM,EAAM,UAAN,EAAsC,UAAAR,KAAlBL,EAAK,UAAsB;AAAA,IAElD,QAAQQ,EAAiB,SAAS;AAAA,IAClC,SAASL,GAAU,YAAY,cAC3B,KACAA,GAAU,YAAY,UACpBA,GAAU,YAAY,UACtBM,EAAa,IAAI,CAACK,MAAMA,CAAC,EAAE,KAAK,IAAI;AAAA,IAC1C,MAAAd;AAAA,EAAA,CACD,IAED,gBAAAW,EAACE,EAAM,UAAN,EAAsC,UAAAR,EAAA,GAAlBL,EAAK,SAAA,CAAsB,GAEpD;AAEJ;"}