{"version":3,"file":"Functions.jsx","sources":["../src/Functions.tsx"],"sourcesContent":["import {\r\n  notifyComponent,\r\n  type EffectiveSetState,\r\n  type FormElementParams,\r\n  type FormOptsType,\r\n  type UpdateArg,\r\n  type UpdateOpts,\r\n} from \"./CogsState\";\r\n\r\nimport {\r\n  getNestedValue,\r\n  isFunction,\r\n  updateNestedProperty,\r\n  updateNestedPropertyIds,\r\n} from \"./utility\";\r\nimport { useEffect, useRef, useState } from \"react\";\r\nimport React from \"react\";\r\nimport { getGlobalStore, formRefStore } from \"./store\";\r\nimport { validateZodPathFunc } from \"./useValidateZodPath\";\r\nimport { ulid } from \"ulid\";\r\n\r\nexport function updateFn<U>(\r\n  setState: EffectiveSetState<U>,\r\n  payload: UpdateArg<U>,\r\n  path: string[],\r\n  validationKey?: string\r\n): void {\r\n  setState(\r\n    (prevState) => {\r\n      if (isFunction<U>(payload)) {\r\n        const nestedValue = payload(getNestedValue(prevState, path));\r\n        console.group(\"nestedValue\", path, nestedValue);\r\n        let value = updateNestedPropertyIds(path, prevState, nestedValue);\r\n        console.group(\"updateFn\", value);\r\n        if (typeof value == \"string\") {\r\n          value = value.trim();\r\n        }\r\n        return value;\r\n      } else {\r\n        let value =\r\n          !path || path.length == 0\r\n            ? payload\r\n            : updateNestedPropertyIds(path, prevState, payload);\r\n        if (typeof value == \"string\") {\r\n          value = value.trim();\r\n        }\r\n        return value;\r\n      }\r\n    },\r\n    path,\r\n    { updateType: \"update\" },\r\n    validationKey\r\n  );\r\n}\r\nexport function pushFunc<U>(\r\n  setState: EffectiveSetState<U>,\r\n  payload: UpdateArg<U>,\r\n  path: string[],\r\n  stateKey: string,\r\n  index?: number\r\n): void {\r\n  // --- THE FIX ---\r\n  // 1. Determine the newItem and its ID BEFORE calling setState.\r\n  const arrayBeforeUpdate =\r\n    (getGlobalStore.getState().getNestedState(stateKey, path) as any[]) || [];\r\n\r\n  const newItem = isFunction<U>(payload)\r\n    ? payload(arrayBeforeUpdate as any)\r\n    : payload;\r\n\r\n  // 2. Ensure it has an ID.\r\n  if (typeof newItem === \"object\" && newItem !== null && !(newItem as any).id) {\r\n    (newItem as any).id = ulid();\r\n  }\r\n  const finalId = (newItem as any).id;\r\n  // --- END OF FIX ---\r\n\r\n  setState(\r\n    (prevState) => {\r\n      // The logic inside here is now much simpler.\r\n      // We already have the final `newItem`.\r\n      const arrayToUpdate = getNestedValue(prevState, [...path]) || [];\r\n      const newArray = [...arrayToUpdate];\r\n      newArray.splice(index ?? newArray.length, 0, newItem);\r\n      return updateNestedPropertyIds([...path], prevState, newArray);\r\n    },\r\n    [...path, `id:${finalId}`], // Now we use the ID that is guaranteed to be correct.\r\n    {\r\n      updateType: \"insert\",\r\n    }\r\n  );\r\n}\r\nexport function cutFunc<U>(\r\n  setState: EffectiveSetState<U>,\r\n  path: string[],\r\n  stateKey: string,\r\n  index: number\r\n): void {\r\n  // Get the ordered IDs to find the ID for this index\r\n  const arrayKey = [stateKey, ...path].join(\".\");\r\n  const arrayMeta = getGlobalStore.getState().shadowStateStore.get(arrayKey);\r\n  const itemId = arrayMeta?.arrayKeys?.[index];\r\n\r\n  if (!itemId) {\r\n    throw new Error(`No ID found for index ${index} in array`);\r\n  }\r\n\r\n  setState(\r\n    (prevState) => {\r\n      const arrayToUpdate = getNestedValue(prevState, [...path]);\r\n      if (index < 0 || index >= arrayToUpdate?.length) {\r\n        throw new Error(`Index ${index} does not exist in the array.`);\r\n      }\r\n\r\n      const updatedArray = [\r\n        ...arrayToUpdate.slice(0, index),\r\n        ...arrayToUpdate.slice(index + 1),\r\n      ] as U;\r\n\r\n      return path.length == 0\r\n        ? updatedArray\r\n        : updateNestedPropertyIds([...path], prevState, updatedArray);\r\n    },\r\n    [...path, itemId], // Use the ID here!\r\n    { updateType: \"cut\" }\r\n  );\r\n}\r\n\r\nexport const useStoreSubscription = <T,>(\r\n  fullPath: string,\r\n  selector: (\r\n    store: ReturnType<typeof getGlobalStore.getState>,\r\n    path: string\r\n  ) => T,\r\n  compare: (a: T, b: T) => boolean = (a, b) =>\r\n    JSON.stringify(a) === JSON.stringify(b)\r\n) => {\r\n  const [value, setValue] = useState<T>(() =>\r\n    selector(getGlobalStore.getState(), fullPath)\r\n  );\r\n  const previousValueRef = useRef<T>(value);\r\n  const fullPathRef = useRef(fullPath);\r\n  useEffect(() => {\r\n    fullPathRef.current = fullPath; // Ensure latest fullPath is always used\r\n\r\n    setValue(selector(getGlobalStore.getState(), fullPath));\r\n\r\n    const callback = (store: any) => {\r\n      const newValue = selector(store, fullPathRef.current);\r\n\r\n      if (!compare(previousValueRef.current, newValue)) {\r\n        previousValueRef.current = newValue;\r\n        setValue(newValue);\r\n      }\r\n    };\r\n    const unsubscribe = getGlobalStore.subscribe(callback);\r\n    return () => {\r\n      unsubscribe();\r\n    };\r\n  }, [fullPath]);\r\n  return value;\r\n};\r\nexport const useGetValidationErrors = (\r\n  validationKey: string,\r\n  path: string[],\r\n  validIndices?: number[]\r\n) => {\r\n  const fullPath =\r\n    validationKey +\r\n    \".\" +\r\n    (path.length > 0 ? [path.join(\".\")] : []) +\r\n    (validIndices && validIndices.length > 0 ? \".\" + validIndices : \"\");\r\n\r\n  const returnresult = useStoreSubscription(\r\n    fullPath,\r\n    (store, path) => store.getValidationErrors(path) || []\r\n  );\r\n\r\n  return returnresult;\r\n};\r\n\r\nexport const useGetSyncInfo = (key: string, path: string[]) => {\r\n  const syncKey = `${key}:${path.join(\".\")}`;\r\n  return useStoreSubscription(syncKey, (store, path) =>\r\n    store.getSyncInfo(path)\r\n  );\r\n};\r\nexport const useGetKeyState = (key: string, path: string[]) => {\r\n  return useStoreSubscription(`${key}:${path.join(\".\")}`, (store, fullPath) =>\r\n    store.getNestedState(key, path)\r\n  );\r\n};\r\ninterface FormControlComponentProps<TStateObject> {\r\n  setState: EffectiveSetState<TStateObject>;\r\n\r\n  path: string[];\r\n  child: (obj: FormElementParams<TStateObject>) => JSX.Element;\r\n  formOpts?: FormOptsType;\r\n  stateKey: string;\r\n}\r\n// Find FormControlComponent in your Functions.ts or equivalent file\r\n\r\nexport const FormControlComponent = <TStateObject,>({\r\n  setState, // This is the real effectiveSetState from the hook\r\n  path,\r\n  child,\r\n  formOpts,\r\n  stateKey,\r\n}: FormControlComponentProps<TStateObject>) => {\r\n  const { registerFormRef, getFormRef } = formRefStore.getState();\r\n  const {\r\n    getValidationErrors,\r\n    addValidationError,\r\n    getInitialOptions,\r\n    removeValidationError,\r\n  } = getGlobalStore.getState();\r\n\r\n  const refKey = stateKey + \".\" + path.join(\".\");\r\n  const localFormRef = useRef<HTMLInputElement>(null);\r\n  const existingRef = getFormRef(refKey);\r\n  if (!existingRef) {\r\n    registerFormRef(refKey, localFormRef);\r\n  }\r\n  const formRef = existingRef || localFormRef;\r\n\r\n  // --- START CHANGES ---\r\n\r\n  const globalStateValue = useGetKeyState(stateKey, path);\r\n  const [localValue, setLocalValue] = useState<any>(globalStateValue);\r\n  const isCurrentlyDebouncing = useRef(false);\r\n  const debounceTimeoutRef = useRef<NodeJS.Timeout | null>(null);\r\n\r\n  // Effect to sync local state if global state changes externally\r\n  useEffect(() => {\r\n    // Only update local if not actively debouncing a local change\r\n    if (!isCurrentlyDebouncing.current && globalStateValue !== localValue) {\r\n      setLocalValue(globalStateValue);\r\n    }\r\n  }, [globalStateValue]); // Removed localValue dependency\r\n\r\n  // Effect for cleanup\r\n  useEffect(() => {\r\n    return () => {\r\n      if (debounceTimeoutRef.current) {\r\n        clearTimeout(debounceTimeoutRef.current);\r\n        debounceTimeoutRef.current = null; // Explicitly nullify\r\n        isCurrentlyDebouncing.current = false;\r\n      }\r\n    };\r\n  }, []);\r\n\r\n  const debouncedUpdater = (payload: UpdateArg<TStateObject>) => {\r\n    setLocalValue(payload); // Update local state immediately\r\n    isCurrentlyDebouncing.current = true;\r\n\r\n    if (payload === \"\") {\r\n      if (debounceTimeoutRef.current) {\r\n        clearTimeout(debounceTimeoutRef.current); // Clear pending timer\r\n        debounceTimeoutRef.current = null;\r\n      }\r\n      updateFn(setState, payload, path, validationKey); // Update global state NOW\r\n      isCurrentlyDebouncing.current = false; // No longer debouncing\r\n      return; // Don't proceed to set another timeout\r\n    }\r\n\r\n    // If not empty, proceed with normal debouncing\r\n    if (debounceTimeoutRef.current) {\r\n      clearTimeout(debounceTimeoutRef.current);\r\n    }\r\n\r\n    debounceTimeoutRef.current = setTimeout(\r\n      () => {\r\n        isCurrentlyDebouncing.current = false;\r\n        updateFn(setState, payload, path, validationKey);\r\n      },\r\n      formOpts?.debounceTime ??\r\n        (typeof globalStateValue == \"boolean\" ? 20 : 200)\r\n    );\r\n  };\r\n\r\n  const initialOptions = getInitialOptions(stateKey);\r\n  if (!initialOptions?.validation?.key) {\r\n    throw new Error(\"Validation key not found.\");\r\n  }\r\n  const validationKey = initialOptions.validation.key;\r\n  const validateOnBlur = initialOptions.validation.onBlur === true;\r\n\r\n  const handleBlur = async () => {\r\n    // --- Ensure latest value is flushed if debouncing ---\r\n    if (debounceTimeoutRef.current) {\r\n      clearTimeout(debounceTimeoutRef.current); // Clear pending timer\r\n      debounceTimeoutRef.current = null;\r\n      isCurrentlyDebouncing.current = false;\r\n      // Ensure the absolute latest local value is committed on blur\r\n      updateFn(setState, localValue, path, validationKey);\r\n    }\r\n    // --- End modification ---\r\n\r\n    if (!initialOptions.validation?.zodSchema || !validateOnBlur) return;\r\n    removeValidationError(validationKey + \".\" + path.join(\".\"));\r\n    try {\r\n      // Use the potentially just flushed value\r\n      const fieldValue = getGlobalStore\r\n        .getState()\r\n        .getNestedState(stateKey, path);\r\n      await validateZodPathFunc(\r\n        validationKey,\r\n        initialOptions.validation.zodSchema,\r\n        path,\r\n        fieldValue\r\n      );\r\n      // forceUpdate might be needed if validation state update doesn't trigger render\r\n      // Consider using useGetValidationErrors hook result directly for validation display\r\n    } catch (error) {\r\n      console.error(\"Validation error on blur:\", error);\r\n    }\r\n  };\r\n\r\n  const rawSyncStatus = useGetSyncInfo(stateKey, path);\r\n  const syncStatus = rawSyncStatus\r\n    ? { ...rawSyncStatus, date: new Date(rawSyncStatus.timeStamp) }\r\n    : null;\r\n\r\n  const childElement = child({\r\n    // --- START CHANGES ---\r\n    get: () => localValue, // Get should return the immediate local value\r\n    set: debouncedUpdater, // Use the new debounced updater\r\n    // --- END CHANGES ---\r\n    syncStatus,\r\n    path: path,\r\n    validationErrors: () =>\r\n      getValidationErrors(validationKey + \".\" + path.join(\".\")),\r\n    addValidationError: (message?: string) => {\r\n      removeValidationError(validationKey + \".\" + path.join(\".\"));\r\n      addValidationError(validationKey + \".\" + path.join(\".\"), message ?? \"\");\r\n    },\r\n    inputProps: {\r\n      // --- START CHANGES ---\r\n      value: localValue ?? \"\", // Input value is always the local state\r\n      onChange: (e: any) => debouncedUpdater(e.target.value), // Use debounced updater\r\n      // --- END CHANGES ---\r\n      onBlur: handleBlur,\r\n      ref: formRef,\r\n    },\r\n  });\r\n\r\n  return (\r\n    <>\r\n      <ValidationWrapper {...{ formOpts, path, stateKey }}>\r\n        {childElement}\r\n      </ValidationWrapper>\r\n    </>\r\n  );\r\n};\r\nexport type ValidationWrapperProps = {\r\n  formOpts?: FormOptsType;\r\n  path: string[];\r\n  stateKey: string;\r\n  children: React.ReactNode;\r\n  validIndices?: number[];\r\n};\r\nexport function ValidationWrapper({\r\n  formOpts,\r\n  path,\r\n\r\n  stateKey,\r\n  children,\r\n  validIndices,\r\n}: ValidationWrapperProps) {\r\n  const { getInitialOptions } = getGlobalStore.getState();\r\n  const thisStateOpts = getInitialOptions(stateKey!);\r\n  const validationKey = thisStateOpts?.validation?.key ?? stateKey!;\r\n  const validationErrors = useGetValidationErrors(\r\n    validationKey,\r\n    path,\r\n    validIndices\r\n  );\r\n  // console.log(\r\n  //   \"validationErrors ValidationWrapper\",\r\n  //   stateKey,\r\n  //   validationKey,\r\n  //   path,\r\n  //   validationErrors\r\n  // );\r\n  const thesMessages: string[] = [];\r\n\r\n  if (validationErrors) {\r\n    const newMessage = validationErrors!.join(\", \");\r\n    if (!thesMessages.includes(newMessage)) {\r\n      thesMessages.push(newMessage);\r\n    }\r\n  }\r\n\r\n  return (\r\n    <>\r\n      {thisStateOpts?.formElements?.validation &&\r\n      !formOpts?.validation?.disable ? (\r\n        thisStateOpts.formElements!.validation!({\r\n          children: (\r\n            <React.Fragment key={path.toString()}>{children}</React.Fragment>\r\n          ),\r\n          active: validationErrors.length > 0 ? true : false,\r\n          message: formOpts?.validation?.hideMessage\r\n            ? \"\"\r\n            : formOpts?.validation?.message\r\n              ? formOpts?.validation?.message\r\n              : thesMessages.map((m) => m).join(\", \"),\r\n          path: path,\r\n        })\r\n      ) : (\r\n        <React.Fragment key={path.toString()}>{children}</React.Fragment>\r\n      )}\r\n    </>\r\n  );\r\n}\r\n"],"names":["updateFn","setState","payload","path","validationKey","prevState","isFunction","nestedValue","getNestedValue","value","updateNestedPropertyIds","pushFunc","stateKey","index","arrayBeforeUpdate","getGlobalStore","newItem","ulid","finalId","newArray","cutFunc","arrayKey","itemId","arrayToUpdate","updatedArray","useStoreSubscription","fullPath","selector","compare","a","b","setValue","useState","previousValueRef","useRef","fullPathRef","useEffect","callback","store","newValue","unsubscribe","useGetValidationErrors","validIndices","useGetSyncInfo","key","syncKey","useGetKeyState","FormControlComponent","child","formOpts","registerFormRef","getFormRef","formRefStore","getValidationErrors","addValidationError","getInitialOptions","removeValidationError","refKey","localFormRef","existingRef","formRef","globalStateValue","localValue","setLocalValue","isCurrentlyDebouncing","debounceTimeoutRef","debouncedUpdater","initialOptions","validateOnBlur","handleBlur","fieldValue","validateZodPathFunc","error","rawSyncStatus","syncStatus","childElement","message","e","jsx","Fragment","ValidationWrapper","children","thisStateOpts","validationErrors","thesMessages","newMessage","React","m"],"mappings":"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"}