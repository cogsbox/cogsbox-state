{"version":3,"file":"Functions.jsx","sources":["../src/Functions.tsx"],"sourcesContent":["import { type FormOptsType } from './CogsState';\r\n\r\nimport { useEffect, useRef, useState } from 'react';\r\nimport React from 'react';\r\nimport { getGlobalStore } from './store';\r\n\r\nexport const useStoreSubscription = <T,>(\r\n  fullPath: string,\r\n  selector: (\r\n    store: ReturnType<typeof getGlobalStore.getState>,\r\n    path: string\r\n  ) => T,\r\n  compare: (a: T, b: T) => boolean = (a, b) =>\r\n    JSON.stringify(a) === JSON.stringify(b)\r\n) => {\r\n  const [value, setValue] = useState<T>(() =>\r\n    selector(getGlobalStore.getState(), fullPath)\r\n  );\r\n  const previousValueRef = useRef<T>(value);\r\n  const fullPathRef = useRef(fullPath);\r\n  useEffect(() => {\r\n    fullPathRef.current = fullPath; // Ensure latest fullPath is always used\r\n\r\n    setValue(selector(getGlobalStore.getState(), fullPath));\r\n\r\n    const callback = (store: any) => {\r\n      const newValue = selector(store, fullPathRef.current);\r\n\r\n      if (!compare(previousValueRef.current, newValue)) {\r\n        previousValueRef.current = newValue;\r\n        setValue(newValue);\r\n      }\r\n    };\r\n    const unsubscribe = getGlobalStore.subscribe(callback);\r\n    return () => {\r\n      unsubscribe();\r\n    };\r\n  }, [fullPath]);\r\n  return value;\r\n};\r\nexport const useGetValidationErrors = (\r\n  validationKey: string,\r\n  path: string[],\r\n  validIndices?: number[]\r\n) => {\r\n  const fullPath =\r\n    validationKey +\r\n    '.' +\r\n    (path.length > 0 ? [path.join('.')] : []) +\r\n    (validIndices && validIndices.length > 0 ? '.' + validIndices : '');\r\n\r\n  const returnresult = useStoreSubscription(\r\n    fullPath,\r\n    (store, path) => store.getValidationErrors(path) || []\r\n  );\r\n\r\n  return returnresult;\r\n};\r\n\r\n// Find FormControlComponent in your Functions.ts or equivalent file\r\n\r\n// export const FormControlComponent = <TStateObject,>({\r\n//   setState, // This is the real effectiveSetState from the hook\r\n//   path,\r\n//   child,\r\n//   formOpts,\r\n//   stateKey,\r\n//   rebuildStateShape,\r\n// }: FormControlComponentProps<TStateObject>) => {\r\n//   const { registerFormRef, getFormRef } = formRefStore.getState();\r\n//   const {\r\n//     getValidationErrors,\r\n//     addValidationError,\r\n//     getInitialOptions,\r\n//     removeValidationError,\r\n//   } = getGlobalStore.getState();\r\n//   const stateKeyPathKey = [stateKey, ...path].join('.');\r\n//   const [, forceUpdate] = useState<any>();\r\n//   getGlobalStore.getState().subscribeToPath(stateKeyPathKey, () => {\r\n//     forceUpdate({});\r\n//   });\r\n\r\n//   const refKey = stateKey + '.' + path.join('.');\r\n//   const localFormRef = useRef<HTMLInputElement>(null);\r\n//   const existingRef = getFormRef(refKey);\r\n//   if (!existingRef) {\r\n//     registerFormRef(refKey, localFormRef);\r\n//   }\r\n//   const formRef = existingRef || localFormRef;\r\n\r\n//   // --- START CHANGES ---\r\n\r\n//   const globalStateValue = getGlobalStore\r\n//     .getState()\r\n//     .getShadowValue(stateKeyPathKey);\r\n//   const [localValue, setLocalValue] = useState<any>(globalStateValue);\r\n//   const isCurrentlyDebouncing = useRef(false);\r\n//   const debounceTimeoutRef = useRef<NodeJS.Timeout | null>(null);\r\n\r\n//   // Effect to sync local state if global state changes externally\r\n//   useEffect(() => {\r\n//     // Only update local if not actively debouncing a local change\r\n//     if (!isCurrentlyDebouncing.current && globalStateValue !== localValue) {\r\n//       setLocalValue(globalStateValue);\r\n//     }\r\n//   }, [globalStateValue]); // Removed localValue dependency\r\n\r\n//   // Effect for cleanup\r\n//   useEffect(() => {\r\n//     return () => {\r\n//       if (debounceTimeoutRef.current) {\r\n//         clearTimeout(debounceTimeoutRef.current);\r\n//         debounceTimeoutRef.current = null; // Explicitly nullify\r\n//         isCurrentlyDebouncing.current = false;\r\n//       }\r\n//     };\r\n//   }, []);\r\n\r\n//   const debouncedUpdater = (payload: UpdateArg<TStateObject>) => {\r\n//     setLocalValue(payload); // Update local state immediately\r\n//     isCurrentlyDebouncing.current = true;\r\n\r\n//     if (payload === '') {\r\n//       if (debounceTimeoutRef.current) {\r\n//         clearTimeout(debounceTimeoutRef.current); // Clear pending timer\r\n//         debounceTimeoutRef.current = null;\r\n//       }\r\n\r\n//       setState(payload, path, { updateType: 'update' });\r\n//       isCurrentlyDebouncing.current = false; // No longer debouncing\r\n//       return; // Don't proceed to set another timeout\r\n//     }\r\n\r\n//     // If not empty, proceed with normal debouncing\r\n//     if (debounceTimeoutRef.current) {\r\n//       clearTimeout(debounceTimeoutRef.current);\r\n//     }\r\n\r\n//     debounceTimeoutRef.current = setTimeout(\r\n//       () => {\r\n//         isCurrentlyDebouncing.current = false;\r\n//         console.log('debouncedUpdater', payload);\r\n//         setState(payload, path, { updateType: 'update' });\r\n//       },\r\n//       formOpts?.debounceTime ??\r\n//         (typeof globalStateValue == 'boolean' ? 20 : 200)\r\n//     );\r\n//   };\r\n\r\n//   const initialOptions = getInitialOptions(stateKey);\r\n\r\n//   const validationKey = initialOptions?.validation?.key;\r\n//   const validateOnBlur = initialOptions?.validation?.onBlur === true;\r\n\r\n//   const handleBlur = async () => {\r\n//     // --- Ensure latest value is flushed if debouncing ---\r\n//     if (debounceTimeoutRef.current) {\r\n//       clearTimeout(debounceTimeoutRef.current); // Clear pending timer\r\n//       debounceTimeoutRef.current = null;\r\n//       isCurrentlyDebouncing.current = false;\r\n//       // Ensure the absolute latest local value is committed on blur\r\n//       setState(localValue, path, { updateType: 'update' });\r\n//     }\r\n//     // --- End modification ---\r\n\r\n//     if (!initialOptions?.validation?.zodSchema || !validateOnBlur) return;\r\n//     removeValidationError(validationKey + '.' + path.join('.'));\r\n//     try {\r\n//       // Use the potentially just flushed value\r\n//       if (!validationKey) return;\r\n//       const fieldValue = getGlobalStore\r\n//         .getState()\r\n//         .getShadowValue(stateKeyPathKey);\r\n//       await validateZodPathFunc(\r\n//         validationKey,\r\n//         initialOptions.validation.zodSchema,\r\n//         path,\r\n//         fieldValue\r\n//       );\r\n//       // forceUpdate might be needed if validation state update doesn't trigger render\r\n//       // Consider using useGetValidationErrors hook result directly for validation display\r\n//     } catch (error) {\r\n//       console.error('Validation error on blur:', error);\r\n//     }\r\n//   };\r\n\r\n//   const childElement = child({\r\n//     state: setter,\r\n//     // --- START CHANGES ---\r\n//     get: () => localValue, // Get should return the immediate local value\r\n//     set: debouncedUpdater, // Use the new debounced updater\r\n//     // --- END CHANGES ---\r\n\r\n//     path: path,\r\n//     validationErrors: () =>\r\n//       getValidationErrors(validationKey + '.' + path.join('.')),\r\n//     addValidationError: (message?: string) => {\r\n//       removeValidationError(validationKey + '.' + path.join('.'));\r\n//       addValidationError(validationKey + '.' + path.join('.'), message ?? '');\r\n//     },\r\n//     inputProps: {\r\n//       // --- START CHANGES ---\r\n//       value: localValue ?? '', // Input value is always the local state\r\n//       onChange: (e: any) => debouncedUpdater(e.target.value), // Use debounced updater\r\n//       // --- END CHANGES ---\r\n//       onBlur: handleBlur,\r\n//       ref: formRef,\r\n//     },\r\n//   });\r\n\r\n//   return (\r\n//     <>\r\n//       <ValidationWrapper {...{ formOpts, path, stateKey }}>\r\n//         {childElement}\r\n//       </ValidationWrapper>\r\n//     </>\r\n//   );\r\n// };\r\nexport type ValidationWrapperProps = {\r\n  formOpts?: FormOptsType;\r\n  path: string[];\r\n  stateKey: string;\r\n  children: React.ReactNode;\r\n  validIndices?: number[];\r\n};\r\nexport function ValidationWrapper({\r\n  formOpts,\r\n  path,\r\n  stateKey,\r\n  children,\r\n  validIndices,\r\n}: ValidationWrapperProps) {\r\n  const { getInitialOptions, getShadowMetadata } = getGlobalStore.getState();\r\n  const thisStateOpts = getInitialOptions(stateKey!);\r\n\r\n  // Get validation from shadow metadata instead of global errors\r\n  const shadowMeta = getShadowMetadata(stateKey!, path);\r\n  const hasValidationError =\r\n    shadowMeta?.validation?.status === 'VALIDATION_FAILED';\r\n  const validationMessage = shadowMeta?.validation?.message;\r\n\r\n  console.log('ValidationWrapper shadow meta:', {\r\n    stateKey,\r\n    path,\r\n    shadowMeta,\r\n    hasValidationError,\r\n    validationMessage,\r\n  });\r\n\r\n  return (\r\n    <>\r\n      {thisStateOpts?.formElements?.validation &&\r\n      !formOpts?.validation?.disable ? (\r\n        thisStateOpts.formElements!.validation!({\r\n          children: (\r\n            <React.Fragment key={path.toString()}>{children}</React.Fragment>\r\n          ),\r\n          active: hasValidationError,\r\n          message: formOpts?.validation?.hideMessage\r\n            ? ''\r\n            : formOpts?.validation?.message\r\n              ? formOpts?.validation?.message\r\n              : validationMessage || '',\r\n          path: path,\r\n        })\r\n      ) : (\r\n        <React.Fragment key={path.toString()}>{children}</React.Fragment>\r\n      )}\r\n    </>\r\n  );\r\n}\r\n"],"names":["ValidationWrapper","formOpts","path","stateKey","children","validIndices","getInitialOptions","getShadowMetadata","getGlobalStore","thisStateOpts","shadowMeta","hasValidationError","validationMessage","jsx","Fragment","React"],"mappings":";;;AAiOO,SAASA,EAAkB;AAAA,EAChC,UAAAC;AAAA,EACA,MAAAC;AAAA,EACA,UAAAC;AAAA,EACA,UAAAC;AAAA,EACA,cAAAC;AACF,GAA2B;AACzB,QAAM,EAAE,mBAAAC,GAAmB,mBAAAC,MAAsBC,EAAe,SAAA,GAC1DC,IAAgBH,EAAkBH,CAAS,GAG3CO,IAAaH,EAAkBJ,GAAWD,CAAI,GAC9CS,IACJD,GAAY,YAAY,WAAW,qBAC/BE,IAAoBF,GAAY,YAAY;AAElD,iBAAQ,IAAI,kCAAkC;AAAA,IAC5C,UAAAP;AAAA,IACA,MAAAD;AAAA,IACA,YAAAQ;AAAA,IACA,oBAAAC;AAAA,IACA,mBAAAC;AAAA,EAAA,CACD,GAGC,gBAAAC,EAAAC,GAAA,EACG,UAAAL,GAAe,cAAc,cAC9B,CAACR,GAAU,YAAY,UACrBQ,EAAc,aAAc,WAAY;AAAA,IACtC,4BACGM,EAAM,UAAN,EAAsC,UAAAX,KAAlBF,EAAK,UAAsB;AAAA,IAElD,QAAQS;AAAA,IACR,SAASV,GAAU,YAAY,cAC3B,KACAA,GAAU,YAAY,UACpBA,GAAU,YAAY,UACtBW,KAAqB;AAAA,IAC3B,MAAAV;AAAA,EAAA,CACD,IAED,gBAAAW,EAACE,EAAM,UAAN,EAAsC,UAAAX,EAAA,GAAlBF,EAAK,SAAA,CAAsB,GAEpD;AAEJ;"}