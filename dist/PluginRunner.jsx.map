{"version":3,"file":"PluginRunner.jsx","sources":["../src/PluginRunner.tsx"],"sourcesContent":["import React, { useEffect, useMemo, useReducer, useRef } from 'react';\r\nimport { pluginStore } from './pluginStore';\r\nimport { getGlobalStore } from './store';\r\nimport { isDeepEqual } from './utility';\r\nimport type { CogsPlugin, PluginContext } from './plugins';\r\n\r\nimport type { StateObject, UpdateTypeDetail } from './CogsState';\r\nconst { setHookResult, removeHookResult } = pluginStore.getState();\r\n/**\r\n * An invisible \"controller\" component that manages the lifecycle for a SINGLE plugin instance.\r\n * Its only job is to correctly call the plugin's hooks and effects.\r\n * By isolating each plugin here, we guarantee the Rules of Hooks are followed.\r\n */\r\nconst PluginInstance = React.memo(\r\n  ({\r\n    stateKey,\r\n    plugin,\r\n    options,\r\n    stateHandler,\r\n  }: {\r\n    stateKey: string;\r\n    plugin: CogsPlugin<any, any, any, any>;\r\n    options: any;\r\n    stateHandler: StateObject<any>;\r\n  }) => {\r\n    // 1. Create a stable context object for the hooks.\r\n    const context = useMemo<PluginContext<any, any>>(\r\n      () => ({\r\n        stateKey,\r\n        cogsState: stateHandler,\r\n        getPluginMetaData: () =>\r\n          getGlobalStore\r\n            .getState()\r\n            .getPluginMetaDataMap(stateKey, [])\r\n            ?.get(plugin.name),\r\n        setPluginMetaData: (data: any) =>\r\n          getGlobalStore\r\n            .getState()\r\n            .setPluginMetaData(stateKey, plugin.name, data),\r\n        removePluginMetaData: () =>\r\n          getGlobalStore\r\n            .getState()\r\n            .removePluginMetaData(stateKey, [], plugin.name),\r\n      }),\r\n      [stateKey, stateHandler, plugin.name]\r\n    );\r\n\r\n    // 2. Call the plugin's hook at the top level of this component. This is the main fix.\r\n    const hookData = plugin.useHook\r\n      ? plugin.useHook(context, options)\r\n      : undefined;\r\n\r\n    useEffect(() => {\r\n      if (plugin.useHook) setHookResult(stateKey, plugin.name, hookData);\r\n      else removeHookResult(stateKey, plugin.name);\r\n\r\n      return () => removeHookResult(stateKey, plugin.name);\r\n    }, [stateKey, plugin.name, !!plugin.useHook, hookData]);\r\n\r\n    // 3. Handle `transformState`. This effect runs ONLY when the plugin's options change.\r\n    const lastProcessedOptionsRef = useRef<any>();\r\n    useEffect(() => {\r\n      if (plugin.transformState) {\r\n        // Use deep equality to prevent re-running for objects with the same value.\r\n        if (!isDeepEqual(options, lastProcessedOptionsRef.current)) {\r\n          plugin.transformState(context, options, hookData);\r\n          lastProcessedOptionsRef.current = options;\r\n        }\r\n      }\r\n    }, [context, plugin, options, hookData]); // Dependencies ensure this logic is re-evaluated correctly.\r\n\r\n    // 4. Handle `onUpdate`. This effect subscribes to the global update bus.\r\n    const hookDataRef = useRef(hookData);\r\n    hookDataRef.current = hookData; // Keep the ref updated with the latest hookData on every render.\r\n\r\n    useEffect(() => {\r\n      if (!plugin.onUpdate) {\r\n        return; // Do nothing if the plugin doesn't have this method.\r\n      }\r\n\r\n      const handleUpdate = (update: UpdateTypeDetail) => {\r\n        // We only care about updates for the stateKey this instance is responsible for.\r\n        if (update.stateKey === stateKey) {\r\n          // As you corrected, the first param is just the stateKey.\r\n          // We read from the ref to ensure the callback uses the LATEST hookData\r\n          // without needing to re-subscribe on every render.\r\n          plugin.onUpdate!(stateKey, update, options, hookDataRef.current);\r\n        }\r\n      };\r\n\r\n      const unsubscribe = pluginStore\r\n        .getState()\r\n        .subscribeToUpdates(handleUpdate);\r\n      return unsubscribe; // React will call this cleanup function when the component unmounts.\r\n    }, [stateKey, plugin, options, context]); // The dependencies are stable and correctly manage the subscription lifecycle.\r\n    useEffect(() => {\r\n      if (!plugin.onFormUpdate) {\r\n        return; // Do nothing if the plugin doesn't have this method.\r\n      }\r\n\r\n      const handleFormUpdate = (event: {\r\n        stateKey: string;\r\n        type: 'focus' | 'blur' | 'input';\r\n        path: string;\r\n        value?: any;\r\n      }) => {\r\n        // Only handle events for this stateKey\r\n        if (event.stateKey === stateKey) {\r\n          plugin.onFormUpdate!(\r\n            stateKey,\r\n            {\r\n              type: event.type,\r\n              path: event.path,\r\n              value: event.value,\r\n            },\r\n            options,\r\n            hookDataRef.current\r\n          );\r\n        }\r\n      };\r\n\r\n      const unsubscribe = pluginStore\r\n        .getState()\r\n        .subscribeToFormUpdates(handleFormUpdate);\r\n      return unsubscribe;\r\n    }, [stateKey, plugin, options]);\r\n    // This component renders nothing to the DOM.\r\n    return null;\r\n  }\r\n);\r\n\r\n/**\r\n * The main orchestrator component. It reads from the central pluginStore\r\n * and renders a `PluginInstance` controller for each active plugin.\r\n */\r\nexport function PluginRunner({ children }: { children: React.ReactNode }) {\r\n  // A simple way to force a re-render when the store changes.\r\n  const [, forceUpdate] = useReducer((c) => c + 1, 0);\r\n\r\n  // Subscribe to the store. When plugins or their options are added/removed,\r\n  // this component will re-render to update the list of PluginInstances.\r\n  useEffect(() => {\r\n    const unsubscribe = pluginStore.subscribe(forceUpdate);\r\n    return unsubscribe;\r\n  }, []);\r\n\r\n  const { pluginOptions, stateHandlers, registeredPlugins } =\r\n    pluginStore.getState();\r\n\r\n  return (\r\n    <>\r\n      {/*\r\n        This declarative mapping is the core of the solution.\r\n        React will now manage adding and removing `PluginInstance` components\r\n        as the application state changes, ensuring hooks are handled safely.\r\n      */}\r\n      {Array.from(pluginOptions.entries()).map(([stateKey, pluginMap]) => {\r\n        const stateHandler = stateHandlers.get(stateKey);\r\n        if (!stateHandler) {\r\n          return null; // Don't render a runner if the state handler isn't ready.\r\n        }\r\n\r\n        return Array.from(pluginMap.entries()).map(([pluginName, options]) => {\r\n          const plugin = registeredPlugins.find((p) => p.name === pluginName);\r\n          if (!plugin) {\r\n            return null; // Don't render if the plugin is not in the registered list.\r\n          }\r\n\r\n          // Render a dedicated, memoized controller for this specific plugin configuration.\r\n          return (\r\n            <PluginInstance\r\n              key={`${stateKey}:${pluginName}`}\r\n              stateKey={stateKey}\r\n              plugin={plugin}\r\n              options={options}\r\n              stateHandler={stateHandler}\r\n            />\r\n          );\r\n        });\r\n      })}\r\n\r\n      {children}\r\n    </>\r\n  );\r\n}\r\n"],"names":["setHookResult","removeHookResult","pluginStore","PluginInstance","React","stateKey","plugin","options","stateHandler","context","useMemo","getGlobalStore","data","hookData","useEffect","lastProcessedOptionsRef","useRef","isDeepEqual","hookDataRef","handleUpdate","update","handleFormUpdate","event","PluginRunner","children","forceUpdate","useReducer","c","pluginOptions","stateHandlers","registeredPlugins","jsxs","Fragment","pluginMap","pluginName","p","jsx"],"mappings":"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"}