{"version":3,"file":"PluginRunner.jsx","sources":["../src/PluginRunner.tsx"],"sourcesContent":["import React, { useEffect, useRef, useState } from 'react';\r\nimport { pluginStore } from './pluginStore';\r\nimport { getGlobalStore } from './store';\r\nimport { isDeepEqual } from './utility';\r\nimport type { UpdateTypeDetail } from './CogsState';\r\n\r\nexport function PluginRunner({ children }: { children: React.ReactNode }) {\r\n  const [, forceUpdate] = useState({});\r\n  const lastProcessedOptionsRef = useRef<Map<string, any>>(new Map());\r\n\r\n  // Subscribe to the store to re-render when plugins or options are registered\r\n  useEffect(() => {\r\n    const unsubscribe = pluginStore.subscribe(() => {\r\n      forceUpdate({});\r\n    });\r\n    return unsubscribe;\r\n  }, []);\r\n\r\n  const state = pluginStore.getState();\r\n\r\n  // --- PHASE 1: Run hooks and collect results for this render ---\r\n  const hookResults = new Map<string, any>();\r\n  state.pluginOptions.forEach((pluginMap, stateKey) => {\r\n    const stateHandler = state.stateHandlers.get(stateKey);\r\n    if (!stateHandler) return;\r\n\r\n    state.registeredPlugins.forEach((plugin) => {\r\n      const options = pluginMap.get(plugin.name);\r\n      if (options === undefined) return;\r\n\r\n      if (plugin.useHook) {\r\n        const configKey = `${stateKey}:${plugin.name}`;\r\n        const context = {\r\n          stateKey,\r\n          cogsState: stateHandler,\r\n          getPluginMetaData: () =>\r\n            getGlobalStore\r\n              .getState()\r\n              .getPluginMetaDataMap(stateKey, [])\r\n              ?.get(plugin.name),\r\n          setPluginMetaData: (data: any) =>\r\n            getGlobalStore\r\n              .getState()\r\n              .setPluginMetaData(stateKey, plugin.name, data),\r\n          removePluginMetaData: () =>\r\n            getGlobalStore\r\n              .getState()\r\n              .removePluginMetaData(stateKey, [], plugin.name),\r\n        };\r\n        const hookResult = plugin.useHook(context, options);\r\n        hookResults.set(configKey, hookResult);\r\n      }\r\n    });\r\n  });\r\n\r\n  // Use refs to give the long-lived update handler access to the latest data\r\n  const stateRef = useRef(state);\r\n  stateRef.current = state;\r\n  const hookResultsRef = useRef(hookResults);\r\n  hookResultsRef.current = hookResults;\r\n\r\n  // --- PHASE 2: Set up listeners for onUpdate and transformState ---\r\n  useEffect(() => {\r\n    // This effect runs only on mount to set up the update listener\r\n    const handleUpdate = (update: UpdateTypeDetail) => {\r\n      const currentState = stateRef.current;\r\n      const currentHookResults = hookResultsRef.current;\r\n      const { stateKey } = update;\r\n\r\n      const stateHandler = currentState.stateHandlers.get(stateKey);\r\n      const pluginMap = currentState.pluginOptions.get(stateKey);\r\n\r\n      if (!stateHandler || !pluginMap) return;\r\n\r\n      currentState.registeredPlugins.forEach((plugin) => {\r\n        if (plugin.onUpdate && pluginMap.has(plugin.name)) {\r\n          const options = pluginMap.get(plugin.name);\r\n          const configKey = `${stateKey}:${plugin.name}`;\r\n          const hookData = currentHookResults.get(configKey);\r\n\r\n          plugin.onUpdate(stateKey, update, options, hookData);\r\n        }\r\n      });\r\n    };\r\n\r\n    const unsubscribe = pluginStore.getState().subscribeToUpdates(handleUpdate);\r\n    return unsubscribe;\r\n  }, []); // Empty dependency array ensures this runs only once\r\n\r\n  // --- PHASE 3: Run transformState when options change ---\r\n  // This logic runs on every render to check if options have changed\r\n  state.pluginOptions.forEach((pluginMap, stateKey) => {\r\n    const stateHandler = state.stateHandlers.get(stateKey);\r\n    if (!stateHandler) return;\r\n\r\n    state.registeredPlugins.forEach((plugin) => {\r\n      if (plugin.transformState) {\r\n        const options = pluginMap.get(plugin.name);\r\n        if (options === undefined) return;\r\n\r\n        const configKey = `${stateKey}:${plugin.name}`;\r\n        const lastOptions = lastProcessedOptionsRef.current.get(configKey);\r\n\r\n        if (!isDeepEqual(options, lastOptions)) {\r\n          const context = {\r\n            stateKey,\r\n            cogsState: stateHandler,\r\n            getPluginMetaData: () =>\r\n              getGlobalStore\r\n                .getState()\r\n                .getPluginMetaDataMap(stateKey, [])\r\n                ?.get(plugin.name),\r\n            setPluginMetaData: (data: any) =>\r\n              getGlobalStore\r\n                .getState()\r\n                .setPluginMetaData(stateKey, plugin.name, data),\r\n            removePluginMetaData: () =>\r\n              getGlobalStore\r\n                .getState()\r\n                .removePluginMetaData(stateKey, [], plugin.name),\r\n          };\r\n          const hookData = hookResults.get(configKey);\r\n          plugin.transformState(context, options, hookData);\r\n          lastProcessedOptionsRef.current.set(configKey, options);\r\n        }\r\n      }\r\n    });\r\n  });\r\n\r\n  return <>{children}</>;\r\n}\r\n"],"names":["PluginRunner","children","forceUpdate","useState","lastProcessedOptionsRef","useRef","useEffect","pluginStore","state","hookResults","pluginMap","stateKey","stateHandler","plugin","options","configKey","context","getGlobalStore","data","hookResult","stateRef","hookResultsRef","handleUpdate","update","currentState","currentHookResults","hookData","lastOptions","isDeepEqual"],"mappings":"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"}