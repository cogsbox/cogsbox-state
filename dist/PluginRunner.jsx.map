{"version":3,"file":"PluginRunner.jsx","sources":["../src/PluginRunner.tsx"],"sourcesContent":["import React, { useEffect, useMemo, useReducer, useRef } from 'react';\r\nimport { pluginStore } from './pluginStore';\r\nimport { getGlobalStore } from './store';\r\nimport { isDeepEqual } from './utility';\r\nimport type { CogsPlugin, PluginContext } from './plugins';\r\n\r\nimport type { StateObject, UpdateTypeDetail } from './CogsState';\r\n\r\n/**\r\n * An invisible \"controller\" component that manages the lifecycle for a SINGLE plugin instance.\r\n * Its only job is to correctly call the plugin's hooks and effects.\r\n * By isolating each plugin here, we guarantee the Rules of Hooks are followed.\r\n */\r\nconst PluginInstance = React.memo(\r\n  ({\r\n    stateKey,\r\n    plugin,\r\n    options,\r\n    stateHandler,\r\n  }: {\r\n    stateKey: string;\r\n    plugin: CogsPlugin<any, any, any, any>;\r\n    options: any;\r\n    stateHandler: StateObject<any>;\r\n  }) => {\r\n    // 1. Create a stable context object for the hooks.\r\n    const context = useMemo<PluginContext<any, any>>(\r\n      () => ({\r\n        stateKey,\r\n        cogsState: stateHandler,\r\n        getPluginMetaData: () =>\r\n          getGlobalStore\r\n            .getState()\r\n            .getPluginMetaDataMap(stateKey, [])\r\n            ?.get(plugin.name),\r\n        setPluginMetaData: (data: any) =>\r\n          getGlobalStore\r\n            .getState()\r\n            .setPluginMetaData(stateKey, plugin.name, data),\r\n        removePluginMetaData: () =>\r\n          getGlobalStore\r\n            .getState()\r\n            .removePluginMetaData(stateKey, [], plugin.name),\r\n      }),\r\n      [stateKey, stateHandler, plugin.name]\r\n    );\r\n\r\n    // 2. Call the plugin's hook at the top level of this component. This is the main fix.\r\n    const hookData = plugin.useHook\r\n      ? plugin.useHook(context, options)\r\n      : undefined;\r\n\r\n    // 3. Handle `transformState`. This effect runs ONLY when the plugin's options change.\r\n    const lastProcessedOptionsRef = useRef<any>();\r\n    useEffect(() => {\r\n      if (plugin.transformState) {\r\n        // Use deep equality to prevent re-running for objects with the same value.\r\n        if (!isDeepEqual(options, lastProcessedOptionsRef.current)) {\r\n          plugin.transformState(context, options, hookData);\r\n          lastProcessedOptionsRef.current = options;\r\n        }\r\n      }\r\n    }, [context, plugin, options, hookData]); // Dependencies ensure this logic is re-evaluated correctly.\r\n\r\n    // 4. Handle `onUpdate`. This effect subscribes to the global update bus.\r\n    const hookDataRef = useRef(hookData);\r\n    hookDataRef.current = hookData; // Keep the ref updated with the latest hookData on every render.\r\n\r\n    useEffect(() => {\r\n      if (!plugin.onUpdate) {\r\n        return; // Do nothing if the plugin doesn't have this method.\r\n      }\r\n\r\n      const handleUpdate = (update: UpdateTypeDetail) => {\r\n        // We only care about updates for the stateKey this instance is responsible for.\r\n        if (update.stateKey === stateKey) {\r\n          // As you corrected, the first param is just the stateKey.\r\n          // We read from the ref to ensure the callback uses the LATEST hookData\r\n          // without needing to re-subscribe on every render.\r\n          plugin.onUpdate!(stateKey, update, options, hookDataRef.current);\r\n        }\r\n      };\r\n\r\n      const unsubscribe = pluginStore\r\n        .getState()\r\n        .subscribeToUpdates(handleUpdate);\r\n      return unsubscribe; // React will call this cleanup function when the component unmounts.\r\n    }, [stateKey, plugin, options, context]); // The dependencies are stable and correctly manage the subscription lifecycle.\r\n\r\n    // This component renders nothing to the DOM.\r\n    return null;\r\n  }\r\n);\r\n\r\n/**\r\n * The main orchestrator component. It reads from the central pluginStore\r\n * and renders a `PluginInstance` controller for each active plugin.\r\n */\r\nexport function PluginRunner({ children }: { children: React.ReactNode }) {\r\n  // A simple way to force a re-render when the store changes.\r\n  const [, forceUpdate] = useReducer((c) => c + 1, 0);\r\n\r\n  // Subscribe to the store. When plugins or their options are added/removed,\r\n  // this component will re-render to update the list of PluginInstances.\r\n  useEffect(() => {\r\n    const unsubscribe = pluginStore.subscribe(forceUpdate);\r\n    return unsubscribe;\r\n  }, []);\r\n\r\n  const { pluginOptions, stateHandlers, registeredPlugins } =\r\n    pluginStore.getState();\r\n\r\n  return (\r\n    <>\r\n      {/*\r\n        This declarative mapping is the core of the solution.\r\n        React will now manage adding and removing `PluginInstance` components\r\n        as the application state changes, ensuring hooks are handled safely.\r\n      */}\r\n      {Array.from(pluginOptions.entries()).map(([stateKey, pluginMap]) => {\r\n        const stateHandler = stateHandlers.get(stateKey);\r\n        if (!stateHandler) {\r\n          return null; // Don't render a runner if the state handler isn't ready.\r\n        }\r\n\r\n        return Array.from(pluginMap.entries()).map(([pluginName, options]) => {\r\n          const plugin = registeredPlugins.find((p) => p.name === pluginName);\r\n          if (!plugin) {\r\n            return null; // Don't render if the plugin is not in the registered list.\r\n          }\r\n\r\n          // Render a dedicated, memoized controller for this specific plugin configuration.\r\n          return (\r\n            <PluginInstance\r\n              key={`${stateKey}:${pluginName}`}\r\n              stateKey={stateKey}\r\n              plugin={plugin}\r\n              options={options}\r\n              stateHandler={stateHandler}\r\n            />\r\n          );\r\n        });\r\n      })}\r\n      {children}\r\n    </>\r\n  );\r\n}\r\n"],"names":["PluginInstance","React","stateKey","plugin","options","stateHandler","context","useMemo","getGlobalStore","data","hookData","lastProcessedOptionsRef","useRef","useEffect","isDeepEqual","hookDataRef","handleUpdate","update","pluginStore","PluginRunner","children","forceUpdate","useReducer","c","pluginOptions","stateHandlers","registeredPlugins","jsxs","Fragment","pluginMap","pluginName","p","jsx"],"mappings":";;;;;AAaA,MAAMA,IAAiBC,EAAM;AAAA,EAC3B,CAAC;AAAA,IACC,UAAAC;AAAA,IACA,QAAAC;AAAA,IACA,SAAAC;AAAA,IACA,cAAAC;AAAA,EAAA,MAMI;AAEJ,UAAMC,IAAUC;AAAA,MACd,OAAO;AAAA,QACL,UAAAL;AAAA,QACA,WAAWG;AAAA,QACX,mBAAmB,MACjBG,EACG,SAAA,EACA,qBAAqBN,GAAU,CAAA,CAAE,GAChC,IAAIC,EAAO,IAAI;AAAA,QACrB,mBAAmB,CAACM,MAClBD,EACG,SAAA,EACA,kBAAkBN,GAAUC,EAAO,MAAMM,CAAI;AAAA,QAClD,sBAAsB,MACpBD,EACG,SAAA,EACA,qBAAqBN,GAAU,CAAA,GAAIC,EAAO,IAAI;AAAA,MAAA;AAAA,MAErD,CAACD,GAAUG,GAAcF,EAAO,IAAI;AAAA,IAAA,GAIhCO,IAAWP,EAAO,UACpBA,EAAO,QAAQG,GAASF,CAAO,IAC/B,QAGEO,IAA0BC,EAAA;AAChC,IAAAC,EAAU,MAAM;AACd,MAAIV,EAAO,mBAEJW,EAAYV,GAASO,EAAwB,OAAO,MACvDR,EAAO,eAAeG,GAASF,GAASM,CAAQ,GAChDC,EAAwB,UAAUP;AAAA,IAGxC,GAAG,CAACE,GAASH,GAAQC,GAASM,CAAQ,CAAC;AAGvC,UAAMK,IAAcH,EAAOF,CAAQ;AACnC,WAAAK,EAAY,UAAUL,GAEtBG,EAAU,MAAM;AACd,UAAI,CAACV,EAAO;AACV;AAGF,YAAMa,IAAe,CAACC,MAA6B;AAEjD,QAAIA,EAAO,aAAaf,KAItBC,EAAO,SAAUD,GAAUe,GAAQb,GAASW,EAAY,OAAO;AAAA,MAEnE;AAKA,aAHoBG,EACjB,SAAA,EACA,mBAAmBF,CAAY;AAAA,IAEpC,GAAG,CAACd,GAAUC,GAAQC,GAASE,CAAO,CAAC,GAGhC;AAAA,EACT;AACF;AAMO,SAASa,EAAa,EAAE,UAAAC,KAA2C;AAExE,QAAM,CAAA,EAAGC,CAAW,IAAIC,EAAW,CAACC,MAAMA,IAAI,GAAG,CAAC;AAIlD,EAAAV,EAAU,MACYK,EAAY,UAAUG,CAAW,GAEpD,CAAA,CAAE;AAEL,QAAM,EAAE,eAAAG,GAAe,eAAAC,GAAe,mBAAAC,EAAA,IACpCR,EAAY,SAAA;AAEd,SACE,gBAAAS,EAAAC,GAAA,EAMG,UAAA;AAAA,IAAA,MAAM,KAAKJ,EAAc,QAAA,CAAS,EAAE,IAAI,CAAC,CAACtB,GAAU2B,CAAS,MAAM;AAClE,YAAMxB,IAAeoB,EAAc,IAAIvB,CAAQ;AAC/C,aAAKG,IAIE,MAAM,KAAKwB,EAAU,QAAA,CAAS,EAAE,IAAI,CAAC,CAACC,GAAY1B,CAAO,MAAM;AACpE,cAAMD,IAASuB,EAAkB,KAAK,CAACK,MAAMA,EAAE,SAASD,CAAU;AAClE,eAAK3B,IAMH,gBAAA6B;AAAA,UAAChC;AAAA,UAAA;AAAA,YAEC,UAAAE;AAAA,YACA,QAAAC;AAAA,YACA,SAAAC;AAAA,YACA,cAAAC;AAAA,UAAA;AAAA,UAJK,GAAGH,CAAQ,IAAI4B,CAAU;AAAA,QAAA,IANzB;AAAA,MAaX,CAAC,IAnBQ;AAAA,IAoBX,CAAC;AAAA,IACAV;AAAA,EAAA,GACH;AAEJ;"}