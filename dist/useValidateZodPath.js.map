{"version":3,"file":"useValidateZodPath.js","sources":["../src/useValidateZodPath.ts"],"sourcesContent":["import { useEffect, useState } from \"react\";\r\nimport {\r\n  z,\r\n  ZodArray,\r\n  ZodEffects,\r\n  ZodError,\r\n  ZodNullable,\r\n  ZodObject,\r\n  ZodOptional,\r\n  type SafeParseReturnType,\r\n  type ZodRawShape,\r\n  type ZodTypeAny,\r\n} from \"zod\";\r\nimport { create } from \"zustand\";\r\nimport { v4 as uuidv4 } from \"uuid\";\r\nimport { getGlobalStore } from \"./store\";\r\n\r\n// Your existing types and store\r\nexport type ResultItem = {\r\n  status: \"loading\" | \"success\" | \"failure\" | \"error\";\r\n  message?: string;\r\n};\r\ntype RequestType = Array<{ path: string[]; data: any; key: string }>;\r\n\r\ntype ResultsState = {\r\n  results: Record<string, Record<string, ResultItem>>;\r\n  request: Record<string, RequestType>;\r\n  getResultsByKey: (key: string) => Record<string, ResultItem> | undefined;\r\n  setResults: (\r\n    key: string\r\n  ) => (\r\n    result:\r\n      | Record<string, ResultItem>\r\n      | ((prevState: Record<string, ResultItem>) => Record<string, ResultItem>)\r\n  ) => void;\r\n  setRequest: (\r\n    key: string\r\n  ) => (\r\n    request: RequestType | ((prevState: RequestType) => RequestType)\r\n  ) => void;\r\n  getRequestsByKey: (\r\n    key: string\r\n  ) => Array<{ path: string[]; data: any; key: string }> | undefined;\r\n};\r\n\r\nexport const useResultsStore = create<ResultsState>((set, get) => ({\r\n  results: {},\r\n  request: {},\r\n  getResultsByKey: (key) => get().results[key],\r\n  setResults: (key) => (result) => {\r\n    set((state) => {\r\n      return {\r\n        results: {\r\n          ...state.results,\r\n          [key]:\r\n            typeof result === \"function\" ? result(state.results[key]!) : result,\r\n        },\r\n      };\r\n    });\r\n  },\r\n  setRequest: (key) => (request) =>\r\n    set((state) => ({\r\n      request: {\r\n        ...state.request,\r\n        [key]:\r\n          typeof request === \"function\"\r\n            ? request(state.request[key]!)\r\n            : request,\r\n      },\r\n    })),\r\n  getRequestsByKey: (key) => get().request[key],\r\n}));\r\n\r\nexport default function useValidateZodPath<T extends ZodRawShape>(\r\n  validationKey: string,\r\n  schema: ZodObject<T>,\r\n  stateKey?: string\r\n) {\r\n  const [thisKey, setThisKey] = useState(stateKey ?? uuidv4());\r\n  const [requests, setRequests] = useState<RequestType | undefined>(undefined);\r\n\r\n  const [localResults, setLocalResults] = useState<Record<string, ResultItem>>(\r\n    {}\r\n  );\r\n  const results = stateKey\r\n    ? useResultsStore((state) => state.getResultsByKey(thisKey))\r\n    : localResults;\r\n  const setResults = stateKey\r\n    ? useResultsStore.getState().setResults(thisKey)\r\n    : setLocalResults;\r\n\r\n  useEffect(() => {\r\n    requests?.forEach(async ({ path, data, key }) => {\r\n      setResults((prevResults) => ({\r\n        ...prevResults,\r\n        [key]: { status: \"loading\" },\r\n      })); // prevResults is saying its any\r\n\r\n      try {\r\n        const response = await validateZodPathFunc(\r\n          validationKey,\r\n          schema,\r\n          path,\r\n          data\r\n        );\r\n        setResults((prevResults) => ({\r\n          ...prevResults,\r\n          [key]: {\r\n            status: response.success ? \"success\" : \"failure\",\r\n            message: response.success ? undefined : response.message, // Now just a string\r\n          },\r\n        }));\r\n      } catch (error) {\r\n        console.error(error);\r\n        setResults((prevResults) => ({\r\n          ...prevResults,\r\n          [key]: {\r\n            status: \"error\",\r\n            message:\r\n              error instanceof Error\r\n                ? error.message\r\n                : \"An unknown error occurred\",\r\n          },\r\n        }));\r\n      }\r\n    });\r\n\r\n    // Clear requests after processing\r\n    if (requests && requests.length > 0) {\r\n      setRequests([]);\r\n    }\r\n  }, [requests, schema]);\r\n\r\n  const validateZodPath = (\r\n    path: string[],\r\n    data: any,\r\n    results?: Record<string, ResultItem> | undefined\r\n  ) => {\r\n    const pathKey = path.join(\".\");\r\n\r\n    setResults((prevResults) => ({\r\n      ...prevResults,\r\n      [pathKey]: { status: \"loading\" },\r\n    }));\r\n    setRequests((prevRequests) => [\r\n      ...(prevRequests ?? []),\r\n      { path, data, key: pathKey },\r\n    ]);\r\n\r\n    return results?.[pathKey]?.status ?? \"loading\";\r\n  };\r\n\r\n  const getZodPathResults = (path: string[]) => {\r\n    const pathKey = path.join(\".\");\r\n    let endsWith = Object.keys(results ?? {}).filter(\r\n      (key) =>\r\n        key.endsWith(pathKey) && key.split(\".\").length === path.length + 1\r\n    );\r\n\r\n    return results?.[pathKey] ?? endsWith ?? null;\r\n  };\r\n\r\n  return { validateZodPath, getZodPathResults, zodPathResults: results };\r\n}\r\n\r\nexport async function validateZodPathFunc<T extends ZodRawShape, U>(\r\n  validationKey: string,\r\n  schema: ZodTypeAny,\r\n  path: string[],\r\n  data: U\r\n): Promise<{ success: boolean; message?: string }> {\r\n  let currentSchema: ZodTypeAny = schema;\r\n  const addValidationError = getGlobalStore.getState().addValidationError;\r\n\r\n  for (const key of path) {\r\n    currentSchema = unwrapSchema(currentSchema);\r\n\r\n    if (currentSchema instanceof ZodArray) {\r\n      const index = Number(key);\r\n      if (!isNaN(index)) {\r\n        currentSchema = currentSchema.element;\r\n      } else {\r\n        throw new Error(`Invalid path: array index expected but got '${key}'.`);\r\n      }\r\n    } else if (currentSchema instanceof ZodObject) {\r\n      if (key in currentSchema.shape) {\r\n        currentSchema = currentSchema.shape[key];\r\n      } else {\r\n        throw new Error(`Invalid path: key '${key}' not found in schema.`);\r\n      }\r\n    } else {\r\n      throw new Error(`Invalid path: key '${key}' not found in schema.`);\r\n    }\r\n  }\r\n\r\n  // Ensure the final schema is fully unwrapped\r\n  currentSchema = unwrapSchema(currentSchema, true);\r\n  // Now currentSchema should be the schema at the end of the path, and we can validate.\r\n  const result: SafeParseReturnType<any, any> =\r\n    await currentSchema.safeParseAsync(data);\r\n\r\n  if (!result.success) {\r\n    const messages = result.error.issues\r\n      .map((issue) => issue.message)\r\n      .join(\", \");\r\n\r\n    const fullErrorPath = [validationKey, ...path].join(\".\");\r\n    addValidationError(fullErrorPath, messages);\r\n    return { success: false, message: messages };\r\n  }\r\n\r\n  return { success: true, message: undefined };\r\n}\r\n\r\nfunction unwrapSchema(\r\n  schema: ZodTypeAny,\r\n  notEffects: boolean = false\r\n): ZodTypeAny {\r\n  while (\r\n    schema instanceof ZodOptional ||\r\n    schema instanceof ZodNullable ||\r\n    (!notEffects && schema instanceof ZodEffects)\r\n  ) {\r\n    if (schema instanceof ZodOptional || schema instanceof ZodNullable) {\r\n      schema = schema.unwrap();\r\n    } else if (schema instanceof ZodEffects) {\r\n      schema = schema._def.schema;\r\n    }\r\n  }\r\n  return schema;\r\n}\r\n"],"names":["create","set","get","key","result","state","request","validateZodPathFunc","validationKey","schema","path","data","currentSchema","addValidationError","getGlobalStore","unwrapSchema","ZodArray","index","ZodObject","messages","issue","fullErrorPath","notEffects","ZodOptional","ZodNullable","ZodEffects"],"mappings":";;;;AA6C+BA,EAAqB,CAACC,GAAKC,OAAS;AAAA,EACjE,SAAS,CAAC;AAAA,EACV,SAAS,CAAC;AAAA,EACV,iBAAiB,CAACC,MAAQD,EAAI,EAAE,QAAQC,CAAG;AAAA,EAC3C,YAAY,CAACA,MAAQ,CAACC,MAAW;AAC/B,IAAAH,EAAI,CAACI,OACI;AAAA,MACL,SAAS;AAAA,QACP,GAAGA,EAAM;AAAA,QACT,CAACF,CAAG,GACF,OAAOC,KAAW,aAAaA,EAAOC,EAAM,QAAQF,CAAG,CAAE,IAAIC;AAAA,MAAA;AAAA,IAEnE,EACD;AAAA,EACH;AAAA,EACA,YAAY,CAACD,MAAQ,CAACG,MACpBL,EAAI,CAACI,OAAW;AAAA,IACd,SAAS;AAAA,MACP,GAAGA,EAAM;AAAA,MACT,CAACF,CAAG,GACF,OAAOG,KAAY,aACfA,EAAQD,EAAM,QAAQF,CAAG,CAAE,IAC3BG;AAAA,IAAA;AAAA,EACR,EACA;AAAA,EACJ,kBAAkB,CAACH,MAAQD,EAAI,EAAE,QAAQC,CAAG;AAC9C,EAAE;AA8FF,eAAsBI,EACpBC,GACAC,GACAC,GACAC,GACiD;AACjD,MAAIC,IAA4BH;AAC1B,QAAAI,IAAqBC,EAAe,SAAA,EAAW;AAErD,aAAWX,KAAOO;AAGhB,QAFAE,IAAgBG,EAAaH,CAAa,GAEtCA,aAAyBI,GAAU;AAC/B,YAAAC,IAAQ,OAAOd,CAAG;AACpB,UAAA,CAAC,MAAMc,CAAK;AACd,QAAAL,IAAgBA,EAAc;AAAA;AAE9B,cAAM,IAAI,MAAM,+CAA+CT,CAAG,IAAI;AAAA,IACxE,WACSS,aAAyBM;AAC9B,UAAAf,KAAOS,EAAc;AACP,QAAAA,IAAAA,EAAc,MAAMT,CAAG;AAAA;AAEvC,cAAM,IAAI,MAAM,sBAAsBA,CAAG,wBAAwB;AAAA;AAGnE,YAAM,IAAI,MAAM,sBAAsBA,CAAG,wBAAwB;AAKrD,EAAAS,IAAAG,EAAaH,GAAe,EAAI;AAEhD,QAAMR,IACJ,MAAMQ,EAAc,eAAeD,CAAI;AAErC,MAAA,CAACP,EAAO,SAAS;AACb,UAAAe,IAAWf,EAAO,MAAM,OAC3B,IAAI,CAACgB,MAAUA,EAAM,OAAO,EAC5B,KAAK,IAAI,GAENC,IAAgB,CAACb,GAAe,GAAGE,CAAI,EAAE,KAAK,GAAG;AACvD,WAAAG,EAAmBQ,GAAeF,CAAQ,GACnC,EAAE,SAAS,IAAO,SAASA,EAAS;AAAA,EAAA;AAG7C,SAAO,EAAE,SAAS,IAAM,SAAS,OAAU;AAC7C;AAEA,SAASJ,EACPN,GACAa,IAAsB,IACV;AACZ,SACEb,aAAkBc,KAClBd,aAAkBe,KACjB,CAACF,KAAcb,aAAkBgB;AAE9B,IAAAhB,aAAkBc,KAAed,aAAkBe,IACrDf,IAASA,EAAO,OAAO,IACdA,aAAkBgB,MAC3BhB,IAASA,EAAO,KAAK;AAGlB,SAAAA;AACT;"}